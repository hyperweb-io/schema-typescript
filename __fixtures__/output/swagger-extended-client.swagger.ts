import { APIClient, APIClientRequestOpts, APIClientOptions } from "@interweb/fetch-api-client";
export interface MonitoringCoreosComV1Alertmanager {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec: {
    additionalArgs?: {
      name: string;
      value?: string;
    }[];
    additionalPeers?: string[];
    affinity?: {
      nodeAffinity?: {
        preferredDuringSchedulingIgnoredDuringExecution?: {
          preference: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchFields?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
          };
          weight: number;
        }[];
        requiredDuringSchedulingIgnoredDuringExecution?: {
          nodeSelectorTerms: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchFields?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
          }[];
        };
      };
      podAffinity?: {
        preferredDuringSchedulingIgnoredDuringExecution?: {
          podAffinityTerm: {
            labelSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            matchLabelKeys?: string[];
            mismatchLabelKeys?: string[];
            namespaceSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            namespaces?: string[];
            topologyKey: string;
          };
          weight: number;
        }[];
        requiredDuringSchedulingIgnoredDuringExecution?: {
          labelSelector?: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchLabels?: {
              [key: string]: unknown;
            };
          };
          matchLabelKeys?: string[];
          mismatchLabelKeys?: string[];
          namespaceSelector?: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchLabels?: {
              [key: string]: unknown;
            };
          };
          namespaces?: string[];
          topologyKey: string;
        }[];
      };
      podAntiAffinity?: {
        preferredDuringSchedulingIgnoredDuringExecution?: {
          podAffinityTerm: {
            labelSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            matchLabelKeys?: string[];
            mismatchLabelKeys?: string[];
            namespaceSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            namespaces?: string[];
            topologyKey: string;
          };
          weight: number;
        }[];
        requiredDuringSchedulingIgnoredDuringExecution?: {
          labelSelector?: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchLabels?: {
              [key: string]: unknown;
            };
          };
          matchLabelKeys?: string[];
          mismatchLabelKeys?: string[];
          namespaceSelector?: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchLabels?: {
              [key: string]: unknown;
            };
          };
          namespaces?: string[];
          topologyKey: string;
        }[];
      };
    };
    alertmanagerConfigMatcherStrategy?: {
      type?: "OnNamespace" | "OnNamespaceExceptForAlertmanagerNamespace" | "None";
    };
    alertmanagerConfigNamespaceSelector?: {
      matchExpressions?: {
        key: string;
        operator: string;
        values?: string[];
      }[];
      matchLabels?: {
        [key: string]: unknown;
      };
    };
    alertmanagerConfigSelector?: {
      matchExpressions?: {
        key: string;
        operator: string;
        values?: string[];
      }[];
      matchLabels?: {
        [key: string]: unknown;
      };
    };
    alertmanagerConfiguration?: {
      global?: {
        httpConfig?: {
          authorization?: {
            credentials?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            type?: string;
          };
          basicAuth?: {
            password?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            username?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          bearerTokenSecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          followRedirects?: boolean;
          noProxy?: string;
          oauth2?: {
            clientId: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            clientSecret: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            endpointParams?: {
              [key: string]: unknown;
            };
            noProxy?: string;
            proxyConnectHeader?: {
              [key: string]: unknown;
            };
            proxyFromEnvironment?: boolean;
            proxyUrl?: string;
            scopes?: string[];
            tlsConfig?: {
              ca?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              cert?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              insecureSkipVerify?: boolean;
              keySecret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              serverName?: string;
            };
            tokenUrl: string;
          };
          proxyConnectHeader?: {
            [key: string]: unknown;
          };
          proxyFromEnvironment?: boolean;
          proxyUrl?: string;
          tlsConfig?: {
            ca?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            cert?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            insecureSkipVerify?: boolean;
            keySecret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            serverName?: string;
          };
        };
        jira?: {
          apiURL?: string;
        };
        opsGenieApiKey?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        opsGenieApiUrl?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        pagerdutyUrl?: string;
        resolveTimeout?: string;
        rocketChat?: {
          apiURL?: string;
          token?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          tokenID?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        slackApiUrl?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        smtp?: {
          authIdentity?: string;
          authPassword?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          authSecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          authUsername?: string;
          from?: string;
          hello?: string;
          requireTLS?: boolean;
          smartHost?: {
            host: string;
            port: string;
          };
          tlsConfig?: {
            ca?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            cert?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            insecureSkipVerify?: boolean;
            keySecret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            serverName?: string;
          };
        };
        telegram?: {
          apiURL?: string;
        };
        victorops?: {
          apiKey?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          apiURL?: string;
        };
        webex?: {
          apiURL?: string;
        };
        wechat?: {
          apiCorpID?: string;
          apiSecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          apiURL?: string;
        };
      };
      name?: string;
      templates?: {
        configMap?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        secret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      }[];
    };
    automountServiceAccountToken?: boolean;
    baseImage?: string;
    clusterAdvertiseAddress?: string;
    clusterGossipInterval?: string;
    clusterLabel?: string;
    clusterPeerTimeout?: string;
    clusterPushpullInterval?: string;
    clusterTLS?: {
      client: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        insecureSkipVerify?: boolean;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
      server: {
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        certFile?: string;
        cipherSuites?: string[];
        clientAuthType?: string;
        clientCAFile?: string;
        client_ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        curvePreferences?: string[];
        keyFile?: string;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: string;
        minVersion?: string;
        preferServerCipherSuites?: boolean;
      };
    };
    configMaps?: string[];
    configSecret?: string;
    containers?: {
      args?: string[];
      command?: string[];
      env?: {
        name: string;
        value?: string;
        valueFrom?: {
          configMapKeyRef?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          fieldRef?: {
            apiVersion?: string;
            fieldPath: string;
          };
          resourceFieldRef?: {
            containerName?: string;
            divisor?: any;
            resource: string;
          };
          secretKeyRef?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
      }[];
      envFrom?: {
        configMapRef?: {
          name?: string;
          optional?: boolean;
        };
        prefix?: string;
        secretRef?: {
          name?: string;
          optional?: boolean;
        };
      }[];
      image?: string;
      imagePullPolicy?: string;
      lifecycle?: {
        postStart?: {
          exec?: {
            command?: string[];
          };
          httpGet?: {
            host?: string;
            httpHeaders?: {
              name: string;
              value: string;
            }[];
            path?: string;
            port: any;
            scheme?: string;
          };
          sleep?: {
            seconds: number;
          };
          tcpSocket?: {
            host?: string;
            port: any;
          };
        };
        preStop?: {
          exec?: {
            command?: string[];
          };
          httpGet?: {
            host?: string;
            httpHeaders?: {
              name: string;
              value: string;
            }[];
            path?: string;
            port: any;
            scheme?: string;
          };
          sleep?: {
            seconds: number;
          };
          tcpSocket?: {
            host?: string;
            port: any;
          };
        };
        stopSignal?: string;
      };
      livenessProbe?: {
        exec?: {
          command?: string[];
        };
        failureThreshold?: number;
        grpc?: {
          port: number;
          service?: string;
        };
        httpGet?: {
          host?: string;
          httpHeaders?: {
            name: string;
            value: string;
          }[];
          path?: string;
          port: any;
          scheme?: string;
        };
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        tcpSocket?: {
          host?: string;
          port: any;
        };
        terminationGracePeriodSeconds?: number;
        timeoutSeconds?: number;
      };
      name: string;
      ports?: {
        containerPort: number;
        hostIP?: string;
        hostPort?: number;
        name?: string;
        protocol?: string;
      }[];
      readinessProbe?: {
        exec?: {
          command?: string[];
        };
        failureThreshold?: number;
        grpc?: {
          port: number;
          service?: string;
        };
        httpGet?: {
          host?: string;
          httpHeaders?: {
            name: string;
            value: string;
          }[];
          path?: string;
          port: any;
          scheme?: string;
        };
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        tcpSocket?: {
          host?: string;
          port: any;
        };
        terminationGracePeriodSeconds?: number;
        timeoutSeconds?: number;
      };
      resizePolicy?: {
        resourceName: string;
        restartPolicy: string;
      }[];
      resources?: {
        claims?: {
          name: string;
          request?: string;
        }[];
        limits?: {
          [key: string]: unknown;
        };
        requests?: {
          [key: string]: unknown;
        };
      };
      restartPolicy?: string;
      securityContext?: {
        allowPrivilegeEscalation?: boolean;
        appArmorProfile?: {
          localhostProfile?: string;
          type: string;
        };
        capabilities?: {
          add?: string[];
          drop?: string[];
        };
        privileged?: boolean;
        procMount?: string;
        readOnlyRootFilesystem?: boolean;
        runAsGroup?: number;
        runAsNonRoot?: boolean;
        runAsUser?: number;
        seLinuxOptions?: {
          level?: string;
          role?: string;
          type?: string;
          user?: string;
        };
        seccompProfile?: {
          localhostProfile?: string;
          type: string;
        };
        windowsOptions?: {
          gmsaCredentialSpec?: string;
          gmsaCredentialSpecName?: string;
          hostProcess?: boolean;
          runAsUserName?: string;
        };
      };
      startupProbe?: {
        exec?: {
          command?: string[];
        };
        failureThreshold?: number;
        grpc?: {
          port: number;
          service?: string;
        };
        httpGet?: {
          host?: string;
          httpHeaders?: {
            name: string;
            value: string;
          }[];
          path?: string;
          port: any;
          scheme?: string;
        };
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        tcpSocket?: {
          host?: string;
          port: any;
        };
        terminationGracePeriodSeconds?: number;
        timeoutSeconds?: number;
      };
      stdin?: boolean;
      stdinOnce?: boolean;
      terminationMessagePath?: string;
      terminationMessagePolicy?: string;
      tty?: boolean;
      volumeDevices?: {
        devicePath: string;
        name: string;
      }[];
      volumeMounts?: {
        mountPath: string;
        mountPropagation?: string;
        name: string;
        readOnly?: boolean;
        recursiveReadOnly?: string;
        subPath?: string;
        subPathExpr?: string;
      }[];
      workingDir?: string;
    }[];
    dnsConfig?: {
      nameservers?: string[];
      options?: {
        name: string;
        value?: string;
      }[];
      searches?: string[];
    };
    dnsPolicy?: "ClusterFirstWithHostNet" | "ClusterFirst" | "Default" | "None";
    enableFeatures?: string[];
    enableServiceLinks?: boolean;
    externalUrl?: string;
    forceEnableClusterMode?: boolean;
    hostAliases?: {
      hostnames: string[];
      ip: string;
    }[];
    hostUsers?: boolean;
    image?: string;
    imagePullPolicy?: "" | "Always" | "Never" | "IfNotPresent";
    imagePullSecrets?: {
      name?: string;
    }[];
    initContainers?: {
      args?: string[];
      command?: string[];
      env?: {
        name: string;
        value?: string;
        valueFrom?: {
          configMapKeyRef?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          fieldRef?: {
            apiVersion?: string;
            fieldPath: string;
          };
          resourceFieldRef?: {
            containerName?: string;
            divisor?: any;
            resource: string;
          };
          secretKeyRef?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
      }[];
      envFrom?: {
        configMapRef?: {
          name?: string;
          optional?: boolean;
        };
        prefix?: string;
        secretRef?: {
          name?: string;
          optional?: boolean;
        };
      }[];
      image?: string;
      imagePullPolicy?: string;
      lifecycle?: {
        postStart?: {
          exec?: {
            command?: string[];
          };
          httpGet?: {
            host?: string;
            httpHeaders?: {
              name: string;
              value: string;
            }[];
            path?: string;
            port: any;
            scheme?: string;
          };
          sleep?: {
            seconds: number;
          };
          tcpSocket?: {
            host?: string;
            port: any;
          };
        };
        preStop?: {
          exec?: {
            command?: string[];
          };
          httpGet?: {
            host?: string;
            httpHeaders?: {
              name: string;
              value: string;
            }[];
            path?: string;
            port: any;
            scheme?: string;
          };
          sleep?: {
            seconds: number;
          };
          tcpSocket?: {
            host?: string;
            port: any;
          };
        };
        stopSignal?: string;
      };
      livenessProbe?: {
        exec?: {
          command?: string[];
        };
        failureThreshold?: number;
        grpc?: {
          port: number;
          service?: string;
        };
        httpGet?: {
          host?: string;
          httpHeaders?: {
            name: string;
            value: string;
          }[];
          path?: string;
          port: any;
          scheme?: string;
        };
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        tcpSocket?: {
          host?: string;
          port: any;
        };
        terminationGracePeriodSeconds?: number;
        timeoutSeconds?: number;
      };
      name: string;
      ports?: {
        containerPort: number;
        hostIP?: string;
        hostPort?: number;
        name?: string;
        protocol?: string;
      }[];
      readinessProbe?: {
        exec?: {
          command?: string[];
        };
        failureThreshold?: number;
        grpc?: {
          port: number;
          service?: string;
        };
        httpGet?: {
          host?: string;
          httpHeaders?: {
            name: string;
            value: string;
          }[];
          path?: string;
          port: any;
          scheme?: string;
        };
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        tcpSocket?: {
          host?: string;
          port: any;
        };
        terminationGracePeriodSeconds?: number;
        timeoutSeconds?: number;
      };
      resizePolicy?: {
        resourceName: string;
        restartPolicy: string;
      }[];
      resources?: {
        claims?: {
          name: string;
          request?: string;
        }[];
        limits?: {
          [key: string]: unknown;
        };
        requests?: {
          [key: string]: unknown;
        };
      };
      restartPolicy?: string;
      securityContext?: {
        allowPrivilegeEscalation?: boolean;
        appArmorProfile?: {
          localhostProfile?: string;
          type: string;
        };
        capabilities?: {
          add?: string[];
          drop?: string[];
        };
        privileged?: boolean;
        procMount?: string;
        readOnlyRootFilesystem?: boolean;
        runAsGroup?: number;
        runAsNonRoot?: boolean;
        runAsUser?: number;
        seLinuxOptions?: {
          level?: string;
          role?: string;
          type?: string;
          user?: string;
        };
        seccompProfile?: {
          localhostProfile?: string;
          type: string;
        };
        windowsOptions?: {
          gmsaCredentialSpec?: string;
          gmsaCredentialSpecName?: string;
          hostProcess?: boolean;
          runAsUserName?: string;
        };
      };
      startupProbe?: {
        exec?: {
          command?: string[];
        };
        failureThreshold?: number;
        grpc?: {
          port: number;
          service?: string;
        };
        httpGet?: {
          host?: string;
          httpHeaders?: {
            name: string;
            value: string;
          }[];
          path?: string;
          port: any;
          scheme?: string;
        };
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        tcpSocket?: {
          host?: string;
          port: any;
        };
        terminationGracePeriodSeconds?: number;
        timeoutSeconds?: number;
      };
      stdin?: boolean;
      stdinOnce?: boolean;
      terminationMessagePath?: string;
      terminationMessagePolicy?: string;
      tty?: boolean;
      volumeDevices?: {
        devicePath: string;
        name: string;
      }[];
      volumeMounts?: {
        mountPath: string;
        mountPropagation?: string;
        name: string;
        readOnly?: boolean;
        recursiveReadOnly?: string;
        subPath?: string;
        subPathExpr?: string;
      }[];
      workingDir?: string;
    }[];
    limits?: {
      maxPerSilenceBytes?: string;
      maxSilences?: number;
    };
    listenLocal?: boolean;
    logFormat?: "" | "logfmt" | "json";
    logLevel?: "" | "debug" | "info" | "warn" | "error";
    minReadySeconds?: number;
    nodeSelector?: {
      [key: string]: unknown;
    };
    paused?: boolean;
    persistentVolumeClaimRetentionPolicy?: {
      whenDeleted?: string;
      whenScaled?: string;
    };
    podMetadata?: {
      annotations?: {
        [key: string]: unknown;
      };
      labels?: {
        [key: string]: unknown;
      };
      name?: string;
    };
    portName?: string;
    priorityClassName?: string;
    replicas?: number;
    resources?: {
      claims?: {
        name: string;
        request?: string;
      }[];
      limits?: {
        [key: string]: unknown;
      };
      requests?: {
        [key: string]: unknown;
      };
    };
    retention?: string;
    routePrefix?: string;
    secrets?: string[];
    securityContext?: {
      appArmorProfile?: {
        localhostProfile?: string;
        type: string;
      };
      fsGroup?: number;
      fsGroupChangePolicy?: string;
      runAsGroup?: number;
      runAsNonRoot?: boolean;
      runAsUser?: number;
      seLinuxChangePolicy?: string;
      seLinuxOptions?: {
        level?: string;
        role?: string;
        type?: string;
        user?: string;
      };
      seccompProfile?: {
        localhostProfile?: string;
        type: string;
      };
      supplementalGroups?: number[];
      supplementalGroupsPolicy?: string;
      sysctls?: {
        name: string;
        value: string;
      }[];
      windowsOptions?: {
        gmsaCredentialSpec?: string;
        gmsaCredentialSpecName?: string;
        hostProcess?: boolean;
        runAsUserName?: string;
      };
    };
    serviceAccountName?: string;
    serviceName?: string;
    sha?: string;
    storage?: {
      disableMountSubPath?: boolean;
      emptyDir?: {
        medium?: string;
        sizeLimit?: any;
      };
      ephemeral?: {
        volumeClaimTemplate?: {
          metadata?: {
            [key: string]: unknown;
          };
          spec: {
            accessModes?: string[];
            dataSource?: {
              apiGroup?: string;
              kind: string;
              name: string;
            };
            dataSourceRef?: {
              apiGroup?: string;
              kind: string;
              name: string;
              namespace?: string;
            };
            resources?: {
              limits?: {
                [key: string]: unknown;
              };
              requests?: {
                [key: string]: unknown;
              };
            };
            selector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            storageClassName?: string;
            volumeAttributesClassName?: string;
            volumeMode?: string;
            volumeName?: string;
          };
        };
      };
      volumeClaimTemplate?: {
        apiVersion?: string;
        kind?: string;
        metadata?: {
          annotations?: {
            [key: string]: unknown;
          };
          labels?: {
            [key: string]: unknown;
          };
          name?: string;
        };
        spec?: {
          accessModes?: string[];
          dataSource?: {
            apiGroup?: string;
            kind: string;
            name: string;
          };
          dataSourceRef?: {
            apiGroup?: string;
            kind: string;
            name: string;
            namespace?: string;
          };
          resources?: {
            limits?: {
              [key: string]: unknown;
            };
            requests?: {
              [key: string]: unknown;
            };
          };
          selector?: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchLabels?: {
              [key: string]: unknown;
            };
          };
          storageClassName?: string;
          volumeAttributesClassName?: string;
          volumeMode?: string;
          volumeName?: string;
        };
        status?: {
          accessModes?: string[];
          allocatedResourceStatuses?: {
            [key: string]: unknown;
          };
          allocatedResources?: {
            [key: string]: unknown;
          };
          capacity?: {
            [key: string]: unknown;
          };
          conditions?: {
            lastProbeTime?: string;
            lastTransitionTime?: string;
            message?: string;
            reason?: string;
            status: string;
            type: string;
          }[];
          currentVolumeAttributesClassName?: string;
          modifyVolumeStatus?: {
            status: string;
            targetVolumeAttributesClassName?: string;
          };
          phase?: string;
        };
      };
    };
    tag?: string;
    terminationGracePeriodSeconds?: number;
    tolerations?: {
      effect?: string;
      key?: string;
      operator?: string;
      tolerationSeconds?: number;
      value?: string;
    }[];
    topologySpreadConstraints?: {
      labelSelector?: {
        matchExpressions?: {
          key: string;
          operator: string;
          values?: string[];
        }[];
        matchLabels?: {
          [key: string]: unknown;
        };
      };
      matchLabelKeys?: string[];
      maxSkew: number;
      minDomains?: number;
      nodeAffinityPolicy?: string;
      nodeTaintsPolicy?: string;
      topologyKey: string;
      whenUnsatisfiable: string;
    }[];
    version?: string;
    volumeMounts?: {
      mountPath: string;
      mountPropagation?: string;
      name: string;
      readOnly?: boolean;
      recursiveReadOnly?: string;
      subPath?: string;
      subPathExpr?: string;
    }[];
    volumes?: {
      awsElasticBlockStore?: {
        fsType?: string;
        partition?: number;
        readOnly?: boolean;
        volumeID: string;
      };
      azureDisk?: {
        cachingMode?: string;
        diskName: string;
        diskURI: string;
        fsType?: string;
        kind?: string;
        readOnly?: boolean;
      };
      azureFile?: {
        readOnly?: boolean;
        secretName: string;
        shareName: string;
      };
      cephfs?: {
        monitors: string[];
        path?: string;
        readOnly?: boolean;
        secretFile?: string;
        secretRef?: {
          name?: string;
        };
        user?: string;
      };
      cinder?: {
        fsType?: string;
        readOnly?: boolean;
        secretRef?: {
          name?: string;
        };
        volumeID: string;
      };
      configMap?: {
        defaultMode?: number;
        items?: {
          key: string;
          mode?: number;
          path: string;
        }[];
        name?: string;
        optional?: boolean;
      };
      csi?: {
        driver: string;
        fsType?: string;
        nodePublishSecretRef?: {
          name?: string;
        };
        readOnly?: boolean;
        volumeAttributes?: {
          [key: string]: unknown;
        };
      };
      downwardAPI?: {
        defaultMode?: number;
        items?: {
          fieldRef?: {
            apiVersion?: string;
            fieldPath: string;
          };
          mode?: number;
          path: string;
          resourceFieldRef?: {
            containerName?: string;
            divisor?: any;
            resource: string;
          };
        }[];
      };
      emptyDir?: {
        medium?: string;
        sizeLimit?: any;
      };
      ephemeral?: {
        volumeClaimTemplate?: {
          metadata?: {
            [key: string]: unknown;
          };
          spec: {
            accessModes?: string[];
            dataSource?: {
              apiGroup?: string;
              kind: string;
              name: string;
            };
            dataSourceRef?: {
              apiGroup?: string;
              kind: string;
              name: string;
              namespace?: string;
            };
            resources?: {
              limits?: {
                [key: string]: unknown;
              };
              requests?: {
                [key: string]: unknown;
              };
            };
            selector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            storageClassName?: string;
            volumeAttributesClassName?: string;
            volumeMode?: string;
            volumeName?: string;
          };
        };
      };
      fc?: {
        fsType?: string;
        lun?: number;
        readOnly?: boolean;
        targetWWNs?: string[];
        wwids?: string[];
      };
      flexVolume?: {
        driver: string;
        fsType?: string;
        options?: {
          [key: string]: unknown;
        };
        readOnly?: boolean;
        secretRef?: {
          name?: string;
        };
      };
      flocker?: {
        datasetName?: string;
        datasetUUID?: string;
      };
      gcePersistentDisk?: {
        fsType?: string;
        partition?: number;
        pdName: string;
        readOnly?: boolean;
      };
      gitRepo?: {
        directory?: string;
        repository: string;
        revision?: string;
      };
      glusterfs?: {
        endpoints: string;
        path: string;
        readOnly?: boolean;
      };
      hostPath?: {
        path: string;
        type?: string;
      };
      image?: {
        pullPolicy?: string;
        reference?: string;
      };
      iscsi?: {
        chapAuthDiscovery?: boolean;
        chapAuthSession?: boolean;
        fsType?: string;
        initiatorName?: string;
        iqn: string;
        iscsiInterface?: string;
        lun: number;
        portals?: string[];
        readOnly?: boolean;
        secretRef?: {
          name?: string;
        };
        targetPortal: string;
      };
      name: string;
      nfs?: {
        path: string;
        readOnly?: boolean;
        server: string;
      };
      persistentVolumeClaim?: {
        claimName: string;
        readOnly?: boolean;
      };
      photonPersistentDisk?: {
        fsType?: string;
        pdID: string;
      };
      portworxVolume?: {
        fsType?: string;
        readOnly?: boolean;
        volumeID: string;
      };
      projected?: {
        defaultMode?: number;
        sources?: {
          clusterTrustBundle?: {
            labelSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            name?: string;
            optional?: boolean;
            path: string;
            signerName?: string;
          };
          configMap?: {
            items?: {
              key: string;
              mode?: number;
              path: string;
            }[];
            name?: string;
            optional?: boolean;
          };
          downwardAPI?: {
            items?: {
              fieldRef?: {
                apiVersion?: string;
                fieldPath: string;
              };
              mode?: number;
              path: string;
              resourceFieldRef?: {
                containerName?: string;
                divisor?: any;
                resource: string;
              };
            }[];
          };
          secret?: {
            items?: {
              key: string;
              mode?: number;
              path: string;
            }[];
            name?: string;
            optional?: boolean;
          };
          serviceAccountToken?: {
            audience?: string;
            expirationSeconds?: number;
            path: string;
          };
        }[];
      };
      quobyte?: {
        group?: string;
        readOnly?: boolean;
        registry: string;
        tenant?: string;
        user?: string;
        volume: string;
      };
      rbd?: {
        fsType?: string;
        image: string;
        keyring?: string;
        monitors: string[];
        pool?: string;
        readOnly?: boolean;
        secretRef?: {
          name?: string;
        };
        user?: string;
      };
      scaleIO?: {
        fsType?: string;
        gateway: string;
        protectionDomain?: string;
        readOnly?: boolean;
        secretRef: {
          name?: string;
        };
        sslEnabled?: boolean;
        storageMode?: string;
        storagePool?: string;
        system: string;
        volumeName?: string;
      };
      secret?: {
        defaultMode?: number;
        items?: {
          key: string;
          mode?: number;
          path: string;
        }[];
        optional?: boolean;
        secretName?: string;
      };
      storageos?: {
        fsType?: string;
        readOnly?: boolean;
        secretRef?: {
          name?: string;
        };
        volumeName?: string;
        volumeNamespace?: string;
      };
      vsphereVolume?: {
        fsType?: string;
        storagePolicyID?: string;
        storagePolicyName?: string;
        volumePath: string;
      };
    }[];
    web?: {
      getConcurrency?: number;
      httpConfig?: {
        headers?: {
          contentSecurityPolicy?: string;
          strictTransportSecurity?: string;
          xContentTypeOptions?: "" | "NoSniff";
          xFrameOptions?: "" | "Deny" | "SameOrigin";
          xXSSProtection?: string;
        };
        http2?: boolean;
      };
      timeout?: number;
      tlsConfig?: {
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        certFile?: string;
        cipherSuites?: string[];
        clientAuthType?: string;
        clientCAFile?: string;
        client_ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        curvePreferences?: string[];
        keyFile?: string;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: string;
        minVersion?: string;
        preferServerCipherSuites?: boolean;
      };
    };
  };
  status?: {
    availableReplicas: number;
    conditions?: {
      lastTransitionTime: string;
      message?: string;
      observedGeneration?: number;
      reason?: string;
      status: string;
      type: string;
    }[];
    paused: boolean;
    replicas: number;
    selector?: string;
    unavailableReplicas: number;
    updatedReplicas: number;
  };
}
export interface MonitoringCoreosComV1AlertmanagerList {
  apiVersion?: string;
  items: MonitoringCoreosComV1Alertmanager[];
  kind?: string;
  metadata?: ListMeta;
}
export interface MonitoringCoreosComV1PodMonitor {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec: {
    attachMetadata?: {
      node?: boolean;
    };
    bodySizeLimit?: string;
    convertClassicHistogramsToNHCB?: boolean;
    fallbackScrapeProtocol?: "PrometheusProto" | "OpenMetricsText0.0.1" | "OpenMetricsText1.0.0" | "PrometheusText0.0.4" | "PrometheusText1.0.0";
    jobLabel?: string;
    keepDroppedTargets?: number;
    labelLimit?: number;
    labelNameLengthLimit?: number;
    labelValueLengthLimit?: number;
    namespaceSelector?: {
      any?: boolean;
      matchNames?: string[];
    };
    nativeHistogramBucketLimit?: number;
    nativeHistogramMinBucketFactor?: any;
    podMetricsEndpoints?: {
      authorization?: {
        credentials?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        type?: string;
      };
      basicAuth?: {
        password?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        username?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      bearerTokenSecret?: {
        key: string;
        name?: string;
        optional?: boolean;
      };
      enableHttp2?: boolean;
      filterRunning?: boolean;
      followRedirects?: boolean;
      honorLabels?: boolean;
      honorTimestamps?: boolean;
      interval?: string;
      metricRelabelings?: {
        action?: "replace" | "Replace" | "keep" | "Keep" | "drop" | "Drop" | "hashmod" | "HashMod" | "labelmap" | "LabelMap" | "labeldrop" | "LabelDrop" | "labelkeep" | "LabelKeep" | "lowercase" | "Lowercase" | "uppercase" | "Uppercase" | "keepequal" | "KeepEqual" | "dropequal" | "DropEqual";
        modulus?: number;
        regex?: string;
        replacement?: string;
        separator?: string;
        sourceLabels?: string[];
        targetLabel?: string;
      }[];
      noProxy?: string;
      oauth2?: {
        clientId: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        clientSecret: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        endpointParams?: {
          [key: string]: unknown;
        };
        noProxy?: string;
        proxyConnectHeader?: {
          [key: string]: unknown;
        };
        proxyFromEnvironment?: boolean;
        proxyUrl?: string;
        scopes?: string[];
        tlsConfig?: {
          ca?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          cert?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          insecureSkipVerify?: boolean;
          keySecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          serverName?: string;
        };
        tokenUrl: string;
      };
      params?: {
        [key: string]: unknown;
      };
      path?: string;
      port?: string;
      portNumber?: number;
      proxyConnectHeader?: {
        [key: string]: unknown;
      };
      proxyFromEnvironment?: boolean;
      proxyUrl?: string;
      relabelings?: {
        action?: "replace" | "Replace" | "keep" | "Keep" | "drop" | "Drop" | "hashmod" | "HashMod" | "labelmap" | "LabelMap" | "labeldrop" | "LabelDrop" | "labelkeep" | "LabelKeep" | "lowercase" | "Lowercase" | "uppercase" | "Uppercase" | "keepequal" | "KeepEqual" | "dropequal" | "DropEqual";
        modulus?: number;
        regex?: string;
        replacement?: string;
        separator?: string;
        sourceLabels?: string[];
        targetLabel?: string;
      }[];
      scheme?: "http" | "https";
      scrapeTimeout?: string;
      targetPort?: any;
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        insecureSkipVerify?: boolean;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
      trackTimestampsStaleness?: boolean;
    }[];
    podTargetLabels?: string[];
    sampleLimit?: number;
    scrapeClass?: string;
    scrapeClassicHistograms?: boolean;
    scrapeProtocols?: ("PrometheusProto" | "OpenMetricsText0.0.1" | "OpenMetricsText1.0.0" | "PrometheusText0.0.4" | "PrometheusText1.0.0")[];
    selector: {
      matchExpressions?: {
        key: string;
        operator: string;
        values?: string[];
      }[];
      matchLabels?: {
        [key: string]: unknown;
      };
    };
    selectorMechanism?: "RelabelConfig" | "RoleSelector";
    targetLimit?: number;
  };
}
export interface MonitoringCoreosComV1PodMonitorList {
  apiVersion?: string;
  items: MonitoringCoreosComV1PodMonitor[];
  kind?: string;
  metadata?: ListMeta;
}
export interface MonitoringCoreosComV1Probe {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec: {
    authorization?: {
      credentials?: {
        key: string;
        name?: string;
        optional?: boolean;
      };
      type?: string;
    };
    basicAuth?: {
      password?: {
        key: string;
        name?: string;
        optional?: boolean;
      };
      username?: {
        key: string;
        name?: string;
        optional?: boolean;
      };
    };
    bearerTokenSecret?: {
      key: string;
      name?: string;
      optional?: boolean;
    };
    convertClassicHistogramsToNHCB?: boolean;
    fallbackScrapeProtocol?: "PrometheusProto" | "OpenMetricsText0.0.1" | "OpenMetricsText1.0.0" | "PrometheusText0.0.4" | "PrometheusText1.0.0";
    interval?: string;
    jobName?: string;
    keepDroppedTargets?: number;
    labelLimit?: number;
    labelNameLengthLimit?: number;
    labelValueLengthLimit?: number;
    metricRelabelings?: {
      action?: "replace" | "Replace" | "keep" | "Keep" | "drop" | "Drop" | "hashmod" | "HashMod" | "labelmap" | "LabelMap" | "labeldrop" | "LabelDrop" | "labelkeep" | "LabelKeep" | "lowercase" | "Lowercase" | "uppercase" | "Uppercase" | "keepequal" | "KeepEqual" | "dropequal" | "DropEqual";
      modulus?: number;
      regex?: string;
      replacement?: string;
      separator?: string;
      sourceLabels?: string[];
      targetLabel?: string;
    }[];
    module?: string;
    nativeHistogramBucketLimit?: number;
    nativeHistogramMinBucketFactor?: any;
    oauth2?: {
      clientId: {
        configMap?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        secret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      clientSecret: {
        key: string;
        name?: string;
        optional?: boolean;
      };
      endpointParams?: {
        [key: string]: unknown;
      };
      noProxy?: string;
      proxyConnectHeader?: {
        [key: string]: unknown;
      };
      proxyFromEnvironment?: boolean;
      proxyUrl?: string;
      scopes?: string[];
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        insecureSkipVerify?: boolean;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
      tokenUrl: string;
    };
    params?: {
      name: string;
      values?: string[];
    }[];
    prober?: {
      noProxy?: string;
      path?: string;
      proxyConnectHeader?: {
        [key: string]: unknown;
      };
      proxyFromEnvironment?: boolean;
      proxyUrl?: string;
      scheme?: "http" | "https";
      url: string;
    };
    sampleLimit?: number;
    scrapeClass?: string;
    scrapeClassicHistograms?: boolean;
    scrapeProtocols?: ("PrometheusProto" | "OpenMetricsText0.0.1" | "OpenMetricsText1.0.0" | "PrometheusText0.0.4" | "PrometheusText1.0.0")[];
    scrapeTimeout?: string;
    targetLimit?: number;
    targets?: {
      ingress?: {
        namespaceSelector?: {
          any?: boolean;
          matchNames?: string[];
        };
        relabelingConfigs?: {
          action?: "replace" | "Replace" | "keep" | "Keep" | "drop" | "Drop" | "hashmod" | "HashMod" | "labelmap" | "LabelMap" | "labeldrop" | "LabelDrop" | "labelkeep" | "LabelKeep" | "lowercase" | "Lowercase" | "uppercase" | "Uppercase" | "keepequal" | "KeepEqual" | "dropequal" | "DropEqual";
          modulus?: number;
          regex?: string;
          replacement?: string;
          separator?: string;
          sourceLabels?: string[];
          targetLabel?: string;
        }[];
        selector?: {
          matchExpressions?: {
            key: string;
            operator: string;
            values?: string[];
          }[];
          matchLabels?: {
            [key: string]: unknown;
          };
        };
      };
      staticConfig?: {
        labels?: {
          [key: string]: unknown;
        };
        relabelingConfigs?: {
          action?: "replace" | "Replace" | "keep" | "Keep" | "drop" | "Drop" | "hashmod" | "HashMod" | "labelmap" | "LabelMap" | "labeldrop" | "LabelDrop" | "labelkeep" | "LabelKeep" | "lowercase" | "Lowercase" | "uppercase" | "Uppercase" | "keepequal" | "KeepEqual" | "dropequal" | "DropEqual";
          modulus?: number;
          regex?: string;
          replacement?: string;
          separator?: string;
          sourceLabels?: string[];
          targetLabel?: string;
        }[];
        static?: string[];
      };
    };
    tlsConfig?: {
      ca?: {
        configMap?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        secret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      cert?: {
        configMap?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        secret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      insecureSkipVerify?: boolean;
      keySecret?: {
        key: string;
        name?: string;
        optional?: boolean;
      };
      maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
      minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
      serverName?: string;
    };
  };
}
export interface MonitoringCoreosComV1ProbeList {
  apiVersion?: string;
  items: MonitoringCoreosComV1Probe[];
  kind?: string;
  metadata?: ListMeta;
}
export interface MonitoringCoreosComV1Prometheus {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec: {
    additionalAlertManagerConfigs?: {
      key: string;
      name?: string;
      optional?: boolean;
    };
    additionalAlertRelabelConfigs?: {
      key: string;
      name?: string;
      optional?: boolean;
    };
    additionalArgs?: {
      name: string;
      value?: string;
    }[];
    additionalScrapeConfigs?: {
      key: string;
      name?: string;
      optional?: boolean;
    };
    affinity?: {
      nodeAffinity?: {
        preferredDuringSchedulingIgnoredDuringExecution?: {
          preference: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchFields?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
          };
          weight: number;
        }[];
        requiredDuringSchedulingIgnoredDuringExecution?: {
          nodeSelectorTerms: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchFields?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
          }[];
        };
      };
      podAffinity?: {
        preferredDuringSchedulingIgnoredDuringExecution?: {
          podAffinityTerm: {
            labelSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            matchLabelKeys?: string[];
            mismatchLabelKeys?: string[];
            namespaceSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            namespaces?: string[];
            topologyKey: string;
          };
          weight: number;
        }[];
        requiredDuringSchedulingIgnoredDuringExecution?: {
          labelSelector?: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchLabels?: {
              [key: string]: unknown;
            };
          };
          matchLabelKeys?: string[];
          mismatchLabelKeys?: string[];
          namespaceSelector?: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchLabels?: {
              [key: string]: unknown;
            };
          };
          namespaces?: string[];
          topologyKey: string;
        }[];
      };
      podAntiAffinity?: {
        preferredDuringSchedulingIgnoredDuringExecution?: {
          podAffinityTerm: {
            labelSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            matchLabelKeys?: string[];
            mismatchLabelKeys?: string[];
            namespaceSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            namespaces?: string[];
            topologyKey: string;
          };
          weight: number;
        }[];
        requiredDuringSchedulingIgnoredDuringExecution?: {
          labelSelector?: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchLabels?: {
              [key: string]: unknown;
            };
          };
          matchLabelKeys?: string[];
          mismatchLabelKeys?: string[];
          namespaceSelector?: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchLabels?: {
              [key: string]: unknown;
            };
          };
          namespaces?: string[];
          topologyKey: string;
        }[];
      };
    };
    alerting?: {
      alertmanagers: {
        alertRelabelings?: {
          action?: "replace" | "Replace" | "keep" | "Keep" | "drop" | "Drop" | "hashmod" | "HashMod" | "labelmap" | "LabelMap" | "labeldrop" | "LabelDrop" | "labelkeep" | "LabelKeep" | "lowercase" | "Lowercase" | "uppercase" | "Uppercase" | "keepequal" | "KeepEqual" | "dropequal" | "DropEqual";
          modulus?: number;
          regex?: string;
          replacement?: string;
          separator?: string;
          sourceLabels?: string[];
          targetLabel?: string;
        }[];
        apiVersion?: "v1" | "V1" | "v2" | "V2";
        authorization?: {
          credentials?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          type?: string;
        };
        basicAuth?: {
          password?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          username?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        bearerTokenFile?: string;
        enableHttp2?: boolean;
        name: string;
        namespace?: string;
        noProxy?: string;
        pathPrefix?: string;
        port: any;
        proxyConnectHeader?: {
          [key: string]: unknown;
        };
        proxyFromEnvironment?: boolean;
        proxyUrl?: string;
        relabelings?: {
          action?: "replace" | "Replace" | "keep" | "Keep" | "drop" | "Drop" | "hashmod" | "HashMod" | "labelmap" | "LabelMap" | "labeldrop" | "LabelDrop" | "labelkeep" | "LabelKeep" | "lowercase" | "Lowercase" | "uppercase" | "Uppercase" | "keepequal" | "KeepEqual" | "dropequal" | "DropEqual";
          modulus?: number;
          regex?: string;
          replacement?: string;
          separator?: string;
          sourceLabels?: string[];
          targetLabel?: string;
        }[];
        scheme?: string;
        sigv4?: {
          accessKey?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          profile?: string;
          region?: string;
          roleArn?: string;
          secretKey?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        timeout?: string;
        tlsConfig?: {
          ca?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          caFile?: string;
          cert?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          certFile?: string;
          insecureSkipVerify?: boolean;
          keyFile?: string;
          keySecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          serverName?: string;
        };
      }[];
    };
    allowOverlappingBlocks?: boolean;
    apiserverConfig?: {
      authorization?: {
        credentials?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        credentialsFile?: string;
        type?: string;
      };
      basicAuth?: {
        password?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        username?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      bearerToken?: string;
      bearerTokenFile?: string;
      host: string;
      noProxy?: string;
      proxyConnectHeader?: {
        [key: string]: unknown;
      };
      proxyFromEnvironment?: boolean;
      proxyUrl?: string;
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        caFile?: string;
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        certFile?: string;
        insecureSkipVerify?: boolean;
        keyFile?: string;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
    };
    arbitraryFSAccessThroughSMs?: {
      deny?: boolean;
    };
    automountServiceAccountToken?: boolean;
    baseImage?: string;
    bodySizeLimit?: string;
    configMaps?: string[];
    containers?: {
      args?: string[];
      command?: string[];
      env?: {
        name: string;
        value?: string;
        valueFrom?: {
          configMapKeyRef?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          fieldRef?: {
            apiVersion?: string;
            fieldPath: string;
          };
          resourceFieldRef?: {
            containerName?: string;
            divisor?: any;
            resource: string;
          };
          secretKeyRef?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
      }[];
      envFrom?: {
        configMapRef?: {
          name?: string;
          optional?: boolean;
        };
        prefix?: string;
        secretRef?: {
          name?: string;
          optional?: boolean;
        };
      }[];
      image?: string;
      imagePullPolicy?: string;
      lifecycle?: {
        postStart?: {
          exec?: {
            command?: string[];
          };
          httpGet?: {
            host?: string;
            httpHeaders?: {
              name: string;
              value: string;
            }[];
            path?: string;
            port: any;
            scheme?: string;
          };
          sleep?: {
            seconds: number;
          };
          tcpSocket?: {
            host?: string;
            port: any;
          };
        };
        preStop?: {
          exec?: {
            command?: string[];
          };
          httpGet?: {
            host?: string;
            httpHeaders?: {
              name: string;
              value: string;
            }[];
            path?: string;
            port: any;
            scheme?: string;
          };
          sleep?: {
            seconds: number;
          };
          tcpSocket?: {
            host?: string;
            port: any;
          };
        };
        stopSignal?: string;
      };
      livenessProbe?: {
        exec?: {
          command?: string[];
        };
        failureThreshold?: number;
        grpc?: {
          port: number;
          service?: string;
        };
        httpGet?: {
          host?: string;
          httpHeaders?: {
            name: string;
            value: string;
          }[];
          path?: string;
          port: any;
          scheme?: string;
        };
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        tcpSocket?: {
          host?: string;
          port: any;
        };
        terminationGracePeriodSeconds?: number;
        timeoutSeconds?: number;
      };
      name: string;
      ports?: {
        containerPort: number;
        hostIP?: string;
        hostPort?: number;
        name?: string;
        protocol?: string;
      }[];
      readinessProbe?: {
        exec?: {
          command?: string[];
        };
        failureThreshold?: number;
        grpc?: {
          port: number;
          service?: string;
        };
        httpGet?: {
          host?: string;
          httpHeaders?: {
            name: string;
            value: string;
          }[];
          path?: string;
          port: any;
          scheme?: string;
        };
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        tcpSocket?: {
          host?: string;
          port: any;
        };
        terminationGracePeriodSeconds?: number;
        timeoutSeconds?: number;
      };
      resizePolicy?: {
        resourceName: string;
        restartPolicy: string;
      }[];
      resources?: {
        claims?: {
          name: string;
          request?: string;
        }[];
        limits?: {
          [key: string]: unknown;
        };
        requests?: {
          [key: string]: unknown;
        };
      };
      restartPolicy?: string;
      securityContext?: {
        allowPrivilegeEscalation?: boolean;
        appArmorProfile?: {
          localhostProfile?: string;
          type: string;
        };
        capabilities?: {
          add?: string[];
          drop?: string[];
        };
        privileged?: boolean;
        procMount?: string;
        readOnlyRootFilesystem?: boolean;
        runAsGroup?: number;
        runAsNonRoot?: boolean;
        runAsUser?: number;
        seLinuxOptions?: {
          level?: string;
          role?: string;
          type?: string;
          user?: string;
        };
        seccompProfile?: {
          localhostProfile?: string;
          type: string;
        };
        windowsOptions?: {
          gmsaCredentialSpec?: string;
          gmsaCredentialSpecName?: string;
          hostProcess?: boolean;
          runAsUserName?: string;
        };
      };
      startupProbe?: {
        exec?: {
          command?: string[];
        };
        failureThreshold?: number;
        grpc?: {
          port: number;
          service?: string;
        };
        httpGet?: {
          host?: string;
          httpHeaders?: {
            name: string;
            value: string;
          }[];
          path?: string;
          port: any;
          scheme?: string;
        };
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        tcpSocket?: {
          host?: string;
          port: any;
        };
        terminationGracePeriodSeconds?: number;
        timeoutSeconds?: number;
      };
      stdin?: boolean;
      stdinOnce?: boolean;
      terminationMessagePath?: string;
      terminationMessagePolicy?: string;
      tty?: boolean;
      volumeDevices?: {
        devicePath: string;
        name: string;
      }[];
      volumeMounts?: {
        mountPath: string;
        mountPropagation?: string;
        name: string;
        readOnly?: boolean;
        recursiveReadOnly?: string;
        subPath?: string;
        subPathExpr?: string;
      }[];
      workingDir?: string;
    }[];
    convertClassicHistogramsToNHCB?: boolean;
    disableCompaction?: boolean;
    dnsConfig?: {
      nameservers?: string[];
      options?: {
        name: string;
        value?: string;
      }[];
      searches?: string[];
    };
    dnsPolicy?: "ClusterFirstWithHostNet" | "ClusterFirst" | "Default" | "None";
    enableAdminAPI?: boolean;
    enableFeatures?: string[];
    enableOTLPReceiver?: boolean;
    enableRemoteWriteReceiver?: boolean;
    enableServiceLinks?: boolean;
    enforcedBodySizeLimit?: string;
    enforcedKeepDroppedTargets?: number;
    enforcedLabelLimit?: number;
    enforcedLabelNameLengthLimit?: number;
    enforcedLabelValueLengthLimit?: number;
    enforcedNamespaceLabel?: string;
    enforcedSampleLimit?: number;
    enforcedTargetLimit?: number;
    evaluationInterval?: string;
    excludedFromEnforcement?: {
      group?: "monitoring.coreos.com";
      name?: string;
      namespace: string;
      resource: "prometheusrules" | "servicemonitors" | "podmonitors" | "probes" | "scrapeconfigs";
    }[];
    exemplars?: {
      maxSize?: number;
    };
    externalLabels?: {
      [key: string]: unknown;
    };
    externalUrl?: string;
    hostAliases?: {
      hostnames: string[];
      ip: string;
    }[];
    hostNetwork?: boolean;
    hostUsers?: boolean;
    ignoreNamespaceSelectors?: boolean;
    image?: string;
    imagePullPolicy?: "" | "Always" | "Never" | "IfNotPresent";
    imagePullSecrets?: {
      name?: string;
    }[];
    initContainers?: {
      args?: string[];
      command?: string[];
      env?: {
        name: string;
        value?: string;
        valueFrom?: {
          configMapKeyRef?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          fieldRef?: {
            apiVersion?: string;
            fieldPath: string;
          };
          resourceFieldRef?: {
            containerName?: string;
            divisor?: any;
            resource: string;
          };
          secretKeyRef?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
      }[];
      envFrom?: {
        configMapRef?: {
          name?: string;
          optional?: boolean;
        };
        prefix?: string;
        secretRef?: {
          name?: string;
          optional?: boolean;
        };
      }[];
      image?: string;
      imagePullPolicy?: string;
      lifecycle?: {
        postStart?: {
          exec?: {
            command?: string[];
          };
          httpGet?: {
            host?: string;
            httpHeaders?: {
              name: string;
              value: string;
            }[];
            path?: string;
            port: any;
            scheme?: string;
          };
          sleep?: {
            seconds: number;
          };
          tcpSocket?: {
            host?: string;
            port: any;
          };
        };
        preStop?: {
          exec?: {
            command?: string[];
          };
          httpGet?: {
            host?: string;
            httpHeaders?: {
              name: string;
              value: string;
            }[];
            path?: string;
            port: any;
            scheme?: string;
          };
          sleep?: {
            seconds: number;
          };
          tcpSocket?: {
            host?: string;
            port: any;
          };
        };
        stopSignal?: string;
      };
      livenessProbe?: {
        exec?: {
          command?: string[];
        };
        failureThreshold?: number;
        grpc?: {
          port: number;
          service?: string;
        };
        httpGet?: {
          host?: string;
          httpHeaders?: {
            name: string;
            value: string;
          }[];
          path?: string;
          port: any;
          scheme?: string;
        };
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        tcpSocket?: {
          host?: string;
          port: any;
        };
        terminationGracePeriodSeconds?: number;
        timeoutSeconds?: number;
      };
      name: string;
      ports?: {
        containerPort: number;
        hostIP?: string;
        hostPort?: number;
        name?: string;
        protocol?: string;
      }[];
      readinessProbe?: {
        exec?: {
          command?: string[];
        };
        failureThreshold?: number;
        grpc?: {
          port: number;
          service?: string;
        };
        httpGet?: {
          host?: string;
          httpHeaders?: {
            name: string;
            value: string;
          }[];
          path?: string;
          port: any;
          scheme?: string;
        };
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        tcpSocket?: {
          host?: string;
          port: any;
        };
        terminationGracePeriodSeconds?: number;
        timeoutSeconds?: number;
      };
      resizePolicy?: {
        resourceName: string;
        restartPolicy: string;
      }[];
      resources?: {
        claims?: {
          name: string;
          request?: string;
        }[];
        limits?: {
          [key: string]: unknown;
        };
        requests?: {
          [key: string]: unknown;
        };
      };
      restartPolicy?: string;
      securityContext?: {
        allowPrivilegeEscalation?: boolean;
        appArmorProfile?: {
          localhostProfile?: string;
          type: string;
        };
        capabilities?: {
          add?: string[];
          drop?: string[];
        };
        privileged?: boolean;
        procMount?: string;
        readOnlyRootFilesystem?: boolean;
        runAsGroup?: number;
        runAsNonRoot?: boolean;
        runAsUser?: number;
        seLinuxOptions?: {
          level?: string;
          role?: string;
          type?: string;
          user?: string;
        };
        seccompProfile?: {
          localhostProfile?: string;
          type: string;
        };
        windowsOptions?: {
          gmsaCredentialSpec?: string;
          gmsaCredentialSpecName?: string;
          hostProcess?: boolean;
          runAsUserName?: string;
        };
      };
      startupProbe?: {
        exec?: {
          command?: string[];
        };
        failureThreshold?: number;
        grpc?: {
          port: number;
          service?: string;
        };
        httpGet?: {
          host?: string;
          httpHeaders?: {
            name: string;
            value: string;
          }[];
          path?: string;
          port: any;
          scheme?: string;
        };
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        tcpSocket?: {
          host?: string;
          port: any;
        };
        terminationGracePeriodSeconds?: number;
        timeoutSeconds?: number;
      };
      stdin?: boolean;
      stdinOnce?: boolean;
      terminationMessagePath?: string;
      terminationMessagePolicy?: string;
      tty?: boolean;
      volumeDevices?: {
        devicePath: string;
        name: string;
      }[];
      volumeMounts?: {
        mountPath: string;
        mountPropagation?: string;
        name: string;
        readOnly?: boolean;
        recursiveReadOnly?: string;
        subPath?: string;
        subPathExpr?: string;
      }[];
      workingDir?: string;
    }[];
    keepDroppedTargets?: number;
    labelLimit?: number;
    labelNameLengthLimit?: number;
    labelValueLengthLimit?: number;
    listenLocal?: boolean;
    logFormat?: "" | "logfmt" | "json";
    logLevel?: "" | "debug" | "info" | "warn" | "error";
    maximumStartupDurationSeconds?: number;
    minReadySeconds?: number;
    nameEscapingScheme?: "AllowUTF8" | "Underscores" | "Dots" | "Values";
    nameValidationScheme?: "UTF8" | "Legacy";
    nodeSelector?: {
      [key: string]: unknown;
    };
    otlp?: {
      convertHistogramsToNHCB?: boolean;
      ignoreResourceAttributes?: string[];
      keepIdentifyingResourceAttributes?: boolean;
      promoteAllResourceAttributes?: boolean;
      promoteResourceAttributes?: string[];
      translationStrategy?: "NoUTF8EscapingWithSuffixes" | "UnderscoreEscapingWithSuffixes" | "NoTranslation";
    };
    overrideHonorLabels?: boolean;
    overrideHonorTimestamps?: boolean;
    paused?: boolean;
    persistentVolumeClaimRetentionPolicy?: {
      whenDeleted?: string;
      whenScaled?: string;
    };
    podMetadata?: {
      annotations?: {
        [key: string]: unknown;
      };
      labels?: {
        [key: string]: unknown;
      };
      name?: string;
    };
    podMonitorNamespaceSelector?: {
      matchExpressions?: {
        key: string;
        operator: string;
        values?: string[];
      }[];
      matchLabels?: {
        [key: string]: unknown;
      };
    };
    podMonitorSelector?: {
      matchExpressions?: {
        key: string;
        operator: string;
        values?: string[];
      }[];
      matchLabels?: {
        [key: string]: unknown;
      };
    };
    podTargetLabels?: string[];
    portName?: string;
    priorityClassName?: string;
    probeNamespaceSelector?: {
      matchExpressions?: {
        key: string;
        operator: string;
        values?: string[];
      }[];
      matchLabels?: {
        [key: string]: unknown;
      };
    };
    probeSelector?: {
      matchExpressions?: {
        key: string;
        operator: string;
        values?: string[];
      }[];
      matchLabels?: {
        [key: string]: unknown;
      };
    };
    prometheusExternalLabelName?: string;
    prometheusRulesExcludedFromEnforce?: {
      ruleName: string;
      ruleNamespace: string;
    }[];
    query?: {
      lookbackDelta?: string;
      maxConcurrency?: number;
      maxSamples?: number;
      timeout?: string;
    };
    queryLogFile?: string;
    reloadStrategy?: "HTTP" | "ProcessSignal";
    remoteRead?: {
      authorization?: {
        credentials?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        credentialsFile?: string;
        type?: string;
      };
      basicAuth?: {
        password?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        username?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      bearerToken?: string;
      bearerTokenFile?: string;
      filterExternalLabels?: boolean;
      followRedirects?: boolean;
      headers?: {
        [key: string]: unknown;
      };
      name?: string;
      noProxy?: string;
      oauth2?: {
        clientId: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        clientSecret: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        endpointParams?: {
          [key: string]: unknown;
        };
        noProxy?: string;
        proxyConnectHeader?: {
          [key: string]: unknown;
        };
        proxyFromEnvironment?: boolean;
        proxyUrl?: string;
        scopes?: string[];
        tlsConfig?: {
          ca?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          cert?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          insecureSkipVerify?: boolean;
          keySecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          serverName?: string;
        };
        tokenUrl: string;
      };
      proxyConnectHeader?: {
        [key: string]: unknown;
      };
      proxyFromEnvironment?: boolean;
      proxyUrl?: string;
      readRecent?: boolean;
      remoteTimeout?: string;
      requiredMatchers?: {
        [key: string]: unknown;
      };
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        caFile?: string;
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        certFile?: string;
        insecureSkipVerify?: boolean;
        keyFile?: string;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
      url: string;
    }[];
    remoteWrite?: {
      authorization?: {
        credentials?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        credentialsFile?: string;
        type?: string;
      };
      azureAd?: {
        cloud?: "AzureChina" | "AzureGovernment" | "AzurePublic";
        managedIdentity?: {
          clientId: string;
        };
        oauth?: {
          clientId: string;
          clientSecret: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          tenantId: string;
        };
        sdk?: {
          tenantId?: string;
        };
      };
      basicAuth?: {
        password?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        username?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      bearerToken?: string;
      bearerTokenFile?: string;
      enableHTTP2?: boolean;
      followRedirects?: boolean;
      headers?: {
        [key: string]: unknown;
      };
      messageVersion?: "V1.0" | "V2.0";
      metadataConfig?: {
        maxSamplesPerSend?: number;
        send?: boolean;
        sendInterval?: string;
      };
      name?: string;
      noProxy?: string;
      oauth2?: {
        clientId: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        clientSecret: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        endpointParams?: {
          [key: string]: unknown;
        };
        noProxy?: string;
        proxyConnectHeader?: {
          [key: string]: unknown;
        };
        proxyFromEnvironment?: boolean;
        proxyUrl?: string;
        scopes?: string[];
        tlsConfig?: {
          ca?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          cert?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          insecureSkipVerify?: boolean;
          keySecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          serverName?: string;
        };
        tokenUrl: string;
      };
      proxyConnectHeader?: {
        [key: string]: unknown;
      };
      proxyFromEnvironment?: boolean;
      proxyUrl?: string;
      queueConfig?: {
        batchSendDeadline?: string;
        capacity?: number;
        maxBackoff?: string;
        maxRetries?: number;
        maxSamplesPerSend?: number;
        maxShards?: number;
        minBackoff?: string;
        minShards?: number;
        retryOnRateLimit?: boolean;
        sampleAgeLimit?: string;
      };
      remoteTimeout?: string;
      roundRobinDNS?: boolean;
      sendExemplars?: boolean;
      sendNativeHistograms?: boolean;
      sigv4?: {
        accessKey?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        profile?: string;
        region?: string;
        roleArn?: string;
        secretKey?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        caFile?: string;
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        certFile?: string;
        insecureSkipVerify?: boolean;
        keyFile?: string;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
      url: string;
      writeRelabelConfigs?: {
        action?: "replace" | "Replace" | "keep" | "Keep" | "drop" | "Drop" | "hashmod" | "HashMod" | "labelmap" | "LabelMap" | "labeldrop" | "LabelDrop" | "labelkeep" | "LabelKeep" | "lowercase" | "Lowercase" | "uppercase" | "Uppercase" | "keepequal" | "KeepEqual" | "dropequal" | "DropEqual";
        modulus?: number;
        regex?: string;
        replacement?: string;
        separator?: string;
        sourceLabels?: string[];
        targetLabel?: string;
      }[];
    }[];
    remoteWriteReceiverMessageVersions?: ("V1.0" | "V2.0")[];
    replicaExternalLabelName?: string;
    replicas?: number;
    resources?: {
      claims?: {
        name: string;
        request?: string;
      }[];
      limits?: {
        [key: string]: unknown;
      };
      requests?: {
        [key: string]: unknown;
      };
    };
    retention?: string;
    retentionSize?: string;
    routePrefix?: string;
    ruleNamespaceSelector?: {
      matchExpressions?: {
        key: string;
        operator: string;
        values?: string[];
      }[];
      matchLabels?: {
        [key: string]: unknown;
      };
    };
    ruleQueryOffset?: string;
    ruleSelector?: {
      matchExpressions?: {
        key: string;
        operator: string;
        values?: string[];
      }[];
      matchLabels?: {
        [key: string]: unknown;
      };
    };
    rules?: {
      alert?: {
        forGracePeriod?: string;
        forOutageTolerance?: string;
        resendDelay?: string;
      };
    };
    runtime?: {
      goGC?: number;
    };
    sampleLimit?: number;
    scrapeClasses?: {
      attachMetadata?: {
        node?: boolean;
      };
      authorization?: {
        credentials?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        credentialsFile?: string;
        type?: string;
      };
      default?: boolean;
      fallbackScrapeProtocol?: "PrometheusProto" | "OpenMetricsText0.0.1" | "OpenMetricsText1.0.0" | "PrometheusText0.0.4" | "PrometheusText1.0.0";
      metricRelabelings?: {
        action?: "replace" | "Replace" | "keep" | "Keep" | "drop" | "Drop" | "hashmod" | "HashMod" | "labelmap" | "LabelMap" | "labeldrop" | "LabelDrop" | "labelkeep" | "LabelKeep" | "lowercase" | "Lowercase" | "uppercase" | "Uppercase" | "keepequal" | "KeepEqual" | "dropequal" | "DropEqual";
        modulus?: number;
        regex?: string;
        replacement?: string;
        separator?: string;
        sourceLabels?: string[];
        targetLabel?: string;
      }[];
      name: string;
      relabelings?: {
        action?: "replace" | "Replace" | "keep" | "Keep" | "drop" | "Drop" | "hashmod" | "HashMod" | "labelmap" | "LabelMap" | "labeldrop" | "LabelDrop" | "labelkeep" | "LabelKeep" | "lowercase" | "Lowercase" | "uppercase" | "Uppercase" | "keepequal" | "KeepEqual" | "dropequal" | "DropEqual";
        modulus?: number;
        regex?: string;
        replacement?: string;
        separator?: string;
        sourceLabels?: string[];
        targetLabel?: string;
      }[];
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        caFile?: string;
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        certFile?: string;
        insecureSkipVerify?: boolean;
        keyFile?: string;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
    }[];
    scrapeClassicHistograms?: boolean;
    scrapeConfigNamespaceSelector?: {
      matchExpressions?: {
        key: string;
        operator: string;
        values?: string[];
      }[];
      matchLabels?: {
        [key: string]: unknown;
      };
    };
    scrapeConfigSelector?: {
      matchExpressions?: {
        key: string;
        operator: string;
        values?: string[];
      }[];
      matchLabels?: {
        [key: string]: unknown;
      };
    };
    scrapeFailureLogFile?: string;
    scrapeInterval?: string;
    scrapeProtocols?: ("PrometheusProto" | "OpenMetricsText0.0.1" | "OpenMetricsText1.0.0" | "PrometheusText0.0.4" | "PrometheusText1.0.0")[];
    scrapeTimeout?: string;
    secrets?: string[];
    securityContext?: {
      appArmorProfile?: {
        localhostProfile?: string;
        type: string;
      };
      fsGroup?: number;
      fsGroupChangePolicy?: string;
      runAsGroup?: number;
      runAsNonRoot?: boolean;
      runAsUser?: number;
      seLinuxChangePolicy?: string;
      seLinuxOptions?: {
        level?: string;
        role?: string;
        type?: string;
        user?: string;
      };
      seccompProfile?: {
        localhostProfile?: string;
        type: string;
      };
      supplementalGroups?: number[];
      supplementalGroupsPolicy?: string;
      sysctls?: {
        name: string;
        value: string;
      }[];
      windowsOptions?: {
        gmsaCredentialSpec?: string;
        gmsaCredentialSpecName?: string;
        hostProcess?: boolean;
        runAsUserName?: string;
      };
    };
    serviceAccountName?: string;
    serviceDiscoveryRole?: "Endpoints" | "EndpointSlice";
    serviceMonitorNamespaceSelector?: {
      matchExpressions?: {
        key: string;
        operator: string;
        values?: string[];
      }[];
      matchLabels?: {
        [key: string]: unknown;
      };
    };
    serviceMonitorSelector?: {
      matchExpressions?: {
        key: string;
        operator: string;
        values?: string[];
      }[];
      matchLabels?: {
        [key: string]: unknown;
      };
    };
    serviceName?: string;
    sha?: string;
    shardRetentionPolicy?: {
      retain?: {
        retentionPeriod: string;
      };
      whenScaled?: "Retain" | "Delete";
    };
    shards?: number;
    storage?: {
      disableMountSubPath?: boolean;
      emptyDir?: {
        medium?: string;
        sizeLimit?: any;
      };
      ephemeral?: {
        volumeClaimTemplate?: {
          metadata?: {
            [key: string]: unknown;
          };
          spec: {
            accessModes?: string[];
            dataSource?: {
              apiGroup?: string;
              kind: string;
              name: string;
            };
            dataSourceRef?: {
              apiGroup?: string;
              kind: string;
              name: string;
              namespace?: string;
            };
            resources?: {
              limits?: {
                [key: string]: unknown;
              };
              requests?: {
                [key: string]: unknown;
              };
            };
            selector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            storageClassName?: string;
            volumeAttributesClassName?: string;
            volumeMode?: string;
            volumeName?: string;
          };
        };
      };
      volumeClaimTemplate?: {
        apiVersion?: string;
        kind?: string;
        metadata?: {
          annotations?: {
            [key: string]: unknown;
          };
          labels?: {
            [key: string]: unknown;
          };
          name?: string;
        };
        spec?: {
          accessModes?: string[];
          dataSource?: {
            apiGroup?: string;
            kind: string;
            name: string;
          };
          dataSourceRef?: {
            apiGroup?: string;
            kind: string;
            name: string;
            namespace?: string;
          };
          resources?: {
            limits?: {
              [key: string]: unknown;
            };
            requests?: {
              [key: string]: unknown;
            };
          };
          selector?: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchLabels?: {
              [key: string]: unknown;
            };
          };
          storageClassName?: string;
          volumeAttributesClassName?: string;
          volumeMode?: string;
          volumeName?: string;
        };
        status?: {
          accessModes?: string[];
          allocatedResourceStatuses?: {
            [key: string]: unknown;
          };
          allocatedResources?: {
            [key: string]: unknown;
          };
          capacity?: {
            [key: string]: unknown;
          };
          conditions?: {
            lastProbeTime?: string;
            lastTransitionTime?: string;
            message?: string;
            reason?: string;
            status: string;
            type: string;
          }[];
          currentVolumeAttributesClassName?: string;
          modifyVolumeStatus?: {
            status: string;
            targetVolumeAttributesClassName?: string;
          };
          phase?: string;
        };
      };
    };
    tag?: string;
    targetLimit?: number;
    terminationGracePeriodSeconds?: number;
    thanos?: {
      additionalArgs?: {
        name: string;
        value?: string;
      }[];
      baseImage?: string;
      blockSize?: string;
      getConfigInterval?: string;
      getConfigTimeout?: string;
      grpcListenLocal?: boolean;
      grpcServerTlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        caFile?: string;
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        certFile?: string;
        insecureSkipVerify?: boolean;
        keyFile?: string;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
      httpListenLocal?: boolean;
      image?: string;
      listenLocal?: boolean;
      logFormat?: "" | "logfmt" | "json";
      logLevel?: "" | "debug" | "info" | "warn" | "error";
      minTime?: string;
      objectStorageConfig?: {
        key: string;
        name?: string;
        optional?: boolean;
      };
      objectStorageConfigFile?: string;
      readyTimeout?: string;
      resources?: {
        claims?: {
          name: string;
          request?: string;
        }[];
        limits?: {
          [key: string]: unknown;
        };
        requests?: {
          [key: string]: unknown;
        };
      };
      sha?: string;
      tag?: string;
      tracingConfig?: {
        key: string;
        name?: string;
        optional?: boolean;
      };
      tracingConfigFile?: string;
      version?: string;
      volumeMounts?: {
        mountPath: string;
        mountPropagation?: string;
        name: string;
        readOnly?: boolean;
        recursiveReadOnly?: string;
        subPath?: string;
        subPathExpr?: string;
      }[];
    };
    tolerations?: {
      effect?: string;
      key?: string;
      operator?: string;
      tolerationSeconds?: number;
      value?: string;
    }[];
    topologySpreadConstraints?: {
      additionalLabelSelectors?: "OnResource" | "OnShard";
      labelSelector?: {
        matchExpressions?: {
          key: string;
          operator: string;
          values?: string[];
        }[];
        matchLabels?: {
          [key: string]: unknown;
        };
      };
      matchLabelKeys?: string[];
      maxSkew: number;
      minDomains?: number;
      nodeAffinityPolicy?: string;
      nodeTaintsPolicy?: string;
      topologyKey: string;
      whenUnsatisfiable: string;
    }[];
    tracingConfig?: {
      clientType?: "http" | "grpc";
      compression?: "gzip";
      endpoint: string;
      headers?: {
        [key: string]: unknown;
      };
      insecure?: boolean;
      samplingFraction?: any;
      timeout?: string;
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        caFile?: string;
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        certFile?: string;
        insecureSkipVerify?: boolean;
        keyFile?: string;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
    };
    tsdb?: {
      outOfOrderTimeWindow?: string;
    };
    version?: string;
    volumeMounts?: {
      mountPath: string;
      mountPropagation?: string;
      name: string;
      readOnly?: boolean;
      recursiveReadOnly?: string;
      subPath?: string;
      subPathExpr?: string;
    }[];
    volumes?: {
      awsElasticBlockStore?: {
        fsType?: string;
        partition?: number;
        readOnly?: boolean;
        volumeID: string;
      };
      azureDisk?: {
        cachingMode?: string;
        diskName: string;
        diskURI: string;
        fsType?: string;
        kind?: string;
        readOnly?: boolean;
      };
      azureFile?: {
        readOnly?: boolean;
        secretName: string;
        shareName: string;
      };
      cephfs?: {
        monitors: string[];
        path?: string;
        readOnly?: boolean;
        secretFile?: string;
        secretRef?: {
          name?: string;
        };
        user?: string;
      };
      cinder?: {
        fsType?: string;
        readOnly?: boolean;
        secretRef?: {
          name?: string;
        };
        volumeID: string;
      };
      configMap?: {
        defaultMode?: number;
        items?: {
          key: string;
          mode?: number;
          path: string;
        }[];
        name?: string;
        optional?: boolean;
      };
      csi?: {
        driver: string;
        fsType?: string;
        nodePublishSecretRef?: {
          name?: string;
        };
        readOnly?: boolean;
        volumeAttributes?: {
          [key: string]: unknown;
        };
      };
      downwardAPI?: {
        defaultMode?: number;
        items?: {
          fieldRef?: {
            apiVersion?: string;
            fieldPath: string;
          };
          mode?: number;
          path: string;
          resourceFieldRef?: {
            containerName?: string;
            divisor?: any;
            resource: string;
          };
        }[];
      };
      emptyDir?: {
        medium?: string;
        sizeLimit?: any;
      };
      ephemeral?: {
        volumeClaimTemplate?: {
          metadata?: {
            [key: string]: unknown;
          };
          spec: {
            accessModes?: string[];
            dataSource?: {
              apiGroup?: string;
              kind: string;
              name: string;
            };
            dataSourceRef?: {
              apiGroup?: string;
              kind: string;
              name: string;
              namespace?: string;
            };
            resources?: {
              limits?: {
                [key: string]: unknown;
              };
              requests?: {
                [key: string]: unknown;
              };
            };
            selector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            storageClassName?: string;
            volumeAttributesClassName?: string;
            volumeMode?: string;
            volumeName?: string;
          };
        };
      };
      fc?: {
        fsType?: string;
        lun?: number;
        readOnly?: boolean;
        targetWWNs?: string[];
        wwids?: string[];
      };
      flexVolume?: {
        driver: string;
        fsType?: string;
        options?: {
          [key: string]: unknown;
        };
        readOnly?: boolean;
        secretRef?: {
          name?: string;
        };
      };
      flocker?: {
        datasetName?: string;
        datasetUUID?: string;
      };
      gcePersistentDisk?: {
        fsType?: string;
        partition?: number;
        pdName: string;
        readOnly?: boolean;
      };
      gitRepo?: {
        directory?: string;
        repository: string;
        revision?: string;
      };
      glusterfs?: {
        endpoints: string;
        path: string;
        readOnly?: boolean;
      };
      hostPath?: {
        path: string;
        type?: string;
      };
      image?: {
        pullPolicy?: string;
        reference?: string;
      };
      iscsi?: {
        chapAuthDiscovery?: boolean;
        chapAuthSession?: boolean;
        fsType?: string;
        initiatorName?: string;
        iqn: string;
        iscsiInterface?: string;
        lun: number;
        portals?: string[];
        readOnly?: boolean;
        secretRef?: {
          name?: string;
        };
        targetPortal: string;
      };
      name: string;
      nfs?: {
        path: string;
        readOnly?: boolean;
        server: string;
      };
      persistentVolumeClaim?: {
        claimName: string;
        readOnly?: boolean;
      };
      photonPersistentDisk?: {
        fsType?: string;
        pdID: string;
      };
      portworxVolume?: {
        fsType?: string;
        readOnly?: boolean;
        volumeID: string;
      };
      projected?: {
        defaultMode?: number;
        sources?: {
          clusterTrustBundle?: {
            labelSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            name?: string;
            optional?: boolean;
            path: string;
            signerName?: string;
          };
          configMap?: {
            items?: {
              key: string;
              mode?: number;
              path: string;
            }[];
            name?: string;
            optional?: boolean;
          };
          downwardAPI?: {
            items?: {
              fieldRef?: {
                apiVersion?: string;
                fieldPath: string;
              };
              mode?: number;
              path: string;
              resourceFieldRef?: {
                containerName?: string;
                divisor?: any;
                resource: string;
              };
            }[];
          };
          secret?: {
            items?: {
              key: string;
              mode?: number;
              path: string;
            }[];
            name?: string;
            optional?: boolean;
          };
          serviceAccountToken?: {
            audience?: string;
            expirationSeconds?: number;
            path: string;
          };
        }[];
      };
      quobyte?: {
        group?: string;
        readOnly?: boolean;
        registry: string;
        tenant?: string;
        user?: string;
        volume: string;
      };
      rbd?: {
        fsType?: string;
        image: string;
        keyring?: string;
        monitors: string[];
        pool?: string;
        readOnly?: boolean;
        secretRef?: {
          name?: string;
        };
        user?: string;
      };
      scaleIO?: {
        fsType?: string;
        gateway: string;
        protectionDomain?: string;
        readOnly?: boolean;
        secretRef: {
          name?: string;
        };
        sslEnabled?: boolean;
        storageMode?: string;
        storagePool?: string;
        system: string;
        volumeName?: string;
      };
      secret?: {
        defaultMode?: number;
        items?: {
          key: string;
          mode?: number;
          path: string;
        }[];
        optional?: boolean;
        secretName?: string;
      };
      storageos?: {
        fsType?: string;
        readOnly?: boolean;
        secretRef?: {
          name?: string;
        };
        volumeName?: string;
        volumeNamespace?: string;
      };
      vsphereVolume?: {
        fsType?: string;
        storagePolicyID?: string;
        storagePolicyName?: string;
        volumePath: string;
      };
    }[];
    walCompression?: boolean;
    web?: {
      httpConfig?: {
        headers?: {
          contentSecurityPolicy?: string;
          strictTransportSecurity?: string;
          xContentTypeOptions?: "" | "NoSniff";
          xFrameOptions?: "" | "Deny" | "SameOrigin";
          xXSSProtection?: string;
        };
        http2?: boolean;
      };
      maxConnections?: number;
      pageTitle?: string;
      tlsConfig?: {
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        certFile?: string;
        cipherSuites?: string[];
        clientAuthType?: string;
        clientCAFile?: string;
        client_ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        curvePreferences?: string[];
        keyFile?: string;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: string;
        minVersion?: string;
        preferServerCipherSuites?: boolean;
      };
    };
  };
  status?: {
    availableReplicas: number;
    conditions?: {
      lastTransitionTime: string;
      message?: string;
      observedGeneration?: number;
      reason?: string;
      status: string;
      type: string;
    }[];
    paused: boolean;
    replicas: number;
    selector?: string;
    shardStatuses?: {
      availableReplicas: number;
      replicas: number;
      shardID: string;
      unavailableReplicas: number;
      updatedReplicas: number;
    }[];
    shards?: number;
    unavailableReplicas: number;
    updatedReplicas: number;
  };
}
export interface MonitoringCoreosComV1PrometheusList {
  apiVersion?: string;
  items: MonitoringCoreosComV1Prometheus[];
  kind?: string;
  metadata?: ListMeta;
}
export interface MonitoringCoreosComV1PrometheusRule {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec: {
    groups?: {
      interval?: string;
      labels?: {
        [key: string]: unknown;
      };
      limit?: number;
      name: string;
      partial_response_strategy?: string;
      query_offset?: string;
      rules?: {
        alert?: string;
        annotations?: {
          [key: string]: unknown;
        };
        expr: any;
        for?: string;
        keep_firing_for?: string;
        labels?: {
          [key: string]: unknown;
        };
        record?: string;
      }[];
    }[];
  };
}
export interface MonitoringCoreosComV1PrometheusRuleList {
  apiVersion?: string;
  items: MonitoringCoreosComV1PrometheusRule[];
  kind?: string;
  metadata?: ListMeta;
}
export interface MonitoringCoreosComV1ServiceMonitor {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec: {
    attachMetadata?: {
      node?: boolean;
    };
    bodySizeLimit?: string;
    convertClassicHistogramsToNHCB?: boolean;
    endpoints: {
      authorization?: {
        credentials?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        type?: string;
      };
      basicAuth?: {
        password?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        username?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      bearerTokenFile?: string;
      bearerTokenSecret?: {
        key: string;
        name?: string;
        optional?: boolean;
      };
      enableHttp2?: boolean;
      filterRunning?: boolean;
      followRedirects?: boolean;
      honorLabels?: boolean;
      honorTimestamps?: boolean;
      interval?: string;
      metricRelabelings?: {
        action?: "replace" | "Replace" | "keep" | "Keep" | "drop" | "Drop" | "hashmod" | "HashMod" | "labelmap" | "LabelMap" | "labeldrop" | "LabelDrop" | "labelkeep" | "LabelKeep" | "lowercase" | "Lowercase" | "uppercase" | "Uppercase" | "keepequal" | "KeepEqual" | "dropequal" | "DropEqual";
        modulus?: number;
        regex?: string;
        replacement?: string;
        separator?: string;
        sourceLabels?: string[];
        targetLabel?: string;
      }[];
      noProxy?: string;
      oauth2?: {
        clientId: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        clientSecret: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        endpointParams?: {
          [key: string]: unknown;
        };
        noProxy?: string;
        proxyConnectHeader?: {
          [key: string]: unknown;
        };
        proxyFromEnvironment?: boolean;
        proxyUrl?: string;
        scopes?: string[];
        tlsConfig?: {
          ca?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          cert?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          insecureSkipVerify?: boolean;
          keySecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          serverName?: string;
        };
        tokenUrl: string;
      };
      params?: {
        [key: string]: unknown;
      };
      path?: string;
      port?: string;
      proxyConnectHeader?: {
        [key: string]: unknown;
      };
      proxyFromEnvironment?: boolean;
      proxyUrl?: string;
      relabelings?: {
        action?: "replace" | "Replace" | "keep" | "Keep" | "drop" | "Drop" | "hashmod" | "HashMod" | "labelmap" | "LabelMap" | "labeldrop" | "LabelDrop" | "labelkeep" | "LabelKeep" | "lowercase" | "Lowercase" | "uppercase" | "Uppercase" | "keepequal" | "KeepEqual" | "dropequal" | "DropEqual";
        modulus?: number;
        regex?: string;
        replacement?: string;
        separator?: string;
        sourceLabels?: string[];
        targetLabel?: string;
      }[];
      scheme?: "http" | "https";
      scrapeTimeout?: string;
      targetPort?: any;
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        caFile?: string;
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        certFile?: string;
        insecureSkipVerify?: boolean;
        keyFile?: string;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
      trackTimestampsStaleness?: boolean;
    }[];
    fallbackScrapeProtocol?: "PrometheusProto" | "OpenMetricsText0.0.1" | "OpenMetricsText1.0.0" | "PrometheusText0.0.4" | "PrometheusText1.0.0";
    jobLabel?: string;
    keepDroppedTargets?: number;
    labelLimit?: number;
    labelNameLengthLimit?: number;
    labelValueLengthLimit?: number;
    namespaceSelector?: {
      any?: boolean;
      matchNames?: string[];
    };
    nativeHistogramBucketLimit?: number;
    nativeHistogramMinBucketFactor?: any;
    podTargetLabels?: string[];
    sampleLimit?: number;
    scrapeClass?: string;
    scrapeClassicHistograms?: boolean;
    scrapeProtocols?: ("PrometheusProto" | "OpenMetricsText0.0.1" | "OpenMetricsText1.0.0" | "PrometheusText0.0.4" | "PrometheusText1.0.0")[];
    selector: {
      matchExpressions?: {
        key: string;
        operator: string;
        values?: string[];
      }[];
      matchLabels?: {
        [key: string]: unknown;
      };
    };
    selectorMechanism?: "RelabelConfig" | "RoleSelector";
    targetLabels?: string[];
    targetLimit?: number;
  };
  status?: {
    bindings?: {
      conditions?: {
        lastTransitionTime: string;
        message?: string;
        observedGeneration?: number;
        reason?: string;
        status: string;
        type: "Accepted";
      }[];
      group: "monitoring.coreos.com";
      name: string;
      namespace: string;
      resource: "prometheuses" | "prometheusagents";
    }[];
  };
}
export interface MonitoringCoreosComV1ServiceMonitorList {
  apiVersion?: string;
  items: MonitoringCoreosComV1ServiceMonitor[];
  kind?: string;
  metadata?: ListMeta;
}
export interface MonitoringCoreosComV1ThanosRuler {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec: {
    additionalArgs?: {
      name: string;
      value?: string;
    }[];
    affinity?: {
      nodeAffinity?: {
        preferredDuringSchedulingIgnoredDuringExecution?: {
          preference: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchFields?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
          };
          weight: number;
        }[];
        requiredDuringSchedulingIgnoredDuringExecution?: {
          nodeSelectorTerms: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchFields?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
          }[];
        };
      };
      podAffinity?: {
        preferredDuringSchedulingIgnoredDuringExecution?: {
          podAffinityTerm: {
            labelSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            matchLabelKeys?: string[];
            mismatchLabelKeys?: string[];
            namespaceSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            namespaces?: string[];
            topologyKey: string;
          };
          weight: number;
        }[];
        requiredDuringSchedulingIgnoredDuringExecution?: {
          labelSelector?: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchLabels?: {
              [key: string]: unknown;
            };
          };
          matchLabelKeys?: string[];
          mismatchLabelKeys?: string[];
          namespaceSelector?: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchLabels?: {
              [key: string]: unknown;
            };
          };
          namespaces?: string[];
          topologyKey: string;
        }[];
      };
      podAntiAffinity?: {
        preferredDuringSchedulingIgnoredDuringExecution?: {
          podAffinityTerm: {
            labelSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            matchLabelKeys?: string[];
            mismatchLabelKeys?: string[];
            namespaceSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            namespaces?: string[];
            topologyKey: string;
          };
          weight: number;
        }[];
        requiredDuringSchedulingIgnoredDuringExecution?: {
          labelSelector?: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchLabels?: {
              [key: string]: unknown;
            };
          };
          matchLabelKeys?: string[];
          mismatchLabelKeys?: string[];
          namespaceSelector?: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchLabels?: {
              [key: string]: unknown;
            };
          };
          namespaces?: string[];
          topologyKey: string;
        }[];
      };
    };
    alertDropLabels?: string[];
    alertQueryUrl?: string;
    alertRelabelConfigFile?: string;
    alertRelabelConfigs?: {
      key: string;
      name?: string;
      optional?: boolean;
    };
    alertmanagersConfig?: {
      key: string;
      name?: string;
      optional?: boolean;
    };
    alertmanagersUrl?: string[];
    containers?: {
      args?: string[];
      command?: string[];
      env?: {
        name: string;
        value?: string;
        valueFrom?: {
          configMapKeyRef?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          fieldRef?: {
            apiVersion?: string;
            fieldPath: string;
          };
          resourceFieldRef?: {
            containerName?: string;
            divisor?: any;
            resource: string;
          };
          secretKeyRef?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
      }[];
      envFrom?: {
        configMapRef?: {
          name?: string;
          optional?: boolean;
        };
        prefix?: string;
        secretRef?: {
          name?: string;
          optional?: boolean;
        };
      }[];
      image?: string;
      imagePullPolicy?: string;
      lifecycle?: {
        postStart?: {
          exec?: {
            command?: string[];
          };
          httpGet?: {
            host?: string;
            httpHeaders?: {
              name: string;
              value: string;
            }[];
            path?: string;
            port: any;
            scheme?: string;
          };
          sleep?: {
            seconds: number;
          };
          tcpSocket?: {
            host?: string;
            port: any;
          };
        };
        preStop?: {
          exec?: {
            command?: string[];
          };
          httpGet?: {
            host?: string;
            httpHeaders?: {
              name: string;
              value: string;
            }[];
            path?: string;
            port: any;
            scheme?: string;
          };
          sleep?: {
            seconds: number;
          };
          tcpSocket?: {
            host?: string;
            port: any;
          };
        };
        stopSignal?: string;
      };
      livenessProbe?: {
        exec?: {
          command?: string[];
        };
        failureThreshold?: number;
        grpc?: {
          port: number;
          service?: string;
        };
        httpGet?: {
          host?: string;
          httpHeaders?: {
            name: string;
            value: string;
          }[];
          path?: string;
          port: any;
          scheme?: string;
        };
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        tcpSocket?: {
          host?: string;
          port: any;
        };
        terminationGracePeriodSeconds?: number;
        timeoutSeconds?: number;
      };
      name: string;
      ports?: {
        containerPort: number;
        hostIP?: string;
        hostPort?: number;
        name?: string;
        protocol?: string;
      }[];
      readinessProbe?: {
        exec?: {
          command?: string[];
        };
        failureThreshold?: number;
        grpc?: {
          port: number;
          service?: string;
        };
        httpGet?: {
          host?: string;
          httpHeaders?: {
            name: string;
            value: string;
          }[];
          path?: string;
          port: any;
          scheme?: string;
        };
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        tcpSocket?: {
          host?: string;
          port: any;
        };
        terminationGracePeriodSeconds?: number;
        timeoutSeconds?: number;
      };
      resizePolicy?: {
        resourceName: string;
        restartPolicy: string;
      }[];
      resources?: {
        claims?: {
          name: string;
          request?: string;
        }[];
        limits?: {
          [key: string]: unknown;
        };
        requests?: {
          [key: string]: unknown;
        };
      };
      restartPolicy?: string;
      securityContext?: {
        allowPrivilegeEscalation?: boolean;
        appArmorProfile?: {
          localhostProfile?: string;
          type: string;
        };
        capabilities?: {
          add?: string[];
          drop?: string[];
        };
        privileged?: boolean;
        procMount?: string;
        readOnlyRootFilesystem?: boolean;
        runAsGroup?: number;
        runAsNonRoot?: boolean;
        runAsUser?: number;
        seLinuxOptions?: {
          level?: string;
          role?: string;
          type?: string;
          user?: string;
        };
        seccompProfile?: {
          localhostProfile?: string;
          type: string;
        };
        windowsOptions?: {
          gmsaCredentialSpec?: string;
          gmsaCredentialSpecName?: string;
          hostProcess?: boolean;
          runAsUserName?: string;
        };
      };
      startupProbe?: {
        exec?: {
          command?: string[];
        };
        failureThreshold?: number;
        grpc?: {
          port: number;
          service?: string;
        };
        httpGet?: {
          host?: string;
          httpHeaders?: {
            name: string;
            value: string;
          }[];
          path?: string;
          port: any;
          scheme?: string;
        };
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        tcpSocket?: {
          host?: string;
          port: any;
        };
        terminationGracePeriodSeconds?: number;
        timeoutSeconds?: number;
      };
      stdin?: boolean;
      stdinOnce?: boolean;
      terminationMessagePath?: string;
      terminationMessagePolicy?: string;
      tty?: boolean;
      volumeDevices?: {
        devicePath: string;
        name: string;
      }[];
      volumeMounts?: {
        mountPath: string;
        mountPropagation?: string;
        name: string;
        readOnly?: boolean;
        recursiveReadOnly?: string;
        subPath?: string;
        subPathExpr?: string;
      }[];
      workingDir?: string;
    }[];
    dnsConfig?: {
      nameservers?: string[];
      options?: {
        name: string;
        value?: string;
      }[];
      searches?: string[];
    };
    dnsPolicy?: "ClusterFirstWithHostNet" | "ClusterFirst" | "Default" | "None";
    enableFeatures?: string[];
    enableServiceLinks?: boolean;
    enforcedNamespaceLabel?: string;
    evaluationInterval?: string;
    excludedFromEnforcement?: {
      group?: "monitoring.coreos.com";
      name?: string;
      namespace: string;
      resource: "prometheusrules" | "servicemonitors" | "podmonitors" | "probes" | "scrapeconfigs";
    }[];
    externalPrefix?: string;
    grpcServerTlsConfig?: {
      ca?: {
        configMap?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        secret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      caFile?: string;
      cert?: {
        configMap?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        secret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      certFile?: string;
      insecureSkipVerify?: boolean;
      keyFile?: string;
      keySecret?: {
        key: string;
        name?: string;
        optional?: boolean;
      };
      maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
      minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
      serverName?: string;
    };
    hostAliases?: {
      hostnames: string[];
      ip: string;
    }[];
    hostUsers?: boolean;
    image?: string;
    imagePullPolicy?: "" | "Always" | "Never" | "IfNotPresent";
    imagePullSecrets?: {
      name?: string;
    }[];
    initContainers?: {
      args?: string[];
      command?: string[];
      env?: {
        name: string;
        value?: string;
        valueFrom?: {
          configMapKeyRef?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          fieldRef?: {
            apiVersion?: string;
            fieldPath: string;
          };
          resourceFieldRef?: {
            containerName?: string;
            divisor?: any;
            resource: string;
          };
          secretKeyRef?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
      }[];
      envFrom?: {
        configMapRef?: {
          name?: string;
          optional?: boolean;
        };
        prefix?: string;
        secretRef?: {
          name?: string;
          optional?: boolean;
        };
      }[];
      image?: string;
      imagePullPolicy?: string;
      lifecycle?: {
        postStart?: {
          exec?: {
            command?: string[];
          };
          httpGet?: {
            host?: string;
            httpHeaders?: {
              name: string;
              value: string;
            }[];
            path?: string;
            port: any;
            scheme?: string;
          };
          sleep?: {
            seconds: number;
          };
          tcpSocket?: {
            host?: string;
            port: any;
          };
        };
        preStop?: {
          exec?: {
            command?: string[];
          };
          httpGet?: {
            host?: string;
            httpHeaders?: {
              name: string;
              value: string;
            }[];
            path?: string;
            port: any;
            scheme?: string;
          };
          sleep?: {
            seconds: number;
          };
          tcpSocket?: {
            host?: string;
            port: any;
          };
        };
        stopSignal?: string;
      };
      livenessProbe?: {
        exec?: {
          command?: string[];
        };
        failureThreshold?: number;
        grpc?: {
          port: number;
          service?: string;
        };
        httpGet?: {
          host?: string;
          httpHeaders?: {
            name: string;
            value: string;
          }[];
          path?: string;
          port: any;
          scheme?: string;
        };
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        tcpSocket?: {
          host?: string;
          port: any;
        };
        terminationGracePeriodSeconds?: number;
        timeoutSeconds?: number;
      };
      name: string;
      ports?: {
        containerPort: number;
        hostIP?: string;
        hostPort?: number;
        name?: string;
        protocol?: string;
      }[];
      readinessProbe?: {
        exec?: {
          command?: string[];
        };
        failureThreshold?: number;
        grpc?: {
          port: number;
          service?: string;
        };
        httpGet?: {
          host?: string;
          httpHeaders?: {
            name: string;
            value: string;
          }[];
          path?: string;
          port: any;
          scheme?: string;
        };
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        tcpSocket?: {
          host?: string;
          port: any;
        };
        terminationGracePeriodSeconds?: number;
        timeoutSeconds?: number;
      };
      resizePolicy?: {
        resourceName: string;
        restartPolicy: string;
      }[];
      resources?: {
        claims?: {
          name: string;
          request?: string;
        }[];
        limits?: {
          [key: string]: unknown;
        };
        requests?: {
          [key: string]: unknown;
        };
      };
      restartPolicy?: string;
      securityContext?: {
        allowPrivilegeEscalation?: boolean;
        appArmorProfile?: {
          localhostProfile?: string;
          type: string;
        };
        capabilities?: {
          add?: string[];
          drop?: string[];
        };
        privileged?: boolean;
        procMount?: string;
        readOnlyRootFilesystem?: boolean;
        runAsGroup?: number;
        runAsNonRoot?: boolean;
        runAsUser?: number;
        seLinuxOptions?: {
          level?: string;
          role?: string;
          type?: string;
          user?: string;
        };
        seccompProfile?: {
          localhostProfile?: string;
          type: string;
        };
        windowsOptions?: {
          gmsaCredentialSpec?: string;
          gmsaCredentialSpecName?: string;
          hostProcess?: boolean;
          runAsUserName?: string;
        };
      };
      startupProbe?: {
        exec?: {
          command?: string[];
        };
        failureThreshold?: number;
        grpc?: {
          port: number;
          service?: string;
        };
        httpGet?: {
          host?: string;
          httpHeaders?: {
            name: string;
            value: string;
          }[];
          path?: string;
          port: any;
          scheme?: string;
        };
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        tcpSocket?: {
          host?: string;
          port: any;
        };
        terminationGracePeriodSeconds?: number;
        timeoutSeconds?: number;
      };
      stdin?: boolean;
      stdinOnce?: boolean;
      terminationMessagePath?: string;
      terminationMessagePolicy?: string;
      tty?: boolean;
      volumeDevices?: {
        devicePath: string;
        name: string;
      }[];
      volumeMounts?: {
        mountPath: string;
        mountPropagation?: string;
        name: string;
        readOnly?: boolean;
        recursiveReadOnly?: string;
        subPath?: string;
        subPathExpr?: string;
      }[];
      workingDir?: string;
    }[];
    labels?: {
      [key: string]: unknown;
    };
    listenLocal?: boolean;
    logFormat?: "" | "logfmt" | "json";
    logLevel?: "" | "debug" | "info" | "warn" | "error";
    minReadySeconds?: number;
    nodeSelector?: {
      [key: string]: unknown;
    };
    objectStorageConfig?: {
      key: string;
      name?: string;
      optional?: boolean;
    };
    objectStorageConfigFile?: string;
    paused?: boolean;
    podMetadata?: {
      annotations?: {
        [key: string]: unknown;
      };
      labels?: {
        [key: string]: unknown;
      };
      name?: string;
    };
    portName?: string;
    priorityClassName?: string;
    prometheusRulesExcludedFromEnforce?: {
      ruleName: string;
      ruleNamespace: string;
    }[];
    queryConfig?: {
      key: string;
      name?: string;
      optional?: boolean;
    };
    queryEndpoints?: string[];
    remoteWrite?: {
      authorization?: {
        credentials?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        credentialsFile?: string;
        type?: string;
      };
      azureAd?: {
        cloud?: "AzureChina" | "AzureGovernment" | "AzurePublic";
        managedIdentity?: {
          clientId: string;
        };
        oauth?: {
          clientId: string;
          clientSecret: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          tenantId: string;
        };
        sdk?: {
          tenantId?: string;
        };
      };
      basicAuth?: {
        password?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        username?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      bearerToken?: string;
      bearerTokenFile?: string;
      enableHTTP2?: boolean;
      followRedirects?: boolean;
      headers?: {
        [key: string]: unknown;
      };
      messageVersion?: "V1.0" | "V2.0";
      metadataConfig?: {
        maxSamplesPerSend?: number;
        send?: boolean;
        sendInterval?: string;
      };
      name?: string;
      noProxy?: string;
      oauth2?: {
        clientId: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        clientSecret: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        endpointParams?: {
          [key: string]: unknown;
        };
        noProxy?: string;
        proxyConnectHeader?: {
          [key: string]: unknown;
        };
        proxyFromEnvironment?: boolean;
        proxyUrl?: string;
        scopes?: string[];
        tlsConfig?: {
          ca?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          cert?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          insecureSkipVerify?: boolean;
          keySecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          serverName?: string;
        };
        tokenUrl: string;
      };
      proxyConnectHeader?: {
        [key: string]: unknown;
      };
      proxyFromEnvironment?: boolean;
      proxyUrl?: string;
      queueConfig?: {
        batchSendDeadline?: string;
        capacity?: number;
        maxBackoff?: string;
        maxRetries?: number;
        maxSamplesPerSend?: number;
        maxShards?: number;
        minBackoff?: string;
        minShards?: number;
        retryOnRateLimit?: boolean;
        sampleAgeLimit?: string;
      };
      remoteTimeout?: string;
      roundRobinDNS?: boolean;
      sendExemplars?: boolean;
      sendNativeHistograms?: boolean;
      sigv4?: {
        accessKey?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        profile?: string;
        region?: string;
        roleArn?: string;
        secretKey?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        caFile?: string;
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        certFile?: string;
        insecureSkipVerify?: boolean;
        keyFile?: string;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
      url: string;
      writeRelabelConfigs?: {
        action?: "replace" | "Replace" | "keep" | "Keep" | "drop" | "Drop" | "hashmod" | "HashMod" | "labelmap" | "LabelMap" | "labeldrop" | "LabelDrop" | "labelkeep" | "LabelKeep" | "lowercase" | "Lowercase" | "uppercase" | "Uppercase" | "keepequal" | "KeepEqual" | "dropequal" | "DropEqual";
        modulus?: number;
        regex?: string;
        replacement?: string;
        separator?: string;
        sourceLabels?: string[];
        targetLabel?: string;
      }[];
    }[];
    replicas?: number;
    resendDelay?: string;
    resources?: {
      claims?: {
        name: string;
        request?: string;
      }[];
      limits?: {
        [key: string]: unknown;
      };
      requests?: {
        [key: string]: unknown;
      };
    };
    retention?: string;
    routePrefix?: string;
    ruleConcurrentEval?: number;
    ruleGracePeriod?: string;
    ruleNamespaceSelector?: {
      matchExpressions?: {
        key: string;
        operator: string;
        values?: string[];
      }[];
      matchLabels?: {
        [key: string]: unknown;
      };
    };
    ruleOutageTolerance?: string;
    ruleQueryOffset?: string;
    ruleSelector?: {
      matchExpressions?: {
        key: string;
        operator: string;
        values?: string[];
      }[];
      matchLabels?: {
        [key: string]: unknown;
      };
    };
    securityContext?: {
      appArmorProfile?: {
        localhostProfile?: string;
        type: string;
      };
      fsGroup?: number;
      fsGroupChangePolicy?: string;
      runAsGroup?: number;
      runAsNonRoot?: boolean;
      runAsUser?: number;
      seLinuxChangePolicy?: string;
      seLinuxOptions?: {
        level?: string;
        role?: string;
        type?: string;
        user?: string;
      };
      seccompProfile?: {
        localhostProfile?: string;
        type: string;
      };
      supplementalGroups?: number[];
      supplementalGroupsPolicy?: string;
      sysctls?: {
        name: string;
        value: string;
      }[];
      windowsOptions?: {
        gmsaCredentialSpec?: string;
        gmsaCredentialSpecName?: string;
        hostProcess?: boolean;
        runAsUserName?: string;
      };
    };
    serviceAccountName?: string;
    serviceName?: string;
    storage?: {
      disableMountSubPath?: boolean;
      emptyDir?: {
        medium?: string;
        sizeLimit?: any;
      };
      ephemeral?: {
        volumeClaimTemplate?: {
          metadata?: {
            [key: string]: unknown;
          };
          spec: {
            accessModes?: string[];
            dataSource?: {
              apiGroup?: string;
              kind: string;
              name: string;
            };
            dataSourceRef?: {
              apiGroup?: string;
              kind: string;
              name: string;
              namespace?: string;
            };
            resources?: {
              limits?: {
                [key: string]: unknown;
              };
              requests?: {
                [key: string]: unknown;
              };
            };
            selector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            storageClassName?: string;
            volumeAttributesClassName?: string;
            volumeMode?: string;
            volumeName?: string;
          };
        };
      };
      volumeClaimTemplate?: {
        apiVersion?: string;
        kind?: string;
        metadata?: {
          annotations?: {
            [key: string]: unknown;
          };
          labels?: {
            [key: string]: unknown;
          };
          name?: string;
        };
        spec?: {
          accessModes?: string[];
          dataSource?: {
            apiGroup?: string;
            kind: string;
            name: string;
          };
          dataSourceRef?: {
            apiGroup?: string;
            kind: string;
            name: string;
            namespace?: string;
          };
          resources?: {
            limits?: {
              [key: string]: unknown;
            };
            requests?: {
              [key: string]: unknown;
            };
          };
          selector?: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchLabels?: {
              [key: string]: unknown;
            };
          };
          storageClassName?: string;
          volumeAttributesClassName?: string;
          volumeMode?: string;
          volumeName?: string;
        };
        status?: {
          accessModes?: string[];
          allocatedResourceStatuses?: {
            [key: string]: unknown;
          };
          allocatedResources?: {
            [key: string]: unknown;
          };
          capacity?: {
            [key: string]: unknown;
          };
          conditions?: {
            lastProbeTime?: string;
            lastTransitionTime?: string;
            message?: string;
            reason?: string;
            status: string;
            type: string;
          }[];
          currentVolumeAttributesClassName?: string;
          modifyVolumeStatus?: {
            status: string;
            targetVolumeAttributesClassName?: string;
          };
          phase?: string;
        };
      };
    };
    terminationGracePeriodSeconds?: number;
    tolerations?: {
      effect?: string;
      key?: string;
      operator?: string;
      tolerationSeconds?: number;
      value?: string;
    }[];
    topologySpreadConstraints?: {
      labelSelector?: {
        matchExpressions?: {
          key: string;
          operator: string;
          values?: string[];
        }[];
        matchLabels?: {
          [key: string]: unknown;
        };
      };
      matchLabelKeys?: string[];
      maxSkew: number;
      minDomains?: number;
      nodeAffinityPolicy?: string;
      nodeTaintsPolicy?: string;
      topologyKey: string;
      whenUnsatisfiable: string;
    }[];
    tracingConfig?: {
      key: string;
      name?: string;
      optional?: boolean;
    };
    tracingConfigFile?: string;
    version?: string;
    volumeMounts?: {
      mountPath: string;
      mountPropagation?: string;
      name: string;
      readOnly?: boolean;
      recursiveReadOnly?: string;
      subPath?: string;
      subPathExpr?: string;
    }[];
    volumes?: {
      awsElasticBlockStore?: {
        fsType?: string;
        partition?: number;
        readOnly?: boolean;
        volumeID: string;
      };
      azureDisk?: {
        cachingMode?: string;
        diskName: string;
        diskURI: string;
        fsType?: string;
        kind?: string;
        readOnly?: boolean;
      };
      azureFile?: {
        readOnly?: boolean;
        secretName: string;
        shareName: string;
      };
      cephfs?: {
        monitors: string[];
        path?: string;
        readOnly?: boolean;
        secretFile?: string;
        secretRef?: {
          name?: string;
        };
        user?: string;
      };
      cinder?: {
        fsType?: string;
        readOnly?: boolean;
        secretRef?: {
          name?: string;
        };
        volumeID: string;
      };
      configMap?: {
        defaultMode?: number;
        items?: {
          key: string;
          mode?: number;
          path: string;
        }[];
        name?: string;
        optional?: boolean;
      };
      csi?: {
        driver: string;
        fsType?: string;
        nodePublishSecretRef?: {
          name?: string;
        };
        readOnly?: boolean;
        volumeAttributes?: {
          [key: string]: unknown;
        };
      };
      downwardAPI?: {
        defaultMode?: number;
        items?: {
          fieldRef?: {
            apiVersion?: string;
            fieldPath: string;
          };
          mode?: number;
          path: string;
          resourceFieldRef?: {
            containerName?: string;
            divisor?: any;
            resource: string;
          };
        }[];
      };
      emptyDir?: {
        medium?: string;
        sizeLimit?: any;
      };
      ephemeral?: {
        volumeClaimTemplate?: {
          metadata?: {
            [key: string]: unknown;
          };
          spec: {
            accessModes?: string[];
            dataSource?: {
              apiGroup?: string;
              kind: string;
              name: string;
            };
            dataSourceRef?: {
              apiGroup?: string;
              kind: string;
              name: string;
              namespace?: string;
            };
            resources?: {
              limits?: {
                [key: string]: unknown;
              };
              requests?: {
                [key: string]: unknown;
              };
            };
            selector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            storageClassName?: string;
            volumeAttributesClassName?: string;
            volumeMode?: string;
            volumeName?: string;
          };
        };
      };
      fc?: {
        fsType?: string;
        lun?: number;
        readOnly?: boolean;
        targetWWNs?: string[];
        wwids?: string[];
      };
      flexVolume?: {
        driver: string;
        fsType?: string;
        options?: {
          [key: string]: unknown;
        };
        readOnly?: boolean;
        secretRef?: {
          name?: string;
        };
      };
      flocker?: {
        datasetName?: string;
        datasetUUID?: string;
      };
      gcePersistentDisk?: {
        fsType?: string;
        partition?: number;
        pdName: string;
        readOnly?: boolean;
      };
      gitRepo?: {
        directory?: string;
        repository: string;
        revision?: string;
      };
      glusterfs?: {
        endpoints: string;
        path: string;
        readOnly?: boolean;
      };
      hostPath?: {
        path: string;
        type?: string;
      };
      image?: {
        pullPolicy?: string;
        reference?: string;
      };
      iscsi?: {
        chapAuthDiscovery?: boolean;
        chapAuthSession?: boolean;
        fsType?: string;
        initiatorName?: string;
        iqn: string;
        iscsiInterface?: string;
        lun: number;
        portals?: string[];
        readOnly?: boolean;
        secretRef?: {
          name?: string;
        };
        targetPortal: string;
      };
      name: string;
      nfs?: {
        path: string;
        readOnly?: boolean;
        server: string;
      };
      persistentVolumeClaim?: {
        claimName: string;
        readOnly?: boolean;
      };
      photonPersistentDisk?: {
        fsType?: string;
        pdID: string;
      };
      portworxVolume?: {
        fsType?: string;
        readOnly?: boolean;
        volumeID: string;
      };
      projected?: {
        defaultMode?: number;
        sources?: {
          clusterTrustBundle?: {
            labelSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            name?: string;
            optional?: boolean;
            path: string;
            signerName?: string;
          };
          configMap?: {
            items?: {
              key: string;
              mode?: number;
              path: string;
            }[];
            name?: string;
            optional?: boolean;
          };
          downwardAPI?: {
            items?: {
              fieldRef?: {
                apiVersion?: string;
                fieldPath: string;
              };
              mode?: number;
              path: string;
              resourceFieldRef?: {
                containerName?: string;
                divisor?: any;
                resource: string;
              };
            }[];
          };
          secret?: {
            items?: {
              key: string;
              mode?: number;
              path: string;
            }[];
            name?: string;
            optional?: boolean;
          };
          serviceAccountToken?: {
            audience?: string;
            expirationSeconds?: number;
            path: string;
          };
        }[];
      };
      quobyte?: {
        group?: string;
        readOnly?: boolean;
        registry: string;
        tenant?: string;
        user?: string;
        volume: string;
      };
      rbd?: {
        fsType?: string;
        image: string;
        keyring?: string;
        monitors: string[];
        pool?: string;
        readOnly?: boolean;
        secretRef?: {
          name?: string;
        };
        user?: string;
      };
      scaleIO?: {
        fsType?: string;
        gateway: string;
        protectionDomain?: string;
        readOnly?: boolean;
        secretRef: {
          name?: string;
        };
        sslEnabled?: boolean;
        storageMode?: string;
        storagePool?: string;
        system: string;
        volumeName?: string;
      };
      secret?: {
        defaultMode?: number;
        items?: {
          key: string;
          mode?: number;
          path: string;
        }[];
        optional?: boolean;
        secretName?: string;
      };
      storageos?: {
        fsType?: string;
        readOnly?: boolean;
        secretRef?: {
          name?: string;
        };
        volumeName?: string;
        volumeNamespace?: string;
      };
      vsphereVolume?: {
        fsType?: string;
        storagePolicyID?: string;
        storagePolicyName?: string;
        volumePath: string;
      };
    }[];
    web?: {
      httpConfig?: {
        headers?: {
          contentSecurityPolicy?: string;
          strictTransportSecurity?: string;
          xContentTypeOptions?: "" | "NoSniff";
          xFrameOptions?: "" | "Deny" | "SameOrigin";
          xXSSProtection?: string;
        };
        http2?: boolean;
      };
      tlsConfig?: {
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        certFile?: string;
        cipherSuites?: string[];
        clientAuthType?: string;
        clientCAFile?: string;
        client_ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        curvePreferences?: string[];
        keyFile?: string;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: string;
        minVersion?: string;
        preferServerCipherSuites?: boolean;
      };
    };
  };
  status?: {
    availableReplicas: number;
    conditions?: {
      lastTransitionTime: string;
      message?: string;
      observedGeneration?: number;
      reason?: string;
      status: string;
      type: string;
    }[];
    paused: boolean;
    replicas: number;
    unavailableReplicas: number;
    updatedReplicas: number;
  };
}
export interface MonitoringCoreosComV1ThanosRulerList {
  apiVersion?: string;
  items: MonitoringCoreosComV1ThanosRuler[];
  kind?: string;
  metadata?: ListMeta;
}
export interface MonitoringCoreosComV1alpha1AlertmanagerConfig {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec: {
    inhibitRules?: {
      equal?: string[];
      sourceMatch?: {
        matchType?: "!=" | "=" | "=~" | "!~";
        name: string;
        regex?: boolean;
        value?: string;
      }[];
      targetMatch?: {
        matchType?: "!=" | "=" | "=~" | "!~";
        name: string;
        regex?: boolean;
        value?: string;
      }[];
    }[];
    muteTimeIntervals?: {
      name: string;
      timeIntervals?: {
        daysOfMonth?: {
          end?: number;
          start?: number;
        }[];
        months?: string[];
        times?: {
          endTime?: string;
          startTime?: string;
        }[];
        weekdays?: string[];
        years?: string[];
      }[];
    }[];
    receivers?: {
      discordConfigs?: {
        apiURL: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        avatarURL?: string;
        content?: string;
        httpConfig?: {
          authorization?: {
            credentials?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            type?: string;
          };
          basicAuth?: {
            password?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            username?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          bearerTokenSecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          followRedirects?: boolean;
          noProxy?: string;
          oauth2?: {
            clientId: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            clientSecret: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            endpointParams?: {
              [key: string]: unknown;
            };
            noProxy?: string;
            proxyConnectHeader?: {
              [key: string]: unknown;
            };
            proxyFromEnvironment?: boolean;
            proxyUrl?: string;
            scopes?: string[];
            tlsConfig?: {
              ca?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              cert?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              insecureSkipVerify?: boolean;
              keySecret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              serverName?: string;
            };
            tokenUrl: string;
          };
          proxyConnectHeader?: {
            [key: string]: unknown;
          };
          proxyFromEnvironment?: boolean;
          proxyURL?: string;
          proxyUrl?: string;
          tlsConfig?: {
            ca?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            cert?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            insecureSkipVerify?: boolean;
            keySecret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            serverName?: string;
          };
        };
        message?: string;
        sendResolved?: boolean;
        title?: string;
        username?: string;
      }[];
      emailConfigs?: {
        authIdentity?: string;
        authPassword?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        authSecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        authUsername?: string;
        from?: string;
        headers?: {
          key: string;
          value: string;
        }[];
        hello?: string;
        html?: string;
        requireTLS?: boolean;
        sendResolved?: boolean;
        smarthost?: string;
        text?: string;
        tlsConfig?: {
          ca?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          cert?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          insecureSkipVerify?: boolean;
          keySecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          serverName?: string;
        };
        to?: string;
      }[];
      msteamsConfigs?: {
        httpConfig?: {
          authorization?: {
            credentials?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            type?: string;
          };
          basicAuth?: {
            password?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            username?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          bearerTokenSecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          followRedirects?: boolean;
          noProxy?: string;
          oauth2?: {
            clientId: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            clientSecret: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            endpointParams?: {
              [key: string]: unknown;
            };
            noProxy?: string;
            proxyConnectHeader?: {
              [key: string]: unknown;
            };
            proxyFromEnvironment?: boolean;
            proxyUrl?: string;
            scopes?: string[];
            tlsConfig?: {
              ca?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              cert?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              insecureSkipVerify?: boolean;
              keySecret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              serverName?: string;
            };
            tokenUrl: string;
          };
          proxyConnectHeader?: {
            [key: string]: unknown;
          };
          proxyFromEnvironment?: boolean;
          proxyURL?: string;
          proxyUrl?: string;
          tlsConfig?: {
            ca?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            cert?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            insecureSkipVerify?: boolean;
            keySecret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            serverName?: string;
          };
        };
        sendResolved?: boolean;
        summary?: string;
        text?: string;
        title?: string;
        webhookUrl: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      }[];
      msteamsv2Configs?: {
        httpConfig?: {
          authorization?: {
            credentials?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            type?: string;
          };
          basicAuth?: {
            password?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            username?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          bearerTokenSecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          followRedirects?: boolean;
          noProxy?: string;
          oauth2?: {
            clientId: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            clientSecret: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            endpointParams?: {
              [key: string]: unknown;
            };
            noProxy?: string;
            proxyConnectHeader?: {
              [key: string]: unknown;
            };
            proxyFromEnvironment?: boolean;
            proxyUrl?: string;
            scopes?: string[];
            tlsConfig?: {
              ca?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              cert?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              insecureSkipVerify?: boolean;
              keySecret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              serverName?: string;
            };
            tokenUrl: string;
          };
          proxyConnectHeader?: {
            [key: string]: unknown;
          };
          proxyFromEnvironment?: boolean;
          proxyURL?: string;
          proxyUrl?: string;
          tlsConfig?: {
            ca?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            cert?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            insecureSkipVerify?: boolean;
            keySecret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            serverName?: string;
          };
        };
        sendResolved?: boolean;
        text?: string;
        title?: string;
        webhookURL?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      }[];
      name: string;
      opsgenieConfigs?: {
        actions?: string;
        apiKey?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        apiURL?: string;
        description?: string;
        details?: {
          key: string;
          value: string;
        }[];
        entity?: string;
        httpConfig?: {
          authorization?: {
            credentials?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            type?: string;
          };
          basicAuth?: {
            password?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            username?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          bearerTokenSecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          followRedirects?: boolean;
          noProxy?: string;
          oauth2?: {
            clientId: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            clientSecret: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            endpointParams?: {
              [key: string]: unknown;
            };
            noProxy?: string;
            proxyConnectHeader?: {
              [key: string]: unknown;
            };
            proxyFromEnvironment?: boolean;
            proxyUrl?: string;
            scopes?: string[];
            tlsConfig?: {
              ca?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              cert?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              insecureSkipVerify?: boolean;
              keySecret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              serverName?: string;
            };
            tokenUrl: string;
          };
          proxyConnectHeader?: {
            [key: string]: unknown;
          };
          proxyFromEnvironment?: boolean;
          proxyURL?: string;
          proxyUrl?: string;
          tlsConfig?: {
            ca?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            cert?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            insecureSkipVerify?: boolean;
            keySecret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            serverName?: string;
          };
        };
        message?: string;
        note?: string;
        priority?: string;
        responders?: {
          id?: string;
          name?: string;
          type: string;
          username?: string;
        }[];
        sendResolved?: boolean;
        source?: string;
        tags?: string;
        updateAlerts?: boolean;
      }[];
      pagerdutyConfigs?: {
        class?: string;
        client?: string;
        clientURL?: string;
        component?: string;
        description?: string;
        details?: {
          key: string;
          value: string;
        }[];
        group?: string;
        httpConfig?: {
          authorization?: {
            credentials?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            type?: string;
          };
          basicAuth?: {
            password?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            username?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          bearerTokenSecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          followRedirects?: boolean;
          noProxy?: string;
          oauth2?: {
            clientId: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            clientSecret: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            endpointParams?: {
              [key: string]: unknown;
            };
            noProxy?: string;
            proxyConnectHeader?: {
              [key: string]: unknown;
            };
            proxyFromEnvironment?: boolean;
            proxyUrl?: string;
            scopes?: string[];
            tlsConfig?: {
              ca?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              cert?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              insecureSkipVerify?: boolean;
              keySecret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              serverName?: string;
            };
            tokenUrl: string;
          };
          proxyConnectHeader?: {
            [key: string]: unknown;
          };
          proxyFromEnvironment?: boolean;
          proxyURL?: string;
          proxyUrl?: string;
          tlsConfig?: {
            ca?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            cert?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            insecureSkipVerify?: boolean;
            keySecret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            serverName?: string;
          };
        };
        pagerDutyImageConfigs?: {
          alt?: string;
          href?: string;
          src?: string;
        }[];
        pagerDutyLinkConfigs?: {
          alt?: string;
          href?: string;
        }[];
        routingKey?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        sendResolved?: boolean;
        serviceKey?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        severity?: string;
        source?: string;
        url?: string;
      }[];
      pushoverConfigs?: {
        device?: string;
        expire?: string;
        html?: boolean;
        httpConfig?: {
          authorization?: {
            credentials?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            type?: string;
          };
          basicAuth?: {
            password?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            username?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          bearerTokenSecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          followRedirects?: boolean;
          noProxy?: string;
          oauth2?: {
            clientId: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            clientSecret: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            endpointParams?: {
              [key: string]: unknown;
            };
            noProxy?: string;
            proxyConnectHeader?: {
              [key: string]: unknown;
            };
            proxyFromEnvironment?: boolean;
            proxyUrl?: string;
            scopes?: string[];
            tlsConfig?: {
              ca?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              cert?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              insecureSkipVerify?: boolean;
              keySecret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              serverName?: string;
            };
            tokenUrl: string;
          };
          proxyConnectHeader?: {
            [key: string]: unknown;
          };
          proxyFromEnvironment?: boolean;
          proxyURL?: string;
          proxyUrl?: string;
          tlsConfig?: {
            ca?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            cert?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            insecureSkipVerify?: boolean;
            keySecret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            serverName?: string;
          };
        };
        message?: string;
        priority?: string;
        retry?: string;
        sendResolved?: boolean;
        sound?: string;
        title?: string;
        token?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        tokenFile?: string;
        ttl?: string;
        url?: string;
        urlTitle?: string;
        userKey?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        userKeyFile?: string;
      }[];
      rocketchatConfigs?: {
        actions?: {
          msg?: string;
          text?: string;
          url?: string;
        }[];
        apiURL?: string;
        channel?: string;
        color?: string;
        emoji?: string;
        fields?: {
          short?: boolean;
          title?: string;
          value?: string;
        }[];
        httpConfig?: {
          authorization?: {
            credentials?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            type?: string;
          };
          basicAuth?: {
            password?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            username?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          bearerTokenSecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          followRedirects?: boolean;
          noProxy?: string;
          oauth2?: {
            clientId: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            clientSecret: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            endpointParams?: {
              [key: string]: unknown;
            };
            noProxy?: string;
            proxyConnectHeader?: {
              [key: string]: unknown;
            };
            proxyFromEnvironment?: boolean;
            proxyUrl?: string;
            scopes?: string[];
            tlsConfig?: {
              ca?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              cert?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              insecureSkipVerify?: boolean;
              keySecret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              serverName?: string;
            };
            tokenUrl: string;
          };
          proxyConnectHeader?: {
            [key: string]: unknown;
          };
          proxyFromEnvironment?: boolean;
          proxyURL?: string;
          proxyUrl?: string;
          tlsConfig?: {
            ca?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            cert?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            insecureSkipVerify?: boolean;
            keySecret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            serverName?: string;
          };
        };
        iconURL?: string;
        imageURL?: string;
        linkNames?: boolean;
        sendResolved?: boolean;
        shortFields?: boolean;
        text?: string;
        thumbURL?: string;
        title?: string;
        titleLink?: string;
        token: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        tokenID: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      }[];
      slackConfigs?: {
        actions?: {
          confirm?: {
            dismissText?: string;
            okText?: string;
            text: string;
            title?: string;
          };
          name?: string;
          style?: string;
          text: string;
          type: string;
          url?: string;
          value?: string;
        }[];
        apiURL?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        callbackId?: string;
        channel?: string;
        color?: string;
        fallback?: string;
        fields?: {
          short?: boolean;
          title: string;
          value: string;
        }[];
        footer?: string;
        httpConfig?: {
          authorization?: {
            credentials?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            type?: string;
          };
          basicAuth?: {
            password?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            username?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          bearerTokenSecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          followRedirects?: boolean;
          noProxy?: string;
          oauth2?: {
            clientId: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            clientSecret: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            endpointParams?: {
              [key: string]: unknown;
            };
            noProxy?: string;
            proxyConnectHeader?: {
              [key: string]: unknown;
            };
            proxyFromEnvironment?: boolean;
            proxyUrl?: string;
            scopes?: string[];
            tlsConfig?: {
              ca?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              cert?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              insecureSkipVerify?: boolean;
              keySecret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              serverName?: string;
            };
            tokenUrl: string;
          };
          proxyConnectHeader?: {
            [key: string]: unknown;
          };
          proxyFromEnvironment?: boolean;
          proxyURL?: string;
          proxyUrl?: string;
          tlsConfig?: {
            ca?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            cert?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            insecureSkipVerify?: boolean;
            keySecret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            serverName?: string;
          };
        };
        iconEmoji?: string;
        iconURL?: string;
        imageURL?: string;
        linkNames?: boolean;
        mrkdwnIn?: string[];
        pretext?: string;
        sendResolved?: boolean;
        shortFields?: boolean;
        text?: string;
        thumbURL?: string;
        title?: string;
        titleLink?: string;
        username?: string;
      }[];
      snsConfigs?: {
        apiURL?: string;
        attributes?: {
          [key: string]: unknown;
        };
        httpConfig?: {
          authorization?: {
            credentials?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            type?: string;
          };
          basicAuth?: {
            password?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            username?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          bearerTokenSecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          followRedirects?: boolean;
          noProxy?: string;
          oauth2?: {
            clientId: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            clientSecret: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            endpointParams?: {
              [key: string]: unknown;
            };
            noProxy?: string;
            proxyConnectHeader?: {
              [key: string]: unknown;
            };
            proxyFromEnvironment?: boolean;
            proxyUrl?: string;
            scopes?: string[];
            tlsConfig?: {
              ca?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              cert?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              insecureSkipVerify?: boolean;
              keySecret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              serverName?: string;
            };
            tokenUrl: string;
          };
          proxyConnectHeader?: {
            [key: string]: unknown;
          };
          proxyFromEnvironment?: boolean;
          proxyURL?: string;
          proxyUrl?: string;
          tlsConfig?: {
            ca?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            cert?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            insecureSkipVerify?: boolean;
            keySecret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            serverName?: string;
          };
        };
        message?: string;
        phoneNumber?: string;
        sendResolved?: boolean;
        sigv4?: {
          accessKey?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          profile?: string;
          region?: string;
          roleArn?: string;
          secretKey?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        subject?: string;
        targetARN?: string;
        topicARN?: string;
      }[];
      telegramConfigs?: {
        apiURL?: string;
        botToken?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        botTokenFile?: string;
        chatID: number;
        disableNotifications?: boolean;
        httpConfig?: {
          authorization?: {
            credentials?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            type?: string;
          };
          basicAuth?: {
            password?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            username?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          bearerTokenSecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          followRedirects?: boolean;
          noProxy?: string;
          oauth2?: {
            clientId: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            clientSecret: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            endpointParams?: {
              [key: string]: unknown;
            };
            noProxy?: string;
            proxyConnectHeader?: {
              [key: string]: unknown;
            };
            proxyFromEnvironment?: boolean;
            proxyUrl?: string;
            scopes?: string[];
            tlsConfig?: {
              ca?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              cert?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              insecureSkipVerify?: boolean;
              keySecret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              serverName?: string;
            };
            tokenUrl: string;
          };
          proxyConnectHeader?: {
            [key: string]: unknown;
          };
          proxyFromEnvironment?: boolean;
          proxyURL?: string;
          proxyUrl?: string;
          tlsConfig?: {
            ca?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            cert?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            insecureSkipVerify?: boolean;
            keySecret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            serverName?: string;
          };
        };
        message?: string;
        messageThreadID?: number;
        parseMode?: "MarkdownV2" | "Markdown" | "HTML";
        sendResolved?: boolean;
      }[];
      victoropsConfigs?: {
        apiKey?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        apiUrl?: string;
        customFields?: {
          key: string;
          value: string;
        }[];
        entityDisplayName?: string;
        httpConfig?: {
          authorization?: {
            credentials?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            type?: string;
          };
          basicAuth?: {
            password?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            username?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          bearerTokenSecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          followRedirects?: boolean;
          noProxy?: string;
          oauth2?: {
            clientId: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            clientSecret: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            endpointParams?: {
              [key: string]: unknown;
            };
            noProxy?: string;
            proxyConnectHeader?: {
              [key: string]: unknown;
            };
            proxyFromEnvironment?: boolean;
            proxyUrl?: string;
            scopes?: string[];
            tlsConfig?: {
              ca?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              cert?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              insecureSkipVerify?: boolean;
              keySecret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              serverName?: string;
            };
            tokenUrl: string;
          };
          proxyConnectHeader?: {
            [key: string]: unknown;
          };
          proxyFromEnvironment?: boolean;
          proxyURL?: string;
          proxyUrl?: string;
          tlsConfig?: {
            ca?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            cert?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            insecureSkipVerify?: boolean;
            keySecret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            serverName?: string;
          };
        };
        messageType?: string;
        monitoringTool?: string;
        routingKey?: string;
        sendResolved?: boolean;
        stateMessage?: string;
      }[];
      webexConfigs?: {
        apiURL?: string;
        httpConfig?: {
          authorization?: {
            credentials?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            type?: string;
          };
          basicAuth?: {
            password?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            username?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          bearerTokenSecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          followRedirects?: boolean;
          noProxy?: string;
          oauth2?: {
            clientId: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            clientSecret: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            endpointParams?: {
              [key: string]: unknown;
            };
            noProxy?: string;
            proxyConnectHeader?: {
              [key: string]: unknown;
            };
            proxyFromEnvironment?: boolean;
            proxyUrl?: string;
            scopes?: string[];
            tlsConfig?: {
              ca?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              cert?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              insecureSkipVerify?: boolean;
              keySecret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              serverName?: string;
            };
            tokenUrl: string;
          };
          proxyConnectHeader?: {
            [key: string]: unknown;
          };
          proxyFromEnvironment?: boolean;
          proxyURL?: string;
          proxyUrl?: string;
          tlsConfig?: {
            ca?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            cert?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            insecureSkipVerify?: boolean;
            keySecret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            serverName?: string;
          };
        };
        message?: string;
        roomID: string;
        sendResolved?: boolean;
      }[];
      webhookConfigs?: {
        httpConfig?: {
          authorization?: {
            credentials?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            type?: string;
          };
          basicAuth?: {
            password?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            username?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          bearerTokenSecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          followRedirects?: boolean;
          noProxy?: string;
          oauth2?: {
            clientId: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            clientSecret: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            endpointParams?: {
              [key: string]: unknown;
            };
            noProxy?: string;
            proxyConnectHeader?: {
              [key: string]: unknown;
            };
            proxyFromEnvironment?: boolean;
            proxyUrl?: string;
            scopes?: string[];
            tlsConfig?: {
              ca?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              cert?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              insecureSkipVerify?: boolean;
              keySecret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              serverName?: string;
            };
            tokenUrl: string;
          };
          proxyConnectHeader?: {
            [key: string]: unknown;
          };
          proxyFromEnvironment?: boolean;
          proxyURL?: string;
          proxyUrl?: string;
          tlsConfig?: {
            ca?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            cert?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            insecureSkipVerify?: boolean;
            keySecret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            serverName?: string;
          };
        };
        maxAlerts?: number;
        sendResolved?: boolean;
        timeout?: string;
        url?: string;
        urlSecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      }[];
      wechatConfigs?: {
        agentID?: string;
        apiSecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        apiURL?: string;
        corpID?: string;
        httpConfig?: {
          authorization?: {
            credentials?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            type?: string;
          };
          basicAuth?: {
            password?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            username?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          bearerTokenSecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          followRedirects?: boolean;
          noProxy?: string;
          oauth2?: {
            clientId: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            clientSecret: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            endpointParams?: {
              [key: string]: unknown;
            };
            noProxy?: string;
            proxyConnectHeader?: {
              [key: string]: unknown;
            };
            proxyFromEnvironment?: boolean;
            proxyUrl?: string;
            scopes?: string[];
            tlsConfig?: {
              ca?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              cert?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              insecureSkipVerify?: boolean;
              keySecret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              serverName?: string;
            };
            tokenUrl: string;
          };
          proxyConnectHeader?: {
            [key: string]: unknown;
          };
          proxyFromEnvironment?: boolean;
          proxyURL?: string;
          proxyUrl?: string;
          tlsConfig?: {
            ca?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            cert?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            insecureSkipVerify?: boolean;
            keySecret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            serverName?: string;
          };
        };
        message?: string;
        messageType?: string;
        sendResolved?: boolean;
        toParty?: string;
        toTag?: string;
        toUser?: string;
      }[];
    }[];
    route?: {
      activeTimeIntervals?: string[];
      continue?: boolean;
      groupBy?: string[];
      groupInterval?: string;
      groupWait?: string;
      matchers?: {
        matchType?: "!=" | "=" | "=~" | "!~";
        name: string;
        regex?: boolean;
        value?: string;
      }[];
      muteTimeIntervals?: string[];
      receiver?: string;
      repeatInterval?: string;
      routes?: any[];
    };
  };
}
export interface MonitoringCoreosComV1alpha1AlertmanagerConfigList {
  apiVersion?: string;
  items: MonitoringCoreosComV1alpha1AlertmanagerConfig[];
  kind?: string;
  metadata?: ListMeta;
}
export interface MonitoringCoreosComV1alpha1PrometheusAgent {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec: {
    additionalArgs?: {
      name: string;
      value?: string;
    }[];
    additionalScrapeConfigs?: {
      key: string;
      name?: string;
      optional?: boolean;
    };
    affinity?: {
      nodeAffinity?: {
        preferredDuringSchedulingIgnoredDuringExecution?: {
          preference: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchFields?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
          };
          weight: number;
        }[];
        requiredDuringSchedulingIgnoredDuringExecution?: {
          nodeSelectorTerms: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchFields?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
          }[];
        };
      };
      podAffinity?: {
        preferredDuringSchedulingIgnoredDuringExecution?: {
          podAffinityTerm: {
            labelSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            matchLabelKeys?: string[];
            mismatchLabelKeys?: string[];
            namespaceSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            namespaces?: string[];
            topologyKey: string;
          };
          weight: number;
        }[];
        requiredDuringSchedulingIgnoredDuringExecution?: {
          labelSelector?: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchLabels?: {
              [key: string]: unknown;
            };
          };
          matchLabelKeys?: string[];
          mismatchLabelKeys?: string[];
          namespaceSelector?: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchLabels?: {
              [key: string]: unknown;
            };
          };
          namespaces?: string[];
          topologyKey: string;
        }[];
      };
      podAntiAffinity?: {
        preferredDuringSchedulingIgnoredDuringExecution?: {
          podAffinityTerm: {
            labelSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            matchLabelKeys?: string[];
            mismatchLabelKeys?: string[];
            namespaceSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            namespaces?: string[];
            topologyKey: string;
          };
          weight: number;
        }[];
        requiredDuringSchedulingIgnoredDuringExecution?: {
          labelSelector?: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchLabels?: {
              [key: string]: unknown;
            };
          };
          matchLabelKeys?: string[];
          mismatchLabelKeys?: string[];
          namespaceSelector?: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchLabels?: {
              [key: string]: unknown;
            };
          };
          namespaces?: string[];
          topologyKey: string;
        }[];
      };
    };
    apiserverConfig?: {
      authorization?: {
        credentials?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        credentialsFile?: string;
        type?: string;
      };
      basicAuth?: {
        password?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        username?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      bearerToken?: string;
      bearerTokenFile?: string;
      host: string;
      noProxy?: string;
      proxyConnectHeader?: {
        [key: string]: unknown;
      };
      proxyFromEnvironment?: boolean;
      proxyUrl?: string;
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        caFile?: string;
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        certFile?: string;
        insecureSkipVerify?: boolean;
        keyFile?: string;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
    };
    arbitraryFSAccessThroughSMs?: {
      deny?: boolean;
    };
    automountServiceAccountToken?: boolean;
    bodySizeLimit?: string;
    configMaps?: string[];
    containers?: {
      args?: string[];
      command?: string[];
      env?: {
        name: string;
        value?: string;
        valueFrom?: {
          configMapKeyRef?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          fieldRef?: {
            apiVersion?: string;
            fieldPath: string;
          };
          resourceFieldRef?: {
            containerName?: string;
            divisor?: any;
            resource: string;
          };
          secretKeyRef?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
      }[];
      envFrom?: {
        configMapRef?: {
          name?: string;
          optional?: boolean;
        };
        prefix?: string;
        secretRef?: {
          name?: string;
          optional?: boolean;
        };
      }[];
      image?: string;
      imagePullPolicy?: string;
      lifecycle?: {
        postStart?: {
          exec?: {
            command?: string[];
          };
          httpGet?: {
            host?: string;
            httpHeaders?: {
              name: string;
              value: string;
            }[];
            path?: string;
            port: any;
            scheme?: string;
          };
          sleep?: {
            seconds: number;
          };
          tcpSocket?: {
            host?: string;
            port: any;
          };
        };
        preStop?: {
          exec?: {
            command?: string[];
          };
          httpGet?: {
            host?: string;
            httpHeaders?: {
              name: string;
              value: string;
            }[];
            path?: string;
            port: any;
            scheme?: string;
          };
          sleep?: {
            seconds: number;
          };
          tcpSocket?: {
            host?: string;
            port: any;
          };
        };
        stopSignal?: string;
      };
      livenessProbe?: {
        exec?: {
          command?: string[];
        };
        failureThreshold?: number;
        grpc?: {
          port: number;
          service?: string;
        };
        httpGet?: {
          host?: string;
          httpHeaders?: {
            name: string;
            value: string;
          }[];
          path?: string;
          port: any;
          scheme?: string;
        };
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        tcpSocket?: {
          host?: string;
          port: any;
        };
        terminationGracePeriodSeconds?: number;
        timeoutSeconds?: number;
      };
      name: string;
      ports?: {
        containerPort: number;
        hostIP?: string;
        hostPort?: number;
        name?: string;
        protocol?: string;
      }[];
      readinessProbe?: {
        exec?: {
          command?: string[];
        };
        failureThreshold?: number;
        grpc?: {
          port: number;
          service?: string;
        };
        httpGet?: {
          host?: string;
          httpHeaders?: {
            name: string;
            value: string;
          }[];
          path?: string;
          port: any;
          scheme?: string;
        };
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        tcpSocket?: {
          host?: string;
          port: any;
        };
        terminationGracePeriodSeconds?: number;
        timeoutSeconds?: number;
      };
      resizePolicy?: {
        resourceName: string;
        restartPolicy: string;
      }[];
      resources?: {
        claims?: {
          name: string;
          request?: string;
        }[];
        limits?: {
          [key: string]: unknown;
        };
        requests?: {
          [key: string]: unknown;
        };
      };
      restartPolicy?: string;
      securityContext?: {
        allowPrivilegeEscalation?: boolean;
        appArmorProfile?: {
          localhostProfile?: string;
          type: string;
        };
        capabilities?: {
          add?: string[];
          drop?: string[];
        };
        privileged?: boolean;
        procMount?: string;
        readOnlyRootFilesystem?: boolean;
        runAsGroup?: number;
        runAsNonRoot?: boolean;
        runAsUser?: number;
        seLinuxOptions?: {
          level?: string;
          role?: string;
          type?: string;
          user?: string;
        };
        seccompProfile?: {
          localhostProfile?: string;
          type: string;
        };
        windowsOptions?: {
          gmsaCredentialSpec?: string;
          gmsaCredentialSpecName?: string;
          hostProcess?: boolean;
          runAsUserName?: string;
        };
      };
      startupProbe?: {
        exec?: {
          command?: string[];
        };
        failureThreshold?: number;
        grpc?: {
          port: number;
          service?: string;
        };
        httpGet?: {
          host?: string;
          httpHeaders?: {
            name: string;
            value: string;
          }[];
          path?: string;
          port: any;
          scheme?: string;
        };
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        tcpSocket?: {
          host?: string;
          port: any;
        };
        terminationGracePeriodSeconds?: number;
        timeoutSeconds?: number;
      };
      stdin?: boolean;
      stdinOnce?: boolean;
      terminationMessagePath?: string;
      terminationMessagePolicy?: string;
      tty?: boolean;
      volumeDevices?: {
        devicePath: string;
        name: string;
      }[];
      volumeMounts?: {
        mountPath: string;
        mountPropagation?: string;
        name: string;
        readOnly?: boolean;
        recursiveReadOnly?: string;
        subPath?: string;
        subPathExpr?: string;
      }[];
      workingDir?: string;
    }[];
    convertClassicHistogramsToNHCB?: boolean;
    dnsConfig?: {
      nameservers?: string[];
      options?: {
        name: string;
        value?: string;
      }[];
      searches?: string[];
    };
    dnsPolicy?: "ClusterFirstWithHostNet" | "ClusterFirst" | "Default" | "None";
    enableFeatures?: string[];
    enableOTLPReceiver?: boolean;
    enableRemoteWriteReceiver?: boolean;
    enableServiceLinks?: boolean;
    enforcedBodySizeLimit?: string;
    enforcedKeepDroppedTargets?: number;
    enforcedLabelLimit?: number;
    enforcedLabelNameLengthLimit?: number;
    enforcedLabelValueLengthLimit?: number;
    enforcedNamespaceLabel?: string;
    enforcedSampleLimit?: number;
    enforcedTargetLimit?: number;
    excludedFromEnforcement?: {
      group?: "monitoring.coreos.com";
      name?: string;
      namespace: string;
      resource: "prometheusrules" | "servicemonitors" | "podmonitors" | "probes" | "scrapeconfigs";
    }[];
    externalLabels?: {
      [key: string]: unknown;
    };
    externalUrl?: string;
    hostAliases?: {
      hostnames: string[];
      ip: string;
    }[];
    hostNetwork?: boolean;
    hostUsers?: boolean;
    ignoreNamespaceSelectors?: boolean;
    image?: string;
    imagePullPolicy?: "" | "Always" | "Never" | "IfNotPresent";
    imagePullSecrets?: {
      name?: string;
    }[];
    initContainers?: {
      args?: string[];
      command?: string[];
      env?: {
        name: string;
        value?: string;
        valueFrom?: {
          configMapKeyRef?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          fieldRef?: {
            apiVersion?: string;
            fieldPath: string;
          };
          resourceFieldRef?: {
            containerName?: string;
            divisor?: any;
            resource: string;
          };
          secretKeyRef?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
      }[];
      envFrom?: {
        configMapRef?: {
          name?: string;
          optional?: boolean;
        };
        prefix?: string;
        secretRef?: {
          name?: string;
          optional?: boolean;
        };
      }[];
      image?: string;
      imagePullPolicy?: string;
      lifecycle?: {
        postStart?: {
          exec?: {
            command?: string[];
          };
          httpGet?: {
            host?: string;
            httpHeaders?: {
              name: string;
              value: string;
            }[];
            path?: string;
            port: any;
            scheme?: string;
          };
          sleep?: {
            seconds: number;
          };
          tcpSocket?: {
            host?: string;
            port: any;
          };
        };
        preStop?: {
          exec?: {
            command?: string[];
          };
          httpGet?: {
            host?: string;
            httpHeaders?: {
              name: string;
              value: string;
            }[];
            path?: string;
            port: any;
            scheme?: string;
          };
          sleep?: {
            seconds: number;
          };
          tcpSocket?: {
            host?: string;
            port: any;
          };
        };
        stopSignal?: string;
      };
      livenessProbe?: {
        exec?: {
          command?: string[];
        };
        failureThreshold?: number;
        grpc?: {
          port: number;
          service?: string;
        };
        httpGet?: {
          host?: string;
          httpHeaders?: {
            name: string;
            value: string;
          }[];
          path?: string;
          port: any;
          scheme?: string;
        };
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        tcpSocket?: {
          host?: string;
          port: any;
        };
        terminationGracePeriodSeconds?: number;
        timeoutSeconds?: number;
      };
      name: string;
      ports?: {
        containerPort: number;
        hostIP?: string;
        hostPort?: number;
        name?: string;
        protocol?: string;
      }[];
      readinessProbe?: {
        exec?: {
          command?: string[];
        };
        failureThreshold?: number;
        grpc?: {
          port: number;
          service?: string;
        };
        httpGet?: {
          host?: string;
          httpHeaders?: {
            name: string;
            value: string;
          }[];
          path?: string;
          port: any;
          scheme?: string;
        };
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        tcpSocket?: {
          host?: string;
          port: any;
        };
        terminationGracePeriodSeconds?: number;
        timeoutSeconds?: number;
      };
      resizePolicy?: {
        resourceName: string;
        restartPolicy: string;
      }[];
      resources?: {
        claims?: {
          name: string;
          request?: string;
        }[];
        limits?: {
          [key: string]: unknown;
        };
        requests?: {
          [key: string]: unknown;
        };
      };
      restartPolicy?: string;
      securityContext?: {
        allowPrivilegeEscalation?: boolean;
        appArmorProfile?: {
          localhostProfile?: string;
          type: string;
        };
        capabilities?: {
          add?: string[];
          drop?: string[];
        };
        privileged?: boolean;
        procMount?: string;
        readOnlyRootFilesystem?: boolean;
        runAsGroup?: number;
        runAsNonRoot?: boolean;
        runAsUser?: number;
        seLinuxOptions?: {
          level?: string;
          role?: string;
          type?: string;
          user?: string;
        };
        seccompProfile?: {
          localhostProfile?: string;
          type: string;
        };
        windowsOptions?: {
          gmsaCredentialSpec?: string;
          gmsaCredentialSpecName?: string;
          hostProcess?: boolean;
          runAsUserName?: string;
        };
      };
      startupProbe?: {
        exec?: {
          command?: string[];
        };
        failureThreshold?: number;
        grpc?: {
          port: number;
          service?: string;
        };
        httpGet?: {
          host?: string;
          httpHeaders?: {
            name: string;
            value: string;
          }[];
          path?: string;
          port: any;
          scheme?: string;
        };
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        tcpSocket?: {
          host?: string;
          port: any;
        };
        terminationGracePeriodSeconds?: number;
        timeoutSeconds?: number;
      };
      stdin?: boolean;
      stdinOnce?: boolean;
      terminationMessagePath?: string;
      terminationMessagePolicy?: string;
      tty?: boolean;
      volumeDevices?: {
        devicePath: string;
        name: string;
      }[];
      volumeMounts?: {
        mountPath: string;
        mountPropagation?: string;
        name: string;
        readOnly?: boolean;
        recursiveReadOnly?: string;
        subPath?: string;
        subPathExpr?: string;
      }[];
      workingDir?: string;
    }[];
    keepDroppedTargets?: number;
    labelLimit?: number;
    labelNameLengthLimit?: number;
    labelValueLengthLimit?: number;
    listenLocal?: boolean;
    logFormat?: "" | "logfmt" | "json";
    logLevel?: "" | "debug" | "info" | "warn" | "error";
    maximumStartupDurationSeconds?: number;
    minReadySeconds?: number;
    mode?: "StatefulSet" | "DaemonSet";
    nameEscapingScheme?: "AllowUTF8" | "Underscores" | "Dots" | "Values";
    nameValidationScheme?: "UTF8" | "Legacy";
    nodeSelector?: {
      [key: string]: unknown;
    };
    otlp?: {
      convertHistogramsToNHCB?: boolean;
      ignoreResourceAttributes?: string[];
      keepIdentifyingResourceAttributes?: boolean;
      promoteAllResourceAttributes?: boolean;
      promoteResourceAttributes?: string[];
      translationStrategy?: "NoUTF8EscapingWithSuffixes" | "UnderscoreEscapingWithSuffixes" | "NoTranslation";
    };
    overrideHonorLabels?: boolean;
    overrideHonorTimestamps?: boolean;
    paused?: boolean;
    persistentVolumeClaimRetentionPolicy?: {
      whenDeleted?: string;
      whenScaled?: string;
    };
    podMetadata?: {
      annotations?: {
        [key: string]: unknown;
      };
      labels?: {
        [key: string]: unknown;
      };
      name?: string;
    };
    podMonitorNamespaceSelector?: {
      matchExpressions?: {
        key: string;
        operator: string;
        values?: string[];
      }[];
      matchLabels?: {
        [key: string]: unknown;
      };
    };
    podMonitorSelector?: {
      matchExpressions?: {
        key: string;
        operator: string;
        values?: string[];
      }[];
      matchLabels?: {
        [key: string]: unknown;
      };
    };
    podTargetLabels?: string[];
    portName?: string;
    priorityClassName?: string;
    probeNamespaceSelector?: {
      matchExpressions?: {
        key: string;
        operator: string;
        values?: string[];
      }[];
      matchLabels?: {
        [key: string]: unknown;
      };
    };
    probeSelector?: {
      matchExpressions?: {
        key: string;
        operator: string;
        values?: string[];
      }[];
      matchLabels?: {
        [key: string]: unknown;
      };
    };
    prometheusExternalLabelName?: string;
    reloadStrategy?: "HTTP" | "ProcessSignal";
    remoteWrite?: {
      authorization?: {
        credentials?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        credentialsFile?: string;
        type?: string;
      };
      azureAd?: {
        cloud?: "AzureChina" | "AzureGovernment" | "AzurePublic";
        managedIdentity?: {
          clientId: string;
        };
        oauth?: {
          clientId: string;
          clientSecret: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          tenantId: string;
        };
        sdk?: {
          tenantId?: string;
        };
      };
      basicAuth?: {
        password?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        username?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      bearerToken?: string;
      bearerTokenFile?: string;
      enableHTTP2?: boolean;
      followRedirects?: boolean;
      headers?: {
        [key: string]: unknown;
      };
      messageVersion?: "V1.0" | "V2.0";
      metadataConfig?: {
        maxSamplesPerSend?: number;
        send?: boolean;
        sendInterval?: string;
      };
      name?: string;
      noProxy?: string;
      oauth2?: {
        clientId: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        clientSecret: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        endpointParams?: {
          [key: string]: unknown;
        };
        noProxy?: string;
        proxyConnectHeader?: {
          [key: string]: unknown;
        };
        proxyFromEnvironment?: boolean;
        proxyUrl?: string;
        scopes?: string[];
        tlsConfig?: {
          ca?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          cert?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          insecureSkipVerify?: boolean;
          keySecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          serverName?: string;
        };
        tokenUrl: string;
      };
      proxyConnectHeader?: {
        [key: string]: unknown;
      };
      proxyFromEnvironment?: boolean;
      proxyUrl?: string;
      queueConfig?: {
        batchSendDeadline?: string;
        capacity?: number;
        maxBackoff?: string;
        maxRetries?: number;
        maxSamplesPerSend?: number;
        maxShards?: number;
        minBackoff?: string;
        minShards?: number;
        retryOnRateLimit?: boolean;
        sampleAgeLimit?: string;
      };
      remoteTimeout?: string;
      roundRobinDNS?: boolean;
      sendExemplars?: boolean;
      sendNativeHistograms?: boolean;
      sigv4?: {
        accessKey?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        profile?: string;
        region?: string;
        roleArn?: string;
        secretKey?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        caFile?: string;
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        certFile?: string;
        insecureSkipVerify?: boolean;
        keyFile?: string;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
      url: string;
      writeRelabelConfigs?: {
        action?: "replace" | "Replace" | "keep" | "Keep" | "drop" | "Drop" | "hashmod" | "HashMod" | "labelmap" | "LabelMap" | "labeldrop" | "LabelDrop" | "labelkeep" | "LabelKeep" | "lowercase" | "Lowercase" | "uppercase" | "Uppercase" | "keepequal" | "KeepEqual" | "dropequal" | "DropEqual";
        modulus?: number;
        regex?: string;
        replacement?: string;
        separator?: string;
        sourceLabels?: string[];
        targetLabel?: string;
      }[];
    }[];
    remoteWriteReceiverMessageVersions?: ("V1.0" | "V2.0")[];
    replicaExternalLabelName?: string;
    replicas?: number;
    resources?: {
      claims?: {
        name: string;
        request?: string;
      }[];
      limits?: {
        [key: string]: unknown;
      };
      requests?: {
        [key: string]: unknown;
      };
    };
    routePrefix?: string;
    runtime?: {
      goGC?: number;
    };
    sampleLimit?: number;
    scrapeClasses?: {
      attachMetadata?: {
        node?: boolean;
      };
      authorization?: {
        credentials?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        credentialsFile?: string;
        type?: string;
      };
      default?: boolean;
      fallbackScrapeProtocol?: "PrometheusProto" | "OpenMetricsText0.0.1" | "OpenMetricsText1.0.0" | "PrometheusText0.0.4" | "PrometheusText1.0.0";
      metricRelabelings?: {
        action?: "replace" | "Replace" | "keep" | "Keep" | "drop" | "Drop" | "hashmod" | "HashMod" | "labelmap" | "LabelMap" | "labeldrop" | "LabelDrop" | "labelkeep" | "LabelKeep" | "lowercase" | "Lowercase" | "uppercase" | "Uppercase" | "keepequal" | "KeepEqual" | "dropequal" | "DropEqual";
        modulus?: number;
        regex?: string;
        replacement?: string;
        separator?: string;
        sourceLabels?: string[];
        targetLabel?: string;
      }[];
      name: string;
      relabelings?: {
        action?: "replace" | "Replace" | "keep" | "Keep" | "drop" | "Drop" | "hashmod" | "HashMod" | "labelmap" | "LabelMap" | "labeldrop" | "LabelDrop" | "labelkeep" | "LabelKeep" | "lowercase" | "Lowercase" | "uppercase" | "Uppercase" | "keepequal" | "KeepEqual" | "dropequal" | "DropEqual";
        modulus?: number;
        regex?: string;
        replacement?: string;
        separator?: string;
        sourceLabels?: string[];
        targetLabel?: string;
      }[];
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        caFile?: string;
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        certFile?: string;
        insecureSkipVerify?: boolean;
        keyFile?: string;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
    }[];
    scrapeClassicHistograms?: boolean;
    scrapeConfigNamespaceSelector?: {
      matchExpressions?: {
        key: string;
        operator: string;
        values?: string[];
      }[];
      matchLabels?: {
        [key: string]: unknown;
      };
    };
    scrapeConfigSelector?: {
      matchExpressions?: {
        key: string;
        operator: string;
        values?: string[];
      }[];
      matchLabels?: {
        [key: string]: unknown;
      };
    };
    scrapeFailureLogFile?: string;
    scrapeInterval?: string;
    scrapeProtocols?: ("PrometheusProto" | "OpenMetricsText0.0.1" | "OpenMetricsText1.0.0" | "PrometheusText0.0.4" | "PrometheusText1.0.0")[];
    scrapeTimeout?: string;
    secrets?: string[];
    securityContext?: {
      appArmorProfile?: {
        localhostProfile?: string;
        type: string;
      };
      fsGroup?: number;
      fsGroupChangePolicy?: string;
      runAsGroup?: number;
      runAsNonRoot?: boolean;
      runAsUser?: number;
      seLinuxChangePolicy?: string;
      seLinuxOptions?: {
        level?: string;
        role?: string;
        type?: string;
        user?: string;
      };
      seccompProfile?: {
        localhostProfile?: string;
        type: string;
      };
      supplementalGroups?: number[];
      supplementalGroupsPolicy?: string;
      sysctls?: {
        name: string;
        value: string;
      }[];
      windowsOptions?: {
        gmsaCredentialSpec?: string;
        gmsaCredentialSpecName?: string;
        hostProcess?: boolean;
        runAsUserName?: string;
      };
    };
    serviceAccountName?: string;
    serviceDiscoveryRole?: "Endpoints" | "EndpointSlice";
    serviceMonitorNamespaceSelector?: {
      matchExpressions?: {
        key: string;
        operator: string;
        values?: string[];
      }[];
      matchLabels?: {
        [key: string]: unknown;
      };
    };
    serviceMonitorSelector?: {
      matchExpressions?: {
        key: string;
        operator: string;
        values?: string[];
      }[];
      matchLabels?: {
        [key: string]: unknown;
      };
    };
    serviceName?: string;
    shards?: number;
    storage?: {
      disableMountSubPath?: boolean;
      emptyDir?: {
        medium?: string;
        sizeLimit?: any;
      };
      ephemeral?: {
        volumeClaimTemplate?: {
          metadata?: {
            [key: string]: unknown;
          };
          spec: {
            accessModes?: string[];
            dataSource?: {
              apiGroup?: string;
              kind: string;
              name: string;
            };
            dataSourceRef?: {
              apiGroup?: string;
              kind: string;
              name: string;
              namespace?: string;
            };
            resources?: {
              limits?: {
                [key: string]: unknown;
              };
              requests?: {
                [key: string]: unknown;
              };
            };
            selector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            storageClassName?: string;
            volumeAttributesClassName?: string;
            volumeMode?: string;
            volumeName?: string;
          };
        };
      };
      volumeClaimTemplate?: {
        apiVersion?: string;
        kind?: string;
        metadata?: {
          annotations?: {
            [key: string]: unknown;
          };
          labels?: {
            [key: string]: unknown;
          };
          name?: string;
        };
        spec?: {
          accessModes?: string[];
          dataSource?: {
            apiGroup?: string;
            kind: string;
            name: string;
          };
          dataSourceRef?: {
            apiGroup?: string;
            kind: string;
            name: string;
            namespace?: string;
          };
          resources?: {
            limits?: {
              [key: string]: unknown;
            };
            requests?: {
              [key: string]: unknown;
            };
          };
          selector?: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchLabels?: {
              [key: string]: unknown;
            };
          };
          storageClassName?: string;
          volumeAttributesClassName?: string;
          volumeMode?: string;
          volumeName?: string;
        };
        status?: {
          accessModes?: string[];
          allocatedResourceStatuses?: {
            [key: string]: unknown;
          };
          allocatedResources?: {
            [key: string]: unknown;
          };
          capacity?: {
            [key: string]: unknown;
          };
          conditions?: {
            lastProbeTime?: string;
            lastTransitionTime?: string;
            message?: string;
            reason?: string;
            status: string;
            type: string;
          }[];
          currentVolumeAttributesClassName?: string;
          modifyVolumeStatus?: {
            status: string;
            targetVolumeAttributesClassName?: string;
          };
          phase?: string;
        };
      };
    };
    targetLimit?: number;
    terminationGracePeriodSeconds?: number;
    tolerations?: {
      effect?: string;
      key?: string;
      operator?: string;
      tolerationSeconds?: number;
      value?: string;
    }[];
    topologySpreadConstraints?: {
      additionalLabelSelectors?: "OnResource" | "OnShard";
      labelSelector?: {
        matchExpressions?: {
          key: string;
          operator: string;
          values?: string[];
        }[];
        matchLabels?: {
          [key: string]: unknown;
        };
      };
      matchLabelKeys?: string[];
      maxSkew: number;
      minDomains?: number;
      nodeAffinityPolicy?: string;
      nodeTaintsPolicy?: string;
      topologyKey: string;
      whenUnsatisfiable: string;
    }[];
    tracingConfig?: {
      clientType?: "http" | "grpc";
      compression?: "gzip";
      endpoint: string;
      headers?: {
        [key: string]: unknown;
      };
      insecure?: boolean;
      samplingFraction?: any;
      timeout?: string;
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        caFile?: string;
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        certFile?: string;
        insecureSkipVerify?: boolean;
        keyFile?: string;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
    };
    tsdb?: {
      outOfOrderTimeWindow?: string;
    };
    version?: string;
    volumeMounts?: {
      mountPath: string;
      mountPropagation?: string;
      name: string;
      readOnly?: boolean;
      recursiveReadOnly?: string;
      subPath?: string;
      subPathExpr?: string;
    }[];
    volumes?: {
      awsElasticBlockStore?: {
        fsType?: string;
        partition?: number;
        readOnly?: boolean;
        volumeID: string;
      };
      azureDisk?: {
        cachingMode?: string;
        diskName: string;
        diskURI: string;
        fsType?: string;
        kind?: string;
        readOnly?: boolean;
      };
      azureFile?: {
        readOnly?: boolean;
        secretName: string;
        shareName: string;
      };
      cephfs?: {
        monitors: string[];
        path?: string;
        readOnly?: boolean;
        secretFile?: string;
        secretRef?: {
          name?: string;
        };
        user?: string;
      };
      cinder?: {
        fsType?: string;
        readOnly?: boolean;
        secretRef?: {
          name?: string;
        };
        volumeID: string;
      };
      configMap?: {
        defaultMode?: number;
        items?: {
          key: string;
          mode?: number;
          path: string;
        }[];
        name?: string;
        optional?: boolean;
      };
      csi?: {
        driver: string;
        fsType?: string;
        nodePublishSecretRef?: {
          name?: string;
        };
        readOnly?: boolean;
        volumeAttributes?: {
          [key: string]: unknown;
        };
      };
      downwardAPI?: {
        defaultMode?: number;
        items?: {
          fieldRef?: {
            apiVersion?: string;
            fieldPath: string;
          };
          mode?: number;
          path: string;
          resourceFieldRef?: {
            containerName?: string;
            divisor?: any;
            resource: string;
          };
        }[];
      };
      emptyDir?: {
        medium?: string;
        sizeLimit?: any;
      };
      ephemeral?: {
        volumeClaimTemplate?: {
          metadata?: {
            [key: string]: unknown;
          };
          spec: {
            accessModes?: string[];
            dataSource?: {
              apiGroup?: string;
              kind: string;
              name: string;
            };
            dataSourceRef?: {
              apiGroup?: string;
              kind: string;
              name: string;
              namespace?: string;
            };
            resources?: {
              limits?: {
                [key: string]: unknown;
              };
              requests?: {
                [key: string]: unknown;
              };
            };
            selector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            storageClassName?: string;
            volumeAttributesClassName?: string;
            volumeMode?: string;
            volumeName?: string;
          };
        };
      };
      fc?: {
        fsType?: string;
        lun?: number;
        readOnly?: boolean;
        targetWWNs?: string[];
        wwids?: string[];
      };
      flexVolume?: {
        driver: string;
        fsType?: string;
        options?: {
          [key: string]: unknown;
        };
        readOnly?: boolean;
        secretRef?: {
          name?: string;
        };
      };
      flocker?: {
        datasetName?: string;
        datasetUUID?: string;
      };
      gcePersistentDisk?: {
        fsType?: string;
        partition?: number;
        pdName: string;
        readOnly?: boolean;
      };
      gitRepo?: {
        directory?: string;
        repository: string;
        revision?: string;
      };
      glusterfs?: {
        endpoints: string;
        path: string;
        readOnly?: boolean;
      };
      hostPath?: {
        path: string;
        type?: string;
      };
      image?: {
        pullPolicy?: string;
        reference?: string;
      };
      iscsi?: {
        chapAuthDiscovery?: boolean;
        chapAuthSession?: boolean;
        fsType?: string;
        initiatorName?: string;
        iqn: string;
        iscsiInterface?: string;
        lun: number;
        portals?: string[];
        readOnly?: boolean;
        secretRef?: {
          name?: string;
        };
        targetPortal: string;
      };
      name: string;
      nfs?: {
        path: string;
        readOnly?: boolean;
        server: string;
      };
      persistentVolumeClaim?: {
        claimName: string;
        readOnly?: boolean;
      };
      photonPersistentDisk?: {
        fsType?: string;
        pdID: string;
      };
      portworxVolume?: {
        fsType?: string;
        readOnly?: boolean;
        volumeID: string;
      };
      projected?: {
        defaultMode?: number;
        sources?: {
          clusterTrustBundle?: {
            labelSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            name?: string;
            optional?: boolean;
            path: string;
            signerName?: string;
          };
          configMap?: {
            items?: {
              key: string;
              mode?: number;
              path: string;
            }[];
            name?: string;
            optional?: boolean;
          };
          downwardAPI?: {
            items?: {
              fieldRef?: {
                apiVersion?: string;
                fieldPath: string;
              };
              mode?: number;
              path: string;
              resourceFieldRef?: {
                containerName?: string;
                divisor?: any;
                resource: string;
              };
            }[];
          };
          secret?: {
            items?: {
              key: string;
              mode?: number;
              path: string;
            }[];
            name?: string;
            optional?: boolean;
          };
          serviceAccountToken?: {
            audience?: string;
            expirationSeconds?: number;
            path: string;
          };
        }[];
      };
      quobyte?: {
        group?: string;
        readOnly?: boolean;
        registry: string;
        tenant?: string;
        user?: string;
        volume: string;
      };
      rbd?: {
        fsType?: string;
        image: string;
        keyring?: string;
        monitors: string[];
        pool?: string;
        readOnly?: boolean;
        secretRef?: {
          name?: string;
        };
        user?: string;
      };
      scaleIO?: {
        fsType?: string;
        gateway: string;
        protectionDomain?: string;
        readOnly?: boolean;
        secretRef: {
          name?: string;
        };
        sslEnabled?: boolean;
        storageMode?: string;
        storagePool?: string;
        system: string;
        volumeName?: string;
      };
      secret?: {
        defaultMode?: number;
        items?: {
          key: string;
          mode?: number;
          path: string;
        }[];
        optional?: boolean;
        secretName?: string;
      };
      storageos?: {
        fsType?: string;
        readOnly?: boolean;
        secretRef?: {
          name?: string;
        };
        volumeName?: string;
        volumeNamespace?: string;
      };
      vsphereVolume?: {
        fsType?: string;
        storagePolicyID?: string;
        storagePolicyName?: string;
        volumePath: string;
      };
    }[];
    walCompression?: boolean;
    web?: {
      httpConfig?: {
        headers?: {
          contentSecurityPolicy?: string;
          strictTransportSecurity?: string;
          xContentTypeOptions?: "" | "NoSniff";
          xFrameOptions?: "" | "Deny" | "SameOrigin";
          xXSSProtection?: string;
        };
        http2?: boolean;
      };
      maxConnections?: number;
      pageTitle?: string;
      tlsConfig?: {
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        certFile?: string;
        cipherSuites?: string[];
        clientAuthType?: string;
        clientCAFile?: string;
        client_ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        curvePreferences?: string[];
        keyFile?: string;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: string;
        minVersion?: string;
        preferServerCipherSuites?: boolean;
      };
    };
  };
  status?: {
    availableReplicas: number;
    conditions?: {
      lastTransitionTime: string;
      message?: string;
      observedGeneration?: number;
      reason?: string;
      status: string;
      type: string;
    }[];
    paused: boolean;
    replicas: number;
    selector?: string;
    shardStatuses?: {
      availableReplicas: number;
      replicas: number;
      shardID: string;
      unavailableReplicas: number;
      updatedReplicas: number;
    }[];
    shards?: number;
    unavailableReplicas: number;
    updatedReplicas: number;
  };
}
export interface MonitoringCoreosComV1alpha1PrometheusAgentList {
  apiVersion?: string;
  items: MonitoringCoreosComV1alpha1PrometheusAgent[];
  kind?: string;
  metadata?: ListMeta;
}
export interface MonitoringCoreosComV1alpha1ScrapeConfig {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec: {
    authorization?: {
      credentials?: {
        key: string;
        name?: string;
        optional?: boolean;
      };
      type?: string;
    };
    azureSDConfigs?: {
      authenticationMethod?: "OAuth" | "ManagedIdentity" | "SDK";
      authorization?: {
        credentials?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        type?: string;
      };
      basicAuth?: {
        password?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        username?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      clientID?: string;
      clientSecret?: {
        key: string;
        name?: string;
        optional?: boolean;
      };
      enableHTTP2?: boolean;
      environment?: string;
      followRedirects?: boolean;
      noProxy?: string;
      oauth2?: {
        clientId: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        clientSecret: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        endpointParams?: {
          [key: string]: unknown;
        };
        noProxy?: string;
        proxyConnectHeader?: {
          [key: string]: unknown;
        };
        proxyFromEnvironment?: boolean;
        proxyUrl?: string;
        scopes?: string[];
        tlsConfig?: {
          ca?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          cert?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          insecureSkipVerify?: boolean;
          keySecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          serverName?: string;
        };
        tokenUrl: string;
      };
      port?: number;
      proxyConnectHeader?: {
        [key: string]: unknown;
      };
      proxyFromEnvironment?: boolean;
      proxyUrl?: string;
      refreshInterval?: string;
      resourceGroup?: string;
      subscriptionID: string;
      tenantID?: string;
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        insecureSkipVerify?: boolean;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
    }[];
    basicAuth?: {
      password?: {
        key: string;
        name?: string;
        optional?: boolean;
      };
      username?: {
        key: string;
        name?: string;
        optional?: boolean;
      };
    };
    consulSDConfigs?: {
      allowStale?: boolean;
      authorization?: {
        credentials?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        type?: string;
      };
      basicAuth?: {
        password?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        username?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      datacenter?: string;
      enableHTTP2?: boolean;
      filter?: string;
      followRedirects?: boolean;
      namespace?: string;
      noProxy?: string;
      nodeMeta?: {
        [key: string]: unknown;
      };
      oauth2?: {
        clientId: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        clientSecret: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        endpointParams?: {
          [key: string]: unknown;
        };
        noProxy?: string;
        proxyConnectHeader?: {
          [key: string]: unknown;
        };
        proxyFromEnvironment?: boolean;
        proxyUrl?: string;
        scopes?: string[];
        tlsConfig?: {
          ca?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          cert?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          insecureSkipVerify?: boolean;
          keySecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          serverName?: string;
        };
        tokenUrl: string;
      };
      partition?: string;
      pathPrefix?: string;
      proxyConnectHeader?: {
        [key: string]: unknown;
      };
      proxyFromEnvironment?: boolean;
      proxyUrl?: string;
      refreshInterval?: string;
      scheme?: "HTTP" | "HTTPS";
      server: string;
      services?: string[];
      tagSeparator?: string;
      tags?: string[];
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        insecureSkipVerify?: boolean;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
      tokenRef?: {
        key: string;
        name?: string;
        optional?: boolean;
      };
    }[];
    convertClassicHistogramsToNHCB?: boolean;
    digitalOceanSDConfigs?: {
      authorization?: {
        credentials?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        type?: string;
      };
      enableHTTP2?: boolean;
      followRedirects?: boolean;
      noProxy?: string;
      oauth2?: {
        clientId: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        clientSecret: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        endpointParams?: {
          [key: string]: unknown;
        };
        noProxy?: string;
        proxyConnectHeader?: {
          [key: string]: unknown;
        };
        proxyFromEnvironment?: boolean;
        proxyUrl?: string;
        scopes?: string[];
        tlsConfig?: {
          ca?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          cert?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          insecureSkipVerify?: boolean;
          keySecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          serverName?: string;
        };
        tokenUrl: string;
      };
      port?: number;
      proxyConnectHeader?: {
        [key: string]: unknown;
      };
      proxyFromEnvironment?: boolean;
      proxyUrl?: string;
      refreshInterval?: string;
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        insecureSkipVerify?: boolean;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
    }[];
    dnsSDConfigs?: {
      names: string[];
      port?: number;
      refreshInterval?: string;
      type?: "A" | "AAAA" | "MX" | "NS" | "SRV";
    }[];
    dockerSDConfigs?: {
      authorization?: {
        credentials?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        type?: string;
      };
      basicAuth?: {
        password?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        username?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      enableHTTP2?: boolean;
      filters?: {
        name: string;
        values: string[];
      }[];
      followRedirects?: boolean;
      host: string;
      hostNetworkingHost?: string;
      matchFirstNetwork?: boolean;
      noProxy?: string;
      oauth2?: {
        clientId: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        clientSecret: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        endpointParams?: {
          [key: string]: unknown;
        };
        noProxy?: string;
        proxyConnectHeader?: {
          [key: string]: unknown;
        };
        proxyFromEnvironment?: boolean;
        proxyUrl?: string;
        scopes?: string[];
        tlsConfig?: {
          ca?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          cert?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          insecureSkipVerify?: boolean;
          keySecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          serverName?: string;
        };
        tokenUrl: string;
      };
      port?: number;
      proxyConnectHeader?: {
        [key: string]: unknown;
      };
      proxyFromEnvironment?: boolean;
      proxyUrl?: string;
      refreshInterval?: string;
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        insecureSkipVerify?: boolean;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
    }[];
    dockerSwarmSDConfigs?: {
      authorization?: {
        credentials?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        type?: string;
      };
      basicAuth?: {
        password?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        username?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      enableHTTP2?: boolean;
      filters?: {
        name: string;
        values: string[];
      }[];
      followRedirects?: boolean;
      host: string;
      noProxy?: string;
      oauth2?: {
        clientId: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        clientSecret: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        endpointParams?: {
          [key: string]: unknown;
        };
        noProxy?: string;
        proxyConnectHeader?: {
          [key: string]: unknown;
        };
        proxyFromEnvironment?: boolean;
        proxyUrl?: string;
        scopes?: string[];
        tlsConfig?: {
          ca?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          cert?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          insecureSkipVerify?: boolean;
          keySecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          serverName?: string;
        };
        tokenUrl: string;
      };
      port?: number;
      proxyConnectHeader?: {
        [key: string]: unknown;
      };
      proxyFromEnvironment?: boolean;
      proxyUrl?: string;
      refreshInterval?: string;
      role: "Services" | "Tasks" | "Nodes";
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        insecureSkipVerify?: boolean;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
    }[];
    ec2SDConfigs?: {
      accessKey?: {
        key: string;
        name?: string;
        optional?: boolean;
      };
      enableHTTP2?: boolean;
      filters?: {
        name: string;
        values: string[];
      }[];
      followRedirects?: boolean;
      noProxy?: string;
      port?: number;
      proxyConnectHeader?: {
        [key: string]: unknown;
      };
      proxyFromEnvironment?: boolean;
      proxyUrl?: string;
      refreshInterval?: string;
      region?: string;
      roleARN?: string;
      secretKey?: {
        key: string;
        name?: string;
        optional?: boolean;
      };
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        insecureSkipVerify?: boolean;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
    }[];
    enableCompression?: boolean;
    enableHTTP2?: boolean;
    eurekaSDConfigs?: {
      authorization?: {
        credentials?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        type?: string;
      };
      basicAuth?: {
        password?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        username?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      enableHTTP2?: boolean;
      followRedirects?: boolean;
      noProxy?: string;
      oauth2?: {
        clientId: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        clientSecret: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        endpointParams?: {
          [key: string]: unknown;
        };
        noProxy?: string;
        proxyConnectHeader?: {
          [key: string]: unknown;
        };
        proxyFromEnvironment?: boolean;
        proxyUrl?: string;
        scopes?: string[];
        tlsConfig?: {
          ca?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          cert?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          insecureSkipVerify?: boolean;
          keySecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          serverName?: string;
        };
        tokenUrl: string;
      };
      proxyConnectHeader?: {
        [key: string]: unknown;
      };
      proxyFromEnvironment?: boolean;
      proxyUrl?: string;
      refreshInterval?: string;
      server: string;
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        insecureSkipVerify?: boolean;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
    }[];
    fallbackScrapeProtocol?: "PrometheusProto" | "OpenMetricsText0.0.1" | "OpenMetricsText1.0.0" | "PrometheusText0.0.4" | "PrometheusText1.0.0";
    fileSDConfigs?: {
      files: string[];
      refreshInterval?: string;
    }[];
    gceSDConfigs?: {
      filter?: string;
      port?: number;
      project: string;
      refreshInterval?: string;
      tagSeparator?: string;
      zone: string;
    }[];
    hetznerSDConfigs?: {
      authorization?: {
        credentials?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        type?: string;
      };
      basicAuth?: {
        password?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        username?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      enableHTTP2?: boolean;
      followRedirects?: boolean;
      labelSelector?: string;
      noProxy?: string;
      oauth2?: {
        clientId: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        clientSecret: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        endpointParams?: {
          [key: string]: unknown;
        };
        noProxy?: string;
        proxyConnectHeader?: {
          [key: string]: unknown;
        };
        proxyFromEnvironment?: boolean;
        proxyUrl?: string;
        scopes?: string[];
        tlsConfig?: {
          ca?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          cert?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          insecureSkipVerify?: boolean;
          keySecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          serverName?: string;
        };
        tokenUrl: string;
      };
      port?: number;
      proxyConnectHeader?: {
        [key: string]: unknown;
      };
      proxyFromEnvironment?: boolean;
      proxyUrl?: string;
      refreshInterval?: string;
      role: "hcloud" | "Hcloud" | "robot" | "Robot";
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        insecureSkipVerify?: boolean;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
    }[];
    honorLabels?: boolean;
    honorTimestamps?: boolean;
    httpSDConfigs?: {
      authorization?: {
        credentials?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        type?: string;
      };
      basicAuth?: {
        password?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        username?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      enableHTTP2?: boolean;
      followRedirects?: boolean;
      noProxy?: string;
      oauth2?: {
        clientId: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        clientSecret: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        endpointParams?: {
          [key: string]: unknown;
        };
        noProxy?: string;
        proxyConnectHeader?: {
          [key: string]: unknown;
        };
        proxyFromEnvironment?: boolean;
        proxyUrl?: string;
        scopes?: string[];
        tlsConfig?: {
          ca?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          cert?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          insecureSkipVerify?: boolean;
          keySecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          serverName?: string;
        };
        tokenUrl: string;
      };
      proxyConnectHeader?: {
        [key: string]: unknown;
      };
      proxyFromEnvironment?: boolean;
      proxyUrl?: string;
      refreshInterval?: string;
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        insecureSkipVerify?: boolean;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
      url: string;
    }[];
    ionosSDConfigs?: {
      authorization: {
        credentials?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        type?: string;
      };
      datacenterID: string;
      enableHTTP2?: boolean;
      followRedirects?: boolean;
      noProxy?: string;
      oauth2?: {
        clientId: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        clientSecret: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        endpointParams?: {
          [key: string]: unknown;
        };
        noProxy?: string;
        proxyConnectHeader?: {
          [key: string]: unknown;
        };
        proxyFromEnvironment?: boolean;
        proxyUrl?: string;
        scopes?: string[];
        tlsConfig?: {
          ca?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          cert?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          insecureSkipVerify?: boolean;
          keySecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          serverName?: string;
        };
        tokenUrl: string;
      };
      port?: number;
      proxyConnectHeader?: {
        [key: string]: unknown;
      };
      proxyFromEnvironment?: boolean;
      proxyUrl?: string;
      refreshInterval?: string;
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        insecureSkipVerify?: boolean;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
    }[];
    jobName?: string;
    keepDroppedTargets?: number;
    kubernetesSDConfigs?: {
      apiServer?: string;
      attachMetadata?: {
        node?: boolean;
      };
      authorization?: {
        credentials?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        type?: string;
      };
      basicAuth?: {
        password?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        username?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      enableHTTP2?: boolean;
      followRedirects?: boolean;
      namespaces?: {
        names?: string[];
        ownNamespace?: boolean;
      };
      noProxy?: string;
      oauth2?: {
        clientId: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        clientSecret: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        endpointParams?: {
          [key: string]: unknown;
        };
        noProxy?: string;
        proxyConnectHeader?: {
          [key: string]: unknown;
        };
        proxyFromEnvironment?: boolean;
        proxyUrl?: string;
        scopes?: string[];
        tlsConfig?: {
          ca?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          cert?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          insecureSkipVerify?: boolean;
          keySecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          serverName?: string;
        };
        tokenUrl: string;
      };
      proxyConnectHeader?: {
        [key: string]: unknown;
      };
      proxyFromEnvironment?: boolean;
      proxyUrl?: string;
      role: "Pod" | "Endpoints" | "Ingress" | "Service" | "Node" | "EndpointSlice";
      selectors?: {
        field?: string;
        label?: string;
        role: "Pod" | "Endpoints" | "Ingress" | "Service" | "Node" | "EndpointSlice";
      }[];
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        insecureSkipVerify?: boolean;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
    }[];
    kumaSDConfigs?: {
      authorization?: {
        credentials?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        type?: string;
      };
      basicAuth?: {
        password?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        username?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      clientID?: string;
      enableHTTP2?: boolean;
      fetchTimeout?: string;
      followRedirects?: boolean;
      noProxy?: string;
      oauth2?: {
        clientId: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        clientSecret: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        endpointParams?: {
          [key: string]: unknown;
        };
        noProxy?: string;
        proxyConnectHeader?: {
          [key: string]: unknown;
        };
        proxyFromEnvironment?: boolean;
        proxyUrl?: string;
        scopes?: string[];
        tlsConfig?: {
          ca?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          cert?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          insecureSkipVerify?: boolean;
          keySecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          serverName?: string;
        };
        tokenUrl: string;
      };
      proxyConnectHeader?: {
        [key: string]: unknown;
      };
      proxyFromEnvironment?: boolean;
      proxyUrl?: string;
      refreshInterval?: string;
      server: string;
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        insecureSkipVerify?: boolean;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
    }[];
    labelLimit?: number;
    labelNameLengthLimit?: number;
    labelValueLengthLimit?: number;
    lightSailSDConfigs?: {
      accessKey?: {
        key: string;
        name?: string;
        optional?: boolean;
      };
      authorization?: {
        credentials?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        type?: string;
      };
      basicAuth?: {
        password?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        username?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      enableHTTP2?: boolean;
      endpoint?: string;
      followRedirects?: boolean;
      noProxy?: string;
      oauth2?: {
        clientId: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        clientSecret: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        endpointParams?: {
          [key: string]: unknown;
        };
        noProxy?: string;
        proxyConnectHeader?: {
          [key: string]: unknown;
        };
        proxyFromEnvironment?: boolean;
        proxyUrl?: string;
        scopes?: string[];
        tlsConfig?: {
          ca?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          cert?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          insecureSkipVerify?: boolean;
          keySecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          serverName?: string;
        };
        tokenUrl: string;
      };
      port?: number;
      proxyConnectHeader?: {
        [key: string]: unknown;
      };
      proxyFromEnvironment?: boolean;
      proxyUrl?: string;
      refreshInterval?: string;
      region?: string;
      roleARN?: string;
      secretKey?: {
        key: string;
        name?: string;
        optional?: boolean;
      };
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        insecureSkipVerify?: boolean;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
    }[];
    linodeSDConfigs?: {
      authorization?: {
        credentials?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        type?: string;
      };
      enableHTTP2?: boolean;
      followRedirects?: boolean;
      noProxy?: string;
      oauth2?: {
        clientId: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        clientSecret: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        endpointParams?: {
          [key: string]: unknown;
        };
        noProxy?: string;
        proxyConnectHeader?: {
          [key: string]: unknown;
        };
        proxyFromEnvironment?: boolean;
        proxyUrl?: string;
        scopes?: string[];
        tlsConfig?: {
          ca?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          cert?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          insecureSkipVerify?: boolean;
          keySecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          serverName?: string;
        };
        tokenUrl: string;
      };
      port?: number;
      proxyConnectHeader?: {
        [key: string]: unknown;
      };
      proxyFromEnvironment?: boolean;
      proxyUrl?: string;
      refreshInterval?: string;
      region?: string;
      tagSeparator?: string;
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        insecureSkipVerify?: boolean;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
    }[];
    metricRelabelings?: {
      action?: "replace" | "Replace" | "keep" | "Keep" | "drop" | "Drop" | "hashmod" | "HashMod" | "labelmap" | "LabelMap" | "labeldrop" | "LabelDrop" | "labelkeep" | "LabelKeep" | "lowercase" | "Lowercase" | "uppercase" | "Uppercase" | "keepequal" | "KeepEqual" | "dropequal" | "DropEqual";
      modulus?: number;
      regex?: string;
      replacement?: string;
      separator?: string;
      sourceLabels?: string[];
      targetLabel?: string;
    }[];
    metricsPath?: string;
    nameEscapingScheme?: "AllowUTF8" | "Underscores" | "Dots" | "Values";
    nameValidationScheme?: "UTF8" | "Legacy";
    nativeHistogramBucketLimit?: number;
    nativeHistogramMinBucketFactor?: any;
    noProxy?: string;
    nomadSDConfigs?: {
      allowStale?: boolean;
      authorization?: {
        credentials?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        type?: string;
      };
      basicAuth?: {
        password?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        username?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      enableHTTP2?: boolean;
      followRedirects?: boolean;
      namespace?: string;
      noProxy?: string;
      oauth2?: {
        clientId: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        clientSecret: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        endpointParams?: {
          [key: string]: unknown;
        };
        noProxy?: string;
        proxyConnectHeader?: {
          [key: string]: unknown;
        };
        proxyFromEnvironment?: boolean;
        proxyUrl?: string;
        scopes?: string[];
        tlsConfig?: {
          ca?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          cert?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          insecureSkipVerify?: boolean;
          keySecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          serverName?: string;
        };
        tokenUrl: string;
      };
      proxyConnectHeader?: {
        [key: string]: unknown;
      };
      proxyFromEnvironment?: boolean;
      proxyUrl?: string;
      refreshInterval?: string;
      region?: string;
      server: string;
      tagSeparator?: string;
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        insecureSkipVerify?: boolean;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
    }[];
    oauth2?: {
      clientId: {
        configMap?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        secret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      clientSecret: {
        key: string;
        name?: string;
        optional?: boolean;
      };
      endpointParams?: {
        [key: string]: unknown;
      };
      noProxy?: string;
      proxyConnectHeader?: {
        [key: string]: unknown;
      };
      proxyFromEnvironment?: boolean;
      proxyUrl?: string;
      scopes?: string[];
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        insecureSkipVerify?: boolean;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
      tokenUrl: string;
    };
    openstackSDConfigs?: {
      allTenants?: boolean;
      applicationCredentialId?: string;
      applicationCredentialName?: string;
      applicationCredentialSecret?: {
        key: string;
        name?: string;
        optional?: boolean;
      };
      availability?: "Public" | "public" | "Admin" | "admin" | "Internal" | "internal";
      domainID?: string;
      domainName?: string;
      identityEndpoint?: string;
      password?: {
        key: string;
        name?: string;
        optional?: boolean;
      };
      port?: number;
      projectID?: string;
      projectName?: string;
      refreshInterval?: string;
      region: string;
      role: "Instance" | "Hypervisor" | "LoadBalancer";
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        insecureSkipVerify?: boolean;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
      userid?: string;
      username?: string;
    }[];
    ovhcloudSDConfigs?: {
      applicationKey: string;
      applicationSecret: {
        key: string;
        name?: string;
        optional?: boolean;
      };
      consumerKey: {
        key: string;
        name?: string;
        optional?: boolean;
      };
      endpoint?: string;
      refreshInterval?: string;
      service: string;
    }[];
    params?: {
      [key: string]: unknown;
    };
    proxyConnectHeader?: {
      [key: string]: unknown;
    };
    proxyFromEnvironment?: boolean;
    proxyUrl?: string;
    puppetDBSDConfigs?: {
      authorization?: {
        credentials?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        type?: string;
      };
      basicAuth?: {
        password?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        username?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      enableHTTP2?: boolean;
      followRedirects?: boolean;
      includeParameters?: boolean;
      noProxy?: string;
      oauth2?: {
        clientId: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        clientSecret: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        endpointParams?: {
          [key: string]: unknown;
        };
        noProxy?: string;
        proxyConnectHeader?: {
          [key: string]: unknown;
        };
        proxyFromEnvironment?: boolean;
        proxyUrl?: string;
        scopes?: string[];
        tlsConfig?: {
          ca?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          cert?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          insecureSkipVerify?: boolean;
          keySecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          serverName?: string;
        };
        tokenUrl: string;
      };
      port?: number;
      proxyConnectHeader?: {
        [key: string]: unknown;
      };
      proxyFromEnvironment?: boolean;
      proxyUrl?: string;
      query: string;
      refreshInterval?: string;
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        insecureSkipVerify?: boolean;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
      url: string;
    }[];
    relabelings?: {
      action?: "replace" | "Replace" | "keep" | "Keep" | "drop" | "Drop" | "hashmod" | "HashMod" | "labelmap" | "LabelMap" | "labeldrop" | "LabelDrop" | "labelkeep" | "LabelKeep" | "lowercase" | "Lowercase" | "uppercase" | "Uppercase" | "keepequal" | "KeepEqual" | "dropequal" | "DropEqual";
      modulus?: number;
      regex?: string;
      replacement?: string;
      separator?: string;
      sourceLabels?: string[];
      targetLabel?: string;
    }[];
    sampleLimit?: number;
    scalewaySDConfigs?: {
      accessKey: string;
      apiURL?: string;
      enableHTTP2?: boolean;
      followRedirects?: boolean;
      nameFilter?: string;
      noProxy?: string;
      port?: number;
      projectID: string;
      proxyConnectHeader?: {
        [key: string]: unknown;
      };
      proxyFromEnvironment?: boolean;
      proxyUrl?: string;
      refreshInterval?: string;
      role: "Instance" | "Baremetal";
      secretKey: {
        key: string;
        name?: string;
        optional?: boolean;
      };
      tagsFilter?: string[];
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        insecureSkipVerify?: boolean;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
      zone?: string;
    }[];
    scheme?: "HTTP" | "HTTPS";
    scrapeClass?: string;
    scrapeClassicHistograms?: boolean;
    scrapeInterval?: string;
    scrapeProtocols?: ("PrometheusProto" | "OpenMetricsText0.0.1" | "OpenMetricsText1.0.0" | "PrometheusText0.0.4" | "PrometheusText1.0.0")[];
    scrapeTimeout?: string;
    staticConfigs?: {
      labels?: {
        [key: string]: unknown;
      };
      targets: string[];
    }[];
    targetLimit?: number;
    tlsConfig?: {
      ca?: {
        configMap?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        secret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      cert?: {
        configMap?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        secret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      insecureSkipVerify?: boolean;
      keySecret?: {
        key: string;
        name?: string;
        optional?: boolean;
      };
      maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
      minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
      serverName?: string;
    };
    trackTimestampsStaleness?: boolean;
  };
}
export interface MonitoringCoreosComV1alpha1ScrapeConfigList {
  apiVersion?: string;
  items: MonitoringCoreosComV1alpha1ScrapeConfig[];
  kind?: string;
  metadata?: ListMeta;
}
export interface AutoscalingInternalKnativeDevV1alpha1Metric {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: {
    panicWindow: number;
    scrapeTarget: string;
    stableWindow: number;
  };
  status?: {
    annotations?: {
      [key: string]: unknown;
    };
    conditions?: {
      lastTransitionTime?: string;
      message?: string;
      reason?: string;
      severity?: string;
      status: string;
      type: string;
    }[];
    observedGeneration?: number;
  };
}
export interface AutoscalingInternalKnativeDevV1alpha1MetricList {
  apiVersion?: string;
  items: AutoscalingInternalKnativeDevV1alpha1Metric[];
  kind?: string;
  metadata?: ListMeta;
}
export interface AutoscalingInternalKnativeDevV1alpha1PodAutoscaler {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: {
    containerConcurrency?: number;
    protocolType: string;
    reachability?: string;
    scaleTargetRef: {
      apiVersion?: string;
      kind?: string;
      name?: string;
    };
  };
  status?: {
    actualScale?: number;
    annotations?: {
      [key: string]: unknown;
    };
    conditions?: {
      lastTransitionTime?: string;
      message?: string;
      reason?: string;
      severity?: string;
      status: string;
      type: string;
    }[];
    desiredScale?: number;
    metricsServiceName: string;
    observedGeneration?: number;
    serviceName: string;
  };
}
export interface AutoscalingInternalKnativeDevV1alpha1PodAutoscalerList {
  apiVersion?: string;
  items: AutoscalingInternalKnativeDevV1alpha1PodAutoscaler[];
  kind?: string;
  metadata?: ListMeta;
}
export interface CachingInternalKnativeDevV1alpha1Image {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: {
    image: string;
    imagePullSecrets?: {
      name?: string;
    }[];
    serviceAccountName?: string;
  };
  status?: {
    annotations?: {
      [key: string]: unknown;
    };
    conditions?: {
      lastTransitionTime?: string;
      message?: string;
      reason?: string;
      severity?: string;
      status: string;
      type: string;
    }[];
    observedGeneration?: number;
  };
}
export interface CachingInternalKnativeDevV1alpha1ImageList {
  apiVersion?: string;
  items: CachingInternalKnativeDevV1alpha1Image[];
  kind?: string;
  metadata?: ListMeta;
}
export interface NetworkingInternalKnativeDevV1alpha1Certificate {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: {
    dnsNames: string[];
    domain?: string;
    secretName: string;
  };
  status?: {
    annotations?: {
      [key: string]: unknown;
    };
    conditions?: {
      lastTransitionTime?: string;
      message?: string;
      reason?: string;
      severity?: string;
      status: string;
      type: string;
    }[];
    http01Challenges?: {
      serviceName?: string;
      serviceNamespace?: string;
      servicePort?: any;
      url?: string;
    }[];
    notAfter?: string;
    observedGeneration?: number;
  };
}
export interface NetworkingInternalKnativeDevV1alpha1CertificateList {
  apiVersion?: string;
  items: NetworkingInternalKnativeDevV1alpha1Certificate[];
  kind?: string;
  metadata?: ListMeta;
}
export interface NetworkingInternalKnativeDevV1alpha1ClusterDomainClaim {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: {
    namespace: string;
  };
}
export interface NetworkingInternalKnativeDevV1alpha1ClusterDomainClaimList {
  apiVersion?: string;
  items: NetworkingInternalKnativeDevV1alpha1ClusterDomainClaim[];
  kind?: string;
  metadata?: ListMeta;
}
export interface NetworkingInternalKnativeDevV1alpha1Ingress {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: {
    httpOption?: string;
    rules?: {
      hosts?: string[];
      http?: {
        paths: {
          appendHeaders?: {
            [key: string]: unknown;
          };
          headers?: {
            [key: string]: unknown;
          };
          path?: string;
          rewriteHost?: string;
          splits: {
            appendHeaders?: {
              [key: string]: unknown;
            };
            percent?: number;
            serviceName: string;
            serviceNamespace: string;
            servicePort: any;
          }[];
        }[];
      };
      visibility?: string;
    }[];
    tls?: {
      hosts?: string[];
      secretName?: string;
      secretNamespace?: string;
    }[];
  };
  status?: {
    annotations?: {
      [key: string]: unknown;
    };
    conditions?: {
      lastTransitionTime?: string;
      message?: string;
      reason?: string;
      severity?: string;
      status: string;
      type: string;
    }[];
    observedGeneration?: number;
    privateLoadBalancer?: {
      ingress?: {
        domain?: string;
        domainInternal?: string;
        ip?: string;
        meshOnly?: boolean;
      }[];
    };
    publicLoadBalancer?: {
      ingress?: {
        domain?: string;
        domainInternal?: string;
        ip?: string;
        meshOnly?: boolean;
      }[];
    };
  };
}
export interface NetworkingInternalKnativeDevV1alpha1IngressList {
  apiVersion?: string;
  items: NetworkingInternalKnativeDevV1alpha1Ingress[];
  kind?: string;
  metadata?: ListMeta;
}
export interface NetworkingInternalKnativeDevV1alpha1ServerlessService {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: {
    mode?: string;
    numActivators?: number;
    objectRef: {
      apiVersion?: string;
      fieldPath?: string;
      kind?: string;
      name?: string;
      namespace?: string;
      resourceVersion?: string;
      uid?: string;
    };
    protocolType: string;
  };
  status?: {
    annotations?: {
      [key: string]: unknown;
    };
    conditions?: {
      lastTransitionTime?: string;
      message?: string;
      reason?: string;
      severity?: string;
      status: string;
      type: string;
    }[];
    observedGeneration?: number;
    privateServiceName?: string;
    serviceName?: string;
  };
}
export interface NetworkingInternalKnativeDevV1alpha1ServerlessServiceList {
  apiVersion?: string;
  items: NetworkingInternalKnativeDevV1alpha1ServerlessService[];
  kind?: string;
  metadata?: ListMeta;
}
export interface ServingKnativeDevV1Configuration {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: {
    template?: {
      metadata?: any;
      spec?: {
        affinity?: any;
        automountServiceAccountToken?: boolean;
        containerConcurrency?: number;
        containers: {
          args?: string[];
          command?: string[];
          env?: {
            name: string;
            value?: string;
            valueFrom?: {
              configMapKeyRef?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              fieldRef?: any;
              resourceFieldRef?: any;
              secretKeyRef?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
          }[];
          envFrom?: {
            configMapRef?: {
              name?: string;
              optional?: boolean;
            };
            prefix?: string;
            secretRef?: {
              name?: string;
              optional?: boolean;
            };
          }[];
          image?: string;
          imagePullPolicy?: string;
          livenessProbe?: {
            exec?: {
              command?: string[];
            };
            failureThreshold?: number;
            grpc?: {
              port: number;
              service?: string;
            };
            httpGet?: {
              host?: string;
              httpHeaders?: {
                name: string;
                value: string;
              }[];
              path?: string;
              port?: any;
              scheme?: string;
            };
            initialDelaySeconds?: number;
            periodSeconds?: number;
            successThreshold?: number;
            tcpSocket?: {
              host?: string;
              port?: any;
            };
            timeoutSeconds?: number;
          };
          name?: string;
          ports?: {
            containerPort: number;
            name?: string;
            protocol?: string;
          }[];
          readinessProbe?: {
            exec?: {
              command?: string[];
            };
            failureThreshold?: number;
            grpc?: {
              port: number;
              service?: string;
            };
            httpGet?: {
              host?: string;
              httpHeaders?: {
                name: string;
                value: string;
              }[];
              path?: string;
              port?: any;
              scheme?: string;
            };
            initialDelaySeconds?: number;
            periodSeconds?: number;
            successThreshold?: number;
            tcpSocket?: {
              host?: string;
              port?: any;
            };
            timeoutSeconds?: number;
          };
          resources?: {
            claims?: {
              name: string;
            }[];
            limits?: {
              [key: string]: unknown;
            };
            requests?: {
              [key: string]: unknown;
            };
          };
          securityContext?: {
            allowPrivilegeEscalation?: boolean;
            capabilities?: {
              add?: string[];
              drop?: string[];
            };
            readOnlyRootFilesystem?: boolean;
            runAsGroup?: number;
            runAsNonRoot?: boolean;
            runAsUser?: number;
            seccompProfile?: {
              localhostProfile?: string;
              type: string;
            };
          };
          startupProbe?: {
            exec?: {
              command?: string[];
            };
            failureThreshold?: number;
            grpc?: {
              port: number;
              service?: string;
            };
            httpGet?: {
              host?: string;
              httpHeaders?: {
                name: string;
                value: string;
              }[];
              path?: string;
              port?: any;
              scheme?: string;
            };
            initialDelaySeconds?: number;
            periodSeconds?: number;
            successThreshold?: number;
            tcpSocket?: {
              host?: string;
              port?: any;
            };
            timeoutSeconds?: number;
          };
          terminationMessagePath?: string;
          terminationMessagePolicy?: string;
          volumeMounts?: {
            mountPath: string;
            name: string;
            readOnly?: boolean;
            subPath?: string;
          }[];
          workingDir?: string;
        }[];
        dnsConfig?: any;
        dnsPolicy?: string;
        enableServiceLinks?: boolean;
        hostAliases?: any[];
        idleTimeoutSeconds?: number;
        imagePullSecrets?: {
          name?: string;
        }[];
        initContainers?: any[];
        nodeSelector?: any;
        priorityClassName?: string;
        responseStartTimeoutSeconds?: number;
        runtimeClassName?: string;
        schedulerName?: string;
        securityContext?: any;
        serviceAccountName?: string;
        shareProcessNamespace?: boolean;
        timeoutSeconds?: number;
        tolerations?: any[];
        topologySpreadConstraints?: any[];
        volumes?: {
          configMap?: {
            defaultMode?: number;
            items?: {
              key: string;
              mode?: number;
              path: string;
            }[];
            name?: string;
            optional?: boolean;
          };
          emptyDir?: any;
          name: string;
          persistentVolumeClaim?: any;
          projected?: {
            defaultMode?: number;
            sources?: {
              configMap?: {
                items?: {
                  key: string;
                  mode?: number;
                  path: string;
                }[];
                name?: string;
                optional?: boolean;
              };
              downwardAPI?: {
                items?: {
                  fieldRef?: {
                    apiVersion?: string;
                    fieldPath: string;
                  };
                  mode?: number;
                  path: string;
                  resourceFieldRef?: {
                    containerName?: string;
                    divisor?: any;
                    resource: string;
                  };
                }[];
              };
              secret?: {
                items?: {
                  key: string;
                  mode?: number;
                  path: string;
                }[];
                name?: string;
                optional?: boolean;
              };
              serviceAccountToken?: {
                audience?: string;
                expirationSeconds?: number;
                path: string;
              };
            }[];
          };
          secret?: {
            defaultMode?: number;
            items?: {
              key: string;
              mode?: number;
              path: string;
            }[];
            optional?: boolean;
            secretName?: string;
          };
        }[];
      };
    };
  };
  status?: {
    annotations?: {
      [key: string]: unknown;
    };
    conditions?: {
      lastTransitionTime?: string;
      message?: string;
      reason?: string;
      severity?: string;
      status: string;
      type: string;
    }[];
    latestCreatedRevisionName?: string;
    latestReadyRevisionName?: string;
    observedGeneration?: number;
  };
}
export interface ServingKnativeDevV1ConfigurationList {
  apiVersion?: string;
  items: ServingKnativeDevV1Configuration[];
  kind?: string;
  metadata?: ListMeta;
}
export interface ServingKnativeDevV1Revision {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: {
    affinity?: any;
    automountServiceAccountToken?: boolean;
    containerConcurrency?: number;
    containers: {
      args?: string[];
      command?: string[];
      env?: {
        name: string;
        value?: string;
        valueFrom?: {
          configMapKeyRef?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          fieldRef?: any;
          resourceFieldRef?: any;
          secretKeyRef?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
      }[];
      envFrom?: {
        configMapRef?: {
          name?: string;
          optional?: boolean;
        };
        prefix?: string;
        secretRef?: {
          name?: string;
          optional?: boolean;
        };
      }[];
      image?: string;
      imagePullPolicy?: string;
      livenessProbe?: {
        exec?: {
          command?: string[];
        };
        failureThreshold?: number;
        grpc?: {
          port: number;
          service?: string;
        };
        httpGet?: {
          host?: string;
          httpHeaders?: {
            name: string;
            value: string;
          }[];
          path?: string;
          port?: any;
          scheme?: string;
        };
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        tcpSocket?: {
          host?: string;
          port?: any;
        };
        timeoutSeconds?: number;
      };
      name?: string;
      ports?: {
        containerPort: number;
        name?: string;
        protocol?: string;
      }[];
      readinessProbe?: {
        exec?: {
          command?: string[];
        };
        failureThreshold?: number;
        grpc?: {
          port: number;
          service?: string;
        };
        httpGet?: {
          host?: string;
          httpHeaders?: {
            name: string;
            value: string;
          }[];
          path?: string;
          port?: any;
          scheme?: string;
        };
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        tcpSocket?: {
          host?: string;
          port?: any;
        };
        timeoutSeconds?: number;
      };
      resources?: {
        claims?: {
          name: string;
        }[];
        limits?: {
          [key: string]: unknown;
        };
        requests?: {
          [key: string]: unknown;
        };
      };
      securityContext?: {
        allowPrivilegeEscalation?: boolean;
        capabilities?: {
          add?: string[];
          drop?: string[];
        };
        readOnlyRootFilesystem?: boolean;
        runAsGroup?: number;
        runAsNonRoot?: boolean;
        runAsUser?: number;
        seccompProfile?: {
          localhostProfile?: string;
          type: string;
        };
      };
      startupProbe?: {
        exec?: {
          command?: string[];
        };
        failureThreshold?: number;
        grpc?: {
          port: number;
          service?: string;
        };
        httpGet?: {
          host?: string;
          httpHeaders?: {
            name: string;
            value: string;
          }[];
          path?: string;
          port?: any;
          scheme?: string;
        };
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        tcpSocket?: {
          host?: string;
          port?: any;
        };
        timeoutSeconds?: number;
      };
      terminationMessagePath?: string;
      terminationMessagePolicy?: string;
      volumeMounts?: {
        mountPath: string;
        name: string;
        readOnly?: boolean;
        subPath?: string;
      }[];
      workingDir?: string;
    }[];
    dnsConfig?: any;
    dnsPolicy?: string;
    enableServiceLinks?: boolean;
    hostAliases?: any[];
    idleTimeoutSeconds?: number;
    imagePullSecrets?: {
      name?: string;
    }[];
    initContainers?: any[];
    nodeSelector?: any;
    priorityClassName?: string;
    responseStartTimeoutSeconds?: number;
    runtimeClassName?: string;
    schedulerName?: string;
    securityContext?: any;
    serviceAccountName?: string;
    shareProcessNamespace?: boolean;
    timeoutSeconds?: number;
    tolerations?: any[];
    topologySpreadConstraints?: any[];
    volumes?: {
      configMap?: {
        defaultMode?: number;
        items?: {
          key: string;
          mode?: number;
          path: string;
        }[];
        name?: string;
        optional?: boolean;
      };
      emptyDir?: any;
      name: string;
      persistentVolumeClaim?: any;
      projected?: {
        defaultMode?: number;
        sources?: {
          configMap?: {
            items?: {
              key: string;
              mode?: number;
              path: string;
            }[];
            name?: string;
            optional?: boolean;
          };
          downwardAPI?: {
            items?: {
              fieldRef?: {
                apiVersion?: string;
                fieldPath: string;
              };
              mode?: number;
              path: string;
              resourceFieldRef?: {
                containerName?: string;
                divisor?: any;
                resource: string;
              };
            }[];
          };
          secret?: {
            items?: {
              key: string;
              mode?: number;
              path: string;
            }[];
            name?: string;
            optional?: boolean;
          };
          serviceAccountToken?: {
            audience?: string;
            expirationSeconds?: number;
            path: string;
          };
        }[];
      };
      secret?: {
        defaultMode?: number;
        items?: {
          key: string;
          mode?: number;
          path: string;
        }[];
        optional?: boolean;
        secretName?: string;
      };
    }[];
  };
  status?: {
    actualReplicas?: number;
    annotations?: {
      [key: string]: unknown;
    };
    conditions?: {
      lastTransitionTime?: string;
      message?: string;
      reason?: string;
      severity?: string;
      status: string;
      type: string;
    }[];
    containerStatuses?: {
      imageDigest?: string;
      name?: string;
    }[];
    desiredReplicas?: number;
    initContainerStatuses?: {
      imageDigest?: string;
      name?: string;
    }[];
    logUrl?: string;
    observedGeneration?: number;
  };
}
export interface ServingKnativeDevV1RevisionList {
  apiVersion?: string;
  items: ServingKnativeDevV1Revision[];
  kind?: string;
  metadata?: ListMeta;
}
export interface ServingKnativeDevV1Route {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: {
    traffic?: {
      configurationName?: string;
      latestRevision?: boolean;
      percent?: number;
      revisionName?: string;
      tag?: string;
      url?: string;
    }[];
  };
  status?: {
    address?: {
      CACerts?: string;
      audience?: string;
      name?: string;
      url?: string;
    };
    annotations?: {
      [key: string]: unknown;
    };
    conditions?: {
      lastTransitionTime?: string;
      message?: string;
      reason?: string;
      severity?: string;
      status: string;
      type: string;
    }[];
    observedGeneration?: number;
    traffic?: {
      configurationName?: string;
      latestRevision?: boolean;
      percent?: number;
      revisionName?: string;
      tag?: string;
      url?: string;
    }[];
    url?: string;
  };
}
export interface ServingKnativeDevV1RouteList {
  apiVersion?: string;
  items: ServingKnativeDevV1Route[];
  kind?: string;
  metadata?: ListMeta;
}
export interface ServingKnativeDevV1Service {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: {
    template?: {
      metadata?: any;
      spec?: {
        affinity?: any;
        automountServiceAccountToken?: boolean;
        containerConcurrency?: number;
        containers: {
          args?: string[];
          command?: string[];
          env?: {
            name: string;
            value?: string;
            valueFrom?: {
              configMapKeyRef?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              fieldRef?: any;
              resourceFieldRef?: any;
              secretKeyRef?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
          }[];
          envFrom?: {
            configMapRef?: {
              name?: string;
              optional?: boolean;
            };
            prefix?: string;
            secretRef?: {
              name?: string;
              optional?: boolean;
            };
          }[];
          image?: string;
          imagePullPolicy?: string;
          livenessProbe?: {
            exec?: {
              command?: string[];
            };
            failureThreshold?: number;
            grpc?: {
              port: number;
              service?: string;
            };
            httpGet?: {
              host?: string;
              httpHeaders?: {
                name: string;
                value: string;
              }[];
              path?: string;
              port?: any;
              scheme?: string;
            };
            initialDelaySeconds?: number;
            periodSeconds?: number;
            successThreshold?: number;
            tcpSocket?: {
              host?: string;
              port?: any;
            };
            timeoutSeconds?: number;
          };
          name?: string;
          ports?: {
            containerPort: number;
            name?: string;
            protocol?: string;
          }[];
          readinessProbe?: {
            exec?: {
              command?: string[];
            };
            failureThreshold?: number;
            grpc?: {
              port: number;
              service?: string;
            };
            httpGet?: {
              host?: string;
              httpHeaders?: {
                name: string;
                value: string;
              }[];
              path?: string;
              port?: any;
              scheme?: string;
            };
            initialDelaySeconds?: number;
            periodSeconds?: number;
            successThreshold?: number;
            tcpSocket?: {
              host?: string;
              port?: any;
            };
            timeoutSeconds?: number;
          };
          resources?: {
            claims?: {
              name: string;
            }[];
            limits?: {
              [key: string]: unknown;
            };
            requests?: {
              [key: string]: unknown;
            };
          };
          securityContext?: {
            allowPrivilegeEscalation?: boolean;
            capabilities?: {
              add?: string[];
              drop?: string[];
            };
            readOnlyRootFilesystem?: boolean;
            runAsGroup?: number;
            runAsNonRoot?: boolean;
            runAsUser?: number;
            seccompProfile?: {
              localhostProfile?: string;
              type: string;
            };
          };
          startupProbe?: {
            exec?: {
              command?: string[];
            };
            failureThreshold?: number;
            grpc?: {
              port: number;
              service?: string;
            };
            httpGet?: {
              host?: string;
              httpHeaders?: {
                name: string;
                value: string;
              }[];
              path?: string;
              port?: any;
              scheme?: string;
            };
            initialDelaySeconds?: number;
            periodSeconds?: number;
            successThreshold?: number;
            tcpSocket?: {
              host?: string;
              port?: any;
            };
            timeoutSeconds?: number;
          };
          terminationMessagePath?: string;
          terminationMessagePolicy?: string;
          volumeMounts?: {
            mountPath: string;
            name: string;
            readOnly?: boolean;
            subPath?: string;
          }[];
          workingDir?: string;
        }[];
        dnsConfig?: any;
        dnsPolicy?: string;
        enableServiceLinks?: boolean;
        hostAliases?: any[];
        idleTimeoutSeconds?: number;
        imagePullSecrets?: {
          name?: string;
        }[];
        initContainers?: any[];
        nodeSelector?: any;
        priorityClassName?: string;
        responseStartTimeoutSeconds?: number;
        runtimeClassName?: string;
        schedulerName?: string;
        securityContext?: any;
        serviceAccountName?: string;
        shareProcessNamespace?: boolean;
        timeoutSeconds?: number;
        tolerations?: any[];
        topologySpreadConstraints?: any[];
        volumes?: {
          configMap?: {
            defaultMode?: number;
            items?: {
              key: string;
              mode?: number;
              path: string;
            }[];
            name?: string;
            optional?: boolean;
          };
          emptyDir?: any;
          name: string;
          persistentVolumeClaim?: any;
          projected?: {
            defaultMode?: number;
            sources?: {
              configMap?: {
                items?: {
                  key: string;
                  mode?: number;
                  path: string;
                }[];
                name?: string;
                optional?: boolean;
              };
              downwardAPI?: {
                items?: {
                  fieldRef?: {
                    apiVersion?: string;
                    fieldPath: string;
                  };
                  mode?: number;
                  path: string;
                  resourceFieldRef?: {
                    containerName?: string;
                    divisor?: any;
                    resource: string;
                  };
                }[];
              };
              secret?: {
                items?: {
                  key: string;
                  mode?: number;
                  path: string;
                }[];
                name?: string;
                optional?: boolean;
              };
              serviceAccountToken?: {
                audience?: string;
                expirationSeconds?: number;
                path: string;
              };
            }[];
          };
          secret?: {
            defaultMode?: number;
            items?: {
              key: string;
              mode?: number;
              path: string;
            }[];
            optional?: boolean;
            secretName?: string;
          };
        }[];
      };
    };
    traffic?: {
      configurationName?: string;
      latestRevision?: boolean;
      percent?: number;
      revisionName?: string;
      tag?: string;
      url?: string;
    }[];
  };
  status?: {
    address?: {
      CACerts?: string;
      audience?: string;
      name?: string;
      url?: string;
    };
    annotations?: {
      [key: string]: unknown;
    };
    conditions?: {
      lastTransitionTime?: string;
      message?: string;
      reason?: string;
      severity?: string;
      status: string;
      type: string;
    }[];
    latestCreatedRevisionName?: string;
    latestReadyRevisionName?: string;
    observedGeneration?: number;
    traffic?: {
      configurationName?: string;
      latestRevision?: boolean;
      percent?: number;
      revisionName?: string;
      tag?: string;
      url?: string;
    }[];
    url?: string;
  };
}
export interface ServingKnativeDevV1ServiceList {
  apiVersion?: string;
  items: ServingKnativeDevV1Service[];
  kind?: string;
  metadata?: ListMeta;
}
export interface AcmeCertManagerIoV1Challenge {
  apiVersion?: string;
  kind?: string;
  metadata: ObjectMeta;
  spec: {
    authorizationURL: string;
    dnsName: string;
    issuerRef: {
      group?: string;
      kind?: string;
      name: string;
    };
    key: string;
    solver: {
      dns01?: {
        acmeDNS?: {
          accountSecretRef: {
            key?: string;
            name: string;
          };
          host: string;
        };
        akamai?: {
          accessTokenSecretRef: {
            key?: string;
            name: string;
          };
          clientSecretSecretRef: {
            key?: string;
            name: string;
          };
          clientTokenSecretRef: {
            key?: string;
            name: string;
          };
          serviceConsumerDomain: string;
        };
        azureDNS?: {
          clientID?: string;
          clientSecretSecretRef?: {
            key?: string;
            name: string;
          };
          environment?: "AzurePublicCloud" | "AzureChinaCloud" | "AzureGermanCloud" | "AzureUSGovernmentCloud";
          hostedZoneName?: string;
          managedIdentity?: {
            clientID?: string;
            resourceID?: string;
            tenantID?: string;
          };
          resourceGroupName: string;
          subscriptionID: string;
          tenantID?: string;
        };
        cloudDNS?: {
          hostedZoneName?: string;
          project: string;
          serviceAccountSecretRef?: {
            key?: string;
            name: string;
          };
        };
        cloudflare?: {
          apiKeySecretRef?: {
            key?: string;
            name: string;
          };
          apiTokenSecretRef?: {
            key?: string;
            name: string;
          };
          email?: string;
        };
        cnameStrategy?: "None" | "Follow";
        digitalocean?: {
          tokenSecretRef: {
            key?: string;
            name: string;
          };
        };
        rfc2136?: {
          nameserver: string;
          tsigAlgorithm?: string;
          tsigKeyName?: string;
          tsigSecretSecretRef?: {
            key?: string;
            name: string;
          };
        };
        route53?: {
          accessKeyID?: string;
          accessKeyIDSecretRef?: {
            key?: string;
            name: string;
          };
          auth?: {
            kubernetes: {
              serviceAccountRef: {
                audiences?: string[];
                name: string;
              };
            };
          };
          hostedZoneID?: string;
          region?: string;
          role?: string;
          secretAccessKeySecretRef?: {
            key?: string;
            name: string;
          };
        };
        webhook?: {
          config?: any;
          groupName: string;
          solverName: string;
        };
      };
      http01?: {
        gatewayHTTPRoute?: {
          labels?: {
            [key: string]: unknown;
          };
          parentRefs?: {
            group?: string;
            kind?: string;
            name: string;
            namespace?: string;
            port?: number;
            sectionName?: string;
          }[];
          podTemplate?: {
            metadata?: {
              annotations?: {
                [key: string]: unknown;
              };
              labels?: {
                [key: string]: unknown;
              };
            };
            spec?: {
              affinity?: {
                nodeAffinity?: {
                  preferredDuringSchedulingIgnoredDuringExecution?: {
                    preference: {
                      matchExpressions?: {
                        key: string;
                        operator: string;
                        values?: string[];
                      }[];
                      matchFields?: {
                        key: string;
                        operator: string;
                        values?: string[];
                      }[];
                    };
                    weight: number;
                  }[];
                  requiredDuringSchedulingIgnoredDuringExecution?: {
                    nodeSelectorTerms: {
                      matchExpressions?: {
                        key: string;
                        operator: string;
                        values?: string[];
                      }[];
                      matchFields?: {
                        key: string;
                        operator: string;
                        values?: string[];
                      }[];
                    }[];
                  };
                };
                podAffinity?: {
                  preferredDuringSchedulingIgnoredDuringExecution?: {
                    podAffinityTerm: {
                      labelSelector?: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchLabels?: {
                          [key: string]: unknown;
                        };
                      };
                      matchLabelKeys?: string[];
                      mismatchLabelKeys?: string[];
                      namespaceSelector?: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchLabels?: {
                          [key: string]: unknown;
                        };
                      };
                      namespaces?: string[];
                      topologyKey: string;
                    };
                    weight: number;
                  }[];
                  requiredDuringSchedulingIgnoredDuringExecution?: {
                    labelSelector?: {
                      matchExpressions?: {
                        key: string;
                        operator: string;
                        values?: string[];
                      }[];
                      matchLabels?: {
                        [key: string]: unknown;
                      };
                    };
                    matchLabelKeys?: string[];
                    mismatchLabelKeys?: string[];
                    namespaceSelector?: {
                      matchExpressions?: {
                        key: string;
                        operator: string;
                        values?: string[];
                      }[];
                      matchLabels?: {
                        [key: string]: unknown;
                      };
                    };
                    namespaces?: string[];
                    topologyKey: string;
                  }[];
                };
                podAntiAffinity?: {
                  preferredDuringSchedulingIgnoredDuringExecution?: {
                    podAffinityTerm: {
                      labelSelector?: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchLabels?: {
                          [key: string]: unknown;
                        };
                      };
                      matchLabelKeys?: string[];
                      mismatchLabelKeys?: string[];
                      namespaceSelector?: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchLabels?: {
                          [key: string]: unknown;
                        };
                      };
                      namespaces?: string[];
                      topologyKey: string;
                    };
                    weight: number;
                  }[];
                  requiredDuringSchedulingIgnoredDuringExecution?: {
                    labelSelector?: {
                      matchExpressions?: {
                        key: string;
                        operator: string;
                        values?: string[];
                      }[];
                      matchLabels?: {
                        [key: string]: unknown;
                      };
                    };
                    matchLabelKeys?: string[];
                    mismatchLabelKeys?: string[];
                    namespaceSelector?: {
                      matchExpressions?: {
                        key: string;
                        operator: string;
                        values?: string[];
                      }[];
                      matchLabels?: {
                        [key: string]: unknown;
                      };
                    };
                    namespaces?: string[];
                    topologyKey: string;
                  }[];
                };
              };
              imagePullSecrets?: {
                name?: string;
              }[];
              nodeSelector?: {
                [key: string]: unknown;
              };
              priorityClassName?: string;
              securityContext?: {
                fsGroup?: number;
                fsGroupChangePolicy?: string;
                runAsGroup?: number;
                runAsNonRoot?: boolean;
                runAsUser?: number;
                seLinuxOptions?: {
                  level?: string;
                  role?: string;
                  type?: string;
                  user?: string;
                };
                seccompProfile?: {
                  localhostProfile?: string;
                  type: string;
                };
                supplementalGroups?: number[];
                sysctls?: {
                  name: string;
                  value: string;
                }[];
              };
              serviceAccountName?: string;
              tolerations?: {
                effect?: string;
                key?: string;
                operator?: string;
                tolerationSeconds?: number;
                value?: string;
              }[];
            };
          };
          serviceType?: string;
        };
        ingress?: {
          class?: string;
          ingressClassName?: string;
          ingressTemplate?: {
            metadata?: {
              annotations?: {
                [key: string]: unknown;
              };
              labels?: {
                [key: string]: unknown;
              };
            };
          };
          name?: string;
          podTemplate?: {
            metadata?: {
              annotations?: {
                [key: string]: unknown;
              };
              labels?: {
                [key: string]: unknown;
              };
            };
            spec?: {
              affinity?: {
                nodeAffinity?: {
                  preferredDuringSchedulingIgnoredDuringExecution?: {
                    preference: {
                      matchExpressions?: {
                        key: string;
                        operator: string;
                        values?: string[];
                      }[];
                      matchFields?: {
                        key: string;
                        operator: string;
                        values?: string[];
                      }[];
                    };
                    weight: number;
                  }[];
                  requiredDuringSchedulingIgnoredDuringExecution?: {
                    nodeSelectorTerms: {
                      matchExpressions?: {
                        key: string;
                        operator: string;
                        values?: string[];
                      }[];
                      matchFields?: {
                        key: string;
                        operator: string;
                        values?: string[];
                      }[];
                    }[];
                  };
                };
                podAffinity?: {
                  preferredDuringSchedulingIgnoredDuringExecution?: {
                    podAffinityTerm: {
                      labelSelector?: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchLabels?: {
                          [key: string]: unknown;
                        };
                      };
                      matchLabelKeys?: string[];
                      mismatchLabelKeys?: string[];
                      namespaceSelector?: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchLabels?: {
                          [key: string]: unknown;
                        };
                      };
                      namespaces?: string[];
                      topologyKey: string;
                    };
                    weight: number;
                  }[];
                  requiredDuringSchedulingIgnoredDuringExecution?: {
                    labelSelector?: {
                      matchExpressions?: {
                        key: string;
                        operator: string;
                        values?: string[];
                      }[];
                      matchLabels?: {
                        [key: string]: unknown;
                      };
                    };
                    matchLabelKeys?: string[];
                    mismatchLabelKeys?: string[];
                    namespaceSelector?: {
                      matchExpressions?: {
                        key: string;
                        operator: string;
                        values?: string[];
                      }[];
                      matchLabels?: {
                        [key: string]: unknown;
                      };
                    };
                    namespaces?: string[];
                    topologyKey: string;
                  }[];
                };
                podAntiAffinity?: {
                  preferredDuringSchedulingIgnoredDuringExecution?: {
                    podAffinityTerm: {
                      labelSelector?: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchLabels?: {
                          [key: string]: unknown;
                        };
                      };
                      matchLabelKeys?: string[];
                      mismatchLabelKeys?: string[];
                      namespaceSelector?: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchLabels?: {
                          [key: string]: unknown;
                        };
                      };
                      namespaces?: string[];
                      topologyKey: string;
                    };
                    weight: number;
                  }[];
                  requiredDuringSchedulingIgnoredDuringExecution?: {
                    labelSelector?: {
                      matchExpressions?: {
                        key: string;
                        operator: string;
                        values?: string[];
                      }[];
                      matchLabels?: {
                        [key: string]: unknown;
                      };
                    };
                    matchLabelKeys?: string[];
                    mismatchLabelKeys?: string[];
                    namespaceSelector?: {
                      matchExpressions?: {
                        key: string;
                        operator: string;
                        values?: string[];
                      }[];
                      matchLabels?: {
                        [key: string]: unknown;
                      };
                    };
                    namespaces?: string[];
                    topologyKey: string;
                  }[];
                };
              };
              imagePullSecrets?: {
                name?: string;
              }[];
              nodeSelector?: {
                [key: string]: unknown;
              };
              priorityClassName?: string;
              securityContext?: {
                fsGroup?: number;
                fsGroupChangePolicy?: string;
                runAsGroup?: number;
                runAsNonRoot?: boolean;
                runAsUser?: number;
                seLinuxOptions?: {
                  level?: string;
                  role?: string;
                  type?: string;
                  user?: string;
                };
                seccompProfile?: {
                  localhostProfile?: string;
                  type: string;
                };
                supplementalGroups?: number[];
                sysctls?: {
                  name: string;
                  value: string;
                }[];
              };
              serviceAccountName?: string;
              tolerations?: {
                effect?: string;
                key?: string;
                operator?: string;
                tolerationSeconds?: number;
                value?: string;
              }[];
            };
          };
          serviceType?: string;
        };
      };
      selector?: {
        dnsNames?: string[];
        dnsZones?: string[];
        matchLabels?: {
          [key: string]: unknown;
        };
      };
    };
    token: string;
    type: "HTTP-01" | "DNS-01";
    url: string;
    wildcard?: boolean;
  };
  status?: {
    presented?: boolean;
    processing?: boolean;
    reason?: string;
    state?: "valid" | "ready" | "pending" | "processing" | "invalid" | "expired" | "errored";
  };
}
export interface AcmeCertManagerIoV1ChallengeList {
  apiVersion?: string;
  items: AcmeCertManagerIoV1Challenge[];
  kind?: string;
  metadata?: ListMeta;
}
export interface AcmeCertManagerIoV1Order {
  apiVersion?: string;
  kind?: string;
  metadata: ObjectMeta;
  spec: {
    commonName?: string;
    dnsNames?: string[];
    duration?: string;
    ipAddresses?: string[];
    issuerRef: {
      group?: string;
      kind?: string;
      name: string;
    };
    request: string;
  };
  status?: {
    authorizations?: {
      challenges?: {
        token: string;
        type: string;
        url: string;
      }[];
      identifier?: string;
      initialState?: "valid" | "ready" | "pending" | "processing" | "invalid" | "expired" | "errored";
      url: string;
      wildcard?: boolean;
    }[];
    certificate?: string;
    failureTime?: string;
    finalizeURL?: string;
    reason?: string;
    state?: "valid" | "ready" | "pending" | "processing" | "invalid" | "expired" | "errored";
    url?: string;
  };
}
export interface AcmeCertManagerIoV1OrderList {
  apiVersion?: string;
  items: AcmeCertManagerIoV1Order[];
  kind?: string;
  metadata?: ListMeta;
}
export interface CertManagerIoV1Certificate {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: {
    additionalOutputFormats?: {
      type: "DER" | "CombinedPEM";
    }[];
    commonName?: string;
    dnsNames?: string[];
    duration?: string;
    emailAddresses?: string[];
    encodeUsagesInRequest?: boolean;
    ipAddresses?: string[];
    isCA?: boolean;
    issuerRef: {
      group?: string;
      kind?: string;
      name: string;
    };
    keystores?: {
      jks?: {
        alias?: string;
        create: boolean;
        password?: string;
        passwordSecretRef?: {
          key?: string;
          name: string;
        };
      };
      pkcs12?: {
        create: boolean;
        password?: string;
        passwordSecretRef?: {
          key?: string;
          name: string;
        };
        profile?: "LegacyRC2" | "LegacyDES" | "Modern2023";
      };
    };
    literalSubject?: string;
    nameConstraints?: {
      critical?: boolean;
      excluded?: {
        dnsDomains?: string[];
        emailAddresses?: string[];
        ipRanges?: string[];
        uriDomains?: string[];
      };
      permitted?: {
        dnsDomains?: string[];
        emailAddresses?: string[];
        ipRanges?: string[];
        uriDomains?: string[];
      };
    };
    otherNames?: {
      oid?: string;
      utf8Value?: string;
    }[];
    privateKey?: {
      algorithm?: "RSA" | "ECDSA" | "Ed25519";
      encoding?: "PKCS1" | "PKCS8";
      rotationPolicy?: "Never" | "Always";
      size?: number;
    };
    renewBefore?: string;
    renewBeforePercentage?: number;
    revisionHistoryLimit?: number;
    secretName: string;
    secretTemplate?: {
      annotations?: {
        [key: string]: unknown;
      };
      labels?: {
        [key: string]: unknown;
      };
    };
    subject?: {
      countries?: string[];
      localities?: string[];
      organizationalUnits?: string[];
      organizations?: string[];
      postalCodes?: string[];
      provinces?: string[];
      serialNumber?: string;
      streetAddresses?: string[];
    };
    uris?: string[];
    usages?: ("signing" | "digital signature" | "content commitment" | "key encipherment" | "key agreement" | "data encipherment" | "cert sign" | "crl sign" | "encipher only" | "decipher only" | "any" | "server auth" | "client auth" | "code signing" | "email protection" | "s/mime" | "ipsec end system" | "ipsec tunnel" | "ipsec user" | "timestamping" | "ocsp signing" | "microsoft sgc" | "netscape sgc")[];
  };
  status?: {
    conditions?: {
      lastTransitionTime?: string;
      message?: string;
      observedGeneration?: number;
      reason?: string;
      status: "True" | "False" | "Unknown";
      type: string;
    }[];
    failedIssuanceAttempts?: number;
    lastFailureTime?: string;
    nextPrivateKeySecretName?: string;
    notAfter?: string;
    notBefore?: string;
    renewalTime?: string;
    revision?: number;
  };
}
export interface CertManagerIoV1CertificateList {
  apiVersion?: string;
  items: CertManagerIoV1Certificate[];
  kind?: string;
  metadata?: ListMeta;
}
export interface CertManagerIoV1CertificateRequest {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: {
    duration?: string;
    extra?: {
      [key: string]: unknown;
    };
    groups?: string[];
    isCA?: boolean;
    issuerRef: {
      group?: string;
      kind?: string;
      name: string;
    };
    request: string;
    uid?: string;
    usages?: ("signing" | "digital signature" | "content commitment" | "key encipherment" | "key agreement" | "data encipherment" | "cert sign" | "crl sign" | "encipher only" | "decipher only" | "any" | "server auth" | "client auth" | "code signing" | "email protection" | "s/mime" | "ipsec end system" | "ipsec tunnel" | "ipsec user" | "timestamping" | "ocsp signing" | "microsoft sgc" | "netscape sgc")[];
    username?: string;
  };
  status?: {
    ca?: string;
    certificate?: string;
    conditions?: {
      lastTransitionTime?: string;
      message?: string;
      reason?: string;
      status: "True" | "False" | "Unknown";
      type: string;
    }[];
    failureTime?: string;
  };
}
export interface CertManagerIoV1CertificateRequestList {
  apiVersion?: string;
  items: CertManagerIoV1CertificateRequest[];
  kind?: string;
  metadata?: ListMeta;
}
export interface CertManagerIoV1ClusterIssuer {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec: {
    acme?: {
      caBundle?: string;
      disableAccountKeyGeneration?: boolean;
      email?: string;
      enableDurationFeature?: boolean;
      externalAccountBinding?: {
        keyAlgorithm?: "HS256" | "HS384" | "HS512";
        keyID: string;
        keySecretRef: {
          key?: string;
          name: string;
        };
      };
      preferredChain?: string;
      privateKeySecretRef: {
        key?: string;
        name: string;
      };
      server: string;
      skipTLSVerify?: boolean;
      solvers?: {
        dns01?: {
          acmeDNS?: {
            accountSecretRef: {
              key?: string;
              name: string;
            };
            host: string;
          };
          akamai?: {
            accessTokenSecretRef: {
              key?: string;
              name: string;
            };
            clientSecretSecretRef: {
              key?: string;
              name: string;
            };
            clientTokenSecretRef: {
              key?: string;
              name: string;
            };
            serviceConsumerDomain: string;
          };
          azureDNS?: {
            clientID?: string;
            clientSecretSecretRef?: {
              key?: string;
              name: string;
            };
            environment?: "AzurePublicCloud" | "AzureChinaCloud" | "AzureGermanCloud" | "AzureUSGovernmentCloud";
            hostedZoneName?: string;
            managedIdentity?: {
              clientID?: string;
              resourceID?: string;
              tenantID?: string;
            };
            resourceGroupName: string;
            subscriptionID: string;
            tenantID?: string;
          };
          cloudDNS?: {
            hostedZoneName?: string;
            project: string;
            serviceAccountSecretRef?: {
              key?: string;
              name: string;
            };
          };
          cloudflare?: {
            apiKeySecretRef?: {
              key?: string;
              name: string;
            };
            apiTokenSecretRef?: {
              key?: string;
              name: string;
            };
            email?: string;
          };
          cnameStrategy?: "None" | "Follow";
          digitalocean?: {
            tokenSecretRef: {
              key?: string;
              name: string;
            };
          };
          rfc2136?: {
            nameserver: string;
            tsigAlgorithm?: string;
            tsigKeyName?: string;
            tsigSecretSecretRef?: {
              key?: string;
              name: string;
            };
          };
          route53?: {
            accessKeyID?: string;
            accessKeyIDSecretRef?: {
              key?: string;
              name: string;
            };
            auth?: {
              kubernetes: {
                serviceAccountRef: {
                  audiences?: string[];
                  name: string;
                };
              };
            };
            hostedZoneID?: string;
            region?: string;
            role?: string;
            secretAccessKeySecretRef?: {
              key?: string;
              name: string;
            };
          };
          webhook?: {
            config?: any;
            groupName: string;
            solverName: string;
          };
        };
        http01?: {
          gatewayHTTPRoute?: {
            labels?: {
              [key: string]: unknown;
            };
            parentRefs?: {
              group?: string;
              kind?: string;
              name: string;
              namespace?: string;
              port?: number;
              sectionName?: string;
            }[];
            podTemplate?: {
              metadata?: {
                annotations?: {
                  [key: string]: unknown;
                };
                labels?: {
                  [key: string]: unknown;
                };
              };
              spec?: {
                affinity?: {
                  nodeAffinity?: {
                    preferredDuringSchedulingIgnoredDuringExecution?: {
                      preference: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchFields?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                      };
                      weight: number;
                    }[];
                    requiredDuringSchedulingIgnoredDuringExecution?: {
                      nodeSelectorTerms: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchFields?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                      }[];
                    };
                  };
                  podAffinity?: {
                    preferredDuringSchedulingIgnoredDuringExecution?: {
                      podAffinityTerm: {
                        labelSelector?: {
                          matchExpressions?: {
                            key: string;
                            operator: string;
                            values?: string[];
                          }[];
                          matchLabels?: {
                            [key: string]: unknown;
                          };
                        };
                        matchLabelKeys?: string[];
                        mismatchLabelKeys?: string[];
                        namespaceSelector?: {
                          matchExpressions?: {
                            key: string;
                            operator: string;
                            values?: string[];
                          }[];
                          matchLabels?: {
                            [key: string]: unknown;
                          };
                        };
                        namespaces?: string[];
                        topologyKey: string;
                      };
                      weight: number;
                    }[];
                    requiredDuringSchedulingIgnoredDuringExecution?: {
                      labelSelector?: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchLabels?: {
                          [key: string]: unknown;
                        };
                      };
                      matchLabelKeys?: string[];
                      mismatchLabelKeys?: string[];
                      namespaceSelector?: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchLabels?: {
                          [key: string]: unknown;
                        };
                      };
                      namespaces?: string[];
                      topologyKey: string;
                    }[];
                  };
                  podAntiAffinity?: {
                    preferredDuringSchedulingIgnoredDuringExecution?: {
                      podAffinityTerm: {
                        labelSelector?: {
                          matchExpressions?: {
                            key: string;
                            operator: string;
                            values?: string[];
                          }[];
                          matchLabels?: {
                            [key: string]: unknown;
                          };
                        };
                        matchLabelKeys?: string[];
                        mismatchLabelKeys?: string[];
                        namespaceSelector?: {
                          matchExpressions?: {
                            key: string;
                            operator: string;
                            values?: string[];
                          }[];
                          matchLabels?: {
                            [key: string]: unknown;
                          };
                        };
                        namespaces?: string[];
                        topologyKey: string;
                      };
                      weight: number;
                    }[];
                    requiredDuringSchedulingIgnoredDuringExecution?: {
                      labelSelector?: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchLabels?: {
                          [key: string]: unknown;
                        };
                      };
                      matchLabelKeys?: string[];
                      mismatchLabelKeys?: string[];
                      namespaceSelector?: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchLabels?: {
                          [key: string]: unknown;
                        };
                      };
                      namespaces?: string[];
                      topologyKey: string;
                    }[];
                  };
                };
                imagePullSecrets?: {
                  name?: string;
                }[];
                nodeSelector?: {
                  [key: string]: unknown;
                };
                priorityClassName?: string;
                securityContext?: {
                  fsGroup?: number;
                  fsGroupChangePolicy?: string;
                  runAsGroup?: number;
                  runAsNonRoot?: boolean;
                  runAsUser?: number;
                  seLinuxOptions?: {
                    level?: string;
                    role?: string;
                    type?: string;
                    user?: string;
                  };
                  seccompProfile?: {
                    localhostProfile?: string;
                    type: string;
                  };
                  supplementalGroups?: number[];
                  sysctls?: {
                    name: string;
                    value: string;
                  }[];
                };
                serviceAccountName?: string;
                tolerations?: {
                  effect?: string;
                  key?: string;
                  operator?: string;
                  tolerationSeconds?: number;
                  value?: string;
                }[];
              };
            };
            serviceType?: string;
          };
          ingress?: {
            class?: string;
            ingressClassName?: string;
            ingressTemplate?: {
              metadata?: {
                annotations?: {
                  [key: string]: unknown;
                };
                labels?: {
                  [key: string]: unknown;
                };
              };
            };
            name?: string;
            podTemplate?: {
              metadata?: {
                annotations?: {
                  [key: string]: unknown;
                };
                labels?: {
                  [key: string]: unknown;
                };
              };
              spec?: {
                affinity?: {
                  nodeAffinity?: {
                    preferredDuringSchedulingIgnoredDuringExecution?: {
                      preference: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchFields?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                      };
                      weight: number;
                    }[];
                    requiredDuringSchedulingIgnoredDuringExecution?: {
                      nodeSelectorTerms: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchFields?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                      }[];
                    };
                  };
                  podAffinity?: {
                    preferredDuringSchedulingIgnoredDuringExecution?: {
                      podAffinityTerm: {
                        labelSelector?: {
                          matchExpressions?: {
                            key: string;
                            operator: string;
                            values?: string[];
                          }[];
                          matchLabels?: {
                            [key: string]: unknown;
                          };
                        };
                        matchLabelKeys?: string[];
                        mismatchLabelKeys?: string[];
                        namespaceSelector?: {
                          matchExpressions?: {
                            key: string;
                            operator: string;
                            values?: string[];
                          }[];
                          matchLabels?: {
                            [key: string]: unknown;
                          };
                        };
                        namespaces?: string[];
                        topologyKey: string;
                      };
                      weight: number;
                    }[];
                    requiredDuringSchedulingIgnoredDuringExecution?: {
                      labelSelector?: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchLabels?: {
                          [key: string]: unknown;
                        };
                      };
                      matchLabelKeys?: string[];
                      mismatchLabelKeys?: string[];
                      namespaceSelector?: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchLabels?: {
                          [key: string]: unknown;
                        };
                      };
                      namespaces?: string[];
                      topologyKey: string;
                    }[];
                  };
                  podAntiAffinity?: {
                    preferredDuringSchedulingIgnoredDuringExecution?: {
                      podAffinityTerm: {
                        labelSelector?: {
                          matchExpressions?: {
                            key: string;
                            operator: string;
                            values?: string[];
                          }[];
                          matchLabels?: {
                            [key: string]: unknown;
                          };
                        };
                        matchLabelKeys?: string[];
                        mismatchLabelKeys?: string[];
                        namespaceSelector?: {
                          matchExpressions?: {
                            key: string;
                            operator: string;
                            values?: string[];
                          }[];
                          matchLabels?: {
                            [key: string]: unknown;
                          };
                        };
                        namespaces?: string[];
                        topologyKey: string;
                      };
                      weight: number;
                    }[];
                    requiredDuringSchedulingIgnoredDuringExecution?: {
                      labelSelector?: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchLabels?: {
                          [key: string]: unknown;
                        };
                      };
                      matchLabelKeys?: string[];
                      mismatchLabelKeys?: string[];
                      namespaceSelector?: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchLabels?: {
                          [key: string]: unknown;
                        };
                      };
                      namespaces?: string[];
                      topologyKey: string;
                    }[];
                  };
                };
                imagePullSecrets?: {
                  name?: string;
                }[];
                nodeSelector?: {
                  [key: string]: unknown;
                };
                priorityClassName?: string;
                securityContext?: {
                  fsGroup?: number;
                  fsGroupChangePolicy?: string;
                  runAsGroup?: number;
                  runAsNonRoot?: boolean;
                  runAsUser?: number;
                  seLinuxOptions?: {
                    level?: string;
                    role?: string;
                    type?: string;
                    user?: string;
                  };
                  seccompProfile?: {
                    localhostProfile?: string;
                    type: string;
                  };
                  supplementalGroups?: number[];
                  sysctls?: {
                    name: string;
                    value: string;
                  }[];
                };
                serviceAccountName?: string;
                tolerations?: {
                  effect?: string;
                  key?: string;
                  operator?: string;
                  tolerationSeconds?: number;
                  value?: string;
                }[];
              };
            };
            serviceType?: string;
          };
        };
        selector?: {
          dnsNames?: string[];
          dnsZones?: string[];
          matchLabels?: {
            [key: string]: unknown;
          };
        };
      }[];
    };
    ca?: {
      crlDistributionPoints?: string[];
      issuingCertificateURLs?: string[];
      ocspServers?: string[];
      secretName: string;
    };
    selfSigned?: {
      crlDistributionPoints?: string[];
    };
    vault?: {
      auth: {
        appRole?: {
          path: string;
          roleId: string;
          secretRef: {
            key?: string;
            name: string;
          };
        };
        clientCertificate?: {
          mountPath?: string;
          name?: string;
          secretName?: string;
        };
        kubernetes?: {
          mountPath?: string;
          role: string;
          secretRef?: {
            key?: string;
            name: string;
          };
          serviceAccountRef?: {
            audiences?: string[];
            name: string;
          };
        };
        tokenSecretRef?: {
          key?: string;
          name: string;
        };
      };
      caBundle?: string;
      caBundleSecretRef?: {
        key?: string;
        name: string;
      };
      clientCertSecretRef?: {
        key?: string;
        name: string;
      };
      clientKeySecretRef?: {
        key?: string;
        name: string;
      };
      namespace?: string;
      path: string;
      server: string;
    };
    venafi?: {
      cloud?: {
        apiTokenSecretRef: {
          key?: string;
          name: string;
        };
        url?: string;
      };
      tpp?: {
        caBundle?: string;
        caBundleSecretRef?: {
          key?: string;
          name: string;
        };
        credentialsRef: {
          name: string;
        };
        url: string;
      };
      zone: string;
    };
  };
  status?: {
    acme?: {
      lastPrivateKeyHash?: string;
      lastRegisteredEmail?: string;
      uri?: string;
    };
    conditions?: {
      lastTransitionTime?: string;
      message?: string;
      observedGeneration?: number;
      reason?: string;
      status: "True" | "False" | "Unknown";
      type: string;
    }[];
  };
}
export interface CertManagerIoV1ClusterIssuerList {
  apiVersion?: string;
  items: CertManagerIoV1ClusterIssuer[];
  kind?: string;
  metadata?: ListMeta;
}
export interface CertManagerIoV1Issuer {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec: {
    acme?: {
      caBundle?: string;
      disableAccountKeyGeneration?: boolean;
      email?: string;
      enableDurationFeature?: boolean;
      externalAccountBinding?: {
        keyAlgorithm?: "HS256" | "HS384" | "HS512";
        keyID: string;
        keySecretRef: {
          key?: string;
          name: string;
        };
      };
      preferredChain?: string;
      privateKeySecretRef: {
        key?: string;
        name: string;
      };
      server: string;
      skipTLSVerify?: boolean;
      solvers?: {
        dns01?: {
          acmeDNS?: {
            accountSecretRef: {
              key?: string;
              name: string;
            };
            host: string;
          };
          akamai?: {
            accessTokenSecretRef: {
              key?: string;
              name: string;
            };
            clientSecretSecretRef: {
              key?: string;
              name: string;
            };
            clientTokenSecretRef: {
              key?: string;
              name: string;
            };
            serviceConsumerDomain: string;
          };
          azureDNS?: {
            clientID?: string;
            clientSecretSecretRef?: {
              key?: string;
              name: string;
            };
            environment?: "AzurePublicCloud" | "AzureChinaCloud" | "AzureGermanCloud" | "AzureUSGovernmentCloud";
            hostedZoneName?: string;
            managedIdentity?: {
              clientID?: string;
              resourceID?: string;
              tenantID?: string;
            };
            resourceGroupName: string;
            subscriptionID: string;
            tenantID?: string;
          };
          cloudDNS?: {
            hostedZoneName?: string;
            project: string;
            serviceAccountSecretRef?: {
              key?: string;
              name: string;
            };
          };
          cloudflare?: {
            apiKeySecretRef?: {
              key?: string;
              name: string;
            };
            apiTokenSecretRef?: {
              key?: string;
              name: string;
            };
            email?: string;
          };
          cnameStrategy?: "None" | "Follow";
          digitalocean?: {
            tokenSecretRef: {
              key?: string;
              name: string;
            };
          };
          rfc2136?: {
            nameserver: string;
            tsigAlgorithm?: string;
            tsigKeyName?: string;
            tsigSecretSecretRef?: {
              key?: string;
              name: string;
            };
          };
          route53?: {
            accessKeyID?: string;
            accessKeyIDSecretRef?: {
              key?: string;
              name: string;
            };
            auth?: {
              kubernetes: {
                serviceAccountRef: {
                  audiences?: string[];
                  name: string;
                };
              };
            };
            hostedZoneID?: string;
            region?: string;
            role?: string;
            secretAccessKeySecretRef?: {
              key?: string;
              name: string;
            };
          };
          webhook?: {
            config?: any;
            groupName: string;
            solverName: string;
          };
        };
        http01?: {
          gatewayHTTPRoute?: {
            labels?: {
              [key: string]: unknown;
            };
            parentRefs?: {
              group?: string;
              kind?: string;
              name: string;
              namespace?: string;
              port?: number;
              sectionName?: string;
            }[];
            podTemplate?: {
              metadata?: {
                annotations?: {
                  [key: string]: unknown;
                };
                labels?: {
                  [key: string]: unknown;
                };
              };
              spec?: {
                affinity?: {
                  nodeAffinity?: {
                    preferredDuringSchedulingIgnoredDuringExecution?: {
                      preference: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchFields?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                      };
                      weight: number;
                    }[];
                    requiredDuringSchedulingIgnoredDuringExecution?: {
                      nodeSelectorTerms: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchFields?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                      }[];
                    };
                  };
                  podAffinity?: {
                    preferredDuringSchedulingIgnoredDuringExecution?: {
                      podAffinityTerm: {
                        labelSelector?: {
                          matchExpressions?: {
                            key: string;
                            operator: string;
                            values?: string[];
                          }[];
                          matchLabels?: {
                            [key: string]: unknown;
                          };
                        };
                        matchLabelKeys?: string[];
                        mismatchLabelKeys?: string[];
                        namespaceSelector?: {
                          matchExpressions?: {
                            key: string;
                            operator: string;
                            values?: string[];
                          }[];
                          matchLabels?: {
                            [key: string]: unknown;
                          };
                        };
                        namespaces?: string[];
                        topologyKey: string;
                      };
                      weight: number;
                    }[];
                    requiredDuringSchedulingIgnoredDuringExecution?: {
                      labelSelector?: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchLabels?: {
                          [key: string]: unknown;
                        };
                      };
                      matchLabelKeys?: string[];
                      mismatchLabelKeys?: string[];
                      namespaceSelector?: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchLabels?: {
                          [key: string]: unknown;
                        };
                      };
                      namespaces?: string[];
                      topologyKey: string;
                    }[];
                  };
                  podAntiAffinity?: {
                    preferredDuringSchedulingIgnoredDuringExecution?: {
                      podAffinityTerm: {
                        labelSelector?: {
                          matchExpressions?: {
                            key: string;
                            operator: string;
                            values?: string[];
                          }[];
                          matchLabels?: {
                            [key: string]: unknown;
                          };
                        };
                        matchLabelKeys?: string[];
                        mismatchLabelKeys?: string[];
                        namespaceSelector?: {
                          matchExpressions?: {
                            key: string;
                            operator: string;
                            values?: string[];
                          }[];
                          matchLabels?: {
                            [key: string]: unknown;
                          };
                        };
                        namespaces?: string[];
                        topologyKey: string;
                      };
                      weight: number;
                    }[];
                    requiredDuringSchedulingIgnoredDuringExecution?: {
                      labelSelector?: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchLabels?: {
                          [key: string]: unknown;
                        };
                      };
                      matchLabelKeys?: string[];
                      mismatchLabelKeys?: string[];
                      namespaceSelector?: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchLabels?: {
                          [key: string]: unknown;
                        };
                      };
                      namespaces?: string[];
                      topologyKey: string;
                    }[];
                  };
                };
                imagePullSecrets?: {
                  name?: string;
                }[];
                nodeSelector?: {
                  [key: string]: unknown;
                };
                priorityClassName?: string;
                securityContext?: {
                  fsGroup?: number;
                  fsGroupChangePolicy?: string;
                  runAsGroup?: number;
                  runAsNonRoot?: boolean;
                  runAsUser?: number;
                  seLinuxOptions?: {
                    level?: string;
                    role?: string;
                    type?: string;
                    user?: string;
                  };
                  seccompProfile?: {
                    localhostProfile?: string;
                    type: string;
                  };
                  supplementalGroups?: number[];
                  sysctls?: {
                    name: string;
                    value: string;
                  }[];
                };
                serviceAccountName?: string;
                tolerations?: {
                  effect?: string;
                  key?: string;
                  operator?: string;
                  tolerationSeconds?: number;
                  value?: string;
                }[];
              };
            };
            serviceType?: string;
          };
          ingress?: {
            class?: string;
            ingressClassName?: string;
            ingressTemplate?: {
              metadata?: {
                annotations?: {
                  [key: string]: unknown;
                };
                labels?: {
                  [key: string]: unknown;
                };
              };
            };
            name?: string;
            podTemplate?: {
              metadata?: {
                annotations?: {
                  [key: string]: unknown;
                };
                labels?: {
                  [key: string]: unknown;
                };
              };
              spec?: {
                affinity?: {
                  nodeAffinity?: {
                    preferredDuringSchedulingIgnoredDuringExecution?: {
                      preference: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchFields?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                      };
                      weight: number;
                    }[];
                    requiredDuringSchedulingIgnoredDuringExecution?: {
                      nodeSelectorTerms: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchFields?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                      }[];
                    };
                  };
                  podAffinity?: {
                    preferredDuringSchedulingIgnoredDuringExecution?: {
                      podAffinityTerm: {
                        labelSelector?: {
                          matchExpressions?: {
                            key: string;
                            operator: string;
                            values?: string[];
                          }[];
                          matchLabels?: {
                            [key: string]: unknown;
                          };
                        };
                        matchLabelKeys?: string[];
                        mismatchLabelKeys?: string[];
                        namespaceSelector?: {
                          matchExpressions?: {
                            key: string;
                            operator: string;
                            values?: string[];
                          }[];
                          matchLabels?: {
                            [key: string]: unknown;
                          };
                        };
                        namespaces?: string[];
                        topologyKey: string;
                      };
                      weight: number;
                    }[];
                    requiredDuringSchedulingIgnoredDuringExecution?: {
                      labelSelector?: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchLabels?: {
                          [key: string]: unknown;
                        };
                      };
                      matchLabelKeys?: string[];
                      mismatchLabelKeys?: string[];
                      namespaceSelector?: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchLabels?: {
                          [key: string]: unknown;
                        };
                      };
                      namespaces?: string[];
                      topologyKey: string;
                    }[];
                  };
                  podAntiAffinity?: {
                    preferredDuringSchedulingIgnoredDuringExecution?: {
                      podAffinityTerm: {
                        labelSelector?: {
                          matchExpressions?: {
                            key: string;
                            operator: string;
                            values?: string[];
                          }[];
                          matchLabels?: {
                            [key: string]: unknown;
                          };
                        };
                        matchLabelKeys?: string[];
                        mismatchLabelKeys?: string[];
                        namespaceSelector?: {
                          matchExpressions?: {
                            key: string;
                            operator: string;
                            values?: string[];
                          }[];
                          matchLabels?: {
                            [key: string]: unknown;
                          };
                        };
                        namespaces?: string[];
                        topologyKey: string;
                      };
                      weight: number;
                    }[];
                    requiredDuringSchedulingIgnoredDuringExecution?: {
                      labelSelector?: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchLabels?: {
                          [key: string]: unknown;
                        };
                      };
                      matchLabelKeys?: string[];
                      mismatchLabelKeys?: string[];
                      namespaceSelector?: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchLabels?: {
                          [key: string]: unknown;
                        };
                      };
                      namespaces?: string[];
                      topologyKey: string;
                    }[];
                  };
                };
                imagePullSecrets?: {
                  name?: string;
                }[];
                nodeSelector?: {
                  [key: string]: unknown;
                };
                priorityClassName?: string;
                securityContext?: {
                  fsGroup?: number;
                  fsGroupChangePolicy?: string;
                  runAsGroup?: number;
                  runAsNonRoot?: boolean;
                  runAsUser?: number;
                  seLinuxOptions?: {
                    level?: string;
                    role?: string;
                    type?: string;
                    user?: string;
                  };
                  seccompProfile?: {
                    localhostProfile?: string;
                    type: string;
                  };
                  supplementalGroups?: number[];
                  sysctls?: {
                    name: string;
                    value: string;
                  }[];
                };
                serviceAccountName?: string;
                tolerations?: {
                  effect?: string;
                  key?: string;
                  operator?: string;
                  tolerationSeconds?: number;
                  value?: string;
                }[];
              };
            };
            serviceType?: string;
          };
        };
        selector?: {
          dnsNames?: string[];
          dnsZones?: string[];
          matchLabels?: {
            [key: string]: unknown;
          };
        };
      }[];
    };
    ca?: {
      crlDistributionPoints?: string[];
      issuingCertificateURLs?: string[];
      ocspServers?: string[];
      secretName: string;
    };
    selfSigned?: {
      crlDistributionPoints?: string[];
    };
    vault?: {
      auth: {
        appRole?: {
          path: string;
          roleId: string;
          secretRef: {
            key?: string;
            name: string;
          };
        };
        clientCertificate?: {
          mountPath?: string;
          name?: string;
          secretName?: string;
        };
        kubernetes?: {
          mountPath?: string;
          role: string;
          secretRef?: {
            key?: string;
            name: string;
          };
          serviceAccountRef?: {
            audiences?: string[];
            name: string;
          };
        };
        tokenSecretRef?: {
          key?: string;
          name: string;
        };
      };
      caBundle?: string;
      caBundleSecretRef?: {
        key?: string;
        name: string;
      };
      clientCertSecretRef?: {
        key?: string;
        name: string;
      };
      clientKeySecretRef?: {
        key?: string;
        name: string;
      };
      namespace?: string;
      path: string;
      server: string;
    };
    venafi?: {
      cloud?: {
        apiTokenSecretRef: {
          key?: string;
          name: string;
        };
        url?: string;
      };
      tpp?: {
        caBundle?: string;
        caBundleSecretRef?: {
          key?: string;
          name: string;
        };
        credentialsRef: {
          name: string;
        };
        url: string;
      };
      zone: string;
    };
  };
  status?: {
    acme?: {
      lastPrivateKeyHash?: string;
      lastRegisteredEmail?: string;
      uri?: string;
    };
    conditions?: {
      lastTransitionTime?: string;
      message?: string;
      observedGeneration?: number;
      reason?: string;
      status: "True" | "False" | "Unknown";
      type: string;
    }[];
  };
}
export interface CertManagerIoV1IssuerList {
  apiVersion?: string;
  items: CertManagerIoV1Issuer[];
  kind?: string;
  metadata?: ListMeta;
}
export interface PostgresqlCnpgIoV1Backup {
  apiVersion?: string;
  kind?: string;
  metadata: ObjectMeta;
  spec: {
    cluster: {
      name: string;
    };
    method?: "barmanObjectStore" | "volumeSnapshot" | "plugin";
    online?: boolean;
    onlineConfiguration?: {
      immediateCheckpoint?: boolean;
      waitForArchive?: boolean;
    };
    pluginConfiguration?: {
      name: string;
      parameters?: {
        [key: string]: unknown;
      };
    };
    target?: "primary" | "prefer-standby";
  };
  status?: {
    azureCredentials?: {
      connectionString?: {
        key: string;
        name: string;
      };
      inheritFromAzureAD?: boolean;
      storageAccount?: {
        key: string;
        name: string;
      };
      storageKey?: {
        key: string;
        name: string;
      };
      storageSasToken?: {
        key: string;
        name: string;
      };
    };
    backupId?: string;
    backupLabelFile?: string;
    backupName?: string;
    beginLSN?: string;
    beginWal?: string;
    commandError?: string;
    commandOutput?: string;
    destinationPath?: string;
    encryption?: string;
    endLSN?: string;
    endWal?: string;
    endpointCA?: {
      key: string;
      name: string;
    };
    endpointURL?: string;
    error?: string;
    googleCredentials?: {
      applicationCredentials?: {
        key: string;
        name: string;
      };
      gkeEnvironment?: boolean;
    };
    instanceID?: {
      ContainerID?: string;
      podName?: string;
    };
    method?: string;
    online?: boolean;
    phase?: string;
    pluginMetadata?: {
      [key: string]: unknown;
    };
    s3Credentials?: {
      accessKeyId?: {
        key: string;
        name: string;
      };
      inheritFromIAMRole?: boolean;
      region?: {
        key: string;
        name: string;
      };
      secretAccessKey?: {
        key: string;
        name: string;
      };
      sessionToken?: {
        key: string;
        name: string;
      };
    };
    serverName?: string;
    snapshotBackupStatus?: {
      elements?: {
        name: string;
        tablespaceName?: string;
        type: string;
      }[];
    };
    startedAt?: string;
    stoppedAt?: string;
    tablespaceMapFile?: string;
  };
}
export interface PostgresqlCnpgIoV1BackupList {
  apiVersion?: string;
  items: PostgresqlCnpgIoV1Backup[];
  kind?: string;
  metadata?: ListMeta;
}
export interface PostgresqlCnpgIoV1Cluster {
  apiVersion?: string;
  kind?: string;
  metadata: ObjectMeta;
  spec: {
    affinity?: {
      additionalPodAffinity?: {
        preferredDuringSchedulingIgnoredDuringExecution?: {
          podAffinityTerm: {
            labelSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            matchLabelKeys?: string[];
            mismatchLabelKeys?: string[];
            namespaceSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            namespaces?: string[];
            topologyKey: string;
          };
          weight: number;
        }[];
        requiredDuringSchedulingIgnoredDuringExecution?: {
          labelSelector?: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchLabels?: {
              [key: string]: unknown;
            };
          };
          matchLabelKeys?: string[];
          mismatchLabelKeys?: string[];
          namespaceSelector?: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchLabels?: {
              [key: string]: unknown;
            };
          };
          namespaces?: string[];
          topologyKey: string;
        }[];
      };
      additionalPodAntiAffinity?: {
        preferredDuringSchedulingIgnoredDuringExecution?: {
          podAffinityTerm: {
            labelSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            matchLabelKeys?: string[];
            mismatchLabelKeys?: string[];
            namespaceSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            namespaces?: string[];
            topologyKey: string;
          };
          weight: number;
        }[];
        requiredDuringSchedulingIgnoredDuringExecution?: {
          labelSelector?: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchLabels?: {
              [key: string]: unknown;
            };
          };
          matchLabelKeys?: string[];
          mismatchLabelKeys?: string[];
          namespaceSelector?: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchLabels?: {
              [key: string]: unknown;
            };
          };
          namespaces?: string[];
          topologyKey: string;
        }[];
      };
      enablePodAntiAffinity?: boolean;
      nodeAffinity?: {
        preferredDuringSchedulingIgnoredDuringExecution?: {
          preference: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchFields?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
          };
          weight: number;
        }[];
        requiredDuringSchedulingIgnoredDuringExecution?: {
          nodeSelectorTerms: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchFields?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
          }[];
        };
      };
      nodeSelector?: {
        [key: string]: unknown;
      };
      podAntiAffinityType?: string;
      tolerations?: {
        effect?: string;
        key?: string;
        operator?: string;
        tolerationSeconds?: number;
        value?: string;
      }[];
      topologyKey?: string;
    };
    backup?: {
      barmanObjectStore?: {
        azureCredentials?: {
          connectionString?: {
            key: string;
            name: string;
          };
          inheritFromAzureAD?: boolean;
          storageAccount?: {
            key: string;
            name: string;
          };
          storageKey?: {
            key: string;
            name: string;
          };
          storageSasToken?: {
            key: string;
            name: string;
          };
        };
        data?: {
          additionalCommandArgs?: string[];
          compression?: "bzip2" | "gzip" | "snappy";
          encryption?: "AES256" | "aws:kms";
          immediateCheckpoint?: boolean;
          jobs?: number;
        };
        destinationPath: string;
        endpointCA?: {
          key: string;
          name: string;
        };
        endpointURL?: string;
        googleCredentials?: {
          applicationCredentials?: {
            key: string;
            name: string;
          };
          gkeEnvironment?: boolean;
        };
        historyTags?: {
          [key: string]: unknown;
        };
        s3Credentials?: {
          accessKeyId?: {
            key: string;
            name: string;
          };
          inheritFromIAMRole?: boolean;
          region?: {
            key: string;
            name: string;
          };
          secretAccessKey?: {
            key: string;
            name: string;
          };
          sessionToken?: {
            key: string;
            name: string;
          };
        };
        serverName?: string;
        tags?: {
          [key: string]: unknown;
        };
        wal?: {
          archiveAdditionalCommandArgs?: string[];
          compression?: "bzip2" | "gzip" | "lz4" | "snappy" | "xz" | "zstd";
          encryption?: "AES256" | "aws:kms";
          maxParallel?: number;
          restoreAdditionalCommandArgs?: string[];
        };
      };
      retentionPolicy?: string;
      target?: "primary" | "prefer-standby";
      volumeSnapshot?: {
        annotations?: {
          [key: string]: unknown;
        };
        className?: string;
        labels?: {
          [key: string]: unknown;
        };
        online?: boolean;
        onlineConfiguration?: {
          immediateCheckpoint?: boolean;
          waitForArchive?: boolean;
        };
        snapshotOwnerReference?: "none" | "cluster" | "backup";
        tablespaceClassName?: {
          [key: string]: unknown;
        };
        walClassName?: string;
      };
    };
    bootstrap?: {
      initdb?: {
        builtinLocale?: string;
        dataChecksums?: boolean;
        database?: string;
        encoding?: string;
        icuLocale?: string;
        icuRules?: string;
        import?: {
          databases: string[];
          pgDumpExtraOptions?: string[];
          pgRestoreExtraOptions?: string[];
          postImportApplicationSQL?: string[];
          roles?: string[];
          schemaOnly?: boolean;
          source: {
            externalCluster: string;
          };
          type: "microservice" | "monolith";
        };
        locale?: string;
        localeCType?: string;
        localeCollate?: string;
        localeProvider?: string;
        options?: string[];
        owner?: string;
        postInitApplicationSQL?: string[];
        postInitApplicationSQLRefs?: {
          configMapRefs?: {
            key: string;
            name: string;
          }[];
          secretRefs?: {
            key: string;
            name: string;
          }[];
        };
        postInitSQL?: string[];
        postInitSQLRefs?: {
          configMapRefs?: {
            key: string;
            name: string;
          }[];
          secretRefs?: {
            key: string;
            name: string;
          }[];
        };
        postInitTemplateSQL?: string[];
        postInitTemplateSQLRefs?: {
          configMapRefs?: {
            key: string;
            name: string;
          }[];
          secretRefs?: {
            key: string;
            name: string;
          }[];
        };
        secret?: {
          name: string;
        };
        walSegmentSize?: number;
      };
      pg_basebackup?: {
        database?: string;
        owner?: string;
        secret?: {
          name: string;
        };
        source: string;
      };
      recovery?: {
        backup?: {
          endpointCA?: {
            key: string;
            name: string;
          };
          name: string;
        };
        database?: string;
        owner?: string;
        recoveryTarget?: {
          backupID?: string;
          exclusive?: boolean;
          targetImmediate?: boolean;
          targetLSN?: string;
          targetName?: string;
          targetTLI?: string;
          targetTime?: string;
          targetXID?: string;
        };
        secret?: {
          name: string;
        };
        source?: string;
        volumeSnapshots?: {
          storage: {
            apiGroup?: string;
            kind: string;
            name: string;
          };
          tablespaceStorage?: {
            [key: string]: unknown;
          };
          walStorage?: {
            apiGroup?: string;
            kind: string;
            name: string;
          };
        };
      };
    };
    certificates?: {
      clientCASecret?: string;
      replicationTLSSecret?: string;
      serverAltDNSNames?: string[];
      serverCASecret?: string;
      serverTLSSecret?: string;
    };
    description?: string;
    enablePDB?: boolean;
    enableSuperuserAccess?: boolean;
    env?: {
      name: string;
      value?: string;
      valueFrom?: {
        configMapKeyRef?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        fieldRef?: {
          apiVersion?: string;
          fieldPath: string;
        };
        resourceFieldRef?: {
          containerName?: string;
          divisor?: any;
          resource: string;
        };
        secretKeyRef?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
    }[];
    envFrom?: {
      configMapRef?: {
        name?: string;
        optional?: boolean;
      };
      prefix?: string;
      secretRef?: {
        name?: string;
        optional?: boolean;
      };
    }[];
    ephemeralVolumeSource?: {
      volumeClaimTemplate?: {
        metadata?: {
          [key: string]: unknown;
        };
        spec: {
          accessModes?: string[];
          dataSource?: {
            apiGroup?: string;
            kind: string;
            name: string;
          };
          dataSourceRef?: {
            apiGroup?: string;
            kind: string;
            name: string;
            namespace?: string;
          };
          resources?: {
            limits?: {
              [key: string]: unknown;
            };
            requests?: {
              [key: string]: unknown;
            };
          };
          selector?: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchLabels?: {
              [key: string]: unknown;
            };
          };
          storageClassName?: string;
          volumeAttributesClassName?: string;
          volumeMode?: string;
          volumeName?: string;
        };
      };
    };
    ephemeralVolumesSizeLimit?: {
      shm?: any;
      temporaryData?: any;
    };
    externalClusters?: {
      barmanObjectStore?: {
        azureCredentials?: {
          connectionString?: {
            key: string;
            name: string;
          };
          inheritFromAzureAD?: boolean;
          storageAccount?: {
            key: string;
            name: string;
          };
          storageKey?: {
            key: string;
            name: string;
          };
          storageSasToken?: {
            key: string;
            name: string;
          };
        };
        data?: {
          additionalCommandArgs?: string[];
          compression?: "bzip2" | "gzip" | "snappy";
          encryption?: "AES256" | "aws:kms";
          immediateCheckpoint?: boolean;
          jobs?: number;
        };
        destinationPath: string;
        endpointCA?: {
          key: string;
          name: string;
        };
        endpointURL?: string;
        googleCredentials?: {
          applicationCredentials?: {
            key: string;
            name: string;
          };
          gkeEnvironment?: boolean;
        };
        historyTags?: {
          [key: string]: unknown;
        };
        s3Credentials?: {
          accessKeyId?: {
            key: string;
            name: string;
          };
          inheritFromIAMRole?: boolean;
          region?: {
            key: string;
            name: string;
          };
          secretAccessKey?: {
            key: string;
            name: string;
          };
          sessionToken?: {
            key: string;
            name: string;
          };
        };
        serverName?: string;
        tags?: {
          [key: string]: unknown;
        };
        wal?: {
          archiveAdditionalCommandArgs?: string[];
          compression?: "bzip2" | "gzip" | "lz4" | "snappy" | "xz" | "zstd";
          encryption?: "AES256" | "aws:kms";
          maxParallel?: number;
          restoreAdditionalCommandArgs?: string[];
        };
      };
      connectionParameters?: {
        [key: string]: unknown;
      };
      name: string;
      password?: {
        key: string;
        name?: string;
        optional?: boolean;
      };
      plugin?: {
        enabled?: boolean;
        isWALArchiver?: boolean;
        name: string;
        parameters?: {
          [key: string]: unknown;
        };
      };
      sslCert?: {
        key: string;
        name?: string;
        optional?: boolean;
      };
      sslKey?: {
        key: string;
        name?: string;
        optional?: boolean;
      };
      sslRootCert?: {
        key: string;
        name?: string;
        optional?: boolean;
      };
    }[];
    failoverDelay?: number;
    imageCatalogRef?: {
      apiGroup?: string;
      kind: string;
      major: number;
      name: string;
    };
    imageName?: string;
    imagePullPolicy?: string;
    imagePullSecrets?: {
      name: string;
    }[];
    inheritedMetadata?: {
      annotations?: {
        [key: string]: unknown;
      };
      labels?: {
        [key: string]: unknown;
      };
    };
    instances: number;
    livenessProbeTimeout?: number;
    logLevel?: "error" | "warning" | "info" | "debug" | "trace";
    managed?: {
      roles?: {
        bypassrls?: boolean;
        comment?: string;
        connectionLimit?: number;
        createdb?: boolean;
        createrole?: boolean;
        disablePassword?: boolean;
        ensure?: "present" | "absent";
        inRoles?: string[];
        inherit?: boolean;
        login?: boolean;
        name: string;
        passwordSecret?: {
          name: string;
        };
        replication?: boolean;
        superuser?: boolean;
        validUntil?: string;
      }[];
      services?: {
        additional?: {
          selectorType: "rw" | "r" | "ro";
          serviceTemplate: {
            metadata?: {
              annotations?: {
                [key: string]: unknown;
              };
              labels?: {
                [key: string]: unknown;
              };
              name?: string;
            };
            spec?: {
              allocateLoadBalancerNodePorts?: boolean;
              clusterIP?: string;
              clusterIPs?: string[];
              externalIPs?: string[];
              externalName?: string;
              externalTrafficPolicy?: string;
              healthCheckNodePort?: number;
              internalTrafficPolicy?: string;
              ipFamilies?: string[];
              ipFamilyPolicy?: string;
              loadBalancerClass?: string;
              loadBalancerIP?: string;
              loadBalancerSourceRanges?: string[];
              ports?: {
                appProtocol?: string;
                name?: string;
                nodePort?: number;
                port: number;
                protocol?: string;
                targetPort?: any;
              }[];
              publishNotReadyAddresses?: boolean;
              selector?: {
                [key: string]: unknown;
              };
              sessionAffinity?: string;
              sessionAffinityConfig?: {
                clientIP?: {
                  timeoutSeconds?: number;
                };
              };
              trafficDistribution?: string;
              type?: string;
            };
          };
          updateStrategy?: "patch" | "replace";
        }[];
        disabledDefaultServices?: ("rw" | "r" | "ro")[];
      };
    };
    maxSyncReplicas?: number;
    minSyncReplicas?: number;
    monitoring?: {
      customQueriesConfigMap?: {
        key: string;
        name: string;
      }[];
      customQueriesSecret?: {
        key: string;
        name: string;
      }[];
      disableDefaultQueries?: boolean;
      enablePodMonitor?: boolean;
      podMonitorMetricRelabelings?: {
        action?: "replace" | "Replace" | "keep" | "Keep" | "drop" | "Drop" | "hashmod" | "HashMod" | "labelmap" | "LabelMap" | "labeldrop" | "LabelDrop" | "labelkeep" | "LabelKeep" | "lowercase" | "Lowercase" | "uppercase" | "Uppercase" | "keepequal" | "KeepEqual" | "dropequal" | "DropEqual";
        modulus?: number;
        regex?: string;
        replacement?: string;
        separator?: string;
        sourceLabels?: string[];
        targetLabel?: string;
      }[];
      podMonitorRelabelings?: {
        action?: "replace" | "Replace" | "keep" | "Keep" | "drop" | "Drop" | "hashmod" | "HashMod" | "labelmap" | "LabelMap" | "labeldrop" | "LabelDrop" | "labelkeep" | "LabelKeep" | "lowercase" | "Lowercase" | "uppercase" | "Uppercase" | "keepequal" | "KeepEqual" | "dropequal" | "DropEqual";
        modulus?: number;
        regex?: string;
        replacement?: string;
        separator?: string;
        sourceLabels?: string[];
        targetLabel?: string;
      }[];
      tls?: {
        enabled?: boolean;
      };
    };
    nodeMaintenanceWindow?: {
      inProgress?: boolean;
      reusePVC?: boolean;
    };
    plugins?: {
      enabled?: boolean;
      isWALArchiver?: boolean;
      name: string;
      parameters?: {
        [key: string]: unknown;
      };
    }[];
    postgresGID?: number;
    postgresUID?: number;
    postgresql?: {
      enableAlterSystem?: boolean;
      ldap?: {
        bindAsAuth?: {
          prefix?: string;
          suffix?: string;
        };
        bindSearchAuth?: {
          baseDN?: string;
          bindDN?: string;
          bindPassword?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          searchAttribute?: string;
          searchFilter?: string;
        };
        port?: number;
        scheme?: "ldap" | "ldaps";
        server?: string;
        tls?: boolean;
      };
      parameters?: {
        [key: string]: unknown;
      };
      pg_hba?: string[];
      pg_ident?: string[];
      promotionTimeout?: number;
      shared_preload_libraries?: string[];
      syncReplicaElectionConstraint?: {
        enabled: boolean;
        nodeLabelsAntiAffinity?: string[];
      };
      synchronous?: {
        dataDurability?: "required" | "preferred";
        maxStandbyNamesFromCluster?: number;
        method: "any" | "first";
        number: number;
        standbyNamesPost?: string[];
        standbyNamesPre?: string[];
      };
    };
    primaryUpdateMethod?: "switchover" | "restart";
    primaryUpdateStrategy?: "unsupervised" | "supervised";
    priorityClassName?: string;
    probes?: {
      liveness?: {
        failureThreshold?: number;
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        terminationGracePeriodSeconds?: number;
        timeoutSeconds?: number;
      };
      readiness?: {
        failureThreshold?: number;
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        terminationGracePeriodSeconds?: number;
        timeoutSeconds?: number;
      };
      startup?: {
        failureThreshold?: number;
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        terminationGracePeriodSeconds?: number;
        timeoutSeconds?: number;
      };
    };
    projectedVolumeTemplate?: {
      defaultMode?: number;
      sources?: {
        clusterTrustBundle?: {
          labelSelector?: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchLabels?: {
              [key: string]: unknown;
            };
          };
          name?: string;
          optional?: boolean;
          path: string;
          signerName?: string;
        };
        configMap?: {
          items?: {
            key: string;
            mode?: number;
            path: string;
          }[];
          name?: string;
          optional?: boolean;
        };
        downwardAPI?: {
          items?: {
            fieldRef?: {
              apiVersion?: string;
              fieldPath: string;
            };
            mode?: number;
            path: string;
            resourceFieldRef?: {
              containerName?: string;
              divisor?: any;
              resource: string;
            };
          }[];
        };
        secret?: {
          items?: {
            key: string;
            mode?: number;
            path: string;
          }[];
          name?: string;
          optional?: boolean;
        };
        serviceAccountToken?: {
          audience?: string;
          expirationSeconds?: number;
          path: string;
        };
      }[];
    };
    replica?: {
      enabled?: boolean;
      minApplyDelay?: string;
      primary?: string;
      promotionToken?: string;
      self?: string;
      source: string;
    };
    replicationSlots?: {
      highAvailability?: {
        enabled?: boolean;
        slotPrefix?: string;
      };
      synchronizeReplicas?: {
        enabled: boolean;
        excludePatterns?: string[];
      };
      updateInterval?: number;
    };
    resources?: {
      claims?: {
        name: string;
        request?: string;
      }[];
      limits?: {
        [key: string]: unknown;
      };
      requests?: {
        [key: string]: unknown;
      };
    };
    schedulerName?: string;
    seccompProfile?: {
      localhostProfile?: string;
      type: string;
    };
    serviceAccountTemplate?: {
      metadata: {
        annotations?: {
          [key: string]: unknown;
        };
        labels?: {
          [key: string]: unknown;
        };
        name?: string;
      };
    };
    smartShutdownTimeout?: number;
    startDelay?: number;
    stopDelay?: number;
    storage?: {
      pvcTemplate?: {
        accessModes?: string[];
        dataSource?: {
          apiGroup?: string;
          kind: string;
          name: string;
        };
        dataSourceRef?: {
          apiGroup?: string;
          kind: string;
          name: string;
          namespace?: string;
        };
        resources?: {
          limits?: {
            [key: string]: unknown;
          };
          requests?: {
            [key: string]: unknown;
          };
        };
        selector?: {
          matchExpressions?: {
            key: string;
            operator: string;
            values?: string[];
          }[];
          matchLabels?: {
            [key: string]: unknown;
          };
        };
        storageClassName?: string;
        volumeAttributesClassName?: string;
        volumeMode?: string;
        volumeName?: string;
      };
      resizeInUseVolumes?: boolean;
      size?: string;
      storageClass?: string;
    };
    superuserSecret?: {
      name: string;
    };
    switchoverDelay?: number;
    tablespaces?: {
      name: string;
      owner?: {
        name?: string;
      };
      storage: {
        pvcTemplate?: {
          accessModes?: string[];
          dataSource?: {
            apiGroup?: string;
            kind: string;
            name: string;
          };
          dataSourceRef?: {
            apiGroup?: string;
            kind: string;
            name: string;
            namespace?: string;
          };
          resources?: {
            limits?: {
              [key: string]: unknown;
            };
            requests?: {
              [key: string]: unknown;
            };
          };
          selector?: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchLabels?: {
              [key: string]: unknown;
            };
          };
          storageClassName?: string;
          volumeAttributesClassName?: string;
          volumeMode?: string;
          volumeName?: string;
        };
        resizeInUseVolumes?: boolean;
        size?: string;
        storageClass?: string;
      };
      temporary?: boolean;
    }[];
    topologySpreadConstraints?: {
      labelSelector?: {
        matchExpressions?: {
          key: string;
          operator: string;
          values?: string[];
        }[];
        matchLabels?: {
          [key: string]: unknown;
        };
      };
      matchLabelKeys?: string[];
      maxSkew: number;
      minDomains?: number;
      nodeAffinityPolicy?: string;
      nodeTaintsPolicy?: string;
      topologyKey: string;
      whenUnsatisfiable: string;
    }[];
    walStorage?: {
      pvcTemplate?: {
        accessModes?: string[];
        dataSource?: {
          apiGroup?: string;
          kind: string;
          name: string;
        };
        dataSourceRef?: {
          apiGroup?: string;
          kind: string;
          name: string;
          namespace?: string;
        };
        resources?: {
          limits?: {
            [key: string]: unknown;
          };
          requests?: {
            [key: string]: unknown;
          };
        };
        selector?: {
          matchExpressions?: {
            key: string;
            operator: string;
            values?: string[];
          }[];
          matchLabels?: {
            [key: string]: unknown;
          };
        };
        storageClassName?: string;
        volumeAttributesClassName?: string;
        volumeMode?: string;
        volumeName?: string;
      };
      resizeInUseVolumes?: boolean;
      size?: string;
      storageClass?: string;
    };
  };
  status?: {
    availableArchitectures?: {
      goArch: string;
      hash: string;
    }[];
    azurePVCUpdateEnabled?: boolean;
    certificates?: {
      clientCASecret?: string;
      expirations?: {
        [key: string]: unknown;
      };
      replicationTLSSecret?: string;
      serverAltDNSNames?: string[];
      serverCASecret?: string;
      serverTLSSecret?: string;
    };
    cloudNativePGCommitHash?: string;
    cloudNativePGOperatorHash?: string;
    conditions?: {
      lastTransitionTime: string;
      message: string;
      observedGeneration?: number;
      reason: string;
      status: "True" | "False" | "Unknown";
      type: string;
    }[];
    configMapResourceVersion?: {
      metrics?: {
        [key: string]: unknown;
      };
    };
    currentPrimary?: string;
    currentPrimaryFailingSinceTimestamp?: string;
    currentPrimaryTimestamp?: string;
    danglingPVC?: string[];
    demotionToken?: string;
    firstRecoverabilityPoint?: string;
    firstRecoverabilityPointByMethod?: {
      [key: string]: unknown;
    };
    healthyPVC?: string[];
    image?: string;
    initializingPVC?: string[];
    instanceNames?: string[];
    instances?: number;
    instancesReportedState?: {
      [key: string]: unknown;
    };
    instancesStatus?: {
      [key: string]: unknown;
    };
    jobCount?: number;
    lastFailedBackup?: string;
    lastPromotionToken?: string;
    lastSuccessfulBackup?: string;
    lastSuccessfulBackupByMethod?: {
      [key: string]: unknown;
    };
    latestGeneratedNode?: number;
    managedRolesStatus?: {
      byStatus?: {
        [key: string]: unknown;
      };
      cannotReconcile?: {
        [key: string]: unknown;
      };
      passwordStatus?: {
        [key: string]: unknown;
      };
    };
    onlineUpdateEnabled?: boolean;
    phase?: string;
    phaseReason?: string;
    pluginStatus?: {
      backupCapabilities?: string[];
      capabilities?: string[];
      name: string;
      operatorCapabilities?: string[];
      restoreJobHookCapabilities?: string[];
      status?: string;
      version: string;
      walCapabilities?: string[];
    }[];
    poolerIntegrations?: {
      pgBouncerIntegration?: {
        secrets?: string[];
      };
    };
    pvcCount?: number;
    readService?: string;
    readyInstances?: number;
    resizingPVC?: string[];
    secretsResourceVersion?: {
      applicationSecretVersion?: string;
      barmanEndpointCA?: string;
      caSecretVersion?: string;
      clientCaSecretVersion?: string;
      externalClusterSecretVersion?: {
        [key: string]: unknown;
      };
      managedRoleSecretVersion?: {
        [key: string]: unknown;
      };
      metrics?: {
        [key: string]: unknown;
      };
      replicationSecretVersion?: string;
      serverCaSecretVersion?: string;
      serverSecretVersion?: string;
      superuserSecretVersion?: string;
    };
    switchReplicaClusterStatus?: {
      inProgress?: boolean;
    };
    tablespacesStatus?: {
      error?: string;
      name: string;
      owner?: string;
      state: string;
    }[];
    targetPrimary?: string;
    targetPrimaryTimestamp?: string;
    timelineID?: number;
    topology?: {
      instances?: {
        [key: string]: unknown;
      };
      nodesUsed?: number;
      successfullyExtracted?: boolean;
    };
    unusablePVC?: string[];
    writeService?: string;
  };
}
export interface PostgresqlCnpgIoV1ClusterImageCatalog {
  apiVersion?: string;
  kind?: string;
  metadata: ObjectMeta;
  spec: {
    images: {
      image: string;
      major: number;
    }[];
  };
}
export interface PostgresqlCnpgIoV1ClusterImageCatalogList {
  apiVersion?: string;
  items: PostgresqlCnpgIoV1ClusterImageCatalog[];
  kind?: string;
  metadata?: ListMeta;
}
export interface PostgresqlCnpgIoV1ClusterList {
  apiVersion?: string;
  items: PostgresqlCnpgIoV1Cluster[];
  kind?: string;
  metadata?: ListMeta;
}
export interface PostgresqlCnpgIoV1Database {
  apiVersion?: string;
  kind?: string;
  metadata: ObjectMeta;
  spec: {
    allowConnections?: boolean;
    builtinLocale?: string;
    cluster: {
      name?: string;
    };
    collationVersion?: string;
    connectionLimit?: number;
    databaseReclaimPolicy?: "delete" | "retain";
    encoding?: string;
    ensure?: "present" | "absent";
    icuLocale?: string;
    icuRules?: string;
    isTemplate?: boolean;
    locale?: string;
    localeCType?: string;
    localeCollate?: string;
    localeProvider?: string;
    name: string;
    owner: string;
    tablespace?: string;
    template?: string;
  };
  status?: {
    applied?: boolean;
    message?: string;
    observedGeneration?: number;
  };
}
export interface PostgresqlCnpgIoV1DatabaseList {
  apiVersion?: string;
  items: PostgresqlCnpgIoV1Database[];
  kind?: string;
  metadata?: ListMeta;
}
export interface PostgresqlCnpgIoV1ImageCatalog {
  apiVersion?: string;
  kind?: string;
  metadata: ObjectMeta;
  spec: {
    images: {
      image: string;
      major: number;
    }[];
  };
}
export interface PostgresqlCnpgIoV1ImageCatalogList {
  apiVersion?: string;
  items: PostgresqlCnpgIoV1ImageCatalog[];
  kind?: string;
  metadata?: ListMeta;
}
export interface PostgresqlCnpgIoV1Pooler {
  apiVersion?: string;
  kind?: string;
  metadata: ObjectMeta;
  spec: {
    cluster: {
      name: string;
    };
    deploymentStrategy?: {
      rollingUpdate?: {
        maxSurge?: any;
        maxUnavailable?: any;
      };
      type?: string;
    };
    instances?: number;
    monitoring?: {
      enablePodMonitor?: boolean;
      podMonitorMetricRelabelings?: {
        action?: "replace" | "Replace" | "keep" | "Keep" | "drop" | "Drop" | "hashmod" | "HashMod" | "labelmap" | "LabelMap" | "labeldrop" | "LabelDrop" | "labelkeep" | "LabelKeep" | "lowercase" | "Lowercase" | "uppercase" | "Uppercase" | "keepequal" | "KeepEqual" | "dropequal" | "DropEqual";
        modulus?: number;
        regex?: string;
        replacement?: string;
        separator?: string;
        sourceLabels?: string[];
        targetLabel?: string;
      }[];
      podMonitorRelabelings?: {
        action?: "replace" | "Replace" | "keep" | "Keep" | "drop" | "Drop" | "hashmod" | "HashMod" | "labelmap" | "LabelMap" | "labeldrop" | "LabelDrop" | "labelkeep" | "LabelKeep" | "lowercase" | "Lowercase" | "uppercase" | "Uppercase" | "keepequal" | "KeepEqual" | "dropequal" | "DropEqual";
        modulus?: number;
        regex?: string;
        replacement?: string;
        separator?: string;
        sourceLabels?: string[];
        targetLabel?: string;
      }[];
    };
    pgbouncer: {
      authQuery?: string;
      authQuerySecret?: {
        name: string;
      };
      parameters?: {
        [key: string]: unknown;
      };
      paused?: boolean;
      pg_hba?: string[];
      poolMode?: "session" | "transaction";
    };
    serviceTemplate?: {
      metadata?: {
        annotations?: {
          [key: string]: unknown;
        };
        labels?: {
          [key: string]: unknown;
        };
        name?: string;
      };
      spec?: {
        allocateLoadBalancerNodePorts?: boolean;
        clusterIP?: string;
        clusterIPs?: string[];
        externalIPs?: string[];
        externalName?: string;
        externalTrafficPolicy?: string;
        healthCheckNodePort?: number;
        internalTrafficPolicy?: string;
        ipFamilies?: string[];
        ipFamilyPolicy?: string;
        loadBalancerClass?: string;
        loadBalancerIP?: string;
        loadBalancerSourceRanges?: string[];
        ports?: {
          appProtocol?: string;
          name?: string;
          nodePort?: number;
          port: number;
          protocol?: string;
          targetPort?: any;
        }[];
        publishNotReadyAddresses?: boolean;
        selector?: {
          [key: string]: unknown;
        };
        sessionAffinity?: string;
        sessionAffinityConfig?: {
          clientIP?: {
            timeoutSeconds?: number;
          };
        };
        trafficDistribution?: string;
        type?: string;
      };
    };
    template?: {
      metadata?: {
        annotations?: {
          [key: string]: unknown;
        };
        labels?: {
          [key: string]: unknown;
        };
        name?: string;
      };
      spec?: {
        activeDeadlineSeconds?: number;
        affinity?: {
          nodeAffinity?: {
            preferredDuringSchedulingIgnoredDuringExecution?: {
              preference: {
                matchExpressions?: {
                  key: string;
                  operator: string;
                  values?: string[];
                }[];
                matchFields?: {
                  key: string;
                  operator: string;
                  values?: string[];
                }[];
              };
              weight: number;
            }[];
            requiredDuringSchedulingIgnoredDuringExecution?: {
              nodeSelectorTerms: {
                matchExpressions?: {
                  key: string;
                  operator: string;
                  values?: string[];
                }[];
                matchFields?: {
                  key: string;
                  operator: string;
                  values?: string[];
                }[];
              }[];
            };
          };
          podAffinity?: {
            preferredDuringSchedulingIgnoredDuringExecution?: {
              podAffinityTerm: {
                labelSelector?: {
                  matchExpressions?: {
                    key: string;
                    operator: string;
                    values?: string[];
                  }[];
                  matchLabels?: {
                    [key: string]: unknown;
                  };
                };
                matchLabelKeys?: string[];
                mismatchLabelKeys?: string[];
                namespaceSelector?: {
                  matchExpressions?: {
                    key: string;
                    operator: string;
                    values?: string[];
                  }[];
                  matchLabels?: {
                    [key: string]: unknown;
                  };
                };
                namespaces?: string[];
                topologyKey: string;
              };
              weight: number;
            }[];
            requiredDuringSchedulingIgnoredDuringExecution?: {
              labelSelector?: {
                matchExpressions?: {
                  key: string;
                  operator: string;
                  values?: string[];
                }[];
                matchLabels?: {
                  [key: string]: unknown;
                };
              };
              matchLabelKeys?: string[];
              mismatchLabelKeys?: string[];
              namespaceSelector?: {
                matchExpressions?: {
                  key: string;
                  operator: string;
                  values?: string[];
                }[];
                matchLabels?: {
                  [key: string]: unknown;
                };
              };
              namespaces?: string[];
              topologyKey: string;
            }[];
          };
          podAntiAffinity?: {
            preferredDuringSchedulingIgnoredDuringExecution?: {
              podAffinityTerm: {
                labelSelector?: {
                  matchExpressions?: {
                    key: string;
                    operator: string;
                    values?: string[];
                  }[];
                  matchLabels?: {
                    [key: string]: unknown;
                  };
                };
                matchLabelKeys?: string[];
                mismatchLabelKeys?: string[];
                namespaceSelector?: {
                  matchExpressions?: {
                    key: string;
                    operator: string;
                    values?: string[];
                  }[];
                  matchLabels?: {
                    [key: string]: unknown;
                  };
                };
                namespaces?: string[];
                topologyKey: string;
              };
              weight: number;
            }[];
            requiredDuringSchedulingIgnoredDuringExecution?: {
              labelSelector?: {
                matchExpressions?: {
                  key: string;
                  operator: string;
                  values?: string[];
                }[];
                matchLabels?: {
                  [key: string]: unknown;
                };
              };
              matchLabelKeys?: string[];
              mismatchLabelKeys?: string[];
              namespaceSelector?: {
                matchExpressions?: {
                  key: string;
                  operator: string;
                  values?: string[];
                }[];
                matchLabels?: {
                  [key: string]: unknown;
                };
              };
              namespaces?: string[];
              topologyKey: string;
            }[];
          };
        };
        automountServiceAccountToken?: boolean;
        containers: {
          args?: string[];
          command?: string[];
          env?: {
            name: string;
            value?: string;
            valueFrom?: {
              configMapKeyRef?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              fieldRef?: {
                apiVersion?: string;
                fieldPath: string;
              };
              resourceFieldRef?: {
                containerName?: string;
                divisor?: any;
                resource: string;
              };
              secretKeyRef?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
          }[];
          envFrom?: {
            configMapRef?: {
              name?: string;
              optional?: boolean;
            };
            prefix?: string;
            secretRef?: {
              name?: string;
              optional?: boolean;
            };
          }[];
          image?: string;
          imagePullPolicy?: string;
          lifecycle?: {
            postStart?: {
              exec?: {
                command?: string[];
              };
              httpGet?: {
                host?: string;
                httpHeaders?: {
                  name: string;
                  value: string;
                }[];
                path?: string;
                port: any;
                scheme?: string;
              };
              sleep?: {
                seconds: number;
              };
              tcpSocket?: {
                host?: string;
                port: any;
              };
            };
            preStop?: {
              exec?: {
                command?: string[];
              };
              httpGet?: {
                host?: string;
                httpHeaders?: {
                  name: string;
                  value: string;
                }[];
                path?: string;
                port: any;
                scheme?: string;
              };
              sleep?: {
                seconds: number;
              };
              tcpSocket?: {
                host?: string;
                port: any;
              };
            };
          };
          livenessProbe?: {
            exec?: {
              command?: string[];
            };
            failureThreshold?: number;
            grpc?: {
              port: number;
              service?: string;
            };
            httpGet?: {
              host?: string;
              httpHeaders?: {
                name: string;
                value: string;
              }[];
              path?: string;
              port: any;
              scheme?: string;
            };
            initialDelaySeconds?: number;
            periodSeconds?: number;
            successThreshold?: number;
            tcpSocket?: {
              host?: string;
              port: any;
            };
            terminationGracePeriodSeconds?: number;
            timeoutSeconds?: number;
          };
          name: string;
          ports?: {
            containerPort: number;
            hostIP?: string;
            hostPort?: number;
            name?: string;
            protocol?: string;
          }[];
          readinessProbe?: {
            exec?: {
              command?: string[];
            };
            failureThreshold?: number;
            grpc?: {
              port: number;
              service?: string;
            };
            httpGet?: {
              host?: string;
              httpHeaders?: {
                name: string;
                value: string;
              }[];
              path?: string;
              port: any;
              scheme?: string;
            };
            initialDelaySeconds?: number;
            periodSeconds?: number;
            successThreshold?: number;
            tcpSocket?: {
              host?: string;
              port: any;
            };
            terminationGracePeriodSeconds?: number;
            timeoutSeconds?: number;
          };
          resizePolicy?: {
            resourceName: string;
            restartPolicy: string;
          }[];
          resources?: {
            claims?: {
              name: string;
              request?: string;
            }[];
            limits?: {
              [key: string]: unknown;
            };
            requests?: {
              [key: string]: unknown;
            };
          };
          restartPolicy?: string;
          securityContext?: {
            allowPrivilegeEscalation?: boolean;
            appArmorProfile?: {
              localhostProfile?: string;
              type: string;
            };
            capabilities?: {
              add?: string[];
              drop?: string[];
            };
            privileged?: boolean;
            procMount?: string;
            readOnlyRootFilesystem?: boolean;
            runAsGroup?: number;
            runAsNonRoot?: boolean;
            runAsUser?: number;
            seLinuxOptions?: {
              level?: string;
              role?: string;
              type?: string;
              user?: string;
            };
            seccompProfile?: {
              localhostProfile?: string;
              type: string;
            };
            windowsOptions?: {
              gmsaCredentialSpec?: string;
              gmsaCredentialSpecName?: string;
              hostProcess?: boolean;
              runAsUserName?: string;
            };
          };
          startupProbe?: {
            exec?: {
              command?: string[];
            };
            failureThreshold?: number;
            grpc?: {
              port: number;
              service?: string;
            };
            httpGet?: {
              host?: string;
              httpHeaders?: {
                name: string;
                value: string;
              }[];
              path?: string;
              port: any;
              scheme?: string;
            };
            initialDelaySeconds?: number;
            periodSeconds?: number;
            successThreshold?: number;
            tcpSocket?: {
              host?: string;
              port: any;
            };
            terminationGracePeriodSeconds?: number;
            timeoutSeconds?: number;
          };
          stdin?: boolean;
          stdinOnce?: boolean;
          terminationMessagePath?: string;
          terminationMessagePolicy?: string;
          tty?: boolean;
          volumeDevices?: {
            devicePath: string;
            name: string;
          }[];
          volumeMounts?: {
            mountPath: string;
            mountPropagation?: string;
            name: string;
            readOnly?: boolean;
            recursiveReadOnly?: string;
            subPath?: string;
            subPathExpr?: string;
          }[];
          workingDir?: string;
        }[];
        dnsConfig?: {
          nameservers?: string[];
          options?: {
            name?: string;
            value?: string;
          }[];
          searches?: string[];
        };
        dnsPolicy?: string;
        enableServiceLinks?: boolean;
        ephemeralContainers?: {
          args?: string[];
          command?: string[];
          env?: {
            name: string;
            value?: string;
            valueFrom?: {
              configMapKeyRef?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              fieldRef?: {
                apiVersion?: string;
                fieldPath: string;
              };
              resourceFieldRef?: {
                containerName?: string;
                divisor?: any;
                resource: string;
              };
              secretKeyRef?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
          }[];
          envFrom?: {
            configMapRef?: {
              name?: string;
              optional?: boolean;
            };
            prefix?: string;
            secretRef?: {
              name?: string;
              optional?: boolean;
            };
          }[];
          image?: string;
          imagePullPolicy?: string;
          lifecycle?: {
            postStart?: {
              exec?: {
                command?: string[];
              };
              httpGet?: {
                host?: string;
                httpHeaders?: {
                  name: string;
                  value: string;
                }[];
                path?: string;
                port: any;
                scheme?: string;
              };
              sleep?: {
                seconds: number;
              };
              tcpSocket?: {
                host?: string;
                port: any;
              };
            };
            preStop?: {
              exec?: {
                command?: string[];
              };
              httpGet?: {
                host?: string;
                httpHeaders?: {
                  name: string;
                  value: string;
                }[];
                path?: string;
                port: any;
                scheme?: string;
              };
              sleep?: {
                seconds: number;
              };
              tcpSocket?: {
                host?: string;
                port: any;
              };
            };
          };
          livenessProbe?: {
            exec?: {
              command?: string[];
            };
            failureThreshold?: number;
            grpc?: {
              port: number;
              service?: string;
            };
            httpGet?: {
              host?: string;
              httpHeaders?: {
                name: string;
                value: string;
              }[];
              path?: string;
              port: any;
              scheme?: string;
            };
            initialDelaySeconds?: number;
            periodSeconds?: number;
            successThreshold?: number;
            tcpSocket?: {
              host?: string;
              port: any;
            };
            terminationGracePeriodSeconds?: number;
            timeoutSeconds?: number;
          };
          name: string;
          ports?: {
            containerPort: number;
            hostIP?: string;
            hostPort?: number;
            name?: string;
            protocol?: string;
          }[];
          readinessProbe?: {
            exec?: {
              command?: string[];
            };
            failureThreshold?: number;
            grpc?: {
              port: number;
              service?: string;
            };
            httpGet?: {
              host?: string;
              httpHeaders?: {
                name: string;
                value: string;
              }[];
              path?: string;
              port: any;
              scheme?: string;
            };
            initialDelaySeconds?: number;
            periodSeconds?: number;
            successThreshold?: number;
            tcpSocket?: {
              host?: string;
              port: any;
            };
            terminationGracePeriodSeconds?: number;
            timeoutSeconds?: number;
          };
          resizePolicy?: {
            resourceName: string;
            restartPolicy: string;
          }[];
          resources?: {
            claims?: {
              name: string;
              request?: string;
            }[];
            limits?: {
              [key: string]: unknown;
            };
            requests?: {
              [key: string]: unknown;
            };
          };
          restartPolicy?: string;
          securityContext?: {
            allowPrivilegeEscalation?: boolean;
            appArmorProfile?: {
              localhostProfile?: string;
              type: string;
            };
            capabilities?: {
              add?: string[];
              drop?: string[];
            };
            privileged?: boolean;
            procMount?: string;
            readOnlyRootFilesystem?: boolean;
            runAsGroup?: number;
            runAsNonRoot?: boolean;
            runAsUser?: number;
            seLinuxOptions?: {
              level?: string;
              role?: string;
              type?: string;
              user?: string;
            };
            seccompProfile?: {
              localhostProfile?: string;
              type: string;
            };
            windowsOptions?: {
              gmsaCredentialSpec?: string;
              gmsaCredentialSpecName?: string;
              hostProcess?: boolean;
              runAsUserName?: string;
            };
          };
          startupProbe?: {
            exec?: {
              command?: string[];
            };
            failureThreshold?: number;
            grpc?: {
              port: number;
              service?: string;
            };
            httpGet?: {
              host?: string;
              httpHeaders?: {
                name: string;
                value: string;
              }[];
              path?: string;
              port: any;
              scheme?: string;
            };
            initialDelaySeconds?: number;
            periodSeconds?: number;
            successThreshold?: number;
            tcpSocket?: {
              host?: string;
              port: any;
            };
            terminationGracePeriodSeconds?: number;
            timeoutSeconds?: number;
          };
          stdin?: boolean;
          stdinOnce?: boolean;
          targetContainerName?: string;
          terminationMessagePath?: string;
          terminationMessagePolicy?: string;
          tty?: boolean;
          volumeDevices?: {
            devicePath: string;
            name: string;
          }[];
          volumeMounts?: {
            mountPath: string;
            mountPropagation?: string;
            name: string;
            readOnly?: boolean;
            recursiveReadOnly?: string;
            subPath?: string;
            subPathExpr?: string;
          }[];
          workingDir?: string;
        }[];
        hostAliases?: {
          hostnames?: string[];
          ip: string;
        }[];
        hostIPC?: boolean;
        hostNetwork?: boolean;
        hostPID?: boolean;
        hostUsers?: boolean;
        hostname?: string;
        imagePullSecrets?: {
          name?: string;
        }[];
        initContainers?: {
          args?: string[];
          command?: string[];
          env?: {
            name: string;
            value?: string;
            valueFrom?: {
              configMapKeyRef?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              fieldRef?: {
                apiVersion?: string;
                fieldPath: string;
              };
              resourceFieldRef?: {
                containerName?: string;
                divisor?: any;
                resource: string;
              };
              secretKeyRef?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
          }[];
          envFrom?: {
            configMapRef?: {
              name?: string;
              optional?: boolean;
            };
            prefix?: string;
            secretRef?: {
              name?: string;
              optional?: boolean;
            };
          }[];
          image?: string;
          imagePullPolicy?: string;
          lifecycle?: {
            postStart?: {
              exec?: {
                command?: string[];
              };
              httpGet?: {
                host?: string;
                httpHeaders?: {
                  name: string;
                  value: string;
                }[];
                path?: string;
                port: any;
                scheme?: string;
              };
              sleep?: {
                seconds: number;
              };
              tcpSocket?: {
                host?: string;
                port: any;
              };
            };
            preStop?: {
              exec?: {
                command?: string[];
              };
              httpGet?: {
                host?: string;
                httpHeaders?: {
                  name: string;
                  value: string;
                }[];
                path?: string;
                port: any;
                scheme?: string;
              };
              sleep?: {
                seconds: number;
              };
              tcpSocket?: {
                host?: string;
                port: any;
              };
            };
          };
          livenessProbe?: {
            exec?: {
              command?: string[];
            };
            failureThreshold?: number;
            grpc?: {
              port: number;
              service?: string;
            };
            httpGet?: {
              host?: string;
              httpHeaders?: {
                name: string;
                value: string;
              }[];
              path?: string;
              port: any;
              scheme?: string;
            };
            initialDelaySeconds?: number;
            periodSeconds?: number;
            successThreshold?: number;
            tcpSocket?: {
              host?: string;
              port: any;
            };
            terminationGracePeriodSeconds?: number;
            timeoutSeconds?: number;
          };
          name: string;
          ports?: {
            containerPort: number;
            hostIP?: string;
            hostPort?: number;
            name?: string;
            protocol?: string;
          }[];
          readinessProbe?: {
            exec?: {
              command?: string[];
            };
            failureThreshold?: number;
            grpc?: {
              port: number;
              service?: string;
            };
            httpGet?: {
              host?: string;
              httpHeaders?: {
                name: string;
                value: string;
              }[];
              path?: string;
              port: any;
              scheme?: string;
            };
            initialDelaySeconds?: number;
            periodSeconds?: number;
            successThreshold?: number;
            tcpSocket?: {
              host?: string;
              port: any;
            };
            terminationGracePeriodSeconds?: number;
            timeoutSeconds?: number;
          };
          resizePolicy?: {
            resourceName: string;
            restartPolicy: string;
          }[];
          resources?: {
            claims?: {
              name: string;
              request?: string;
            }[];
            limits?: {
              [key: string]: unknown;
            };
            requests?: {
              [key: string]: unknown;
            };
          };
          restartPolicy?: string;
          securityContext?: {
            allowPrivilegeEscalation?: boolean;
            appArmorProfile?: {
              localhostProfile?: string;
              type: string;
            };
            capabilities?: {
              add?: string[];
              drop?: string[];
            };
            privileged?: boolean;
            procMount?: string;
            readOnlyRootFilesystem?: boolean;
            runAsGroup?: number;
            runAsNonRoot?: boolean;
            runAsUser?: number;
            seLinuxOptions?: {
              level?: string;
              role?: string;
              type?: string;
              user?: string;
            };
            seccompProfile?: {
              localhostProfile?: string;
              type: string;
            };
            windowsOptions?: {
              gmsaCredentialSpec?: string;
              gmsaCredentialSpecName?: string;
              hostProcess?: boolean;
              runAsUserName?: string;
            };
          };
          startupProbe?: {
            exec?: {
              command?: string[];
            };
            failureThreshold?: number;
            grpc?: {
              port: number;
              service?: string;
            };
            httpGet?: {
              host?: string;
              httpHeaders?: {
                name: string;
                value: string;
              }[];
              path?: string;
              port: any;
              scheme?: string;
            };
            initialDelaySeconds?: number;
            periodSeconds?: number;
            successThreshold?: number;
            tcpSocket?: {
              host?: string;
              port: any;
            };
            terminationGracePeriodSeconds?: number;
            timeoutSeconds?: number;
          };
          stdin?: boolean;
          stdinOnce?: boolean;
          terminationMessagePath?: string;
          terminationMessagePolicy?: string;
          tty?: boolean;
          volumeDevices?: {
            devicePath: string;
            name: string;
          }[];
          volumeMounts?: {
            mountPath: string;
            mountPropagation?: string;
            name: string;
            readOnly?: boolean;
            recursiveReadOnly?: string;
            subPath?: string;
            subPathExpr?: string;
          }[];
          workingDir?: string;
        }[];
        nodeName?: string;
        nodeSelector?: {
          [key: string]: unknown;
        };
        os?: {
          name: string;
        };
        overhead?: {
          [key: string]: unknown;
        };
        preemptionPolicy?: string;
        priority?: number;
        priorityClassName?: string;
        readinessGates?: {
          conditionType: string;
        }[];
        resourceClaims?: {
          name: string;
          resourceClaimName?: string;
          resourceClaimTemplateName?: string;
        }[];
        resources?: {
          claims?: {
            name: string;
            request?: string;
          }[];
          limits?: {
            [key: string]: unknown;
          };
          requests?: {
            [key: string]: unknown;
          };
        };
        restartPolicy?: string;
        runtimeClassName?: string;
        schedulerName?: string;
        schedulingGates?: {
          name: string;
        }[];
        securityContext?: {
          appArmorProfile?: {
            localhostProfile?: string;
            type: string;
          };
          fsGroup?: number;
          fsGroupChangePolicy?: string;
          runAsGroup?: number;
          runAsNonRoot?: boolean;
          runAsUser?: number;
          seLinuxChangePolicy?: string;
          seLinuxOptions?: {
            level?: string;
            role?: string;
            type?: string;
            user?: string;
          };
          seccompProfile?: {
            localhostProfile?: string;
            type: string;
          };
          supplementalGroups?: number[];
          supplementalGroupsPolicy?: string;
          sysctls?: {
            name: string;
            value: string;
          }[];
          windowsOptions?: {
            gmsaCredentialSpec?: string;
            gmsaCredentialSpecName?: string;
            hostProcess?: boolean;
            runAsUserName?: string;
          };
        };
        serviceAccount?: string;
        serviceAccountName?: string;
        setHostnameAsFQDN?: boolean;
        shareProcessNamespace?: boolean;
        subdomain?: string;
        terminationGracePeriodSeconds?: number;
        tolerations?: {
          effect?: string;
          key?: string;
          operator?: string;
          tolerationSeconds?: number;
          value?: string;
        }[];
        topologySpreadConstraints?: {
          labelSelector?: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchLabels?: {
              [key: string]: unknown;
            };
          };
          matchLabelKeys?: string[];
          maxSkew: number;
          minDomains?: number;
          nodeAffinityPolicy?: string;
          nodeTaintsPolicy?: string;
          topologyKey: string;
          whenUnsatisfiable: string;
        }[];
        volumes?: {
          awsElasticBlockStore?: {
            fsType?: string;
            partition?: number;
            readOnly?: boolean;
            volumeID: string;
          };
          azureDisk?: {
            cachingMode?: string;
            diskName: string;
            diskURI: string;
            fsType?: string;
            kind?: string;
            readOnly?: boolean;
          };
          azureFile?: {
            readOnly?: boolean;
            secretName: string;
            shareName: string;
          };
          cephfs?: {
            monitors: string[];
            path?: string;
            readOnly?: boolean;
            secretFile?: string;
            secretRef?: {
              name?: string;
            };
            user?: string;
          };
          cinder?: {
            fsType?: string;
            readOnly?: boolean;
            secretRef?: {
              name?: string;
            };
            volumeID: string;
          };
          configMap?: {
            defaultMode?: number;
            items?: {
              key: string;
              mode?: number;
              path: string;
            }[];
            name?: string;
            optional?: boolean;
          };
          csi?: {
            driver: string;
            fsType?: string;
            nodePublishSecretRef?: {
              name?: string;
            };
            readOnly?: boolean;
            volumeAttributes?: {
              [key: string]: unknown;
            };
          };
          downwardAPI?: {
            defaultMode?: number;
            items?: {
              fieldRef?: {
                apiVersion?: string;
                fieldPath: string;
              };
              mode?: number;
              path: string;
              resourceFieldRef?: {
                containerName?: string;
                divisor?: any;
                resource: string;
              };
            }[];
          };
          emptyDir?: {
            medium?: string;
            sizeLimit?: any;
          };
          ephemeral?: {
            volumeClaimTemplate?: {
              metadata?: {
                [key: string]: unknown;
              };
              spec: {
                accessModes?: string[];
                dataSource?: {
                  apiGroup?: string;
                  kind: string;
                  name: string;
                };
                dataSourceRef?: {
                  apiGroup?: string;
                  kind: string;
                  name: string;
                  namespace?: string;
                };
                resources?: {
                  limits?: {
                    [key: string]: unknown;
                  };
                  requests?: {
                    [key: string]: unknown;
                  };
                };
                selector?: {
                  matchExpressions?: {
                    key: string;
                    operator: string;
                    values?: string[];
                  }[];
                  matchLabels?: {
                    [key: string]: unknown;
                  };
                };
                storageClassName?: string;
                volumeAttributesClassName?: string;
                volumeMode?: string;
                volumeName?: string;
              };
            };
          };
          fc?: {
            fsType?: string;
            lun?: number;
            readOnly?: boolean;
            targetWWNs?: string[];
            wwids?: string[];
          };
          flexVolume?: {
            driver: string;
            fsType?: string;
            options?: {
              [key: string]: unknown;
            };
            readOnly?: boolean;
            secretRef?: {
              name?: string;
            };
          };
          flocker?: {
            datasetName?: string;
            datasetUUID?: string;
          };
          gcePersistentDisk?: {
            fsType?: string;
            partition?: number;
            pdName: string;
            readOnly?: boolean;
          };
          gitRepo?: {
            directory?: string;
            repository: string;
            revision?: string;
          };
          glusterfs?: {
            endpoints: string;
            path: string;
            readOnly?: boolean;
          };
          hostPath?: {
            path: string;
            type?: string;
          };
          image?: {
            pullPolicy?: string;
            reference?: string;
          };
          iscsi?: {
            chapAuthDiscovery?: boolean;
            chapAuthSession?: boolean;
            fsType?: string;
            initiatorName?: string;
            iqn: string;
            iscsiInterface?: string;
            lun: number;
            portals?: string[];
            readOnly?: boolean;
            secretRef?: {
              name?: string;
            };
            targetPortal: string;
          };
          name: string;
          nfs?: {
            path: string;
            readOnly?: boolean;
            server: string;
          };
          persistentVolumeClaim?: {
            claimName: string;
            readOnly?: boolean;
          };
          photonPersistentDisk?: {
            fsType?: string;
            pdID: string;
          };
          portworxVolume?: {
            fsType?: string;
            readOnly?: boolean;
            volumeID: string;
          };
          projected?: {
            defaultMode?: number;
            sources?: {
              clusterTrustBundle?: {
                labelSelector?: {
                  matchExpressions?: {
                    key: string;
                    operator: string;
                    values?: string[];
                  }[];
                  matchLabels?: {
                    [key: string]: unknown;
                  };
                };
                name?: string;
                optional?: boolean;
                path: string;
                signerName?: string;
              };
              configMap?: {
                items?: {
                  key: string;
                  mode?: number;
                  path: string;
                }[];
                name?: string;
                optional?: boolean;
              };
              downwardAPI?: {
                items?: {
                  fieldRef?: {
                    apiVersion?: string;
                    fieldPath: string;
                  };
                  mode?: number;
                  path: string;
                  resourceFieldRef?: {
                    containerName?: string;
                    divisor?: any;
                    resource: string;
                  };
                }[];
              };
              secret?: {
                items?: {
                  key: string;
                  mode?: number;
                  path: string;
                }[];
                name?: string;
                optional?: boolean;
              };
              serviceAccountToken?: {
                audience?: string;
                expirationSeconds?: number;
                path: string;
              };
            }[];
          };
          quobyte?: {
            group?: string;
            readOnly?: boolean;
            registry: string;
            tenant?: string;
            user?: string;
            volume: string;
          };
          rbd?: {
            fsType?: string;
            image: string;
            keyring?: string;
            monitors: string[];
            pool?: string;
            readOnly?: boolean;
            secretRef?: {
              name?: string;
            };
            user?: string;
          };
          scaleIO?: {
            fsType?: string;
            gateway: string;
            protectionDomain?: string;
            readOnly?: boolean;
            secretRef: {
              name?: string;
            };
            sslEnabled?: boolean;
            storageMode?: string;
            storagePool?: string;
            system: string;
            volumeName?: string;
          };
          secret?: {
            defaultMode?: number;
            items?: {
              key: string;
              mode?: number;
              path: string;
            }[];
            optional?: boolean;
            secretName?: string;
          };
          storageos?: {
            fsType?: string;
            readOnly?: boolean;
            secretRef?: {
              name?: string;
            };
            volumeName?: string;
            volumeNamespace?: string;
          };
          vsphereVolume?: {
            fsType?: string;
            storagePolicyID?: string;
            storagePolicyName?: string;
            volumePath: string;
          };
        }[];
      };
    };
    type?: "rw" | "ro" | "r";
  };
  status?: {
    instances?: number;
    secrets?: {
      clientCA?: {
        name?: string;
        version?: string;
      };
      pgBouncerSecrets?: {
        authQuery?: {
          name?: string;
          version?: string;
        };
      };
      serverCA?: {
        name?: string;
        version?: string;
      };
      serverTLS?: {
        name?: string;
        version?: string;
      };
    };
  };
}
export interface PostgresqlCnpgIoV1PoolerList {
  apiVersion?: string;
  items: PostgresqlCnpgIoV1Pooler[];
  kind?: string;
  metadata?: ListMeta;
}
export interface PostgresqlCnpgIoV1Publication {
  apiVersion?: string;
  kind?: string;
  metadata: ObjectMeta;
  spec: {
    cluster: {
      name?: string;
    };
    dbname: string;
    name: string;
    parameters?: {
      [key: string]: unknown;
    };
    publicationReclaimPolicy?: "delete" | "retain";
    target: {
      allTables?: boolean;
      objects?: {
        table?: {
          columns?: string[];
          name: string;
          only?: boolean;
          schema?: string;
        };
        tablesInSchema?: string;
      }[];
    };
  };
  status?: {
    applied?: boolean;
    message?: string;
    observedGeneration?: number;
  };
}
export interface PostgresqlCnpgIoV1PublicationList {
  apiVersion?: string;
  items: PostgresqlCnpgIoV1Publication[];
  kind?: string;
  metadata?: ListMeta;
}
export interface PostgresqlCnpgIoV1ScheduledBackup {
  apiVersion?: string;
  kind?: string;
  metadata: ObjectMeta;
  spec: {
    backupOwnerReference?: "none" | "self" | "cluster";
    cluster: {
      name: string;
    };
    immediate?: boolean;
    method?: "barmanObjectStore" | "volumeSnapshot" | "plugin";
    online?: boolean;
    onlineConfiguration?: {
      immediateCheckpoint?: boolean;
      waitForArchive?: boolean;
    };
    pluginConfiguration?: {
      name: string;
      parameters?: {
        [key: string]: unknown;
      };
    };
    schedule: string;
    suspend?: boolean;
    target?: "primary" | "prefer-standby";
  };
  status?: {
    lastCheckTime?: string;
    lastScheduleTime?: string;
    nextScheduleTime?: string;
  };
}
export interface PostgresqlCnpgIoV1ScheduledBackupList {
  apiVersion?: string;
  items: PostgresqlCnpgIoV1ScheduledBackup[];
  kind?: string;
  metadata?: ListMeta;
}
export interface PostgresqlCnpgIoV1Subscription {
  apiVersion?: string;
  kind?: string;
  metadata: ObjectMeta;
  spec: {
    cluster: {
      name?: string;
    };
    dbname: string;
    externalClusterName: string;
    name: string;
    parameters?: {
      [key: string]: unknown;
    };
    publicationDBName?: string;
    publicationName: string;
    subscriptionReclaimPolicy?: "delete" | "retain";
  };
  status?: {
    applied?: boolean;
    message?: string;
    observedGeneration?: number;
  };
}
export interface PostgresqlCnpgIoV1SubscriptionList {
  apiVersion?: string;
  items: PostgresqlCnpgIoV1Subscription[];
  kind?: string;
  metadata?: ListMeta;
}
export interface AuditAnnotation {
  key: string;
  valueExpression: string;
}
export interface ExpressionWarning {
  fieldRef: string;
  warning: string;
}
export interface MatchCondition {
  expression: string;
  name: string;
}
export interface MatchResources {
  excludeResourceRules?: NamedRuleWithOperations[];
  matchPolicy?: "Equivalent" | "Exact";
  namespaceSelector?: LabelSelector;
  objectSelector?: LabelSelector;
  resourceRules?: NamedRuleWithOperations[];
}
export interface MutatingWebhook {
  admissionReviewVersions: string[];
  clientConfig: IoK8sApiAdmissionregistrationV1WebhookClientConfig;
  failurePolicy?: "Fail" | "Ignore";
  matchConditions?: MatchCondition[];
  matchPolicy?: "Equivalent" | "Exact";
  name: string;
  namespaceSelector?: LabelSelector;
  objectSelector?: LabelSelector;
  reinvocationPolicy?: "IfNeeded" | "Never";
  rules?: RuleWithOperations[];
  sideEffects: "None" | "NoneOnDryRun" | "Some" | "Unknown";
  timeoutSeconds?: number;
}
export interface AdmissionregistrationK8sIoV1MutatingWebhookConfiguration {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  webhooks?: MutatingWebhook[];
}
export interface AdmissionregistrationK8sIoV1MutatingWebhookConfigurationList {
  apiVersion?: string;
  items: AdmissionregistrationK8sIoV1MutatingWebhookConfiguration[];
  kind?: string;
  metadata?: ListMeta;
}
export interface NamedRuleWithOperations {
  apiGroups?: string[];
  apiVersions?: string[];
  operations?: ("*" | "CONNECT" | "CREATE" | "DELETE" | "UPDATE")[];
  resourceNames?: string[];
  resources?: string[];
  scope?: string;
}
export interface ParamKind {
  apiVersion?: string;
  kind?: string;
}
export interface ParamRef {
  name?: string;
  namespace?: string;
  parameterNotFoundAction?: string;
  selector?: LabelSelector;
}
export interface RuleWithOperations {
  apiGroups?: string[];
  apiVersions?: string[];
  operations?: ("*" | "CONNECT" | "CREATE" | "DELETE" | "UPDATE")[];
  resources?: string[];
  scope?: string;
}
export interface IoK8sApiAdmissionregistrationV1ServiceReference {
  name: string;
  namespace: string;
  path?: string;
  port?: number;
}
export interface TypeChecking {
  expressionWarnings?: ExpressionWarning[];
}
export interface AdmissionregistrationK8sIoV1ValidatingAdmissionPolicy {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: ValidatingAdmissionPolicySpec;
  status?: ValidatingAdmissionPolicyStatus;
}
export interface AdmissionregistrationK8sIoV1ValidatingAdmissionPolicyBinding {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: ValidatingAdmissionPolicyBindingSpec;
}
export interface AdmissionregistrationK8sIoV1ValidatingAdmissionPolicyBindingList {
  apiVersion?: string;
  items: AdmissionregistrationK8sIoV1ValidatingAdmissionPolicyBinding[];
  kind?: string;
  metadata?: ListMeta;
}
export interface ValidatingAdmissionPolicyBindingSpec {
  matchResources?: MatchResources;
  paramRef?: ParamRef;
  policyName?: string;
  validationActions?: ("Audit" | "Deny" | "Warn")[];
}
export interface AdmissionregistrationK8sIoV1ValidatingAdmissionPolicyList {
  apiVersion?: string;
  items: AdmissionregistrationK8sIoV1ValidatingAdmissionPolicy[];
  kind?: string;
  metadata?: ListMeta;
}
export interface ValidatingAdmissionPolicySpec {
  auditAnnotations?: AuditAnnotation[];
  failurePolicy?: "Fail" | "Ignore";
  matchConditions?: MatchCondition[];
  matchConstraints?: MatchResources;
  paramKind?: ParamKind;
  validations?: Validation[];
  variables?: Variable[];
}
export interface ValidatingAdmissionPolicyStatus {
  conditions?: Condition[];
  observedGeneration?: number;
  typeChecking?: TypeChecking;
}
export interface ValidatingWebhook {
  admissionReviewVersions: string[];
  clientConfig: IoK8sApiAdmissionregistrationV1WebhookClientConfig;
  failurePolicy?: "Fail" | "Ignore";
  matchConditions?: MatchCondition[];
  matchPolicy?: "Equivalent" | "Exact";
  name: string;
  namespaceSelector?: LabelSelector;
  objectSelector?: LabelSelector;
  rules?: RuleWithOperations[];
  sideEffects: "None" | "NoneOnDryRun" | "Some" | "Unknown";
  timeoutSeconds?: number;
}
export interface AdmissionregistrationK8sIoV1ValidatingWebhookConfiguration {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  webhooks?: ValidatingWebhook[];
}
export interface AdmissionregistrationK8sIoV1ValidatingWebhookConfigurationList {
  apiVersion?: string;
  items: AdmissionregistrationK8sIoV1ValidatingWebhookConfiguration[];
  kind?: string;
  metadata?: ListMeta;
}
export interface Validation {
  expression: string;
  message?: string;
  messageExpression?: string;
  reason?: string;
}
export interface Variable {
  expression: string;
  name: string;
}
export interface IoK8sApiAdmissionregistrationV1WebhookClientConfig {
  caBundle?: string;
  service?: IoK8sApiAdmissionregistrationV1ServiceReference;
  url?: string;
}
export interface AppsV1ControllerRevision {
  apiVersion?: string;
  data?: RawExtension;
  kind?: string;
  metadata?: ObjectMeta;
  revision: number;
}
export interface AppsV1ControllerRevisionList {
  apiVersion?: string;
  items: AppsV1ControllerRevision[];
  kind?: string;
  metadata?: ListMeta;
}
export interface AppsV1DaemonSet {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: DaemonSetSpec;
  status?: DaemonSetStatus;
}
export interface DaemonSetCondition {
  lastTransitionTime?: Time;
  message?: string;
  reason?: string;
  status: string;
  type: string;
}
export interface AppsV1DaemonSetList {
  apiVersion?: string;
  items: AppsV1DaemonSet[];
  kind?: string;
  metadata?: ListMeta;
}
export interface DaemonSetSpec {
  minReadySeconds?: number;
  revisionHistoryLimit?: number;
  selector: LabelSelector;
  template: PodTemplateSpec;
  updateStrategy?: DaemonSetUpdateStrategy;
}
export interface DaemonSetStatus {
  collisionCount?: number;
  conditions?: DaemonSetCondition[];
  currentNumberScheduled: number;
  desiredNumberScheduled: number;
  numberAvailable?: number;
  numberMisscheduled: number;
  numberReady: number;
  numberUnavailable?: number;
  observedGeneration?: number;
  updatedNumberScheduled?: number;
}
export interface DaemonSetUpdateStrategy {
  rollingUpdate?: RollingUpdateDaemonSet;
  type?: "OnDelete" | "RollingUpdate";
}
export interface AppsV1Deployment {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: DeploymentSpec;
  status?: DeploymentStatus;
}
export interface DeploymentCondition {
  lastTransitionTime?: Time;
  lastUpdateTime?: Time;
  message?: string;
  reason?: string;
  status: string;
  type: string;
}
export interface AppsV1DeploymentList {
  apiVersion?: string;
  items: AppsV1Deployment[];
  kind?: string;
  metadata?: ListMeta;
}
export interface DeploymentSpec {
  minReadySeconds?: number;
  paused?: boolean;
  progressDeadlineSeconds?: number;
  replicas?: number;
  revisionHistoryLimit?: number;
  selector: LabelSelector;
  strategy?: DeploymentStrategy;
  template: PodTemplateSpec;
}
export interface DeploymentStatus {
  availableReplicas?: number;
  collisionCount?: number;
  conditions?: DeploymentCondition[];
  observedGeneration?: number;
  readyReplicas?: number;
  replicas?: number;
  unavailableReplicas?: number;
  updatedReplicas?: number;
}
export interface DeploymentStrategy {
  rollingUpdate?: RollingUpdateDeployment;
  type?: "Recreate" | "RollingUpdate";
}
export interface AppsV1ReplicaSet {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: ReplicaSetSpec;
  status?: ReplicaSetStatus;
}
export interface ReplicaSetCondition {
  lastTransitionTime?: Time;
  message?: string;
  reason?: string;
  status: string;
  type: string;
}
export interface AppsV1ReplicaSetList {
  apiVersion?: string;
  items: AppsV1ReplicaSet[];
  kind?: string;
  metadata?: ListMeta;
}
export interface ReplicaSetSpec {
  minReadySeconds?: number;
  replicas?: number;
  selector: LabelSelector;
  template?: PodTemplateSpec;
}
export interface ReplicaSetStatus {
  availableReplicas?: number;
  conditions?: ReplicaSetCondition[];
  fullyLabeledReplicas?: number;
  observedGeneration?: number;
  readyReplicas?: number;
  replicas: number;
}
export interface RollingUpdateDaemonSet {
  maxSurge?: IntOrString;
  maxUnavailable?: IntOrString;
}
export interface RollingUpdateDeployment {
  maxSurge?: IntOrString;
  maxUnavailable?: IntOrString;
}
export interface RollingUpdateStatefulSetStrategy {
  maxUnavailable?: IntOrString;
  partition?: number;
}
export interface AppsV1StatefulSet {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: StatefulSetSpec;
  status?: StatefulSetStatus;
}
export interface StatefulSetCondition {
  lastTransitionTime?: Time;
  message?: string;
  reason?: string;
  status: string;
  type: string;
}
export interface AppsV1StatefulSetList {
  apiVersion?: string;
  items: AppsV1StatefulSet[];
  kind?: string;
  metadata?: ListMeta;
}
export interface StatefulSetOrdinals {
  start?: number;
}
export interface StatefulSetPersistentVolumeClaimRetentionPolicy {
  whenDeleted?: string;
  whenScaled?: string;
}
export interface StatefulSetSpec {
  minReadySeconds?: number;
  ordinals?: StatefulSetOrdinals;
  persistentVolumeClaimRetentionPolicy?: StatefulSetPersistentVolumeClaimRetentionPolicy;
  podManagementPolicy?: "OrderedReady" | "Parallel";
  replicas?: number;
  revisionHistoryLimit?: number;
  selector: LabelSelector;
  serviceName: string;
  template: PodTemplateSpec;
  updateStrategy?: StatefulSetUpdateStrategy;
  volumeClaimTemplates?: PersistentVolumeClaim[];
}
export interface StatefulSetStatus {
  availableReplicas?: number;
  collisionCount?: number;
  conditions?: StatefulSetCondition[];
  currentReplicas?: number;
  currentRevision?: string;
  observedGeneration?: number;
  readyReplicas?: number;
  replicas: number;
  updateRevision?: string;
  updatedReplicas?: number;
}
export interface StatefulSetUpdateStrategy {
  rollingUpdate?: RollingUpdateStatefulSetStrategy;
  type?: "OnDelete" | "RollingUpdate";
}
export interface BoundObjectReference {
  apiVersion?: string;
  kind?: string;
  name?: string;
  uid?: string;
}
export interface AuthenticationK8sIoV1SelfSubjectReview {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  status?: SelfSubjectReviewStatus;
}
export interface SelfSubjectReviewStatus {
  userInfo?: UserInfo;
}
export interface AuthenticationK8sIoV1TokenRequest {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec: TokenRequestSpec;
  status?: TokenRequestStatus;
}
export interface TokenRequestSpec {
  audiences: string[];
  boundObjectRef?: BoundObjectReference;
  expirationSeconds?: number;
}
export interface TokenRequestStatus {
  expirationTimestamp: Time;
  token: string;
}
export interface AuthenticationK8sIoV1TokenReview {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec: TokenReviewSpec;
  status?: TokenReviewStatus;
}
export interface TokenReviewSpec {
  audiences?: string[];
  token?: string;
}
export interface TokenReviewStatus {
  audiences?: string[];
  authenticated?: boolean;
  error?: string;
  user?: UserInfo;
}
export interface UserInfo {
  extra?: {
    [key: string]: unknown;
  };
  groups?: string[];
  uid?: string;
  username?: string;
}
export interface FieldSelectorAttributes {
  rawSelector?: string;
  requirements?: FieldSelectorRequirement[];
}
export interface LabelSelectorAttributes {
  rawSelector?: string;
  requirements?: LabelSelectorRequirement[];
}
export interface AuthorizationK8sIoV1LocalSubjectAccessReview {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec: SubjectAccessReviewSpec;
  status?: SubjectAccessReviewStatus;
}
export interface NonResourceAttributes {
  path?: string;
  verb?: string;
}
export interface NonResourceRule {
  nonResourceURLs?: string[];
  verbs: string[];
}
export interface ResourceAttributes {
  fieldSelector?: FieldSelectorAttributes;
  group?: string;
  labelSelector?: LabelSelectorAttributes;
  name?: string;
  namespace?: string;
  resource?: string;
  subresource?: string;
  verb?: string;
  version?: string;
}
export interface ResourceRule {
  apiGroups?: string[];
  resourceNames?: string[];
  resources?: string[];
  verbs: string[];
}
export interface AuthorizationK8sIoV1SelfSubjectAccessReview {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec: SelfSubjectAccessReviewSpec;
  status?: SubjectAccessReviewStatus;
}
export interface SelfSubjectAccessReviewSpec {
  nonResourceAttributes?: NonResourceAttributes;
  resourceAttributes?: ResourceAttributes;
}
export interface AuthorizationK8sIoV1SelfSubjectRulesReview {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec: SelfSubjectRulesReviewSpec;
  status?: SubjectRulesReviewStatus;
}
export interface SelfSubjectRulesReviewSpec {
  namespace?: string;
}
export interface AuthorizationK8sIoV1SubjectAccessReview {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec: SubjectAccessReviewSpec;
  status?: SubjectAccessReviewStatus;
}
export interface SubjectAccessReviewSpec {
  extra?: {
    [key: string]: unknown;
  };
  groups?: string[];
  nonResourceAttributes?: NonResourceAttributes;
  resourceAttributes?: ResourceAttributes;
  uid?: string;
  user?: string;
}
export interface SubjectAccessReviewStatus {
  allowed: boolean;
  denied?: boolean;
  evaluationError?: string;
  reason?: string;
}
export interface SubjectRulesReviewStatus {
  evaluationError?: string;
  incomplete: boolean;
  nonResourceRules: NonResourceRule[];
  resourceRules: ResourceRule[];
}
export interface IoK8sApiAutoscalingV1CrossVersionObjectReference {
  apiVersion?: string;
  kind: string;
  name: string;
}
export interface AutoscalingV1HorizontalPodAutoscaler {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: IoK8sApiAutoscalingV1HorizontalPodAutoscalerSpec;
  status?: IoK8sApiAutoscalingV1HorizontalPodAutoscalerStatus;
}
export interface AutoscalingV1HorizontalPodAutoscalerList {
  apiVersion?: string;
  items: AutoscalingV1HorizontalPodAutoscaler[];
  kind?: string;
  metadata?: ListMeta;
}
export interface IoK8sApiAutoscalingV1HorizontalPodAutoscalerSpec {
  maxReplicas: number;
  minReplicas?: number;
  scaleTargetRef: IoK8sApiAutoscalingV1CrossVersionObjectReference;
  targetCPUUtilizationPercentage?: number;
}
export interface IoK8sApiAutoscalingV1HorizontalPodAutoscalerStatus {
  currentCPUUtilizationPercentage?: number;
  currentReplicas: number;
  desiredReplicas: number;
  lastScaleTime?: Time;
  observedGeneration?: number;
}
export interface AutoscalingV1Scale {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: ScaleSpec;
  status?: ScaleStatus;
}
export interface ScaleSpec {
  replicas?: number;
}
export interface ScaleStatus {
  replicas: number;
  selector?: string;
}
export interface ContainerResourceMetricSource {
  container: string;
  name: string;
  target: MetricTarget;
}
export interface ContainerResourceMetricStatus {
  container: string;
  current: MetricValueStatus;
  name: string;
}
export interface IoK8sApiAutoscalingV2CrossVersionObjectReference {
  apiVersion?: string;
  kind: string;
  name: string;
}
export interface ExternalMetricSource {
  metric: MetricIdentifier;
  target: MetricTarget;
}
export interface ExternalMetricStatus {
  current: MetricValueStatus;
  metric: MetricIdentifier;
}
export interface HPAScalingPolicy {
  periodSeconds: number;
  type: string;
  value: number;
}
export interface HPAScalingRules {
  policies?: HPAScalingPolicy[];
  selectPolicy?: string;
  stabilizationWindowSeconds?: number;
}
export interface AutoscalingV2HorizontalPodAutoscaler {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: IoK8sApiAutoscalingV2HorizontalPodAutoscalerSpec;
  status?: IoK8sApiAutoscalingV2HorizontalPodAutoscalerStatus;
}
export interface HorizontalPodAutoscalerBehavior {
  scaleDown?: HPAScalingRules;
  scaleUp?: HPAScalingRules;
}
export interface HorizontalPodAutoscalerCondition {
  lastTransitionTime?: Time;
  message?: string;
  reason?: string;
  status: string;
  type: string;
}
export interface AutoscalingV2HorizontalPodAutoscalerList {
  apiVersion?: string;
  items: AutoscalingV2HorizontalPodAutoscaler[];
  kind?: string;
  metadata?: ListMeta;
}
export interface IoK8sApiAutoscalingV2HorizontalPodAutoscalerSpec {
  behavior?: HorizontalPodAutoscalerBehavior;
  maxReplicas: number;
  metrics?: MetricSpec[];
  minReplicas?: number;
  scaleTargetRef: IoK8sApiAutoscalingV2CrossVersionObjectReference;
}
export interface IoK8sApiAutoscalingV2HorizontalPodAutoscalerStatus {
  conditions?: HorizontalPodAutoscalerCondition[];
  currentMetrics?: MetricStatus[];
  currentReplicas?: number;
  desiredReplicas: number;
  lastScaleTime?: Time;
  observedGeneration?: number;
}
export interface MetricIdentifier {
  name: string;
  selector?: LabelSelector;
}
export interface MetricSpec {
  containerResource?: ContainerResourceMetricSource;
  external?: ExternalMetricSource;
  object?: ObjectMetricSource;
  pods?: PodsMetricSource;
  resource?: ResourceMetricSource;
  type: string;
}
export interface MetricStatus {
  containerResource?: ContainerResourceMetricStatus;
  external?: ExternalMetricStatus;
  object?: ObjectMetricStatus;
  pods?: PodsMetricStatus;
  resource?: ResourceMetricStatus;
  type: string;
}
export interface MetricTarget {
  averageUtilization?: number;
  averageValue?: Quantity;
  type: string;
  value?: Quantity;
}
export interface MetricValueStatus {
  averageUtilization?: number;
  averageValue?: Quantity;
  value?: Quantity;
}
export interface ObjectMetricSource {
  describedObject: IoK8sApiAutoscalingV2CrossVersionObjectReference;
  metric: MetricIdentifier;
  target: MetricTarget;
}
export interface ObjectMetricStatus {
  current: MetricValueStatus;
  describedObject: IoK8sApiAutoscalingV2CrossVersionObjectReference;
  metric: MetricIdentifier;
}
export interface PodsMetricSource {
  metric: MetricIdentifier;
  target: MetricTarget;
}
export interface PodsMetricStatus {
  current: MetricValueStatus;
  metric: MetricIdentifier;
}
export interface ResourceMetricSource {
  name: string;
  target: MetricTarget;
}
export interface ResourceMetricStatus {
  current: MetricValueStatus;
  name: string;
}
export interface BatchV1CronJob {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: CronJobSpec;
  status?: CronJobStatus;
}
export interface BatchV1CronJobList {
  apiVersion?: string;
  items: BatchV1CronJob[];
  kind?: string;
  metadata?: ListMeta;
}
export interface CronJobSpec {
  concurrencyPolicy?: "Allow" | "Forbid" | "Replace";
  failedJobsHistoryLimit?: number;
  jobTemplate: JobTemplateSpec;
  schedule: string;
  startingDeadlineSeconds?: number;
  successfulJobsHistoryLimit?: number;
  suspend?: boolean;
  timeZone?: string;
}
export interface CronJobStatus {
  active?: ObjectReference[];
  lastScheduleTime?: Time;
  lastSuccessfulTime?: Time;
}
export interface BatchV1Job {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: JobSpec;
  status?: JobStatus;
}
export interface JobCondition {
  lastProbeTime?: Time;
  lastTransitionTime?: Time;
  message?: string;
  reason?: string;
  status: string;
  type: string;
}
export interface BatchV1JobList {
  apiVersion?: string;
  items: BatchV1Job[];
  kind?: string;
  metadata?: ListMeta;
}
export interface JobSpec {
  activeDeadlineSeconds?: number;
  backoffLimit?: number;
  backoffLimitPerIndex?: number;
  completionMode?: "Indexed" | "NonIndexed";
  completions?: number;
  managedBy?: string;
  manualSelector?: boolean;
  maxFailedIndexes?: number;
  parallelism?: number;
  podFailurePolicy?: PodFailurePolicy;
  podReplacementPolicy?: "Failed" | "TerminatingOrFailed";
  selector?: LabelSelector;
  successPolicy?: SuccessPolicy;
  suspend?: boolean;
  template: PodTemplateSpec;
  ttlSecondsAfterFinished?: number;
}
export interface JobStatus {
  active?: number;
  completedIndexes?: string;
  completionTime?: Time;
  conditions?: JobCondition[];
  failed?: number;
  failedIndexes?: string;
  ready?: number;
  startTime?: Time;
  succeeded?: number;
  terminating?: number;
  uncountedTerminatedPods?: UncountedTerminatedPods;
}
export interface JobTemplateSpec {
  metadata?: ObjectMeta;
  spec?: JobSpec;
}
export interface PodFailurePolicy {
  rules: PodFailurePolicyRule[];
}
export interface PodFailurePolicyOnExitCodesRequirement {
  containerName?: string;
  operator: "In" | "NotIn";
  values: number[];
}
export interface PodFailurePolicyOnPodConditionsPattern {
  status: string;
  type: string;
}
export interface PodFailurePolicyRule {
  action: "Count" | "FailIndex" | "FailJob" | "Ignore";
  onExitCodes?: PodFailurePolicyOnExitCodesRequirement;
  onPodConditions?: PodFailurePolicyOnPodConditionsPattern[];
}
export interface SuccessPolicy {
  rules: SuccessPolicyRule[];
}
export interface SuccessPolicyRule {
  succeededCount?: number;
  succeededIndexes?: string;
}
export interface UncountedTerminatedPods {
  failed?: string[];
  succeeded?: string[];
}
export interface CertificatesK8sIoV1CertificateSigningRequest {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec: CertificateSigningRequestSpec;
  status?: CertificateSigningRequestStatus;
}
export interface CertificateSigningRequestCondition {
  lastTransitionTime?: Time;
  lastUpdateTime?: Time;
  message?: string;
  reason?: string;
  status: string;
  type: string;
}
export interface CertificatesK8sIoV1CertificateSigningRequestList {
  apiVersion?: string;
  items: CertificatesK8sIoV1CertificateSigningRequest[];
  kind?: string;
  metadata?: ListMeta;
}
export interface CertificateSigningRequestSpec {
  expirationSeconds?: number;
  extra?: {
    [key: string]: unknown;
  };
  groups?: string[];
  request: string;
  signerName: string;
  uid?: string;
  usages?: ("any" | "cert sign" | "client auth" | "code signing" | "content commitment" | "crl sign" | "data encipherment" | "decipher only" | "digital signature" | "email protection" | "encipher only" | "ipsec end system" | "ipsec tunnel" | "ipsec user" | "key agreement" | "key encipherment" | "microsoft sgc" | "netscape sgc" | "ocsp signing" | "s/mime" | "server auth" | "signing" | "timestamping")[];
  username?: string;
}
export interface CertificateSigningRequestStatus {
  certificate?: string;
  conditions?: CertificateSigningRequestCondition[];
}
export interface CoordinationK8sIoV1Lease {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: LeaseSpec;
}
export interface CoordinationK8sIoV1LeaseList {
  apiVersion?: string;
  items: CoordinationK8sIoV1Lease[];
  kind?: string;
  metadata?: ListMeta;
}
export interface LeaseSpec {
  acquireTime?: MicroTime;
  holderIdentity?: string;
  leaseDurationSeconds?: number;
  leaseTransitions?: number;
  preferredHolder?: string;
  renewTime?: MicroTime;
  strategy?: string;
}
export interface AWSElasticBlockStoreVolumeSource {
  fsType?: string;
  partition?: number;
  readOnly?: boolean;
  volumeID: string;
}
export interface Affinity {
  nodeAffinity?: NodeAffinity;
  podAffinity?: PodAffinity;
  podAntiAffinity?: PodAntiAffinity;
}
export interface AppArmorProfile {
  localhostProfile?: string;
  type: "Localhost" | "RuntimeDefault" | "Unconfined";
}
export interface AttachedVolume {
  devicePath: string;
  name: string;
}
export interface AzureDiskVolumeSource {
  cachingMode?: "None" | "ReadOnly" | "ReadWrite";
  diskName: string;
  diskURI: string;
  fsType?: string;
  kind?: "Dedicated" | "Managed" | "Shared";
  readOnly?: boolean;
}
export interface AzureFilePersistentVolumeSource {
  readOnly?: boolean;
  secretName: string;
  secretNamespace?: string;
  shareName: string;
}
export interface AzureFileVolumeSource {
  readOnly?: boolean;
  secretName: string;
  shareName: string;
}
export interface Binding {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  target: ObjectReference;
}
export interface CSIPersistentVolumeSource {
  controllerExpandSecretRef?: SecretReference;
  controllerPublishSecretRef?: SecretReference;
  driver: string;
  fsType?: string;
  nodeExpandSecretRef?: SecretReference;
  nodePublishSecretRef?: SecretReference;
  nodeStageSecretRef?: SecretReference;
  readOnly?: boolean;
  volumeAttributes?: {
    [key: string]: unknown;
  };
  volumeHandle: string;
}
export interface CSIVolumeSource {
  driver: string;
  fsType?: string;
  nodePublishSecretRef?: LocalObjectReference;
  readOnly?: boolean;
  volumeAttributes?: {
    [key: string]: unknown;
  };
}
export interface Capabilities {
  add?: string[];
  drop?: string[];
}
export interface CephFSPersistentVolumeSource {
  monitors: string[];
  path?: string;
  readOnly?: boolean;
  secretFile?: string;
  secretRef?: SecretReference;
  user?: string;
}
export interface CephFSVolumeSource {
  monitors: string[];
  path?: string;
  readOnly?: boolean;
  secretFile?: string;
  secretRef?: LocalObjectReference;
  user?: string;
}
export interface CinderPersistentVolumeSource {
  fsType?: string;
  readOnly?: boolean;
  secretRef?: SecretReference;
  volumeID: string;
}
export interface CinderVolumeSource {
  fsType?: string;
  readOnly?: boolean;
  secretRef?: LocalObjectReference;
  volumeID: string;
}
export interface ClientIPConfig {
  timeoutSeconds?: number;
}
export interface ClusterTrustBundleProjection {
  labelSelector?: LabelSelector;
  name?: string;
  optional?: boolean;
  path: string;
  signerName?: string;
}
export interface ComponentCondition {
  error?: string;
  message?: string;
  status: string;
  type: string;
}
export interface ComponentStatus {
  apiVersion?: string;
  conditions?: ComponentCondition[];
  kind?: string;
  metadata?: ObjectMeta;
}
export interface ComponentStatusList {
  apiVersion?: string;
  items: ComponentStatus[];
  kind?: string;
  metadata?: ListMeta;
}
export interface ConfigMap {
  apiVersion?: string;
  binaryData?: {
    [key: string]: unknown;
  };
  data?: {
    [key: string]: unknown;
  };
  immutable?: boolean;
  kind?: string;
  metadata?: ObjectMeta;
}
export interface ConfigMapEnvSource {
  name?: string;
  optional?: boolean;
}
export interface ConfigMapKeySelector {
  key: string;
  name?: string;
  optional?: boolean;
}
export interface ConfigMapList {
  apiVersion?: string;
  items: ConfigMap[];
  kind?: string;
  metadata?: ListMeta;
}
export interface ConfigMapNodeConfigSource {
  kubeletConfigKey: string;
  name: string;
  namespace: string;
  resourceVersion?: string;
  uid?: string;
}
export interface ConfigMapProjection {
  items?: KeyToPath[];
  name?: string;
  optional?: boolean;
}
export interface ConfigMapVolumeSource {
  defaultMode?: number;
  items?: KeyToPath[];
  name?: string;
  optional?: boolean;
}
export interface Container {
  args?: string[];
  command?: string[];
  env?: EnvVar[];
  envFrom?: EnvFromSource[];
  image?: string;
  imagePullPolicy?: "Always" | "IfNotPresent" | "Never";
  lifecycle?: Lifecycle;
  livenessProbe?: IoK8sApiCoreV1Probe;
  name: string;
  ports?: ContainerPort[];
  readinessProbe?: IoK8sApiCoreV1Probe;
  resizePolicy?: ContainerResizePolicy[];
  resources?: ResourceRequirements;
  restartPolicy?: string;
  securityContext?: SecurityContext;
  startupProbe?: IoK8sApiCoreV1Probe;
  stdin?: boolean;
  stdinOnce?: boolean;
  terminationMessagePath?: string;
  terminationMessagePolicy?: "FallbackToLogsOnError" | "File";
  tty?: boolean;
  volumeDevices?: VolumeDevice[];
  volumeMounts?: VolumeMount[];
  workingDir?: string;
}
export interface ContainerImage {
  names?: string[];
  sizeBytes?: number;
}
export interface ContainerPort {
  containerPort: number;
  hostIP?: string;
  hostPort?: number;
  name?: string;
  protocol?: "SCTP" | "TCP" | "UDP";
}
export interface ContainerResizePolicy {
  resourceName: string;
  restartPolicy: string;
}
export interface ContainerState {
  running?: ContainerStateRunning;
  terminated?: ContainerStateTerminated;
  waiting?: ContainerStateWaiting;
}
export interface ContainerStateRunning {
  startedAt?: Time;
}
export interface ContainerStateTerminated {
  containerID?: string;
  exitCode: number;
  finishedAt?: Time;
  message?: string;
  reason?: string;
  signal?: number;
  startedAt?: Time;
}
export interface ContainerStateWaiting {
  message?: string;
  reason?: string;
}
export interface ContainerStatus {
  allocatedResources?: {
    [key: string]: unknown;
  };
  allocatedResourcesStatus?: ResourceStatus[];
  containerID?: string;
  image: string;
  imageID: string;
  lastState?: ContainerState;
  name: string;
  ready: boolean;
  resources?: ResourceRequirements;
  restartCount: number;
  started?: boolean;
  state?: ContainerState;
  user?: ContainerUser;
  volumeMounts?: VolumeMountStatus[];
}
export interface ContainerUser {
  linux?: LinuxContainerUser;
}
export interface DaemonEndpoint {
  Port: number;
}
export interface DownwardAPIProjection {
  items?: DownwardAPIVolumeFile[];
}
export interface DownwardAPIVolumeFile {
  fieldRef?: ObjectFieldSelector;
  mode?: number;
  path: string;
  resourceFieldRef?: ResourceFieldSelector;
}
export interface DownwardAPIVolumeSource {
  defaultMode?: number;
  items?: DownwardAPIVolumeFile[];
}
export interface EmptyDirVolumeSource {
  medium?: string;
  sizeLimit?: Quantity;
}
export interface EndpointAddress {
  hostname?: string;
  ip: string;
  nodeName?: string;
  targetRef?: ObjectReference;
}
export interface IoK8sApiCoreV1EndpointPort {
  appProtocol?: string;
  name?: string;
  port: number;
  protocol?: "SCTP" | "TCP" | "UDP";
}
export interface EndpointSubset {
  addresses?: EndpointAddress[];
  notReadyAddresses?: EndpointAddress[];
  ports?: IoK8sApiCoreV1EndpointPort[];
}
export interface Endpoints {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  subsets?: EndpointSubset[];
}
export interface EndpointsList {
  apiVersion?: string;
  items: Endpoints[];
  kind?: string;
  metadata?: ListMeta;
}
export interface EnvFromSource {
  configMapRef?: ConfigMapEnvSource;
  prefix?: string;
  secretRef?: SecretEnvSource;
}
export interface EnvVar {
  name: string;
  value?: string;
  valueFrom?: EnvVarSource;
}
export interface EnvVarSource {
  configMapKeyRef?: ConfigMapKeySelector;
  fieldRef?: ObjectFieldSelector;
  resourceFieldRef?: ResourceFieldSelector;
  secretKeyRef?: SecretKeySelector;
}
export interface EphemeralContainer {
  args?: string[];
  command?: string[];
  env?: EnvVar[];
  envFrom?: EnvFromSource[];
  image?: string;
  imagePullPolicy?: "Always" | "IfNotPresent" | "Never";
  lifecycle?: Lifecycle;
  livenessProbe?: IoK8sApiCoreV1Probe;
  name: string;
  ports?: ContainerPort[];
  readinessProbe?: IoK8sApiCoreV1Probe;
  resizePolicy?: ContainerResizePolicy[];
  resources?: ResourceRequirements;
  restartPolicy?: string;
  securityContext?: SecurityContext;
  startupProbe?: IoK8sApiCoreV1Probe;
  stdin?: boolean;
  stdinOnce?: boolean;
  targetContainerName?: string;
  terminationMessagePath?: string;
  terminationMessagePolicy?: "FallbackToLogsOnError" | "File";
  tty?: boolean;
  volumeDevices?: VolumeDevice[];
  volumeMounts?: VolumeMount[];
  workingDir?: string;
}
export interface EphemeralVolumeSource {
  volumeClaimTemplate?: PersistentVolumeClaimTemplate;
}
export interface Event {
  action?: string;
  apiVersion?: string;
  count?: number;
  eventTime?: MicroTime;
  firstTimestamp?: Time;
  involvedObject: ObjectReference;
  kind?: string;
  lastTimestamp?: Time;
  message?: string;
  metadata: ObjectMeta;
  reason?: string;
  related?: ObjectReference;
  reportingComponent?: string;
  reportingInstance?: string;
  series?: IoK8sApiCoreV1EventSeries;
  source?: EventSource;
  type?: string;
}
export interface EventList {
  apiVersion?: string;
  items: Event[];
  kind?: string;
  metadata?: ListMeta;
}
export interface IoK8sApiCoreV1EventSeries {
  count?: number;
  lastObservedTime?: MicroTime;
}
export interface EventSource {
  component?: string;
  host?: string;
}
export interface ExecAction {
  command?: string[];
}
export interface FCVolumeSource {
  fsType?: string;
  lun?: number;
  readOnly?: boolean;
  targetWWNs?: string[];
  wwids?: string[];
}
export interface FlexPersistentVolumeSource {
  driver: string;
  fsType?: string;
  options?: {
    [key: string]: unknown;
  };
  readOnly?: boolean;
  secretRef?: SecretReference;
}
export interface FlexVolumeSource {
  driver: string;
  fsType?: string;
  options?: {
    [key: string]: unknown;
  };
  readOnly?: boolean;
  secretRef?: LocalObjectReference;
}
export interface FlockerVolumeSource {
  datasetName?: string;
  datasetUUID?: string;
}
export interface GCEPersistentDiskVolumeSource {
  fsType?: string;
  partition?: number;
  pdName: string;
  readOnly?: boolean;
}
export interface GRPCAction {
  port: number;
  service?: string;
}
export interface GitRepoVolumeSource {
  directory?: string;
  repository: string;
  revision?: string;
}
export interface GlusterfsPersistentVolumeSource {
  endpoints: string;
  endpointsNamespace?: string;
  path: string;
  readOnly?: boolean;
}
export interface GlusterfsVolumeSource {
  endpoints: string;
  path: string;
  readOnly?: boolean;
}
export interface HTTPGetAction {
  host?: string;
  httpHeaders?: HTTPHeader[];
  path?: string;
  port: IntOrString;
  scheme?: "HTTP" | "HTTPS";
}
export interface HTTPHeader {
  name: string;
  value: string;
}
export interface HostAlias {
  hostnames?: string[];
  ip: string;
}
export interface HostIP {
  ip: string;
}
export interface HostPathVolumeSource {
  path: string;
  type?: "" | "BlockDevice" | "CharDevice" | "Directory" | "DirectoryOrCreate" | "File" | "FileOrCreate" | "Socket";
}
export interface ISCSIPersistentVolumeSource {
  chapAuthDiscovery?: boolean;
  chapAuthSession?: boolean;
  fsType?: string;
  initiatorName?: string;
  iqn: string;
  iscsiInterface?: string;
  lun: number;
  portals?: string[];
  readOnly?: boolean;
  secretRef?: SecretReference;
  targetPortal: string;
}
export interface ISCSIVolumeSource {
  chapAuthDiscovery?: boolean;
  chapAuthSession?: boolean;
  fsType?: string;
  initiatorName?: string;
  iqn: string;
  iscsiInterface?: string;
  lun: number;
  portals?: string[];
  readOnly?: boolean;
  secretRef?: LocalObjectReference;
  targetPortal: string;
}
export interface ImageVolumeSource {
  pullPolicy?: "Always" | "IfNotPresent" | "Never";
  reference?: string;
}
export interface KeyToPath {
  key: string;
  mode?: number;
  path: string;
}
export interface Lifecycle {
  postStart?: LifecycleHandler;
  preStop?: LifecycleHandler;
}
export interface LifecycleHandler {
  exec?: ExecAction;
  httpGet?: HTTPGetAction;
  sleep?: SleepAction;
  tcpSocket?: TCPSocketAction;
}
export interface LimitRange {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: LimitRangeSpec;
}
export interface LimitRangeItem {
  default?: {
    [key: string]: unknown;
  };
  defaultRequest?: {
    [key: string]: unknown;
  };
  max?: {
    [key: string]: unknown;
  };
  maxLimitRequestRatio?: {
    [key: string]: unknown;
  };
  min?: {
    [key: string]: unknown;
  };
  type: string;
}
export interface LimitRangeList {
  apiVersion?: string;
  items: LimitRange[];
  kind?: string;
  metadata?: ListMeta;
}
export interface LimitRangeSpec {
  limits: LimitRangeItem[];
}
export interface LinuxContainerUser {
  gid: number;
  supplementalGroups?: number[];
  uid: number;
}
export interface LoadBalancerIngress {
  hostname?: string;
  ip?: string;
  ipMode?: string;
  ports?: PortStatus[];
}
export interface LoadBalancerStatus {
  ingress?: LoadBalancerIngress[];
}
export interface LocalObjectReference {
  name?: string;
}
export interface LocalVolumeSource {
  fsType?: string;
  path: string;
}
export interface ModifyVolumeStatus {
  status: "InProgress" | "Infeasible" | "Pending";
  targetVolumeAttributesClassName?: string;
}
export interface NFSVolumeSource {
  path: string;
  readOnly?: boolean;
  server: string;
}
export interface Namespace {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: NamespaceSpec;
  status?: NamespaceStatus;
}
export interface NamespaceCondition {
  lastTransitionTime?: Time;
  message?: string;
  reason?: string;
  status: string;
  type: string;
}
export interface NamespaceList {
  apiVersion?: string;
  items: Namespace[];
  kind?: string;
  metadata?: ListMeta;
}
export interface NamespaceSpec {
  finalizers?: string[];
}
export interface NamespaceStatus {
  conditions?: NamespaceCondition[];
  phase?: "Active" | "Terminating";
}
export interface Node {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: NodeSpec;
  status?: NodeStatus;
}
export interface NodeAddress {
  address: string;
  type: string;
}
export interface NodeAffinity {
  preferredDuringSchedulingIgnoredDuringExecution?: PreferredSchedulingTerm[];
  requiredDuringSchedulingIgnoredDuringExecution?: NodeSelector;
}
export interface NodeCondition {
  lastHeartbeatTime?: Time;
  lastTransitionTime?: Time;
  message?: string;
  reason?: string;
  status: string;
  type: string;
}
export interface NodeConfigSource {
  configMap?: ConfigMapNodeConfigSource;
}
export interface NodeConfigStatus {
  active?: NodeConfigSource;
  assigned?: NodeConfigSource;
  error?: string;
  lastKnownGood?: NodeConfigSource;
}
export interface NodeDaemonEndpoints {
  kubeletEndpoint?: DaemonEndpoint;
}
export interface NodeFeatures {
  supplementalGroupsPolicy?: boolean;
}
export interface NodeList {
  apiVersion?: string;
  items: Node[];
  kind?: string;
  metadata?: ListMeta;
}
export interface NodeRuntimeHandler {
  features?: NodeRuntimeHandlerFeatures;
  name?: string;
}
export interface NodeRuntimeHandlerFeatures {
  recursiveReadOnlyMounts?: boolean;
  userNamespaces?: boolean;
}
export interface NodeSelector {
  nodeSelectorTerms: NodeSelectorTerm[];
}
export interface NodeSelectorRequirement {
  key: string;
  operator: "DoesNotExist" | "Exists" | "Gt" | "In" | "Lt" | "NotIn";
  values?: string[];
}
export interface NodeSelectorTerm {
  matchExpressions?: NodeSelectorRequirement[];
  matchFields?: NodeSelectorRequirement[];
}
export interface NodeSpec {
  configSource?: NodeConfigSource;
  externalID?: string;
  podCIDR?: string;
  podCIDRs?: string[];
  providerID?: string;
  taints?: Taint[];
  unschedulable?: boolean;
}
export interface NodeStatus {
  addresses?: NodeAddress[];
  allocatable?: {
    [key: string]: unknown;
  };
  capacity?: {
    [key: string]: unknown;
  };
  conditions?: NodeCondition[];
  config?: NodeConfigStatus;
  daemonEndpoints?: NodeDaemonEndpoints;
  features?: NodeFeatures;
  images?: ContainerImage[];
  nodeInfo?: NodeSystemInfo;
  phase?: "Pending" | "Running" | "Terminated";
  runtimeHandlers?: NodeRuntimeHandler[];
  volumesAttached?: AttachedVolume[];
  volumesInUse?: string[];
}
export interface NodeSystemInfo {
  architecture: string;
  bootID: string;
  containerRuntimeVersion: string;
  kernelVersion: string;
  kubeProxyVersion: string;
  kubeletVersion: string;
  machineID: string;
  operatingSystem: string;
  osImage: string;
  systemUUID: string;
}
export interface ObjectFieldSelector {
  apiVersion?: string;
  fieldPath: string;
}
export interface ObjectReference {
  apiVersion?: string;
  fieldPath?: string;
  kind?: string;
  name?: string;
  namespace?: string;
  resourceVersion?: string;
  uid?: string;
}
export interface PersistentVolume {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: PersistentVolumeSpec;
  status?: PersistentVolumeStatus;
}
export interface PersistentVolumeClaim {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: PersistentVolumeClaimSpec;
  status?: PersistentVolumeClaimStatus;
}
export interface PersistentVolumeClaimCondition {
  lastProbeTime?: Time;
  lastTransitionTime?: Time;
  message?: string;
  reason?: string;
  status: string;
  type: string;
}
export interface PersistentVolumeClaimList {
  apiVersion?: string;
  items: PersistentVolumeClaim[];
  kind?: string;
  metadata?: ListMeta;
}
export interface PersistentVolumeClaimSpec {
  accessModes?: ("ReadOnlyMany" | "ReadWriteMany" | "ReadWriteOnce" | "ReadWriteOncePod")[];
  dataSource?: TypedLocalObjectReference;
  dataSourceRef?: TypedObjectReference;
  resources?: VolumeResourceRequirements;
  selector?: LabelSelector;
  storageClassName?: string;
  volumeAttributesClassName?: string;
  volumeMode?: "Block" | "Filesystem";
  volumeName?: string;
}
export interface PersistentVolumeClaimStatus {
  accessModes?: ("ReadOnlyMany" | "ReadWriteMany" | "ReadWriteOnce" | "ReadWriteOncePod")[];
  allocatedResourceStatuses?: {
    [key: string]: unknown;
  };
  allocatedResources?: {
    [key: string]: unknown;
  };
  capacity?: {
    [key: string]: unknown;
  };
  conditions?: PersistentVolumeClaimCondition[];
  currentVolumeAttributesClassName?: string;
  modifyVolumeStatus?: ModifyVolumeStatus;
  phase?: "Bound" | "Lost" | "Pending";
}
export interface PersistentVolumeClaimTemplate {
  metadata?: ObjectMeta;
  spec: PersistentVolumeClaimSpec;
}
export interface PersistentVolumeClaimVolumeSource {
  claimName: string;
  readOnly?: boolean;
}
export interface PersistentVolumeList {
  apiVersion?: string;
  items: PersistentVolume[];
  kind?: string;
  metadata?: ListMeta;
}
export interface PersistentVolumeSpec {
  accessModes?: ("ReadOnlyMany" | "ReadWriteMany" | "ReadWriteOnce" | "ReadWriteOncePod")[];
  awsElasticBlockStore?: AWSElasticBlockStoreVolumeSource;
  azureDisk?: AzureDiskVolumeSource;
  azureFile?: AzureFilePersistentVolumeSource;
  capacity?: {
    [key: string]: unknown;
  };
  cephfs?: CephFSPersistentVolumeSource;
  cinder?: CinderPersistentVolumeSource;
  claimRef?: ObjectReference;
  csi?: CSIPersistentVolumeSource;
  fc?: FCVolumeSource;
  flexVolume?: FlexPersistentVolumeSource;
  flocker?: FlockerVolumeSource;
  gcePersistentDisk?: GCEPersistentDiskVolumeSource;
  glusterfs?: GlusterfsPersistentVolumeSource;
  hostPath?: HostPathVolumeSource;
  iscsi?: ISCSIPersistentVolumeSource;
  local?: LocalVolumeSource;
  mountOptions?: string[];
  nfs?: NFSVolumeSource;
  nodeAffinity?: VolumeNodeAffinity;
  persistentVolumeReclaimPolicy?: "Delete" | "Recycle" | "Retain";
  photonPersistentDisk?: PhotonPersistentDiskVolumeSource;
  portworxVolume?: PortworxVolumeSource;
  quobyte?: QuobyteVolumeSource;
  rbd?: RBDPersistentVolumeSource;
  scaleIO?: ScaleIOPersistentVolumeSource;
  storageClassName?: string;
  storageos?: StorageOSPersistentVolumeSource;
  volumeAttributesClassName?: string;
  volumeMode?: "Block" | "Filesystem";
  vsphereVolume?: VsphereVirtualDiskVolumeSource;
}
export interface PersistentVolumeStatus {
  lastPhaseTransitionTime?: Time;
  message?: string;
  phase?: "Available" | "Bound" | "Failed" | "Pending" | "Released";
  reason?: string;
}
export interface PhotonPersistentDiskVolumeSource {
  fsType?: string;
  pdID: string;
}
export interface Pod {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: PodSpec;
  status?: PodStatus;
}
export interface PodAffinity {
  preferredDuringSchedulingIgnoredDuringExecution?: WeightedPodAffinityTerm[];
  requiredDuringSchedulingIgnoredDuringExecution?: PodAffinityTerm[];
}
export interface PodAffinityTerm {
  labelSelector?: LabelSelector;
  matchLabelKeys?: string[];
  mismatchLabelKeys?: string[];
  namespaceSelector?: LabelSelector;
  namespaces?: string[];
  topologyKey: string;
}
export interface PodAntiAffinity {
  preferredDuringSchedulingIgnoredDuringExecution?: WeightedPodAffinityTerm[];
  requiredDuringSchedulingIgnoredDuringExecution?: PodAffinityTerm[];
}
export interface PodCondition {
  lastProbeTime?: Time;
  lastTransitionTime?: Time;
  message?: string;
  reason?: string;
  status: string;
  type: string;
}
export interface PodDNSConfig {
  nameservers?: string[];
  options?: PodDNSConfigOption[];
  searches?: string[];
}
export interface PodDNSConfigOption {
  name?: string;
  value?: string;
}
export interface PodIP {
  ip: string;
}
export interface PodList {
  apiVersion?: string;
  items: Pod[];
  kind?: string;
  metadata?: ListMeta;
}
export interface PodOS {
  name: string;
}
export interface PodReadinessGate {
  conditionType: string;
}
export interface PodResourceClaim {
  name: string;
  resourceClaimName?: string;
  resourceClaimTemplateName?: string;
}
export interface PodResourceClaimStatus {
  name: string;
  resourceClaimName?: string;
}
export interface PodSchedulingGate {
  name: string;
}
export interface PodSecurityContext {
  appArmorProfile?: AppArmorProfile;
  fsGroup?: number;
  fsGroupChangePolicy?: "Always" | "OnRootMismatch";
  runAsGroup?: number;
  runAsNonRoot?: boolean;
  runAsUser?: number;
  seLinuxChangePolicy?: string;
  seLinuxOptions?: SELinuxOptions;
  seccompProfile?: SeccompProfile;
  supplementalGroups?: number[];
  supplementalGroupsPolicy?: "Merge" | "Strict";
  sysctls?: Sysctl[];
  windowsOptions?: WindowsSecurityContextOptions;
}
export interface PodSpec {
  activeDeadlineSeconds?: number;
  affinity?: Affinity;
  automountServiceAccountToken?: boolean;
  containers: Container[];
  dnsConfig?: PodDNSConfig;
  dnsPolicy?: "ClusterFirst" | "ClusterFirstWithHostNet" | "Default" | "None";
  enableServiceLinks?: boolean;
  ephemeralContainers?: EphemeralContainer[];
  hostAliases?: HostAlias[];
  hostIPC?: boolean;
  hostNetwork?: boolean;
  hostPID?: boolean;
  hostUsers?: boolean;
  hostname?: string;
  imagePullSecrets?: LocalObjectReference[];
  initContainers?: Container[];
  nodeName?: string;
  nodeSelector?: {
    [key: string]: unknown;
  };
  os?: PodOS;
  overhead?: {
    [key: string]: unknown;
  };
  preemptionPolicy?: "Never" | "PreemptLowerPriority";
  priority?: number;
  priorityClassName?: string;
  readinessGates?: PodReadinessGate[];
  resourceClaims?: PodResourceClaim[];
  resources?: ResourceRequirements;
  restartPolicy?: "Always" | "Never" | "OnFailure";
  runtimeClassName?: string;
  schedulerName?: string;
  schedulingGates?: PodSchedulingGate[];
  securityContext?: PodSecurityContext;
  serviceAccount?: string;
  serviceAccountName?: string;
  setHostnameAsFQDN?: boolean;
  shareProcessNamespace?: boolean;
  subdomain?: string;
  terminationGracePeriodSeconds?: number;
  tolerations?: Toleration[];
  topologySpreadConstraints?: TopologySpreadConstraint[];
  volumes?: Volume[];
}
export interface PodStatus {
  conditions?: PodCondition[];
  containerStatuses?: ContainerStatus[];
  ephemeralContainerStatuses?: ContainerStatus[];
  hostIP?: string;
  hostIPs?: HostIP[];
  initContainerStatuses?: ContainerStatus[];
  message?: string;
  nominatedNodeName?: string;
  phase?: "Failed" | "Pending" | "Running" | "Succeeded" | "Unknown";
  podIP?: string;
  podIPs?: PodIP[];
  qosClass?: "BestEffort" | "Burstable" | "Guaranteed";
  reason?: string;
  resize?: string;
  resourceClaimStatuses?: PodResourceClaimStatus[];
  startTime?: Time;
}
export interface PodTemplate {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  template?: PodTemplateSpec;
}
export interface PodTemplateList {
  apiVersion?: string;
  items: PodTemplate[];
  kind?: string;
  metadata?: ListMeta;
}
export interface PodTemplateSpec {
  metadata?: ObjectMeta;
  spec?: PodSpec;
}
export interface PortStatus {
  error?: string;
  port: number;
  protocol: "SCTP" | "TCP" | "UDP";
}
export interface PortworxVolumeSource {
  fsType?: string;
  readOnly?: boolean;
  volumeID: string;
}
export interface PreferredSchedulingTerm {
  preference: NodeSelectorTerm;
  weight: number;
}
export interface IoK8sApiCoreV1Probe {
  exec?: ExecAction;
  failureThreshold?: number;
  grpc?: GRPCAction;
  httpGet?: HTTPGetAction;
  initialDelaySeconds?: number;
  periodSeconds?: number;
  successThreshold?: number;
  tcpSocket?: TCPSocketAction;
  terminationGracePeriodSeconds?: number;
  timeoutSeconds?: number;
}
export interface ProjectedVolumeSource {
  defaultMode?: number;
  sources?: VolumeProjection[];
}
export interface QuobyteVolumeSource {
  group?: string;
  readOnly?: boolean;
  registry: string;
  tenant?: string;
  user?: string;
  volume: string;
}
export interface RBDPersistentVolumeSource {
  fsType?: string;
  image: string;
  keyring?: string;
  monitors: string[];
  pool?: string;
  readOnly?: boolean;
  secretRef?: SecretReference;
  user?: string;
}
export interface RBDVolumeSource {
  fsType?: string;
  image: string;
  keyring?: string;
  monitors: string[];
  pool?: string;
  readOnly?: boolean;
  secretRef?: LocalObjectReference;
  user?: string;
}
export interface ReplicationController {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: ReplicationControllerSpec;
  status?: ReplicationControllerStatus;
}
export interface ReplicationControllerCondition {
  lastTransitionTime?: Time;
  message?: string;
  reason?: string;
  status: string;
  type: string;
}
export interface ReplicationControllerList {
  apiVersion?: string;
  items: ReplicationController[];
  kind?: string;
  metadata?: ListMeta;
}
export interface ReplicationControllerSpec {
  minReadySeconds?: number;
  replicas?: number;
  selector?: {
    [key: string]: unknown;
  };
  template?: PodTemplateSpec;
}
export interface ReplicationControllerStatus {
  availableReplicas?: number;
  conditions?: ReplicationControllerCondition[];
  fullyLabeledReplicas?: number;
  observedGeneration?: number;
  readyReplicas?: number;
  replicas: number;
}
export interface ResourceClaim {
  name: string;
  request?: string;
}
export interface ResourceFieldSelector {
  containerName?: string;
  divisor?: Quantity;
  resource: string;
}
export interface ResourceHealth {
  health?: string;
  resourceID: string;
}
export interface ResourceQuota {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: ResourceQuotaSpec;
  status?: ResourceQuotaStatus;
}
export interface ResourceQuotaList {
  apiVersion?: string;
  items: ResourceQuota[];
  kind?: string;
  metadata?: ListMeta;
}
export interface ResourceQuotaSpec {
  hard?: {
    [key: string]: unknown;
  };
  scopeSelector?: ScopeSelector;
  scopes?: ("BestEffort" | "CrossNamespacePodAffinity" | "NotBestEffort" | "NotTerminating" | "PriorityClass" | "Terminating")[];
}
export interface ResourceQuotaStatus {
  hard?: {
    [key: string]: unknown;
  };
  used?: {
    [key: string]: unknown;
  };
}
export interface ResourceRequirements {
  claims?: ResourceClaim[];
  limits?: {
    [key: string]: unknown;
  };
  requests?: {
    [key: string]: unknown;
  };
}
export interface ResourceStatus {
  name: string;
  resources?: ResourceHealth[];
}
export interface SELinuxOptions {
  level?: string;
  role?: string;
  type?: string;
  user?: string;
}
export interface ScaleIOPersistentVolumeSource {
  fsType?: string;
  gateway: string;
  protectionDomain?: string;
  readOnly?: boolean;
  secretRef: SecretReference;
  sslEnabled?: boolean;
  storageMode?: string;
  storagePool?: string;
  system: string;
  volumeName?: string;
}
export interface ScaleIOVolumeSource {
  fsType?: string;
  gateway: string;
  protectionDomain?: string;
  readOnly?: boolean;
  secretRef: LocalObjectReference;
  sslEnabled?: boolean;
  storageMode?: string;
  storagePool?: string;
  system: string;
  volumeName?: string;
}
export interface ScopeSelector {
  matchExpressions?: ScopedResourceSelectorRequirement[];
}
export interface ScopedResourceSelectorRequirement {
  operator: "DoesNotExist" | "Exists" | "In" | "NotIn";
  scopeName: "BestEffort" | "CrossNamespacePodAffinity" | "NotBestEffort" | "NotTerminating" | "PriorityClass" | "Terminating";
  values?: string[];
}
export interface SeccompProfile {
  localhostProfile?: string;
  type: "Localhost" | "RuntimeDefault" | "Unconfined";
}
export interface Secret {
  apiVersion?: string;
  data?: {
    [key: string]: unknown;
  };
  immutable?: boolean;
  kind?: string;
  metadata?: ObjectMeta;
  stringData?: {
    [key: string]: unknown;
  };
  type?: string;
}
export interface SecretEnvSource {
  name?: string;
  optional?: boolean;
}
export interface SecretKeySelector {
  key: string;
  name?: string;
  optional?: boolean;
}
export interface SecretList {
  apiVersion?: string;
  items: Secret[];
  kind?: string;
  metadata?: ListMeta;
}
export interface SecretProjection {
  items?: KeyToPath[];
  name?: string;
  optional?: boolean;
}
export interface SecretReference {
  name?: string;
  namespace?: string;
}
export interface SecretVolumeSource {
  defaultMode?: number;
  items?: KeyToPath[];
  optional?: boolean;
  secretName?: string;
}
export interface SecurityContext {
  allowPrivilegeEscalation?: boolean;
  appArmorProfile?: AppArmorProfile;
  capabilities?: Capabilities;
  privileged?: boolean;
  procMount?: "Default" | "Unmasked";
  readOnlyRootFilesystem?: boolean;
  runAsGroup?: number;
  runAsNonRoot?: boolean;
  runAsUser?: number;
  seLinuxOptions?: SELinuxOptions;
  seccompProfile?: SeccompProfile;
  windowsOptions?: WindowsSecurityContextOptions;
}
export interface Service {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: ServiceSpec;
  status?: ServiceStatus;
}
export interface ServiceAccount {
  apiVersion?: string;
  automountServiceAccountToken?: boolean;
  imagePullSecrets?: LocalObjectReference[];
  kind?: string;
  metadata?: ObjectMeta;
  secrets?: ObjectReference[];
}
export interface ServiceAccountList {
  apiVersion?: string;
  items: ServiceAccount[];
  kind?: string;
  metadata?: ListMeta;
}
export interface ServiceAccountTokenProjection {
  audience?: string;
  expirationSeconds?: number;
  path: string;
}
export interface ServiceList {
  apiVersion?: string;
  items: Service[];
  kind?: string;
  metadata?: ListMeta;
}
export interface ServicePort {
  appProtocol?: string;
  name?: string;
  nodePort?: number;
  port: number;
  protocol?: "SCTP" | "TCP" | "UDP";
  targetPort?: IntOrString;
}
export interface ServiceSpec {
  allocateLoadBalancerNodePorts?: boolean;
  clusterIP?: string;
  clusterIPs?: string[];
  externalIPs?: string[];
  externalName?: string;
  externalTrafficPolicy?: "Cluster" | "Local";
  healthCheckNodePort?: number;
  internalTrafficPolicy?: "Cluster" | "Local";
  ipFamilies?: ("" | "IPv4" | "IPv6")[];
  ipFamilyPolicy?: "PreferDualStack" | "RequireDualStack" | "SingleStack";
  loadBalancerClass?: string;
  loadBalancerIP?: string;
  loadBalancerSourceRanges?: string[];
  ports?: ServicePort[];
  publishNotReadyAddresses?: boolean;
  selector?: {
    [key: string]: unknown;
  };
  sessionAffinity?: "ClientIP" | "None";
  sessionAffinityConfig?: SessionAffinityConfig;
  trafficDistribution?: string;
  type?: "ClusterIP" | "ExternalName" | "LoadBalancer" | "NodePort";
}
export interface ServiceStatus {
  conditions?: Condition[];
  loadBalancer?: LoadBalancerStatus;
}
export interface SessionAffinityConfig {
  clientIP?: ClientIPConfig;
}
export interface SleepAction {
  seconds: number;
}
export interface StorageOSPersistentVolumeSource {
  fsType?: string;
  readOnly?: boolean;
  secretRef?: ObjectReference;
  volumeName?: string;
  volumeNamespace?: string;
}
export interface StorageOSVolumeSource {
  fsType?: string;
  readOnly?: boolean;
  secretRef?: LocalObjectReference;
  volumeName?: string;
  volumeNamespace?: string;
}
export interface Sysctl {
  name: string;
  value: string;
}
export interface TCPSocketAction {
  host?: string;
  port: IntOrString;
}
export interface Taint {
  effect: "NoExecute" | "NoSchedule" | "PreferNoSchedule";
  key: string;
  timeAdded?: Time;
  value?: string;
}
export interface Toleration {
  effect?: "NoExecute" | "NoSchedule" | "PreferNoSchedule";
  key?: string;
  operator?: "Equal" | "Exists";
  tolerationSeconds?: number;
  value?: string;
}
export interface TopologySelectorLabelRequirement {
  key: string;
  values: string[];
}
export interface TopologySelectorTerm {
  matchLabelExpressions?: TopologySelectorLabelRequirement[];
}
export interface TopologySpreadConstraint {
  labelSelector?: LabelSelector;
  matchLabelKeys?: string[];
  maxSkew: number;
  minDomains?: number;
  nodeAffinityPolicy?: "Honor" | "Ignore";
  nodeTaintsPolicy?: "Honor" | "Ignore";
  topologyKey: string;
  whenUnsatisfiable: "DoNotSchedule" | "ScheduleAnyway";
}
export interface TypedLocalObjectReference {
  apiGroup?: string;
  kind: string;
  name: string;
}
export interface TypedObjectReference {
  apiGroup?: string;
  kind: string;
  name: string;
  namespace?: string;
}
export interface Volume {
  awsElasticBlockStore?: AWSElasticBlockStoreVolumeSource;
  azureDisk?: AzureDiskVolumeSource;
  azureFile?: AzureFileVolumeSource;
  cephfs?: CephFSVolumeSource;
  cinder?: CinderVolumeSource;
  configMap?: ConfigMapVolumeSource;
  csi?: CSIVolumeSource;
  downwardAPI?: DownwardAPIVolumeSource;
  emptyDir?: EmptyDirVolumeSource;
  ephemeral?: EphemeralVolumeSource;
  fc?: FCVolumeSource;
  flexVolume?: FlexVolumeSource;
  flocker?: FlockerVolumeSource;
  gcePersistentDisk?: GCEPersistentDiskVolumeSource;
  gitRepo?: GitRepoVolumeSource;
  glusterfs?: GlusterfsVolumeSource;
  hostPath?: HostPathVolumeSource;
  image?: ImageVolumeSource;
  iscsi?: ISCSIVolumeSource;
  name: string;
  nfs?: NFSVolumeSource;
  persistentVolumeClaim?: PersistentVolumeClaimVolumeSource;
  photonPersistentDisk?: PhotonPersistentDiskVolumeSource;
  portworxVolume?: PortworxVolumeSource;
  projected?: ProjectedVolumeSource;
  quobyte?: QuobyteVolumeSource;
  rbd?: RBDVolumeSource;
  scaleIO?: ScaleIOVolumeSource;
  secret?: SecretVolumeSource;
  storageos?: StorageOSVolumeSource;
  vsphereVolume?: VsphereVirtualDiskVolumeSource;
}
export interface VolumeDevice {
  devicePath: string;
  name: string;
}
export interface VolumeMount {
  mountPath: string;
  mountPropagation?: "Bidirectional" | "HostToContainer" | "None";
  name: string;
  readOnly?: boolean;
  recursiveReadOnly?: string;
  subPath?: string;
  subPathExpr?: string;
}
export interface VolumeMountStatus {
  mountPath: string;
  name: string;
  readOnly?: boolean;
  recursiveReadOnly?: string;
}
export interface VolumeNodeAffinity {
  required?: NodeSelector;
}
export interface VolumeProjection {
  clusterTrustBundle?: ClusterTrustBundleProjection;
  configMap?: ConfigMapProjection;
  downwardAPI?: DownwardAPIProjection;
  secret?: SecretProjection;
  serviceAccountToken?: ServiceAccountTokenProjection;
}
export interface VolumeResourceRequirements {
  limits?: {
    [key: string]: unknown;
  };
  requests?: {
    [key: string]: unknown;
  };
}
export interface VsphereVirtualDiskVolumeSource {
  fsType?: string;
  storagePolicyID?: string;
  storagePolicyName?: string;
  volumePath: string;
}
export interface WeightedPodAffinityTerm {
  podAffinityTerm: PodAffinityTerm;
  weight: number;
}
export interface WindowsSecurityContextOptions {
  gmsaCredentialSpec?: string;
  gmsaCredentialSpecName?: string;
  hostProcess?: boolean;
  runAsUserName?: string;
}
export interface Endpoint {
  addresses: string[];
  conditions?: EndpointConditions;
  deprecatedTopology?: {
    [key: string]: unknown;
  };
  hints?: EndpointHints;
  hostname?: string;
  nodeName?: string;
  targetRef?: ObjectReference;
  zone?: string;
}
export interface EndpointConditions {
  ready?: boolean;
  serving?: boolean;
  terminating?: boolean;
}
export interface EndpointHints {
  forZones?: ForZone[];
}
export interface IoK8sApiDiscoveryV1EndpointPort {
  appProtocol?: string;
  name?: string;
  port?: number;
  protocol?: "SCTP" | "TCP" | "UDP";
}
export interface DiscoveryK8sIoV1EndpointSlice {
  addressType: "FQDN" | "IPv4" | "IPv6";
  apiVersion?: string;
  endpoints: Endpoint[];
  kind?: string;
  metadata?: ObjectMeta;
  ports?: IoK8sApiDiscoveryV1EndpointPort[];
}
export interface DiscoveryK8sIoV1EndpointSliceList {
  apiVersion?: string;
  items: DiscoveryK8sIoV1EndpointSlice[];
  kind?: string;
  metadata?: ListMeta;
}
export interface ForZone {
  name: string;
}
export interface EventsK8sIoV1Event {
  action?: string;
  apiVersion?: string;
  deprecatedCount?: number;
  deprecatedFirstTimestamp?: Time;
  deprecatedLastTimestamp?: Time;
  deprecatedSource?: EventSource;
  eventTime: MicroTime;
  kind?: string;
  metadata?: ObjectMeta;
  note?: string;
  reason?: string;
  regarding?: ObjectReference;
  related?: ObjectReference;
  reportingController?: string;
  reportingInstance?: string;
  series?: IoK8sApiEventsV1EventSeries;
  type?: string;
}
export interface EventsK8sIoV1EventList {
  apiVersion?: string;
  items: EventsK8sIoV1Event[];
  kind?: string;
  metadata?: ListMeta;
}
export interface IoK8sApiEventsV1EventSeries {
  count: number;
  lastObservedTime: MicroTime;
}
export interface ExemptPriorityLevelConfiguration {
  lendablePercent?: number;
  nominalConcurrencyShares?: number;
}
export interface FlowDistinguisherMethod {
  type: string;
}
export interface FlowcontrolApiserverK8sIoV1FlowSchema {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: FlowSchemaSpec;
  status?: FlowSchemaStatus;
}
export interface FlowSchemaCondition {
  lastTransitionTime?: Time;
  message?: string;
  reason?: string;
  status?: string;
  type?: string;
}
export interface FlowcontrolApiserverK8sIoV1FlowSchemaList {
  apiVersion?: string;
  items: FlowcontrolApiserverK8sIoV1FlowSchema[];
  kind?: string;
  metadata?: ListMeta;
}
export interface FlowSchemaSpec {
  distinguisherMethod?: FlowDistinguisherMethod;
  matchingPrecedence?: number;
  priorityLevelConfiguration: PriorityLevelConfigurationReference;
  rules?: PolicyRulesWithSubjects[];
}
export interface FlowSchemaStatus {
  conditions?: FlowSchemaCondition[];
}
export interface GroupSubject {
  name: string;
}
export interface LimitResponse {
  queuing?: QueuingConfiguration;
  type: string;
}
export interface LimitedPriorityLevelConfiguration {
  borrowingLimitPercent?: number;
  lendablePercent?: number;
  limitResponse?: LimitResponse;
  nominalConcurrencyShares?: number;
}
export interface NonResourcePolicyRule {
  nonResourceURLs: string[];
  verbs: string[];
}
export interface PolicyRulesWithSubjects {
  nonResourceRules?: NonResourcePolicyRule[];
  resourceRules?: ResourcePolicyRule[];
  subjects: IoK8sApiFlowcontrolV1Subject[];
}
export interface FlowcontrolApiserverK8sIoV1PriorityLevelConfiguration {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: PriorityLevelConfigurationSpec;
  status?: PriorityLevelConfigurationStatus;
}
export interface PriorityLevelConfigurationCondition {
  lastTransitionTime?: Time;
  message?: string;
  reason?: string;
  status?: string;
  type?: string;
}
export interface FlowcontrolApiserverK8sIoV1PriorityLevelConfigurationList {
  apiVersion?: string;
  items: FlowcontrolApiserverK8sIoV1PriorityLevelConfiguration[];
  kind?: string;
  metadata?: ListMeta;
}
export interface PriorityLevelConfigurationReference {
  name: string;
}
export interface PriorityLevelConfigurationSpec {
  exempt?: ExemptPriorityLevelConfiguration;
  limited?: LimitedPriorityLevelConfiguration;
  type: string;
}
export interface PriorityLevelConfigurationStatus {
  conditions?: PriorityLevelConfigurationCondition[];
}
export interface QueuingConfiguration {
  handSize?: number;
  queueLengthLimit?: number;
  queues?: number;
}
export interface ResourcePolicyRule {
  apiGroups: string[];
  clusterScope?: boolean;
  namespaces?: string[];
  resources: string[];
  verbs: string[];
}
export interface ServiceAccountSubject {
  name: string;
  namespace: string;
}
export interface IoK8sApiFlowcontrolV1Subject {
  group?: GroupSubject;
  kind: string;
  serviceAccount?: ServiceAccountSubject;
  user?: UserSubject;
}
export interface UserSubject {
  name: string;
}
export interface HTTPIngressPath {
  backend: IngressBackend;
  path?: string;
  pathType: "Exact" | "ImplementationSpecific" | "Prefix";
}
export interface HTTPIngressRuleValue {
  paths: HTTPIngressPath[];
}
export interface IPBlock {
  cidr: string;
  except?: string[];
}
export interface NetworkingK8sIoV1Ingress {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: IngressSpec;
  status?: IngressStatus;
}
export interface IngressBackend {
  resource?: TypedLocalObjectReference;
  service?: IngressServiceBackend;
}
export interface NetworkingK8sIoV1IngressClass {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: IngressClassSpec;
}
export interface NetworkingK8sIoV1IngressClassList {
  apiVersion?: string;
  items: NetworkingK8sIoV1IngressClass[];
  kind?: string;
  metadata?: ListMeta;
}
export interface IngressClassParametersReference {
  apiGroup?: string;
  kind: string;
  name: string;
  namespace?: string;
  scope?: string;
}
export interface IngressClassSpec {
  controller?: string;
  parameters?: IngressClassParametersReference;
}
export interface NetworkingK8sIoV1IngressList {
  apiVersion?: string;
  items: NetworkingK8sIoV1Ingress[];
  kind?: string;
  metadata?: ListMeta;
}
export interface IngressLoadBalancerIngress {
  hostname?: string;
  ip?: string;
  ports?: IngressPortStatus[];
}
export interface IngressLoadBalancerStatus {
  ingress?: IngressLoadBalancerIngress[];
}
export interface IngressPortStatus {
  error?: string;
  port: number;
  protocol: "SCTP" | "TCP" | "UDP";
}
export interface IngressRule {
  host?: string;
  http?: HTTPIngressRuleValue;
}
export interface IngressServiceBackend {
  name: string;
  port?: ServiceBackendPort;
}
export interface IngressSpec {
  defaultBackend?: IngressBackend;
  ingressClassName?: string;
  rules?: IngressRule[];
  tls?: IngressTLS[];
}
export interface IngressStatus {
  loadBalancer?: IngressLoadBalancerStatus;
}
export interface IngressTLS {
  hosts?: string[];
  secretName?: string;
}
export interface NetworkingK8sIoV1NetworkPolicy {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: NetworkPolicySpec;
}
export interface NetworkPolicyEgressRule {
  ports?: NetworkPolicyPort[];
  to?: NetworkPolicyPeer[];
}
export interface NetworkPolicyIngressRule {
  from?: NetworkPolicyPeer[];
  ports?: NetworkPolicyPort[];
}
export interface NetworkingK8sIoV1NetworkPolicyList {
  apiVersion?: string;
  items: NetworkingK8sIoV1NetworkPolicy[];
  kind?: string;
  metadata?: ListMeta;
}
export interface NetworkPolicyPeer {
  ipBlock?: IPBlock;
  namespaceSelector?: LabelSelector;
  podSelector?: LabelSelector;
}
export interface NetworkPolicyPort {
  endPort?: number;
  port?: IntOrString;
  protocol?: "SCTP" | "TCP" | "UDP";
}
export interface NetworkPolicySpec {
  egress?: NetworkPolicyEgressRule[];
  ingress?: NetworkPolicyIngressRule[];
  podSelector: LabelSelector;
  policyTypes?: ("Egress" | "Ingress")[];
}
export interface ServiceBackendPort {
  name?: string;
  number?: number;
}
export interface Overhead {
  podFixed?: {
    [key: string]: unknown;
  };
}
export interface NodeK8sIoV1RuntimeClass {
  apiVersion?: string;
  handler: string;
  kind?: string;
  metadata?: ObjectMeta;
  overhead?: Overhead;
  scheduling?: Scheduling;
}
export interface NodeK8sIoV1RuntimeClassList {
  apiVersion?: string;
  items: NodeK8sIoV1RuntimeClass[];
  kind?: string;
  metadata?: ListMeta;
}
export interface Scheduling {
  nodeSelector?: {
    [key: string]: unknown;
  };
  tolerations?: Toleration[];
}
export interface PolicyV1Eviction {
  apiVersion?: string;
  deleteOptions?: DeleteOptions;
  kind?: string;
  metadata?: ObjectMeta;
}
export interface PolicyV1PodDisruptionBudget {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: PodDisruptionBudgetSpec;
  status?: PodDisruptionBudgetStatus;
}
export interface PolicyV1PodDisruptionBudgetList {
  apiVersion?: string;
  items: PolicyV1PodDisruptionBudget[];
  kind?: string;
  metadata?: ListMeta;
}
export interface PodDisruptionBudgetSpec {
  maxUnavailable?: IntOrString;
  minAvailable?: IntOrString;
  selector?: LabelSelector;
  unhealthyPodEvictionPolicy?: "AlwaysAllow" | "IfHealthyBudget";
}
export interface PodDisruptionBudgetStatus {
  conditions?: Condition[];
  currentHealthy: number;
  desiredHealthy: number;
  disruptedPods?: {
    [key: string]: unknown;
  };
  disruptionsAllowed: number;
  expectedPods: number;
  observedGeneration?: number;
}
export interface AggregationRule {
  clusterRoleSelectors?: LabelSelector[];
}
export interface RbacAuthorizationK8sIoV1ClusterRole {
  aggregationRule?: AggregationRule;
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  rules?: PolicyRule[];
}
export interface RbacAuthorizationK8sIoV1ClusterRoleBinding {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  roleRef: RoleRef;
  subjects?: IoK8sApiRbacV1Subject[];
}
export interface RbacAuthorizationK8sIoV1ClusterRoleBindingList {
  apiVersion?: string;
  items: RbacAuthorizationK8sIoV1ClusterRoleBinding[];
  kind?: string;
  metadata?: ListMeta;
}
export interface RbacAuthorizationK8sIoV1ClusterRoleList {
  apiVersion?: string;
  items: RbacAuthorizationK8sIoV1ClusterRole[];
  kind?: string;
  metadata?: ListMeta;
}
export interface PolicyRule {
  apiGroups?: string[];
  nonResourceURLs?: string[];
  resourceNames?: string[];
  resources?: string[];
  verbs: string[];
}
export interface RbacAuthorizationK8sIoV1Role {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  rules?: PolicyRule[];
}
export interface RbacAuthorizationK8sIoV1RoleBinding {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  roleRef: RoleRef;
  subjects?: IoK8sApiRbacV1Subject[];
}
export interface RbacAuthorizationK8sIoV1RoleBindingList {
  apiVersion?: string;
  items: RbacAuthorizationK8sIoV1RoleBinding[];
  kind?: string;
  metadata?: ListMeta;
}
export interface RbacAuthorizationK8sIoV1RoleList {
  apiVersion?: string;
  items: RbacAuthorizationK8sIoV1Role[];
  kind?: string;
  metadata?: ListMeta;
}
export interface RoleRef {
  apiGroup: string;
  kind: string;
  name: string;
}
export interface IoK8sApiRbacV1Subject {
  apiGroup?: string;
  kind: string;
  name: string;
  namespace?: string;
}
export interface SchedulingK8sIoV1PriorityClass {
  apiVersion?: string;
  description?: string;
  globalDefault?: boolean;
  kind?: string;
  metadata?: ObjectMeta;
  preemptionPolicy?: "Never" | "PreemptLowerPriority";
  value: number;
}
export interface SchedulingK8sIoV1PriorityClassList {
  apiVersion?: string;
  items: SchedulingK8sIoV1PriorityClass[];
  kind?: string;
  metadata?: ListMeta;
}
export interface StorageK8sIoV1CSIDriver {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec: CSIDriverSpec;
}
export interface StorageK8sIoV1CSIDriverList {
  apiVersion?: string;
  items: StorageK8sIoV1CSIDriver[];
  kind?: string;
  metadata?: ListMeta;
}
export interface CSIDriverSpec {
  attachRequired?: boolean;
  fsGroupPolicy?: string;
  podInfoOnMount?: boolean;
  requiresRepublish?: boolean;
  seLinuxMount?: boolean;
  storageCapacity?: boolean;
  tokenRequests?: IoK8sApiStorageV1TokenRequest[];
  volumeLifecycleModes?: string[];
}
export interface StorageK8sIoV1CSINode {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec: CSINodeSpec;
}
export interface CSINodeDriver {
  allocatable?: VolumeNodeResources;
  name: string;
  nodeID: string;
  topologyKeys?: string[];
}
export interface StorageK8sIoV1CSINodeList {
  apiVersion?: string;
  items: StorageK8sIoV1CSINode[];
  kind?: string;
  metadata?: ListMeta;
}
export interface CSINodeSpec {
  drivers: CSINodeDriver[];
}
export interface StorageK8sIoV1CSIStorageCapacity {
  apiVersion?: string;
  capacity?: Quantity;
  kind?: string;
  maximumVolumeSize?: Quantity;
  metadata?: ObjectMeta;
  nodeTopology?: LabelSelector;
  storageClassName: string;
}
export interface StorageK8sIoV1CSIStorageCapacityList {
  apiVersion?: string;
  items: StorageK8sIoV1CSIStorageCapacity[];
  kind?: string;
  metadata?: ListMeta;
}
export interface StorageK8sIoV1StorageClass {
  allowVolumeExpansion?: boolean;
  allowedTopologies?: TopologySelectorTerm[];
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  mountOptions?: string[];
  parameters?: {
    [key: string]: unknown;
  };
  provisioner: string;
  reclaimPolicy?: "Delete" | "Recycle" | "Retain";
  volumeBindingMode?: "Immediate" | "WaitForFirstConsumer";
}
export interface StorageK8sIoV1StorageClassList {
  apiVersion?: string;
  items: StorageK8sIoV1StorageClass[];
  kind?: string;
  metadata?: ListMeta;
}
export interface IoK8sApiStorageV1TokenRequest {
  audience: string;
  expirationSeconds?: number;
}
export interface StorageK8sIoV1VolumeAttachment {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec: VolumeAttachmentSpec;
  status?: VolumeAttachmentStatus;
}
export interface StorageK8sIoV1VolumeAttachmentList {
  apiVersion?: string;
  items: StorageK8sIoV1VolumeAttachment[];
  kind?: string;
  metadata?: ListMeta;
}
export interface VolumeAttachmentSource {
  inlineVolumeSpec?: PersistentVolumeSpec;
  persistentVolumeName?: string;
}
export interface VolumeAttachmentSpec {
  attacher: string;
  nodeName: string;
  source: VolumeAttachmentSource;
}
export interface VolumeAttachmentStatus {
  attachError?: VolumeError;
  attached: boolean;
  attachmentMetadata?: {
    [key: string]: unknown;
  };
  detachError?: VolumeError;
}
export interface VolumeError {
  message?: string;
  time?: Time;
}
export interface VolumeNodeResources {
  count?: number;
}
export interface CustomResourceColumnDefinition {
  description?: string;
  format?: string;
  jsonPath: string;
  name: string;
  priority?: number;
  type: string;
}
export interface CustomResourceConversion {
  strategy: string;
  webhook?: WebhookConversion;
}
export interface ApiextensionsK8sIoV1CustomResourceDefinition {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec: CustomResourceDefinitionSpec;
  status?: CustomResourceDefinitionStatus;
}
export interface CustomResourceDefinitionCondition {
  lastTransitionTime?: Time;
  message?: string;
  reason?: string;
  status: string;
  type: string;
}
export interface ApiextensionsK8sIoV1CustomResourceDefinitionList {
  apiVersion?: string;
  items: ApiextensionsK8sIoV1CustomResourceDefinition[];
  kind?: string;
  metadata?: ListMeta;
}
export interface CustomResourceDefinitionNames {
  categories?: string[];
  kind: string;
  listKind?: string;
  plural: string;
  shortNames?: string[];
  singular?: string;
}
export interface CustomResourceDefinitionSpec {
  conversion?: CustomResourceConversion;
  group: string;
  names: CustomResourceDefinitionNames;
  preserveUnknownFields?: boolean;
  scope: string;
  versions: CustomResourceDefinitionVersion[];
}
export interface CustomResourceDefinitionStatus {
  acceptedNames?: CustomResourceDefinitionNames;
  conditions?: CustomResourceDefinitionCondition[];
  storedVersions?: string[];
}
export interface CustomResourceDefinitionVersion {
  additionalPrinterColumns?: CustomResourceColumnDefinition[];
  deprecated?: boolean;
  deprecationWarning?: string;
  name: string;
  schema?: CustomResourceValidation;
  selectableFields?: SelectableField[];
  served: boolean;
  storage: boolean;
  subresources?: CustomResourceSubresources;
}
export interface CustomResourceSubresourceScale {
  labelSelectorPath?: string;
  specReplicasPath: string;
  statusReplicasPath: string;
}
export type CustomResourceSubresourceStatus = {
  [key: string]: unknown;
};
export interface CustomResourceSubresources {
  scale?: CustomResourceSubresourceScale;
  status?: CustomResourceSubresourceStatus;
}
export interface CustomResourceValidation {
  openAPIV3Schema?: JSONSchemaProps;
}
export interface ExternalDocumentation {
  description?: string;
  url?: string;
}
export type JSON = any;
export interface JSONSchemaProps {
  $ref?: string;
  $schema?: string;
  additionalItems?: JSONSchemaPropsOrBool;
  additionalProperties?: JSONSchemaPropsOrBool;
  allOf?: JSONSchemaProps[];
  anyOf?: JSONSchemaProps[];
  default?: JSON;
  definitions?: {
    [key: string]: unknown;
  };
  dependencies?: {
    [key: string]: unknown;
  };
  description?: string;
  enum?: JSON[];
  example?: JSON;
  exclusiveMaximum?: boolean;
  exclusiveMinimum?: boolean;
  externalDocs?: ExternalDocumentation;
  format?: string;
  id?: string;
  items?: JSONSchemaPropsOrArray;
  maxItems?: number;
  maxLength?: number;
  maxProperties?: number;
  maximum?: number;
  minItems?: number;
  minLength?: number;
  minProperties?: number;
  minimum?: number;
  multipleOf?: number;
  not?: JSONSchemaProps;
  nullable?: boolean;
  oneOf?: JSONSchemaProps[];
  pattern?: string;
  patternProperties?: {
    [key: string]: unknown;
  };
  properties?: {
    [key: string]: unknown;
  };
  required?: string[];
  title?: string;
  type?: string;
  uniqueItems?: boolean;
  "x-kubernetes-embedded-resource"?: boolean;
  "x-kubernetes-int-or-string"?: boolean;
  "x-kubernetes-list-map-keys"?: string[];
  "x-kubernetes-list-type"?: string;
  "x-kubernetes-map-type"?: string;
  "x-kubernetes-preserve-unknown-fields"?: boolean;
  "x-kubernetes-validations"?: ValidationRule[];
}
export type JSONSchemaPropsOrArray = any;
export type JSONSchemaPropsOrBool = any;
export type JSONSchemaPropsOrStringArray = any;
export interface SelectableField {
  jsonPath: string;
}
export interface IoK8sApiextensionsApiserverPkgApisApiextensionsV1ServiceReference {
  name: string;
  namespace: string;
  path?: string;
  port?: number;
}
export interface ValidationRule {
  fieldPath?: string;
  message?: string;
  messageExpression?: string;
  optionalOldSelf?: boolean;
  reason?: "FieldValueDuplicate" | "FieldValueForbidden" | "FieldValueInvalid" | "FieldValueRequired";
  rule: string;
}
export interface IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookClientConfig {
  caBundle?: string;
  service?: IoK8sApiextensionsApiserverPkgApisApiextensionsV1ServiceReference;
  url?: string;
}
export interface WebhookConversion {
  clientConfig?: IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookClientConfig;
  conversionReviewVersions: string[];
}
export type Quantity = string;
export interface APIGroup {
  apiVersion?: string;
  kind?: string;
  name: string;
  preferredVersion?: GroupVersionForDiscovery;
  serverAddressByClientCIDRs?: ServerAddressByClientCIDR[];
  versions: GroupVersionForDiscovery[];
}
export interface APIGroupList {
  apiVersion?: string;
  groups: APIGroup[];
  kind?: string;
}
export interface APIResource {
  categories?: string[];
  group?: string;
  kind: string;
  name: string;
  namespaced: boolean;
  shortNames?: string[];
  singularName: string;
  storageVersionHash?: string;
  verbs: string[];
  version?: string;
}
export interface APIResourceList {
  apiVersion?: string;
  groupVersion: string;
  kind?: string;
  resources: APIResource[];
}
export interface APIVersions {
  apiVersion?: string;
  kind?: string;
  serverAddressByClientCIDRs: ServerAddressByClientCIDR[];
  versions: string[];
}
export interface Condition {
  lastTransitionTime: Time;
  message: string;
  observedGeneration?: number;
  reason: string;
  status: string;
  type: string;
}
export interface DeleteOptions {
  apiVersion?: string;
  dryRun?: string[];
  gracePeriodSeconds?: number;
  ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
  kind?: string;
  orphanDependents?: boolean;
  preconditions?: Preconditions;
  propagationPolicy?: string;
}
export interface FieldSelectorRequirement {
  key: string;
  operator: string;
  values?: string[];
}
export type FieldsV1 = {
  [key: string]: unknown;
};
export interface GroupVersionForDiscovery {
  groupVersion: string;
  version: string;
}
export interface LabelSelector {
  matchExpressions?: LabelSelectorRequirement[];
  matchLabels?: {
    [key: string]: unknown;
  };
}
export interface LabelSelectorRequirement {
  key: string;
  operator: string;
  values?: string[];
}
export interface ListMeta {
  continue?: string;
  remainingItemCount?: number;
  resourceVersion?: string;
  selfLink?: string;
}
export interface ManagedFieldsEntry {
  apiVersion?: string;
  fieldsType?: string;
  fieldsV1?: FieldsV1;
  manager?: string;
  operation?: string;
  subresource?: string;
  time?: Time;
}
export type MicroTime = string;
export interface ObjectMeta {
  annotations?: {
    [key: string]: unknown;
  };
  creationTimestamp?: Time;
  deletionGracePeriodSeconds?: number;
  deletionTimestamp?: Time;
  finalizers?: string[];
  generateName?: string;
  generation?: number;
  labels?: {
    [key: string]: unknown;
  };
  managedFields?: ManagedFieldsEntry[];
  name?: string;
  namespace?: string;
  ownerReferences?: OwnerReference[];
  resourceVersion?: string;
  selfLink?: string;
  uid?: string;
}
export interface OwnerReference {
  apiVersion: string;
  blockOwnerDeletion?: boolean;
  controller?: boolean;
  kind: string;
  name: string;
  uid: string;
}
export type Patch = {
  [key: string]: unknown;
};
export interface Preconditions {
  resourceVersion?: string;
  uid?: string;
}
export interface ServerAddressByClientCIDR {
  clientCIDR: string;
  serverAddress: string;
}
export interface Status {
  apiVersion?: string;
  code?: number;
  details?: StatusDetails;
  kind?: string;
  message?: string;
  metadata?: ListMeta;
  reason?: string;
  status?: string;
}
export interface StatusCause {
  field?: string;
  message?: string;
  reason?: string;
}
export interface StatusDetails {
  causes?: StatusCause[];
  group?: string;
  kind?: string;
  name?: string;
  retryAfterSeconds?: number;
  uid?: string;
}
export type Time = string;
export interface WatchEvent {
  object: RawExtension;
  type: string;
}
export type RawExtension = {
  [key: string]: unknown;
};
export type IntOrString = string;
export interface Info {
  buildDate: string;
  compiler: string;
  gitCommit: string;
  gitTreeState: string;
  gitVersion: string;
  goVersion: string;
  major: string;
  minor: string;
  platform: string;
}
export interface ApiregistrationK8sIoV1APIService {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: APIServiceSpec;
  status?: APIServiceStatus;
}
export interface APIServiceCondition {
  lastTransitionTime?: Time;
  message?: string;
  reason?: string;
  status: string;
  type: string;
}
export interface ApiregistrationK8sIoV1APIServiceList {
  apiVersion?: string;
  items: ApiregistrationK8sIoV1APIService[];
  kind?: string;
  metadata?: ListMeta;
}
export interface APIServiceSpec {
  caBundle?: string;
  group?: string;
  groupPriorityMinimum: number;
  insecureSkipTLSVerify?: boolean;
  service?: IoK8sKubeAggregatorPkgApisApiregistrationV1ServiceReference;
  version?: string;
  versionPriority: number;
}
export interface APIServiceStatus {
  conditions?: APIServiceCondition[];
}
export interface IoK8sKubeAggregatorPkgApisApiregistrationV1ServiceReference {
  name?: string;
  namespace?: string;
  port?: number;
}
export interface GetServiceAccountIssuerOpenIDConfigurationRequest {}
export interface GetCoreAPIVersionsRequest {}
export interface GetCoreV1APIResourcesRequest {}
export interface ListCoreV1ComponentStatusRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ReadCoreV1ComponentStatusRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ListCoreV1ConfigMapForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListCoreV1EndpointsForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListCoreV1EventForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListCoreV1LimitRangeForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListCoreV1NamespaceRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface CreateCoreV1NamespaceRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  body: Namespace;
}
export interface CreateCoreV1NamespacedBindingRequest {
  query: {
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    pretty?: string;
  };
  path: {
    namespace: string;
  };
  body: Binding;
}
export interface ListCoreV1NamespacedConfigMapRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateCoreV1NamespacedConfigMapRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: ConfigMap;
}
export interface DeleteCoreV1CollectionNamespacedConfigMapRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadCoreV1NamespacedConfigMapRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceCoreV1NamespacedConfigMapRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: ConfigMap;
}
export interface DeleteCoreV1NamespacedConfigMapRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchCoreV1NamespacedConfigMapRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListCoreV1NamespacedEndpointsRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateCoreV1NamespacedEndpointsRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: Endpoints;
}
export interface DeleteCoreV1CollectionNamespacedEndpointsRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadCoreV1NamespacedEndpointsRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceCoreV1NamespacedEndpointsRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Endpoints;
}
export interface DeleteCoreV1NamespacedEndpointsRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchCoreV1NamespacedEndpointsRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListCoreV1NamespacedEventRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateCoreV1NamespacedEventRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: Event;
}
export interface DeleteCoreV1CollectionNamespacedEventRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadCoreV1NamespacedEventRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceCoreV1NamespacedEventRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Event;
}
export interface DeleteCoreV1NamespacedEventRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchCoreV1NamespacedEventRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListCoreV1NamespacedLimitRangeRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateCoreV1NamespacedLimitRangeRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: LimitRange;
}
export interface DeleteCoreV1CollectionNamespacedLimitRangeRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadCoreV1NamespacedLimitRangeRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceCoreV1NamespacedLimitRangeRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: LimitRange;
}
export interface DeleteCoreV1NamespacedLimitRangeRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchCoreV1NamespacedLimitRangeRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListCoreV1NamespacedPersistentVolumeClaimRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateCoreV1NamespacedPersistentVolumeClaimRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: PersistentVolumeClaim;
}
export interface DeleteCoreV1CollectionNamespacedPersistentVolumeClaimRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadCoreV1NamespacedPersistentVolumeClaimRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceCoreV1NamespacedPersistentVolumeClaimRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: PersistentVolumeClaim;
}
export interface DeleteCoreV1NamespacedPersistentVolumeClaimRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchCoreV1NamespacedPersistentVolumeClaimRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadCoreV1NamespacedPersistentVolumeClaimStatusRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceCoreV1NamespacedPersistentVolumeClaimStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: PersistentVolumeClaim;
}
export interface PatchCoreV1NamespacedPersistentVolumeClaimStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListCoreV1NamespacedPodRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateCoreV1NamespacedPodRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: Pod;
}
export interface DeleteCoreV1CollectionNamespacedPodRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadCoreV1NamespacedPodRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceCoreV1NamespacedPodRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Pod;
}
export interface DeleteCoreV1NamespacedPodRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchCoreV1NamespacedPodRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ConnectCoreV1GetNamespacedPodAttachRequest {
  query: {
    container?: string;
    stderr?: boolean;
    stdin?: boolean;
    stdout?: boolean;
    tty?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ConnectCoreV1PostNamespacedPodAttachRequest {
  query: {
    container?: string;
    stderr?: boolean;
    stdin?: boolean;
    stdout?: boolean;
    tty?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface CreateCoreV1NamespacedPodBindingRequest {
  query: {
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Binding;
}
export interface ReadCoreV1NamespacedPodEphemeralcontainersRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceCoreV1NamespacedPodEphemeralcontainersRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Pod;
}
export interface PatchCoreV1NamespacedPodEphemeralcontainersRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface CreateCoreV1NamespacedPodEvictionRequest {
  query: {
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: PolicyV1Eviction;
}
export interface ConnectCoreV1GetNamespacedPodExecRequest {
  query: {
    command?: string;
    container?: string;
    stderr?: boolean;
    stdin?: boolean;
    stdout?: boolean;
    tty?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ConnectCoreV1PostNamespacedPodExecRequest {
  query: {
    command?: string;
    container?: string;
    stderr?: boolean;
    stdin?: boolean;
    stdout?: boolean;
    tty?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReadCoreV1NamespacedPodLogRequest {
  query: {
    container?: string;
    follow?: boolean;
    insecureSkipTLSVerifyBackend?: boolean;
    limitBytes?: number;
    pretty?: string;
    previous?: boolean;
    sinceSeconds?: number;
    stream?: string;
    tailLines?: number;
    timestamps?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ConnectCoreV1GetNamespacedPodPortforwardRequest {
  query: {
    ports?: number;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ConnectCoreV1PostNamespacedPodPortforwardRequest {
  query: {
    ports?: number;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ConnectCoreV1GetNamespacedPodProxyRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ConnectCoreV1PostNamespacedPodProxyRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ConnectCoreV1PutNamespacedPodProxyRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ConnectCoreV1DeleteNamespacedPodProxyRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ConnectCoreV1PatchNamespacedPodProxyRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ConnectCoreV1GetNamespacedPodProxyWithPathRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
    namespace: string;
    path: string;
  };
}
export interface ConnectCoreV1PostNamespacedPodProxyWithPathRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
    namespace: string;
    path: string;
  };
}
export interface ConnectCoreV1PutNamespacedPodProxyWithPathRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
    namespace: string;
    path: string;
  };
}
export interface ConnectCoreV1DeleteNamespacedPodProxyWithPathRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
    namespace: string;
    path: string;
  };
}
export interface ConnectCoreV1PatchNamespacedPodProxyWithPathRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
    namespace: string;
    path: string;
  };
}
export interface ReadCoreV1NamespacedPodStatusRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceCoreV1NamespacedPodStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Pod;
}
export interface PatchCoreV1NamespacedPodStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListCoreV1NamespacedPodTemplateRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateCoreV1NamespacedPodTemplateRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: PodTemplate;
}
export interface DeleteCoreV1CollectionNamespacedPodTemplateRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadCoreV1NamespacedPodTemplateRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceCoreV1NamespacedPodTemplateRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: PodTemplate;
}
export interface DeleteCoreV1NamespacedPodTemplateRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchCoreV1NamespacedPodTemplateRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListCoreV1NamespacedReplicationControllerRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateCoreV1NamespacedReplicationControllerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: ReplicationController;
}
export interface DeleteCoreV1CollectionNamespacedReplicationControllerRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadCoreV1NamespacedReplicationControllerRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceCoreV1NamespacedReplicationControllerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: ReplicationController;
}
export interface DeleteCoreV1NamespacedReplicationControllerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchCoreV1NamespacedReplicationControllerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadCoreV1NamespacedReplicationControllerScaleRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceCoreV1NamespacedReplicationControllerScaleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AutoscalingV1Scale;
}
export interface PatchCoreV1NamespacedReplicationControllerScaleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadCoreV1NamespacedReplicationControllerStatusRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceCoreV1NamespacedReplicationControllerStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: ReplicationController;
}
export interface PatchCoreV1NamespacedReplicationControllerStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListCoreV1NamespacedResourceQuotaRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateCoreV1NamespacedResourceQuotaRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: ResourceQuota;
}
export interface DeleteCoreV1CollectionNamespacedResourceQuotaRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadCoreV1NamespacedResourceQuotaRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceCoreV1NamespacedResourceQuotaRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: ResourceQuota;
}
export interface DeleteCoreV1NamespacedResourceQuotaRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchCoreV1NamespacedResourceQuotaRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadCoreV1NamespacedResourceQuotaStatusRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceCoreV1NamespacedResourceQuotaStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: ResourceQuota;
}
export interface PatchCoreV1NamespacedResourceQuotaStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListCoreV1NamespacedSecretRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateCoreV1NamespacedSecretRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: Secret;
}
export interface DeleteCoreV1CollectionNamespacedSecretRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadCoreV1NamespacedSecretRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceCoreV1NamespacedSecretRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Secret;
}
export interface DeleteCoreV1NamespacedSecretRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchCoreV1NamespacedSecretRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListCoreV1NamespacedServiceAccountRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateCoreV1NamespacedServiceAccountRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: ServiceAccount;
}
export interface DeleteCoreV1CollectionNamespacedServiceAccountRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadCoreV1NamespacedServiceAccountRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceCoreV1NamespacedServiceAccountRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: ServiceAccount;
}
export interface DeleteCoreV1NamespacedServiceAccountRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchCoreV1NamespacedServiceAccountRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface CreateCoreV1NamespacedServiceAccountTokenRequest {
  query: {
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AuthenticationK8sIoV1TokenRequest;
}
export interface ListCoreV1NamespacedServiceRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateCoreV1NamespacedServiceRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: Service;
}
export interface DeleteCoreV1CollectionNamespacedServiceRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadCoreV1NamespacedServiceRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceCoreV1NamespacedServiceRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Service;
}
export interface DeleteCoreV1NamespacedServiceRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchCoreV1NamespacedServiceRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ConnectCoreV1GetNamespacedServiceProxyRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ConnectCoreV1PostNamespacedServiceProxyRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ConnectCoreV1PutNamespacedServiceProxyRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ConnectCoreV1DeleteNamespacedServiceProxyRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ConnectCoreV1PatchNamespacedServiceProxyRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ConnectCoreV1GetNamespacedServiceProxyWithPathRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
    namespace: string;
    path: string;
  };
}
export interface ConnectCoreV1PostNamespacedServiceProxyWithPathRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
    namespace: string;
    path: string;
  };
}
export interface ConnectCoreV1PutNamespacedServiceProxyWithPathRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
    namespace: string;
    path: string;
  };
}
export interface ConnectCoreV1DeleteNamespacedServiceProxyWithPathRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
    namespace: string;
    path: string;
  };
}
export interface ConnectCoreV1PatchNamespacedServiceProxyWithPathRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
    namespace: string;
    path: string;
  };
}
export interface ReadCoreV1NamespacedServiceStatusRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceCoreV1NamespacedServiceStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Service;
}
export interface PatchCoreV1NamespacedServiceStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadCoreV1NamespaceRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceCoreV1NamespaceRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: Namespace;
}
export interface DeleteCoreV1NamespaceRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
  };
}
export interface PatchCoreV1NamespaceRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface ReplaceCoreV1NamespaceFinalizeRequest {
  query: {
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    pretty?: string;
  };
  path: {
    name: string;
  };
  body: Namespace;
}
export interface ReadCoreV1NamespaceStatusRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceCoreV1NamespaceStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: Namespace;
}
export interface PatchCoreV1NamespaceStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface ListCoreV1NodeRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface CreateCoreV1NodeRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  body: Node;
}
export interface DeleteCoreV1CollectionNodeRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
}
export interface ReadCoreV1NodeRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceCoreV1NodeRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: Node;
}
export interface DeleteCoreV1NodeRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
  };
}
export interface PatchCoreV1NodeRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface ConnectCoreV1GetNodeProxyRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
  };
}
export interface ConnectCoreV1PostNodeProxyRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
  };
}
export interface ConnectCoreV1PutNodeProxyRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
  };
}
export interface ConnectCoreV1DeleteNodeProxyRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
  };
}
export interface ConnectCoreV1PatchNodeProxyRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
  };
}
export interface ConnectCoreV1GetNodeProxyWithPathRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
    path: string;
  };
}
export interface ConnectCoreV1PostNodeProxyWithPathRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
    path: string;
  };
}
export interface ConnectCoreV1PutNodeProxyWithPathRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
    path: string;
  };
}
export interface ConnectCoreV1DeleteNodeProxyWithPathRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
    path: string;
  };
}
export interface ConnectCoreV1PatchNodeProxyWithPathRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
    path: string;
  };
}
export interface ReadCoreV1NodeStatusRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceCoreV1NodeStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: Node;
}
export interface PatchCoreV1NodeStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface ListCoreV1PersistentVolumeClaimForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListCoreV1PersistentVolumeRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface CreateCoreV1PersistentVolumeRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  body: PersistentVolume;
}
export interface DeleteCoreV1CollectionPersistentVolumeRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
}
export interface ReadCoreV1PersistentVolumeRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceCoreV1PersistentVolumeRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: PersistentVolume;
}
export interface DeleteCoreV1PersistentVolumeRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
  };
}
export interface PatchCoreV1PersistentVolumeRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface ReadCoreV1PersistentVolumeStatusRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceCoreV1PersistentVolumeStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: PersistentVolume;
}
export interface PatchCoreV1PersistentVolumeStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface ListCoreV1PodForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListCoreV1PodTemplateForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListCoreV1ReplicationControllerForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListCoreV1ResourceQuotaForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListCoreV1SecretForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListCoreV1ServiceAccountForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListCoreV1ServiceForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchCoreV1ConfigMapListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchCoreV1EndpointsListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchCoreV1EventListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchCoreV1LimitRangeListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchCoreV1NamespaceListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchCoreV1NamespacedConfigMapListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchCoreV1NamespacedConfigMapRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface WatchCoreV1NamespacedEndpointsListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchCoreV1NamespacedEndpointsRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface WatchCoreV1NamespacedEventListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchCoreV1NamespacedEventRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface WatchCoreV1NamespacedLimitRangeListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchCoreV1NamespacedLimitRangeRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface WatchCoreV1NamespacedPersistentVolumeClaimListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchCoreV1NamespacedPersistentVolumeClaimRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface WatchCoreV1NamespacedPodListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchCoreV1NamespacedPodRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface WatchCoreV1NamespacedPodTemplateListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchCoreV1NamespacedPodTemplateRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface WatchCoreV1NamespacedReplicationControllerListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchCoreV1NamespacedReplicationControllerRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface WatchCoreV1NamespacedResourceQuotaListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchCoreV1NamespacedResourceQuotaRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface WatchCoreV1NamespacedSecretListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchCoreV1NamespacedSecretRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface WatchCoreV1NamespacedServiceAccountListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchCoreV1NamespacedServiceAccountRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface WatchCoreV1NamespacedServiceListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchCoreV1NamespacedServiceRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface WatchCoreV1NamespaceRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
  };
}
export interface WatchCoreV1NodeListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchCoreV1NodeRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
  };
}
export interface WatchCoreV1PersistentVolumeClaimListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchCoreV1PersistentVolumeListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchCoreV1PersistentVolumeRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
  };
}
export interface WatchCoreV1PodListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchCoreV1PodTemplateListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchCoreV1ReplicationControllerListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchCoreV1ResourceQuotaListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchCoreV1SecretListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchCoreV1ServiceAccountListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchCoreV1ServiceListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface GetAPIVersionsRequest {}
export interface ListAcmeCertManagerIoV1ChallengeForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListAcmeCertManagerIoV1NamespacedChallengeRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateAcmeCertManagerIoV1NamespacedChallengeRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: AcmeCertManagerIoV1Challenge;
}
export interface DeleteAcmeCertManagerIoV1CollectionNamespacedChallengeRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadAcmeCertManagerIoV1NamespacedChallengeRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceAcmeCertManagerIoV1NamespacedChallengeRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AcmeCertManagerIoV1Challenge;
}
export interface DeleteAcmeCertManagerIoV1NamespacedChallengeRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchAcmeCertManagerIoV1NamespacedChallengeRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadAcmeCertManagerIoV1NamespacedChallengeStatusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceAcmeCertManagerIoV1NamespacedChallengeStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AcmeCertManagerIoV1Challenge;
}
export interface PatchAcmeCertManagerIoV1NamespacedChallengeStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListAcmeCertManagerIoV1NamespacedOrderRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateAcmeCertManagerIoV1NamespacedOrderRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: AcmeCertManagerIoV1Order;
}
export interface DeleteAcmeCertManagerIoV1CollectionNamespacedOrderRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadAcmeCertManagerIoV1NamespacedOrderRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceAcmeCertManagerIoV1NamespacedOrderRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AcmeCertManagerIoV1Order;
}
export interface DeleteAcmeCertManagerIoV1NamespacedOrderRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchAcmeCertManagerIoV1NamespacedOrderRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadAcmeCertManagerIoV1NamespacedOrderStatusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceAcmeCertManagerIoV1NamespacedOrderStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AcmeCertManagerIoV1Order;
}
export interface PatchAcmeCertManagerIoV1NamespacedOrderStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListAcmeCertManagerIoV1OrderForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface GetAdmissionregistrationAPIGroupRequest {}
export interface GetAdmissionregistrationV1APIResourcesRequest {}
export interface ListAdmissionregistrationV1MutatingWebhookConfigurationRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface CreateAdmissionregistrationV1MutatingWebhookConfigurationRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  body: AdmissionregistrationK8sIoV1MutatingWebhookConfiguration;
}
export interface DeleteAdmissionregistrationV1CollectionMutatingWebhookConfigurationRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
}
export interface ReadAdmissionregistrationV1MutatingWebhookConfigurationRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceAdmissionregistrationV1MutatingWebhookConfigurationRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: AdmissionregistrationK8sIoV1MutatingWebhookConfiguration;
}
export interface DeleteAdmissionregistrationV1MutatingWebhookConfigurationRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
  };
}
export interface PatchAdmissionregistrationV1MutatingWebhookConfigurationRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface ListAdmissionregistrationV1ValidatingAdmissionPolicyRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface CreateAdmissionregistrationV1ValidatingAdmissionPolicyRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  body: AdmissionregistrationK8sIoV1ValidatingAdmissionPolicy;
}
export interface DeleteAdmissionregistrationV1CollectionValidatingAdmissionPolicyRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
}
export interface ReadAdmissionregistrationV1ValidatingAdmissionPolicyRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceAdmissionregistrationV1ValidatingAdmissionPolicyRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: AdmissionregistrationK8sIoV1ValidatingAdmissionPolicy;
}
export interface DeleteAdmissionregistrationV1ValidatingAdmissionPolicyRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
  };
}
export interface PatchAdmissionregistrationV1ValidatingAdmissionPolicyRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface ReadAdmissionregistrationV1ValidatingAdmissionPolicyStatusRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceAdmissionregistrationV1ValidatingAdmissionPolicyStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: AdmissionregistrationK8sIoV1ValidatingAdmissionPolicy;
}
export interface PatchAdmissionregistrationV1ValidatingAdmissionPolicyStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface ListAdmissionregistrationV1ValidatingAdmissionPolicyBindingRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface CreateAdmissionregistrationV1ValidatingAdmissionPolicyBindingRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  body: AdmissionregistrationK8sIoV1ValidatingAdmissionPolicyBinding;
}
export interface DeleteAdmissionregistrationV1CollectionValidatingAdmissionPolicyBindingRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
}
export interface ReadAdmissionregistrationV1ValidatingAdmissionPolicyBindingRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceAdmissionregistrationV1ValidatingAdmissionPolicyBindingRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: AdmissionregistrationK8sIoV1ValidatingAdmissionPolicyBinding;
}
export interface DeleteAdmissionregistrationV1ValidatingAdmissionPolicyBindingRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
  };
}
export interface PatchAdmissionregistrationV1ValidatingAdmissionPolicyBindingRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface ListAdmissionregistrationV1ValidatingWebhookConfigurationRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface CreateAdmissionregistrationV1ValidatingWebhookConfigurationRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  body: AdmissionregistrationK8sIoV1ValidatingWebhookConfiguration;
}
export interface DeleteAdmissionregistrationV1CollectionValidatingWebhookConfigurationRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
}
export interface ReadAdmissionregistrationV1ValidatingWebhookConfigurationRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceAdmissionregistrationV1ValidatingWebhookConfigurationRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: AdmissionregistrationK8sIoV1ValidatingWebhookConfiguration;
}
export interface DeleteAdmissionregistrationV1ValidatingWebhookConfigurationRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
  };
}
export interface PatchAdmissionregistrationV1ValidatingWebhookConfigurationRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface WatchAdmissionregistrationV1MutatingWebhookConfigurationListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchAdmissionregistrationV1MutatingWebhookConfigurationRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
  };
}
export interface WatchAdmissionregistrationV1ValidatingAdmissionPolicyListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchAdmissionregistrationV1ValidatingAdmissionPolicyRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
  };
}
export interface WatchAdmissionregistrationV1ValidatingAdmissionPolicyBindingListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchAdmissionregistrationV1ValidatingAdmissionPolicyBindingRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
  };
}
export interface WatchAdmissionregistrationV1ValidatingWebhookConfigurationListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchAdmissionregistrationV1ValidatingWebhookConfigurationRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
  };
}
export interface GetApiextensionsAPIGroupRequest {}
export interface GetApiextensionsV1APIResourcesRequest {}
export interface ListApiextensionsV1CustomResourceDefinitionRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface CreateApiextensionsV1CustomResourceDefinitionRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  body: ApiextensionsK8sIoV1CustomResourceDefinition;
}
export interface DeleteApiextensionsV1CollectionCustomResourceDefinitionRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
}
export interface ReadApiextensionsV1CustomResourceDefinitionRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceApiextensionsV1CustomResourceDefinitionRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: ApiextensionsK8sIoV1CustomResourceDefinition;
}
export interface DeleteApiextensionsV1CustomResourceDefinitionRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
  };
}
export interface PatchApiextensionsV1CustomResourceDefinitionRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface ReadApiextensionsV1CustomResourceDefinitionStatusRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceApiextensionsV1CustomResourceDefinitionStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: ApiextensionsK8sIoV1CustomResourceDefinition;
}
export interface PatchApiextensionsV1CustomResourceDefinitionStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface WatchApiextensionsV1CustomResourceDefinitionListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchApiextensionsV1CustomResourceDefinitionRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
  };
}
export interface GetApiregistrationAPIGroupRequest {}
export interface GetApiregistrationV1APIResourcesRequest {}
export interface ListApiregistrationV1APIServiceRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface CreateApiregistrationV1APIServiceRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  body: ApiregistrationK8sIoV1APIService;
}
export interface DeleteApiregistrationV1CollectionAPIServiceRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
}
export interface ReadApiregistrationV1APIServiceRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceApiregistrationV1APIServiceRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: ApiregistrationK8sIoV1APIService;
}
export interface DeleteApiregistrationV1APIServiceRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
  };
}
export interface PatchApiregistrationV1APIServiceRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface ReadApiregistrationV1APIServiceStatusRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceApiregistrationV1APIServiceStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: ApiregistrationK8sIoV1APIService;
}
export interface PatchApiregistrationV1APIServiceStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface WatchApiregistrationV1APIServiceListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchApiregistrationV1APIServiceRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
  };
}
export interface GetAppsAPIGroupRequest {}
export interface GetAppsV1APIResourcesRequest {}
export interface ListAppsV1ControllerRevisionForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListAppsV1DaemonSetForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListAppsV1DeploymentForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListAppsV1NamespacedControllerRevisionRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateAppsV1NamespacedControllerRevisionRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: AppsV1ControllerRevision;
}
export interface DeleteAppsV1CollectionNamespacedControllerRevisionRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadAppsV1NamespacedControllerRevisionRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceAppsV1NamespacedControllerRevisionRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AppsV1ControllerRevision;
}
export interface DeleteAppsV1NamespacedControllerRevisionRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchAppsV1NamespacedControllerRevisionRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListAppsV1NamespacedDaemonSetRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateAppsV1NamespacedDaemonSetRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: AppsV1DaemonSet;
}
export interface DeleteAppsV1CollectionNamespacedDaemonSetRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadAppsV1NamespacedDaemonSetRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceAppsV1NamespacedDaemonSetRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AppsV1DaemonSet;
}
export interface DeleteAppsV1NamespacedDaemonSetRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchAppsV1NamespacedDaemonSetRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadAppsV1NamespacedDaemonSetStatusRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceAppsV1NamespacedDaemonSetStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AppsV1DaemonSet;
}
export interface PatchAppsV1NamespacedDaemonSetStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListAppsV1NamespacedDeploymentRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateAppsV1NamespacedDeploymentRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: AppsV1Deployment;
}
export interface DeleteAppsV1CollectionNamespacedDeploymentRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadAppsV1NamespacedDeploymentRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceAppsV1NamespacedDeploymentRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AppsV1Deployment;
}
export interface DeleteAppsV1NamespacedDeploymentRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchAppsV1NamespacedDeploymentRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadAppsV1NamespacedDeploymentScaleRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceAppsV1NamespacedDeploymentScaleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AutoscalingV1Scale;
}
export interface PatchAppsV1NamespacedDeploymentScaleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadAppsV1NamespacedDeploymentStatusRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceAppsV1NamespacedDeploymentStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AppsV1Deployment;
}
export interface PatchAppsV1NamespacedDeploymentStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListAppsV1NamespacedReplicaSetRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateAppsV1NamespacedReplicaSetRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: AppsV1ReplicaSet;
}
export interface DeleteAppsV1CollectionNamespacedReplicaSetRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadAppsV1NamespacedReplicaSetRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceAppsV1NamespacedReplicaSetRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AppsV1ReplicaSet;
}
export interface DeleteAppsV1NamespacedReplicaSetRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchAppsV1NamespacedReplicaSetRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadAppsV1NamespacedReplicaSetScaleRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceAppsV1NamespacedReplicaSetScaleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AutoscalingV1Scale;
}
export interface PatchAppsV1NamespacedReplicaSetScaleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadAppsV1NamespacedReplicaSetStatusRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceAppsV1NamespacedReplicaSetStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AppsV1ReplicaSet;
}
export interface PatchAppsV1NamespacedReplicaSetStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListAppsV1NamespacedStatefulSetRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateAppsV1NamespacedStatefulSetRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: AppsV1StatefulSet;
}
export interface DeleteAppsV1CollectionNamespacedStatefulSetRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadAppsV1NamespacedStatefulSetRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceAppsV1NamespacedStatefulSetRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AppsV1StatefulSet;
}
export interface DeleteAppsV1NamespacedStatefulSetRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchAppsV1NamespacedStatefulSetRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadAppsV1NamespacedStatefulSetScaleRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceAppsV1NamespacedStatefulSetScaleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AutoscalingV1Scale;
}
export interface PatchAppsV1NamespacedStatefulSetScaleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadAppsV1NamespacedStatefulSetStatusRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceAppsV1NamespacedStatefulSetStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AppsV1StatefulSet;
}
export interface PatchAppsV1NamespacedStatefulSetStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListAppsV1ReplicaSetForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListAppsV1StatefulSetForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchAppsV1ControllerRevisionListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchAppsV1DaemonSetListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchAppsV1DeploymentListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchAppsV1NamespacedControllerRevisionListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchAppsV1NamespacedControllerRevisionRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface WatchAppsV1NamespacedDaemonSetListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchAppsV1NamespacedDaemonSetRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface WatchAppsV1NamespacedDeploymentListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchAppsV1NamespacedDeploymentRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface WatchAppsV1NamespacedReplicaSetListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchAppsV1NamespacedReplicaSetRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface WatchAppsV1NamespacedStatefulSetListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchAppsV1NamespacedStatefulSetRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface WatchAppsV1ReplicaSetListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchAppsV1StatefulSetListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface GetAuthenticationAPIGroupRequest {}
export interface GetAuthenticationV1APIResourcesRequest {}
export interface CreateAuthenticationV1SelfSubjectReviewRequest {
  query: {
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    pretty?: string;
  };
  body: AuthenticationK8sIoV1SelfSubjectReview;
}
export interface CreateAuthenticationV1TokenReviewRequest {
  query: {
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    pretty?: string;
  };
  body: AuthenticationK8sIoV1TokenReview;
}
export interface GetAuthorizationAPIGroupRequest {}
export interface GetAuthorizationV1APIResourcesRequest {}
export interface CreateAuthorizationV1NamespacedLocalSubjectAccessReviewRequest {
  query: {
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    pretty?: string;
  };
  path: {
    namespace: string;
  };
  body: AuthorizationK8sIoV1LocalSubjectAccessReview;
}
export interface CreateAuthorizationV1SelfSubjectAccessReviewRequest {
  query: {
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    pretty?: string;
  };
  body: AuthorizationK8sIoV1SelfSubjectAccessReview;
}
export interface CreateAuthorizationV1SelfSubjectRulesReviewRequest {
  query: {
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    pretty?: string;
  };
  body: AuthorizationK8sIoV1SelfSubjectRulesReview;
}
export interface CreateAuthorizationV1SubjectAccessReviewRequest {
  query: {
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    pretty?: string;
  };
  body: AuthorizationK8sIoV1SubjectAccessReview;
}
export interface ListAutoscalingInternalKnativeDevV1alpha1MetricForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListAutoscalingInternalKnativeDevV1alpha1NamespacedMetricRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateAutoscalingInternalKnativeDevV1alpha1NamespacedMetricRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: AutoscalingInternalKnativeDevV1alpha1Metric;
}
export interface DeleteAutoscalingInternalKnativeDevV1alpha1CollectionNamespacedMetricRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadAutoscalingInternalKnativeDevV1alpha1NamespacedMetricRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceAutoscalingInternalKnativeDevV1alpha1NamespacedMetricRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AutoscalingInternalKnativeDevV1alpha1Metric;
}
export interface DeleteAutoscalingInternalKnativeDevV1alpha1NamespacedMetricRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchAutoscalingInternalKnativeDevV1alpha1NamespacedMetricRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadAutoscalingInternalKnativeDevV1alpha1NamespacedMetricStatusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceAutoscalingInternalKnativeDevV1alpha1NamespacedMetricStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AutoscalingInternalKnativeDevV1alpha1Metric;
}
export interface PatchAutoscalingInternalKnativeDevV1alpha1NamespacedMetricStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListAutoscalingInternalKnativeDevV1alpha1NamespacedPodAutoscalerRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateAutoscalingInternalKnativeDevV1alpha1NamespacedPodAutoscalerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: AutoscalingInternalKnativeDevV1alpha1PodAutoscaler;
}
export interface DeleteAutoscalingInternalKnativeDevV1alpha1CollectionNamespacedPodAutoscalerRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadAutoscalingInternalKnativeDevV1alpha1NamespacedPodAutoscalerRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceAutoscalingInternalKnativeDevV1alpha1NamespacedPodAutoscalerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AutoscalingInternalKnativeDevV1alpha1PodAutoscaler;
}
export interface DeleteAutoscalingInternalKnativeDevV1alpha1NamespacedPodAutoscalerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchAutoscalingInternalKnativeDevV1alpha1NamespacedPodAutoscalerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadAutoscalingInternalKnativeDevV1alpha1NamespacedPodAutoscalerStatusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceAutoscalingInternalKnativeDevV1alpha1NamespacedPodAutoscalerStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AutoscalingInternalKnativeDevV1alpha1PodAutoscaler;
}
export interface PatchAutoscalingInternalKnativeDevV1alpha1NamespacedPodAutoscalerStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListAutoscalingInternalKnativeDevV1alpha1PodAutoscalerForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface GetAutoscalingAPIGroupRequest {}
export interface GetAutoscalingV1APIResourcesRequest {}
export interface ListAutoscalingV1HorizontalPodAutoscalerForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListAutoscalingV1NamespacedHorizontalPodAutoscalerRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateAutoscalingV1NamespacedHorizontalPodAutoscalerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: AutoscalingV1HorizontalPodAutoscaler;
}
export interface DeleteAutoscalingV1CollectionNamespacedHorizontalPodAutoscalerRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadAutoscalingV1NamespacedHorizontalPodAutoscalerRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceAutoscalingV1NamespacedHorizontalPodAutoscalerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AutoscalingV1HorizontalPodAutoscaler;
}
export interface DeleteAutoscalingV1NamespacedHorizontalPodAutoscalerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchAutoscalingV1NamespacedHorizontalPodAutoscalerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadAutoscalingV1NamespacedHorizontalPodAutoscalerStatusRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceAutoscalingV1NamespacedHorizontalPodAutoscalerStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AutoscalingV1HorizontalPodAutoscaler;
}
export interface PatchAutoscalingV1NamespacedHorizontalPodAutoscalerStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface WatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchAutoscalingV1NamespacedHorizontalPodAutoscalerListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchAutoscalingV1NamespacedHorizontalPodAutoscalerRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface GetAutoscalingV2APIResourcesRequest {}
export interface ListAutoscalingV2HorizontalPodAutoscalerForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListAutoscalingV2NamespacedHorizontalPodAutoscalerRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateAutoscalingV2NamespacedHorizontalPodAutoscalerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: AutoscalingV2HorizontalPodAutoscaler;
}
export interface DeleteAutoscalingV2CollectionNamespacedHorizontalPodAutoscalerRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadAutoscalingV2NamespacedHorizontalPodAutoscalerRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceAutoscalingV2NamespacedHorizontalPodAutoscalerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AutoscalingV2HorizontalPodAutoscaler;
}
export interface DeleteAutoscalingV2NamespacedHorizontalPodAutoscalerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchAutoscalingV2NamespacedHorizontalPodAutoscalerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadAutoscalingV2NamespacedHorizontalPodAutoscalerStatusRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceAutoscalingV2NamespacedHorizontalPodAutoscalerStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AutoscalingV2HorizontalPodAutoscaler;
}
export interface PatchAutoscalingV2NamespacedHorizontalPodAutoscalerStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface WatchAutoscalingV2HorizontalPodAutoscalerListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchAutoscalingV2NamespacedHorizontalPodAutoscalerListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchAutoscalingV2NamespacedHorizontalPodAutoscalerRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface GetBatchAPIGroupRequest {}
export interface GetBatchV1APIResourcesRequest {}
export interface ListBatchV1CronJobForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListBatchV1JobForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListBatchV1NamespacedCronJobRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateBatchV1NamespacedCronJobRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: BatchV1CronJob;
}
export interface DeleteBatchV1CollectionNamespacedCronJobRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadBatchV1NamespacedCronJobRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceBatchV1NamespacedCronJobRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: BatchV1CronJob;
}
export interface DeleteBatchV1NamespacedCronJobRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchBatchV1NamespacedCronJobRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadBatchV1NamespacedCronJobStatusRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceBatchV1NamespacedCronJobStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: BatchV1CronJob;
}
export interface PatchBatchV1NamespacedCronJobStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListBatchV1NamespacedJobRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateBatchV1NamespacedJobRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: BatchV1Job;
}
export interface DeleteBatchV1CollectionNamespacedJobRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadBatchV1NamespacedJobRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceBatchV1NamespacedJobRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: BatchV1Job;
}
export interface DeleteBatchV1NamespacedJobRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchBatchV1NamespacedJobRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadBatchV1NamespacedJobStatusRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceBatchV1NamespacedJobStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: BatchV1Job;
}
export interface PatchBatchV1NamespacedJobStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface WatchBatchV1CronJobListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchBatchV1JobListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchBatchV1NamespacedCronJobListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchBatchV1NamespacedCronJobRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface WatchBatchV1NamespacedJobListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchBatchV1NamespacedJobRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ListCachingInternalKnativeDevV1alpha1ImageForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListCachingInternalKnativeDevV1alpha1NamespacedImageRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateCachingInternalKnativeDevV1alpha1NamespacedImageRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: CachingInternalKnativeDevV1alpha1Image;
}
export interface DeleteCachingInternalKnativeDevV1alpha1CollectionNamespacedImageRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadCachingInternalKnativeDevV1alpha1NamespacedImageRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceCachingInternalKnativeDevV1alpha1NamespacedImageRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: CachingInternalKnativeDevV1alpha1Image;
}
export interface DeleteCachingInternalKnativeDevV1alpha1NamespacedImageRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchCachingInternalKnativeDevV1alpha1NamespacedImageRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadCachingInternalKnativeDevV1alpha1NamespacedImageStatusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceCachingInternalKnativeDevV1alpha1NamespacedImageStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: CachingInternalKnativeDevV1alpha1Image;
}
export interface PatchCachingInternalKnativeDevV1alpha1NamespacedImageStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListCertManagerIoV1CertificateRequestForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListCertManagerIoV1CertificateForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListCertManagerIoV1ClusterIssuerRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface CreateCertManagerIoV1ClusterIssuerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  body: CertManagerIoV1ClusterIssuer;
}
export interface DeleteCertManagerIoV1CollectionClusterIssuerRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ReadCertManagerIoV1ClusterIssuerRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceCertManagerIoV1ClusterIssuerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: CertManagerIoV1ClusterIssuer;
}
export interface DeleteCertManagerIoV1ClusterIssuerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
  };
}
export interface PatchCertManagerIoV1ClusterIssuerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface ReadCertManagerIoV1ClusterIssuerStatusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceCertManagerIoV1ClusterIssuerStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: CertManagerIoV1ClusterIssuer;
}
export interface PatchCertManagerIoV1ClusterIssuerStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface ListCertManagerIoV1IssuerForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListCertManagerIoV1NamespacedCertificateRequestRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateCertManagerIoV1NamespacedCertificateRequestRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: CertManagerIoV1CertificateRequest;
}
export interface DeleteCertManagerIoV1CollectionNamespacedCertificateRequestRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadCertManagerIoV1NamespacedCertificateRequestRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceCertManagerIoV1NamespacedCertificateRequestRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: CertManagerIoV1CertificateRequest;
}
export interface DeleteCertManagerIoV1NamespacedCertificateRequestRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchCertManagerIoV1NamespacedCertificateRequestRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadCertManagerIoV1NamespacedCertificateRequestStatusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceCertManagerIoV1NamespacedCertificateRequestStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: CertManagerIoV1CertificateRequest;
}
export interface PatchCertManagerIoV1NamespacedCertificateRequestStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListCertManagerIoV1NamespacedCertificateRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateCertManagerIoV1NamespacedCertificateRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: CertManagerIoV1Certificate;
}
export interface DeleteCertManagerIoV1CollectionNamespacedCertificateRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadCertManagerIoV1NamespacedCertificateRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceCertManagerIoV1NamespacedCertificateRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: CertManagerIoV1Certificate;
}
export interface DeleteCertManagerIoV1NamespacedCertificateRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchCertManagerIoV1NamespacedCertificateRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadCertManagerIoV1NamespacedCertificateStatusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceCertManagerIoV1NamespacedCertificateStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: CertManagerIoV1Certificate;
}
export interface PatchCertManagerIoV1NamespacedCertificateStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListCertManagerIoV1NamespacedIssuerRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateCertManagerIoV1NamespacedIssuerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: CertManagerIoV1Issuer;
}
export interface DeleteCertManagerIoV1CollectionNamespacedIssuerRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadCertManagerIoV1NamespacedIssuerRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceCertManagerIoV1NamespacedIssuerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: CertManagerIoV1Issuer;
}
export interface DeleteCertManagerIoV1NamespacedIssuerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchCertManagerIoV1NamespacedIssuerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadCertManagerIoV1NamespacedIssuerStatusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceCertManagerIoV1NamespacedIssuerStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: CertManagerIoV1Issuer;
}
export interface PatchCertManagerIoV1NamespacedIssuerStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface GetCertificatesAPIGroupRequest {}
export interface GetCertificatesV1APIResourcesRequest {}
export interface ListCertificatesV1CertificateSigningRequestRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface CreateCertificatesV1CertificateSigningRequestRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  body: CertificatesK8sIoV1CertificateSigningRequest;
}
export interface DeleteCertificatesV1CollectionCertificateSigningRequestRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
}
export interface ReadCertificatesV1CertificateSigningRequestRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceCertificatesV1CertificateSigningRequestRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: CertificatesK8sIoV1CertificateSigningRequest;
}
export interface DeleteCertificatesV1CertificateSigningRequestRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
  };
}
export interface PatchCertificatesV1CertificateSigningRequestRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface ReadCertificatesV1CertificateSigningRequestApprovalRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceCertificatesV1CertificateSigningRequestApprovalRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: CertificatesK8sIoV1CertificateSigningRequest;
}
export interface PatchCertificatesV1CertificateSigningRequestApprovalRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface ReadCertificatesV1CertificateSigningRequestStatusRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceCertificatesV1CertificateSigningRequestStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: CertificatesK8sIoV1CertificateSigningRequest;
}
export interface PatchCertificatesV1CertificateSigningRequestStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface WatchCertificatesV1CertificateSigningRequestListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchCertificatesV1CertificateSigningRequestRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
  };
}
export interface GetCoordinationAPIGroupRequest {}
export interface GetCoordinationV1APIResourcesRequest {}
export interface ListCoordinationV1LeaseForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListCoordinationV1NamespacedLeaseRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateCoordinationV1NamespacedLeaseRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: CoordinationK8sIoV1Lease;
}
export interface DeleteCoordinationV1CollectionNamespacedLeaseRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadCoordinationV1NamespacedLeaseRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceCoordinationV1NamespacedLeaseRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: CoordinationK8sIoV1Lease;
}
export interface DeleteCoordinationV1NamespacedLeaseRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchCoordinationV1NamespacedLeaseRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface WatchCoordinationV1LeaseListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchCoordinationV1NamespacedLeaseListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchCoordinationV1NamespacedLeaseRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface GetDiscoveryAPIGroupRequest {}
export interface GetDiscoveryV1APIResourcesRequest {}
export interface ListDiscoveryV1EndpointSliceForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListDiscoveryV1NamespacedEndpointSliceRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateDiscoveryV1NamespacedEndpointSliceRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: DiscoveryK8sIoV1EndpointSlice;
}
export interface DeleteDiscoveryV1CollectionNamespacedEndpointSliceRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadDiscoveryV1NamespacedEndpointSliceRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceDiscoveryV1NamespacedEndpointSliceRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: DiscoveryK8sIoV1EndpointSlice;
}
export interface DeleteDiscoveryV1NamespacedEndpointSliceRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchDiscoveryV1NamespacedEndpointSliceRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface WatchDiscoveryV1EndpointSliceListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchDiscoveryV1NamespacedEndpointSliceListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchDiscoveryV1NamespacedEndpointSliceRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface GetEventsAPIGroupRequest {}
export interface GetEventsV1APIResourcesRequest {}
export interface ListEventsV1EventForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListEventsV1NamespacedEventRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateEventsV1NamespacedEventRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: EventsK8sIoV1Event;
}
export interface DeleteEventsV1CollectionNamespacedEventRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadEventsV1NamespacedEventRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceEventsV1NamespacedEventRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: EventsK8sIoV1Event;
}
export interface DeleteEventsV1NamespacedEventRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchEventsV1NamespacedEventRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface WatchEventsV1EventListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchEventsV1NamespacedEventListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchEventsV1NamespacedEventRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface GetFlowcontrolApiserverAPIGroupRequest {}
export interface GetFlowcontrolApiserverV1APIResourcesRequest {}
export interface ListFlowcontrolApiserverV1FlowSchemaRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface CreateFlowcontrolApiserverV1FlowSchemaRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  body: FlowcontrolApiserverK8sIoV1FlowSchema;
}
export interface DeleteFlowcontrolApiserverV1CollectionFlowSchemaRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
}
export interface ReadFlowcontrolApiserverV1FlowSchemaRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceFlowcontrolApiserverV1FlowSchemaRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: FlowcontrolApiserverK8sIoV1FlowSchema;
}
export interface DeleteFlowcontrolApiserverV1FlowSchemaRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
  };
}
export interface PatchFlowcontrolApiserverV1FlowSchemaRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface ReadFlowcontrolApiserverV1FlowSchemaStatusRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceFlowcontrolApiserverV1FlowSchemaStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: FlowcontrolApiserverK8sIoV1FlowSchema;
}
export interface PatchFlowcontrolApiserverV1FlowSchemaStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface ListFlowcontrolApiserverV1PriorityLevelConfigurationRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface CreateFlowcontrolApiserverV1PriorityLevelConfigurationRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  body: FlowcontrolApiserverK8sIoV1PriorityLevelConfiguration;
}
export interface DeleteFlowcontrolApiserverV1CollectionPriorityLevelConfigurationRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
}
export interface ReadFlowcontrolApiserverV1PriorityLevelConfigurationRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceFlowcontrolApiserverV1PriorityLevelConfigurationRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: FlowcontrolApiserverK8sIoV1PriorityLevelConfiguration;
}
export interface DeleteFlowcontrolApiserverV1PriorityLevelConfigurationRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
  };
}
export interface PatchFlowcontrolApiserverV1PriorityLevelConfigurationRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface ReadFlowcontrolApiserverV1PriorityLevelConfigurationStatusRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceFlowcontrolApiserverV1PriorityLevelConfigurationStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: FlowcontrolApiserverK8sIoV1PriorityLevelConfiguration;
}
export interface PatchFlowcontrolApiserverV1PriorityLevelConfigurationStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface WatchFlowcontrolApiserverV1FlowSchemaListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchFlowcontrolApiserverV1FlowSchemaRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
  };
}
export interface WatchFlowcontrolApiserverV1PriorityLevelConfigurationListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchFlowcontrolApiserverV1PriorityLevelConfigurationRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
  };
}
export interface ListMonitoringCoreosComV1AlertmanagerForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListMonitoringCoreosComV1NamespacedAlertmanagerRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateMonitoringCoreosComV1NamespacedAlertmanagerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: MonitoringCoreosComV1Alertmanager;
}
export interface DeleteMonitoringCoreosComV1CollectionNamespacedAlertmanagerRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadMonitoringCoreosComV1NamespacedAlertmanagerRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceMonitoringCoreosComV1NamespacedAlertmanagerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: MonitoringCoreosComV1Alertmanager;
}
export interface DeleteMonitoringCoreosComV1NamespacedAlertmanagerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchMonitoringCoreosComV1NamespacedAlertmanagerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadMonitoringCoreosComV1NamespacedAlertmanagerScaleRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceMonitoringCoreosComV1NamespacedAlertmanagerScaleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AutoscalingV1Scale;
}
export interface PatchMonitoringCoreosComV1NamespacedAlertmanagerScaleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadMonitoringCoreosComV1NamespacedAlertmanagerStatusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceMonitoringCoreosComV1NamespacedAlertmanagerStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: MonitoringCoreosComV1Alertmanager;
}
export interface PatchMonitoringCoreosComV1NamespacedAlertmanagerStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListMonitoringCoreosComV1NamespacedPodMonitorRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateMonitoringCoreosComV1NamespacedPodMonitorRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: MonitoringCoreosComV1PodMonitor;
}
export interface DeleteMonitoringCoreosComV1CollectionNamespacedPodMonitorRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadMonitoringCoreosComV1NamespacedPodMonitorRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceMonitoringCoreosComV1NamespacedPodMonitorRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: MonitoringCoreosComV1PodMonitor;
}
export interface DeleteMonitoringCoreosComV1NamespacedPodMonitorRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchMonitoringCoreosComV1NamespacedPodMonitorRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListMonitoringCoreosComV1NamespacedProbeRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateMonitoringCoreosComV1NamespacedProbeRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: MonitoringCoreosComV1Probe;
}
export interface DeleteMonitoringCoreosComV1CollectionNamespacedProbeRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadMonitoringCoreosComV1NamespacedProbeRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceMonitoringCoreosComV1NamespacedProbeRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: MonitoringCoreosComV1Probe;
}
export interface DeleteMonitoringCoreosComV1NamespacedProbeRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchMonitoringCoreosComV1NamespacedProbeRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListMonitoringCoreosComV1NamespacedPrometheusRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateMonitoringCoreosComV1NamespacedPrometheusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: MonitoringCoreosComV1Prometheus;
}
export interface DeleteMonitoringCoreosComV1CollectionNamespacedPrometheusRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadMonitoringCoreosComV1NamespacedPrometheusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceMonitoringCoreosComV1NamespacedPrometheusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: MonitoringCoreosComV1Prometheus;
}
export interface DeleteMonitoringCoreosComV1NamespacedPrometheusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchMonitoringCoreosComV1NamespacedPrometheusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadMonitoringCoreosComV1NamespacedPrometheusScaleRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceMonitoringCoreosComV1NamespacedPrometheusScaleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AutoscalingV1Scale;
}
export interface PatchMonitoringCoreosComV1NamespacedPrometheusScaleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadMonitoringCoreosComV1NamespacedPrometheusStatusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceMonitoringCoreosComV1NamespacedPrometheusStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: MonitoringCoreosComV1Prometheus;
}
export interface PatchMonitoringCoreosComV1NamespacedPrometheusStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListMonitoringCoreosComV1NamespacedPrometheusRuleRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateMonitoringCoreosComV1NamespacedPrometheusRuleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: MonitoringCoreosComV1PrometheusRule;
}
export interface DeleteMonitoringCoreosComV1CollectionNamespacedPrometheusRuleRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadMonitoringCoreosComV1NamespacedPrometheusRuleRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceMonitoringCoreosComV1NamespacedPrometheusRuleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: MonitoringCoreosComV1PrometheusRule;
}
export interface DeleteMonitoringCoreosComV1NamespacedPrometheusRuleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchMonitoringCoreosComV1NamespacedPrometheusRuleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListMonitoringCoreosComV1NamespacedServiceMonitorRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateMonitoringCoreosComV1NamespacedServiceMonitorRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: MonitoringCoreosComV1ServiceMonitor;
}
export interface DeleteMonitoringCoreosComV1CollectionNamespacedServiceMonitorRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadMonitoringCoreosComV1NamespacedServiceMonitorRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceMonitoringCoreosComV1NamespacedServiceMonitorRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: MonitoringCoreosComV1ServiceMonitor;
}
export interface DeleteMonitoringCoreosComV1NamespacedServiceMonitorRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchMonitoringCoreosComV1NamespacedServiceMonitorRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadMonitoringCoreosComV1NamespacedServiceMonitorStatusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceMonitoringCoreosComV1NamespacedServiceMonitorStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: MonitoringCoreosComV1ServiceMonitor;
}
export interface PatchMonitoringCoreosComV1NamespacedServiceMonitorStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListMonitoringCoreosComV1NamespacedThanosRulerRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateMonitoringCoreosComV1NamespacedThanosRulerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: MonitoringCoreosComV1ThanosRuler;
}
export interface DeleteMonitoringCoreosComV1CollectionNamespacedThanosRulerRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadMonitoringCoreosComV1NamespacedThanosRulerRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceMonitoringCoreosComV1NamespacedThanosRulerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: MonitoringCoreosComV1ThanosRuler;
}
export interface DeleteMonitoringCoreosComV1NamespacedThanosRulerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchMonitoringCoreosComV1NamespacedThanosRulerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadMonitoringCoreosComV1NamespacedThanosRulerStatusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceMonitoringCoreosComV1NamespacedThanosRulerStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: MonitoringCoreosComV1ThanosRuler;
}
export interface PatchMonitoringCoreosComV1NamespacedThanosRulerStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListMonitoringCoreosComV1PodMonitorForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListMonitoringCoreosComV1ProbeForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListMonitoringCoreosComV1PrometheusForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListMonitoringCoreosComV1PrometheusRuleForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListMonitoringCoreosComV1ServiceMonitorForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListMonitoringCoreosComV1ThanosRulerForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListMonitoringCoreosComV1alpha1AlertmanagerConfigForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListMonitoringCoreosComV1alpha1NamespacedAlertmanagerConfigRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateMonitoringCoreosComV1alpha1NamespacedAlertmanagerConfigRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: MonitoringCoreosComV1alpha1AlertmanagerConfig;
}
export interface DeleteMonitoringCoreosComV1alpha1CollectionNamespacedAlertmanagerConfigRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadMonitoringCoreosComV1alpha1NamespacedAlertmanagerConfigRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceMonitoringCoreosComV1alpha1NamespacedAlertmanagerConfigRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: MonitoringCoreosComV1alpha1AlertmanagerConfig;
}
export interface DeleteMonitoringCoreosComV1alpha1NamespacedAlertmanagerConfigRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchMonitoringCoreosComV1alpha1NamespacedAlertmanagerConfigRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListMonitoringCoreosComV1alpha1NamespacedPrometheusAgentRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateMonitoringCoreosComV1alpha1NamespacedPrometheusAgentRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: MonitoringCoreosComV1alpha1PrometheusAgent;
}
export interface DeleteMonitoringCoreosComV1alpha1CollectionNamespacedPrometheusAgentRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadMonitoringCoreosComV1alpha1NamespacedPrometheusAgentRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceMonitoringCoreosComV1alpha1NamespacedPrometheusAgentRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: MonitoringCoreosComV1alpha1PrometheusAgent;
}
export interface DeleteMonitoringCoreosComV1alpha1NamespacedPrometheusAgentRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchMonitoringCoreosComV1alpha1NamespacedPrometheusAgentRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadMonitoringCoreosComV1alpha1NamespacedPrometheusAgentScaleRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceMonitoringCoreosComV1alpha1NamespacedPrometheusAgentScaleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AutoscalingV1Scale;
}
export interface PatchMonitoringCoreosComV1alpha1NamespacedPrometheusAgentScaleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadMonitoringCoreosComV1alpha1NamespacedPrometheusAgentStatusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceMonitoringCoreosComV1alpha1NamespacedPrometheusAgentStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: MonitoringCoreosComV1alpha1PrometheusAgent;
}
export interface PatchMonitoringCoreosComV1alpha1NamespacedPrometheusAgentStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListMonitoringCoreosComV1alpha1NamespacedScrapeConfigRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateMonitoringCoreosComV1alpha1NamespacedScrapeConfigRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: MonitoringCoreosComV1alpha1ScrapeConfig;
}
export interface DeleteMonitoringCoreosComV1alpha1CollectionNamespacedScrapeConfigRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadMonitoringCoreosComV1alpha1NamespacedScrapeConfigRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceMonitoringCoreosComV1alpha1NamespacedScrapeConfigRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: MonitoringCoreosComV1alpha1ScrapeConfig;
}
export interface DeleteMonitoringCoreosComV1alpha1NamespacedScrapeConfigRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchMonitoringCoreosComV1alpha1NamespacedScrapeConfigRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListMonitoringCoreosComV1alpha1PrometheusAgentForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListMonitoringCoreosComV1alpha1ScrapeConfigForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListNetworkingInternalKnativeDevV1alpha1CertificateForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListNetworkingInternalKnativeDevV1alpha1ClusterDomainClaimRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface CreateNetworkingInternalKnativeDevV1alpha1ClusterDomainClaimRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  body: NetworkingInternalKnativeDevV1alpha1ClusterDomainClaim;
}
export interface DeleteNetworkingInternalKnativeDevV1alpha1CollectionClusterDomainClaimRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ReadNetworkingInternalKnativeDevV1alpha1ClusterDomainClaimRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceNetworkingInternalKnativeDevV1alpha1ClusterDomainClaimRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: NetworkingInternalKnativeDevV1alpha1ClusterDomainClaim;
}
export interface DeleteNetworkingInternalKnativeDevV1alpha1ClusterDomainClaimRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
  };
}
export interface PatchNetworkingInternalKnativeDevV1alpha1ClusterDomainClaimRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface ReadNetworkingInternalKnativeDevV1alpha1ClusterDomainClaimStatusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceNetworkingInternalKnativeDevV1alpha1ClusterDomainClaimStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: NetworkingInternalKnativeDevV1alpha1ClusterDomainClaim;
}
export interface PatchNetworkingInternalKnativeDevV1alpha1ClusterDomainClaimStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface ListNetworkingInternalKnativeDevV1alpha1IngressForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListNetworkingInternalKnativeDevV1alpha1NamespacedCertificateRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateNetworkingInternalKnativeDevV1alpha1NamespacedCertificateRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: NetworkingInternalKnativeDevV1alpha1Certificate;
}
export interface DeleteNetworkingInternalKnativeDevV1alpha1CollectionNamespacedCertificateRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadNetworkingInternalKnativeDevV1alpha1NamespacedCertificateRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceNetworkingInternalKnativeDevV1alpha1NamespacedCertificateRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: NetworkingInternalKnativeDevV1alpha1Certificate;
}
export interface DeleteNetworkingInternalKnativeDevV1alpha1NamespacedCertificateRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchNetworkingInternalKnativeDevV1alpha1NamespacedCertificateRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadNetworkingInternalKnativeDevV1alpha1NamespacedCertificateStatusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceNetworkingInternalKnativeDevV1alpha1NamespacedCertificateStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: NetworkingInternalKnativeDevV1alpha1Certificate;
}
export interface PatchNetworkingInternalKnativeDevV1alpha1NamespacedCertificateStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListNetworkingInternalKnativeDevV1alpha1NamespacedIngressRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateNetworkingInternalKnativeDevV1alpha1NamespacedIngressRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: NetworkingInternalKnativeDevV1alpha1Ingress;
}
export interface DeleteNetworkingInternalKnativeDevV1alpha1CollectionNamespacedIngressRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadNetworkingInternalKnativeDevV1alpha1NamespacedIngressRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceNetworkingInternalKnativeDevV1alpha1NamespacedIngressRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: NetworkingInternalKnativeDevV1alpha1Ingress;
}
export interface DeleteNetworkingInternalKnativeDevV1alpha1NamespacedIngressRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchNetworkingInternalKnativeDevV1alpha1NamespacedIngressRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadNetworkingInternalKnativeDevV1alpha1NamespacedIngressStatusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceNetworkingInternalKnativeDevV1alpha1NamespacedIngressStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: NetworkingInternalKnativeDevV1alpha1Ingress;
}
export interface PatchNetworkingInternalKnativeDevV1alpha1NamespacedIngressStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListNetworkingInternalKnativeDevV1alpha1NamespacedServerlessServiceRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateNetworkingInternalKnativeDevV1alpha1NamespacedServerlessServiceRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: NetworkingInternalKnativeDevV1alpha1ServerlessService;
}
export interface DeleteNetworkingInternalKnativeDevV1alpha1CollectionNamespacedServerlessServiceRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadNetworkingInternalKnativeDevV1alpha1NamespacedServerlessServiceRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceNetworkingInternalKnativeDevV1alpha1NamespacedServerlessServiceRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: NetworkingInternalKnativeDevV1alpha1ServerlessService;
}
export interface DeleteNetworkingInternalKnativeDevV1alpha1NamespacedServerlessServiceRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchNetworkingInternalKnativeDevV1alpha1NamespacedServerlessServiceRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadNetworkingInternalKnativeDevV1alpha1NamespacedServerlessServiceStatusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceNetworkingInternalKnativeDevV1alpha1NamespacedServerlessServiceStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: NetworkingInternalKnativeDevV1alpha1ServerlessService;
}
export interface PatchNetworkingInternalKnativeDevV1alpha1NamespacedServerlessServiceStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListNetworkingInternalKnativeDevV1alpha1ServerlessServiceForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface GetNetworkingAPIGroupRequest {}
export interface GetNetworkingV1APIResourcesRequest {}
export interface ListNetworkingV1IngressClassRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface CreateNetworkingV1IngressClassRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  body: NetworkingK8sIoV1IngressClass;
}
export interface DeleteNetworkingV1CollectionIngressClassRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
}
export interface ReadNetworkingV1IngressClassRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceNetworkingV1IngressClassRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: NetworkingK8sIoV1IngressClass;
}
export interface DeleteNetworkingV1IngressClassRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
  };
}
export interface PatchNetworkingV1IngressClassRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface ListNetworkingV1IngressForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListNetworkingV1NamespacedIngressRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateNetworkingV1NamespacedIngressRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: NetworkingK8sIoV1Ingress;
}
export interface DeleteNetworkingV1CollectionNamespacedIngressRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadNetworkingV1NamespacedIngressRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceNetworkingV1NamespacedIngressRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: NetworkingK8sIoV1Ingress;
}
export interface DeleteNetworkingV1NamespacedIngressRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchNetworkingV1NamespacedIngressRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadNetworkingV1NamespacedIngressStatusRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceNetworkingV1NamespacedIngressStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: NetworkingK8sIoV1Ingress;
}
export interface PatchNetworkingV1NamespacedIngressStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListNetworkingV1NamespacedNetworkPolicyRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateNetworkingV1NamespacedNetworkPolicyRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: NetworkingK8sIoV1NetworkPolicy;
}
export interface DeleteNetworkingV1CollectionNamespacedNetworkPolicyRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadNetworkingV1NamespacedNetworkPolicyRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceNetworkingV1NamespacedNetworkPolicyRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: NetworkingK8sIoV1NetworkPolicy;
}
export interface DeleteNetworkingV1NamespacedNetworkPolicyRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchNetworkingV1NamespacedNetworkPolicyRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListNetworkingV1NetworkPolicyForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchNetworkingV1IngressClassListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchNetworkingV1IngressClassRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
  };
}
export interface WatchNetworkingV1IngressListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchNetworkingV1NamespacedIngressListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchNetworkingV1NamespacedIngressRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface WatchNetworkingV1NamespacedNetworkPolicyListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchNetworkingV1NamespacedNetworkPolicyRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface WatchNetworkingV1NetworkPolicyListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface GetNodeAPIGroupRequest {}
export interface GetNodeV1APIResourcesRequest {}
export interface ListNodeV1RuntimeClassRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface CreateNodeV1RuntimeClassRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  body: NodeK8sIoV1RuntimeClass;
}
export interface DeleteNodeV1CollectionRuntimeClassRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
}
export interface ReadNodeV1RuntimeClassRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceNodeV1RuntimeClassRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: NodeK8sIoV1RuntimeClass;
}
export interface DeleteNodeV1RuntimeClassRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
  };
}
export interface PatchNodeV1RuntimeClassRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface WatchNodeV1RuntimeClassListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchNodeV1RuntimeClassRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
  };
}
export interface GetPolicyAPIGroupRequest {}
export interface GetPolicyV1APIResourcesRequest {}
export interface ListPolicyV1NamespacedPodDisruptionBudgetRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreatePolicyV1NamespacedPodDisruptionBudgetRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: PolicyV1PodDisruptionBudget;
}
export interface DeletePolicyV1CollectionNamespacedPodDisruptionBudgetRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadPolicyV1NamespacedPodDisruptionBudgetRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplacePolicyV1NamespacedPodDisruptionBudgetRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: PolicyV1PodDisruptionBudget;
}
export interface DeletePolicyV1NamespacedPodDisruptionBudgetRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchPolicyV1NamespacedPodDisruptionBudgetRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadPolicyV1NamespacedPodDisruptionBudgetStatusRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplacePolicyV1NamespacedPodDisruptionBudgetStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: PolicyV1PodDisruptionBudget;
}
export interface PatchPolicyV1NamespacedPodDisruptionBudgetStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListPolicyV1PodDisruptionBudgetForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchPolicyV1NamespacedPodDisruptionBudgetListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchPolicyV1NamespacedPodDisruptionBudgetRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface WatchPolicyV1PodDisruptionBudgetListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListPostgresqlCnpgIoV1BackupForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListPostgresqlCnpgIoV1ClusterImageCatalogRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface CreatePostgresqlCnpgIoV1ClusterImageCatalogRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  body: PostgresqlCnpgIoV1ClusterImageCatalog;
}
export interface DeletePostgresqlCnpgIoV1CollectionClusterImageCatalogRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ReadPostgresqlCnpgIoV1ClusterImageCatalogRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplacePostgresqlCnpgIoV1ClusterImageCatalogRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: PostgresqlCnpgIoV1ClusterImageCatalog;
}
export interface DeletePostgresqlCnpgIoV1ClusterImageCatalogRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
  };
}
export interface PatchPostgresqlCnpgIoV1ClusterImageCatalogRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface ListPostgresqlCnpgIoV1ClusterForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListPostgresqlCnpgIoV1DatabaseForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListPostgresqlCnpgIoV1ImageCatalogForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListPostgresqlCnpgIoV1NamespacedBackupRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreatePostgresqlCnpgIoV1NamespacedBackupRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: PostgresqlCnpgIoV1Backup;
}
export interface DeletePostgresqlCnpgIoV1CollectionNamespacedBackupRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadPostgresqlCnpgIoV1NamespacedBackupRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplacePostgresqlCnpgIoV1NamespacedBackupRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: PostgresqlCnpgIoV1Backup;
}
export interface DeletePostgresqlCnpgIoV1NamespacedBackupRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchPostgresqlCnpgIoV1NamespacedBackupRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadPostgresqlCnpgIoV1NamespacedBackupStatusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplacePostgresqlCnpgIoV1NamespacedBackupStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: PostgresqlCnpgIoV1Backup;
}
export interface PatchPostgresqlCnpgIoV1NamespacedBackupStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListPostgresqlCnpgIoV1NamespacedClusterRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreatePostgresqlCnpgIoV1NamespacedClusterRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: PostgresqlCnpgIoV1Cluster;
}
export interface DeletePostgresqlCnpgIoV1CollectionNamespacedClusterRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadPostgresqlCnpgIoV1NamespacedClusterRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplacePostgresqlCnpgIoV1NamespacedClusterRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: PostgresqlCnpgIoV1Cluster;
}
export interface DeletePostgresqlCnpgIoV1NamespacedClusterRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchPostgresqlCnpgIoV1NamespacedClusterRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadPostgresqlCnpgIoV1NamespacedClusterScaleRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplacePostgresqlCnpgIoV1NamespacedClusterScaleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AutoscalingV1Scale;
}
export interface PatchPostgresqlCnpgIoV1NamespacedClusterScaleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadPostgresqlCnpgIoV1NamespacedClusterStatusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplacePostgresqlCnpgIoV1NamespacedClusterStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: PostgresqlCnpgIoV1Cluster;
}
export interface PatchPostgresqlCnpgIoV1NamespacedClusterStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListPostgresqlCnpgIoV1NamespacedDatabaseRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreatePostgresqlCnpgIoV1NamespacedDatabaseRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: PostgresqlCnpgIoV1Database;
}
export interface DeletePostgresqlCnpgIoV1CollectionNamespacedDatabaseRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadPostgresqlCnpgIoV1NamespacedDatabaseRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplacePostgresqlCnpgIoV1NamespacedDatabaseRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: PostgresqlCnpgIoV1Database;
}
export interface DeletePostgresqlCnpgIoV1NamespacedDatabaseRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchPostgresqlCnpgIoV1NamespacedDatabaseRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadPostgresqlCnpgIoV1NamespacedDatabaseStatusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplacePostgresqlCnpgIoV1NamespacedDatabaseStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: PostgresqlCnpgIoV1Database;
}
export interface PatchPostgresqlCnpgIoV1NamespacedDatabaseStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListPostgresqlCnpgIoV1NamespacedImageCatalogRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreatePostgresqlCnpgIoV1NamespacedImageCatalogRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: PostgresqlCnpgIoV1ImageCatalog;
}
export interface DeletePostgresqlCnpgIoV1CollectionNamespacedImageCatalogRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadPostgresqlCnpgIoV1NamespacedImageCatalogRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplacePostgresqlCnpgIoV1NamespacedImageCatalogRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: PostgresqlCnpgIoV1ImageCatalog;
}
export interface DeletePostgresqlCnpgIoV1NamespacedImageCatalogRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchPostgresqlCnpgIoV1NamespacedImageCatalogRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListPostgresqlCnpgIoV1NamespacedPoolerRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreatePostgresqlCnpgIoV1NamespacedPoolerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: PostgresqlCnpgIoV1Pooler;
}
export interface DeletePostgresqlCnpgIoV1CollectionNamespacedPoolerRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadPostgresqlCnpgIoV1NamespacedPoolerRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplacePostgresqlCnpgIoV1NamespacedPoolerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: PostgresqlCnpgIoV1Pooler;
}
export interface DeletePostgresqlCnpgIoV1NamespacedPoolerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchPostgresqlCnpgIoV1NamespacedPoolerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadPostgresqlCnpgIoV1NamespacedPoolerScaleRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplacePostgresqlCnpgIoV1NamespacedPoolerScaleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AutoscalingV1Scale;
}
export interface PatchPostgresqlCnpgIoV1NamespacedPoolerScaleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadPostgresqlCnpgIoV1NamespacedPoolerStatusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplacePostgresqlCnpgIoV1NamespacedPoolerStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: PostgresqlCnpgIoV1Pooler;
}
export interface PatchPostgresqlCnpgIoV1NamespacedPoolerStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListPostgresqlCnpgIoV1NamespacedPublicationRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreatePostgresqlCnpgIoV1NamespacedPublicationRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: PostgresqlCnpgIoV1Publication;
}
export interface DeletePostgresqlCnpgIoV1CollectionNamespacedPublicationRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadPostgresqlCnpgIoV1NamespacedPublicationRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplacePostgresqlCnpgIoV1NamespacedPublicationRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: PostgresqlCnpgIoV1Publication;
}
export interface DeletePostgresqlCnpgIoV1NamespacedPublicationRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchPostgresqlCnpgIoV1NamespacedPublicationRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadPostgresqlCnpgIoV1NamespacedPublicationStatusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplacePostgresqlCnpgIoV1NamespacedPublicationStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: PostgresqlCnpgIoV1Publication;
}
export interface PatchPostgresqlCnpgIoV1NamespacedPublicationStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListPostgresqlCnpgIoV1NamespacedScheduledBackupRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreatePostgresqlCnpgIoV1NamespacedScheduledBackupRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: PostgresqlCnpgIoV1ScheduledBackup;
}
export interface DeletePostgresqlCnpgIoV1CollectionNamespacedScheduledBackupRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadPostgresqlCnpgIoV1NamespacedScheduledBackupRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplacePostgresqlCnpgIoV1NamespacedScheduledBackupRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: PostgresqlCnpgIoV1ScheduledBackup;
}
export interface DeletePostgresqlCnpgIoV1NamespacedScheduledBackupRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchPostgresqlCnpgIoV1NamespacedScheduledBackupRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadPostgresqlCnpgIoV1NamespacedScheduledBackupStatusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplacePostgresqlCnpgIoV1NamespacedScheduledBackupStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: PostgresqlCnpgIoV1ScheduledBackup;
}
export interface PatchPostgresqlCnpgIoV1NamespacedScheduledBackupStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListPostgresqlCnpgIoV1NamespacedSubscriptionRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreatePostgresqlCnpgIoV1NamespacedSubscriptionRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: PostgresqlCnpgIoV1Subscription;
}
export interface DeletePostgresqlCnpgIoV1CollectionNamespacedSubscriptionRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadPostgresqlCnpgIoV1NamespacedSubscriptionRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplacePostgresqlCnpgIoV1NamespacedSubscriptionRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: PostgresqlCnpgIoV1Subscription;
}
export interface DeletePostgresqlCnpgIoV1NamespacedSubscriptionRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchPostgresqlCnpgIoV1NamespacedSubscriptionRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadPostgresqlCnpgIoV1NamespacedSubscriptionStatusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplacePostgresqlCnpgIoV1NamespacedSubscriptionStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: PostgresqlCnpgIoV1Subscription;
}
export interface PatchPostgresqlCnpgIoV1NamespacedSubscriptionStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListPostgresqlCnpgIoV1PoolerForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListPostgresqlCnpgIoV1PublicationForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListPostgresqlCnpgIoV1ScheduledBackupForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListPostgresqlCnpgIoV1SubscriptionForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface GetRbacAuthorizationAPIGroupRequest {}
export interface GetRbacAuthorizationV1APIResourcesRequest {}
export interface ListRbacAuthorizationV1ClusterRoleBindingRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface CreateRbacAuthorizationV1ClusterRoleBindingRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  body: RbacAuthorizationK8sIoV1ClusterRoleBinding;
}
export interface DeleteRbacAuthorizationV1CollectionClusterRoleBindingRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
}
export interface ReadRbacAuthorizationV1ClusterRoleBindingRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceRbacAuthorizationV1ClusterRoleBindingRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: RbacAuthorizationK8sIoV1ClusterRoleBinding;
}
export interface DeleteRbacAuthorizationV1ClusterRoleBindingRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
  };
}
export interface PatchRbacAuthorizationV1ClusterRoleBindingRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface ListRbacAuthorizationV1ClusterRoleRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface CreateRbacAuthorizationV1ClusterRoleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  body: RbacAuthorizationK8sIoV1ClusterRole;
}
export interface DeleteRbacAuthorizationV1CollectionClusterRoleRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
}
export interface ReadRbacAuthorizationV1ClusterRoleRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceRbacAuthorizationV1ClusterRoleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: RbacAuthorizationK8sIoV1ClusterRole;
}
export interface DeleteRbacAuthorizationV1ClusterRoleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
  };
}
export interface PatchRbacAuthorizationV1ClusterRoleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface ListRbacAuthorizationV1NamespacedRoleBindingRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateRbacAuthorizationV1NamespacedRoleBindingRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: RbacAuthorizationK8sIoV1RoleBinding;
}
export interface DeleteRbacAuthorizationV1CollectionNamespacedRoleBindingRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadRbacAuthorizationV1NamespacedRoleBindingRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceRbacAuthorizationV1NamespacedRoleBindingRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: RbacAuthorizationK8sIoV1RoleBinding;
}
export interface DeleteRbacAuthorizationV1NamespacedRoleBindingRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchRbacAuthorizationV1NamespacedRoleBindingRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListRbacAuthorizationV1NamespacedRoleRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateRbacAuthorizationV1NamespacedRoleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: RbacAuthorizationK8sIoV1Role;
}
export interface DeleteRbacAuthorizationV1CollectionNamespacedRoleRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadRbacAuthorizationV1NamespacedRoleRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceRbacAuthorizationV1NamespacedRoleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: RbacAuthorizationK8sIoV1Role;
}
export interface DeleteRbacAuthorizationV1NamespacedRoleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchRbacAuthorizationV1NamespacedRoleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListRbacAuthorizationV1RoleBindingForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListRbacAuthorizationV1RoleForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchRbacAuthorizationV1ClusterRoleBindingListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchRbacAuthorizationV1ClusterRoleBindingRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
  };
}
export interface WatchRbacAuthorizationV1ClusterRoleListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchRbacAuthorizationV1ClusterRoleRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
  };
}
export interface WatchRbacAuthorizationV1NamespacedRoleBindingListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchRbacAuthorizationV1NamespacedRoleBindingRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface WatchRbacAuthorizationV1NamespacedRoleListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchRbacAuthorizationV1NamespacedRoleRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface WatchRbacAuthorizationV1RoleBindingListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchRbacAuthorizationV1RoleListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface GetSchedulingAPIGroupRequest {}
export interface GetSchedulingV1APIResourcesRequest {}
export interface ListSchedulingV1PriorityClassRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface CreateSchedulingV1PriorityClassRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  body: SchedulingK8sIoV1PriorityClass;
}
export interface DeleteSchedulingV1CollectionPriorityClassRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
}
export interface ReadSchedulingV1PriorityClassRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceSchedulingV1PriorityClassRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: SchedulingK8sIoV1PriorityClass;
}
export interface DeleteSchedulingV1PriorityClassRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
  };
}
export interface PatchSchedulingV1PriorityClassRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface WatchSchedulingV1PriorityClassListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchSchedulingV1PriorityClassRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
  };
}
export interface ListServingKnativeDevV1ConfigurationForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListServingKnativeDevV1NamespacedConfigurationRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateServingKnativeDevV1NamespacedConfigurationRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: ServingKnativeDevV1Configuration;
}
export interface DeleteServingKnativeDevV1CollectionNamespacedConfigurationRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadServingKnativeDevV1NamespacedConfigurationRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceServingKnativeDevV1NamespacedConfigurationRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: ServingKnativeDevV1Configuration;
}
export interface DeleteServingKnativeDevV1NamespacedConfigurationRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchServingKnativeDevV1NamespacedConfigurationRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadServingKnativeDevV1NamespacedConfigurationStatusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceServingKnativeDevV1NamespacedConfigurationStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: ServingKnativeDevV1Configuration;
}
export interface PatchServingKnativeDevV1NamespacedConfigurationStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListServingKnativeDevV1NamespacedRevisionRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateServingKnativeDevV1NamespacedRevisionRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: ServingKnativeDevV1Revision;
}
export interface DeleteServingKnativeDevV1CollectionNamespacedRevisionRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadServingKnativeDevV1NamespacedRevisionRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceServingKnativeDevV1NamespacedRevisionRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: ServingKnativeDevV1Revision;
}
export interface DeleteServingKnativeDevV1NamespacedRevisionRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchServingKnativeDevV1NamespacedRevisionRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadServingKnativeDevV1NamespacedRevisionStatusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceServingKnativeDevV1NamespacedRevisionStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: ServingKnativeDevV1Revision;
}
export interface PatchServingKnativeDevV1NamespacedRevisionStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListServingKnativeDevV1NamespacedRouteRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateServingKnativeDevV1NamespacedRouteRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: ServingKnativeDevV1Route;
}
export interface DeleteServingKnativeDevV1CollectionNamespacedRouteRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadServingKnativeDevV1NamespacedRouteRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceServingKnativeDevV1NamespacedRouteRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: ServingKnativeDevV1Route;
}
export interface DeleteServingKnativeDevV1NamespacedRouteRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchServingKnativeDevV1NamespacedRouteRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadServingKnativeDevV1NamespacedRouteStatusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceServingKnativeDevV1NamespacedRouteStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: ServingKnativeDevV1Route;
}
export interface PatchServingKnativeDevV1NamespacedRouteStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListServingKnativeDevV1NamespacedServiceRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateServingKnativeDevV1NamespacedServiceRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: ServingKnativeDevV1Service;
}
export interface DeleteServingKnativeDevV1CollectionNamespacedServiceRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadServingKnativeDevV1NamespacedServiceRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceServingKnativeDevV1NamespacedServiceRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: ServingKnativeDevV1Service;
}
export interface DeleteServingKnativeDevV1NamespacedServiceRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchServingKnativeDevV1NamespacedServiceRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadServingKnativeDevV1NamespacedServiceStatusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceServingKnativeDevV1NamespacedServiceStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: ServingKnativeDevV1Service;
}
export interface PatchServingKnativeDevV1NamespacedServiceStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListServingKnativeDevV1RevisionForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListServingKnativeDevV1RouteForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListServingKnativeDevV1ServiceForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface GetStorageAPIGroupRequest {}
export interface GetStorageV1APIResourcesRequest {}
export interface ListStorageV1CSIDriverRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface CreateStorageV1CSIDriverRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  body: StorageK8sIoV1CSIDriver;
}
export interface DeleteStorageV1CollectionCSIDriverRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
}
export interface ReadStorageV1CSIDriverRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceStorageV1CSIDriverRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: StorageK8sIoV1CSIDriver;
}
export interface DeleteStorageV1CSIDriverRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
  };
}
export interface PatchStorageV1CSIDriverRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface ListStorageV1CSINodeRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface CreateStorageV1CSINodeRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  body: StorageK8sIoV1CSINode;
}
export interface DeleteStorageV1CollectionCSINodeRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
}
export interface ReadStorageV1CSINodeRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceStorageV1CSINodeRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: StorageK8sIoV1CSINode;
}
export interface DeleteStorageV1CSINodeRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
  };
}
export interface PatchStorageV1CSINodeRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface ListStorageV1CSIStorageCapacityForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListStorageV1NamespacedCSIStorageCapacityRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateStorageV1NamespacedCSIStorageCapacityRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: StorageK8sIoV1CSIStorageCapacity;
}
export interface DeleteStorageV1CollectionNamespacedCSIStorageCapacityRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadStorageV1NamespacedCSIStorageCapacityRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceStorageV1NamespacedCSIStorageCapacityRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: StorageK8sIoV1CSIStorageCapacity;
}
export interface DeleteStorageV1NamespacedCSIStorageCapacityRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchStorageV1NamespacedCSIStorageCapacityRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListStorageV1StorageClassRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface CreateStorageV1StorageClassRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  body: StorageK8sIoV1StorageClass;
}
export interface DeleteStorageV1CollectionStorageClassRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
}
export interface ReadStorageV1StorageClassRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceStorageV1StorageClassRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: StorageK8sIoV1StorageClass;
}
export interface DeleteStorageV1StorageClassRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
  };
}
export interface PatchStorageV1StorageClassRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface ListStorageV1VolumeAttachmentRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface CreateStorageV1VolumeAttachmentRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  body: StorageK8sIoV1VolumeAttachment;
}
export interface DeleteStorageV1CollectionVolumeAttachmentRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
}
export interface ReadStorageV1VolumeAttachmentRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceStorageV1VolumeAttachmentRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: StorageK8sIoV1VolumeAttachment;
}
export interface DeleteStorageV1VolumeAttachmentRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
  };
}
export interface PatchStorageV1VolumeAttachmentRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface ReadStorageV1VolumeAttachmentStatusRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceStorageV1VolumeAttachmentStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: StorageK8sIoV1VolumeAttachment;
}
export interface PatchStorageV1VolumeAttachmentStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface WatchStorageV1CSIDriverListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchStorageV1CSIDriverRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
  };
}
export interface WatchStorageV1CSINodeListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchStorageV1CSINodeRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
  };
}
export interface WatchStorageV1CSIStorageCapacityListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchStorageV1NamespacedCSIStorageCapacityListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchStorageV1NamespacedCSIStorageCapacityRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface WatchStorageV1StorageClassListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchStorageV1StorageClassRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
  };
}
export interface WatchStorageV1VolumeAttachmentListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchStorageV1VolumeAttachmentRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
  };
}
export interface GetServiceAccountIssuerOpenIDKeysetRequest {}
export interface GetCodeVersionRequest {}
export class KubernetesClient extends APIClient {
  constructor(options: APIClientOptions) {
    super(options);
  }
  async getSwaggerJSON() {
    const path = "/openapi/v2";
    return this.get(path);
  }
  async getServiceAccountIssuerOpenIDConfiguration(params: GetServiceAccountIssuerOpenIDConfigurationRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/.well-known/openid-configuration/`;
    return await this.get<string>(path, null, null, opts);
  }
  async getCoreAPIVersions(params: GetCoreAPIVersionsRequest, opts?: APIClientRequestOpts): Promise<APIVersions> {
    const path = `/api/`;
    return await this.get<APIVersions>(path, null, null, opts);
  }
  async getCoreV1APIResources(params: GetCoreV1APIResourcesRequest, opts?: APIClientRequestOpts): Promise<APIResourceList> {
    const path = `/api/v1/`;
    return await this.get<APIResourceList>(path, null, null, opts);
  }
  async listCoreV1ComponentStatus(params: ListCoreV1ComponentStatusRequest, opts?: APIClientRequestOpts): Promise<ComponentStatusList> {
    const path = `/api/v1/componentstatuses`;
    return await this.get<ComponentStatusList>(path, null, null, opts);
  }
  async readCoreV1ComponentStatus(params: ReadCoreV1ComponentStatusRequest, opts?: APIClientRequestOpts): Promise<ComponentStatus> {
    const path = `/api/v1/componentstatuses/${params.path.name}`;
    return await this.get<ComponentStatus>(path, null, null, opts);
  }
  async listCoreV1ConfigMapForAllNamespaces(params: ListCoreV1ConfigMapForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<ConfigMapList> {
    const path = `/api/v1/configmaps`;
    return await this.get<ConfigMapList>(path, null, null, opts);
  }
  async listCoreV1EndpointsForAllNamespaces(params: ListCoreV1EndpointsForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<EndpointsList> {
    const path = `/api/v1/endpoints`;
    return await this.get<EndpointsList>(path, null, null, opts);
  }
  async listCoreV1EventForAllNamespaces(params: ListCoreV1EventForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<EventList> {
    const path = `/api/v1/events`;
    return await this.get<EventList>(path, null, null, opts);
  }
  async listCoreV1LimitRangeForAllNamespaces(params: ListCoreV1LimitRangeForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<LimitRangeList> {
    const path = `/api/v1/limitranges`;
    return await this.get<LimitRangeList>(path, null, null, opts);
  }
  async listCoreV1Namespace(params: ListCoreV1NamespaceRequest, opts?: APIClientRequestOpts): Promise<NamespaceList> {
    const path = `/api/v1/namespaces`;
    return await this.get<NamespaceList>(path, null, null, opts);
  }
  async createCoreV1Namespace(params: CreateCoreV1NamespaceRequest, opts?: APIClientRequestOpts): Promise<Namespace> {
    const path = `/api/v1/namespaces`;
    return await this.post<Namespace>(path, params.query, params.body, opts);
  }
  async createCoreV1NamespacedBinding(params: CreateCoreV1NamespacedBindingRequest, opts?: APIClientRequestOpts): Promise<Binding> {
    const path = `/api/v1/namespaces/${params.path.namespace}/bindings`;
    return await this.post<Binding>(path, null, params.body, opts);
  }
  async listCoreV1NamespacedConfigMap(params: ListCoreV1NamespacedConfigMapRequest, opts?: APIClientRequestOpts): Promise<ConfigMapList> {
    const path = `/api/v1/namespaces/${params.path.namespace}/configmaps`;
    return await this.get<ConfigMapList>(path, null, null, opts);
  }
  async createCoreV1NamespacedConfigMap(params: CreateCoreV1NamespacedConfigMapRequest, opts?: APIClientRequestOpts): Promise<ConfigMap> {
    const path = `/api/v1/namespaces/${params.path.namespace}/configmaps`;
    return await this.post<ConfigMap>(path, params.query, params.body, opts);
  }
  async deleteCoreV1CollectionNamespacedConfigMap(params: DeleteCoreV1CollectionNamespacedConfigMapRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/api/v1/namespaces/${params.path.namespace}/configmaps`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readCoreV1NamespacedConfigMap(params: ReadCoreV1NamespacedConfigMapRequest, opts?: APIClientRequestOpts): Promise<ConfigMap> {
    const path = `/api/v1/namespaces/${params.path.namespace}/configmaps/${params.path.name}`;
    return await this.get<ConfigMap>(path, null, null, opts);
  }
  async replaceCoreV1NamespacedConfigMap(params: ReplaceCoreV1NamespacedConfigMapRequest, opts?: APIClientRequestOpts): Promise<ConfigMap> {
    const path = `/api/v1/namespaces/${params.path.namespace}/configmaps/${params.path.name}`;
    return await this.put<ConfigMap>(path, params.query, params.body, opts);
  }
  async deleteCoreV1NamespacedConfigMap(params: DeleteCoreV1NamespacedConfigMapRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/api/v1/namespaces/${params.path.namespace}/configmaps/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchCoreV1NamespacedConfigMap(params: PatchCoreV1NamespacedConfigMapRequest, opts?: APIClientRequestOpts): Promise<ConfigMap> {
    const path = `/api/v1/namespaces/${params.path.namespace}/configmaps/${params.path.name}`;
    return await this.patch<ConfigMap>(path, params.query, null, opts);
  }
  async listCoreV1NamespacedEndpoints(params: ListCoreV1NamespacedEndpointsRequest, opts?: APIClientRequestOpts): Promise<EndpointsList> {
    const path = `/api/v1/namespaces/${params.path.namespace}/endpoints`;
    return await this.get<EndpointsList>(path, null, null, opts);
  }
  async createCoreV1NamespacedEndpoints(params: CreateCoreV1NamespacedEndpointsRequest, opts?: APIClientRequestOpts): Promise<Endpoints> {
    const path = `/api/v1/namespaces/${params.path.namespace}/endpoints`;
    return await this.post<Endpoints>(path, params.query, params.body, opts);
  }
  async deleteCoreV1CollectionNamespacedEndpoints(params: DeleteCoreV1CollectionNamespacedEndpointsRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/api/v1/namespaces/${params.path.namespace}/endpoints`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readCoreV1NamespacedEndpoints(params: ReadCoreV1NamespacedEndpointsRequest, opts?: APIClientRequestOpts): Promise<Endpoints> {
    const path = `/api/v1/namespaces/${params.path.namespace}/endpoints/${params.path.name}`;
    return await this.get<Endpoints>(path, null, null, opts);
  }
  async replaceCoreV1NamespacedEndpoints(params: ReplaceCoreV1NamespacedEndpointsRequest, opts?: APIClientRequestOpts): Promise<Endpoints> {
    const path = `/api/v1/namespaces/${params.path.namespace}/endpoints/${params.path.name}`;
    return await this.put<Endpoints>(path, params.query, params.body, opts);
  }
  async deleteCoreV1NamespacedEndpoints(params: DeleteCoreV1NamespacedEndpointsRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/api/v1/namespaces/${params.path.namespace}/endpoints/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchCoreV1NamespacedEndpoints(params: PatchCoreV1NamespacedEndpointsRequest, opts?: APIClientRequestOpts): Promise<Endpoints> {
    const path = `/api/v1/namespaces/${params.path.namespace}/endpoints/${params.path.name}`;
    return await this.patch<Endpoints>(path, params.query, null, opts);
  }
  async listCoreV1NamespacedEvent(params: ListCoreV1NamespacedEventRequest, opts?: APIClientRequestOpts): Promise<EventList> {
    const path = `/api/v1/namespaces/${params.path.namespace}/events`;
    return await this.get<EventList>(path, null, null, opts);
  }
  async createCoreV1NamespacedEvent(params: CreateCoreV1NamespacedEventRequest, opts?: APIClientRequestOpts): Promise<Event> {
    const path = `/api/v1/namespaces/${params.path.namespace}/events`;
    return await this.post<Event>(path, params.query, params.body, opts);
  }
  async deleteCoreV1CollectionNamespacedEvent(params: DeleteCoreV1CollectionNamespacedEventRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/api/v1/namespaces/${params.path.namespace}/events`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readCoreV1NamespacedEvent(params: ReadCoreV1NamespacedEventRequest, opts?: APIClientRequestOpts): Promise<Event> {
    const path = `/api/v1/namespaces/${params.path.namespace}/events/${params.path.name}`;
    return await this.get<Event>(path, null, null, opts);
  }
  async replaceCoreV1NamespacedEvent(params: ReplaceCoreV1NamespacedEventRequest, opts?: APIClientRequestOpts): Promise<Event> {
    const path = `/api/v1/namespaces/${params.path.namespace}/events/${params.path.name}`;
    return await this.put<Event>(path, params.query, params.body, opts);
  }
  async deleteCoreV1NamespacedEvent(params: DeleteCoreV1NamespacedEventRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/api/v1/namespaces/${params.path.namespace}/events/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchCoreV1NamespacedEvent(params: PatchCoreV1NamespacedEventRequest, opts?: APIClientRequestOpts): Promise<Event> {
    const path = `/api/v1/namespaces/${params.path.namespace}/events/${params.path.name}`;
    return await this.patch<Event>(path, params.query, null, opts);
  }
  async listCoreV1NamespacedLimitRange(params: ListCoreV1NamespacedLimitRangeRequest, opts?: APIClientRequestOpts): Promise<LimitRangeList> {
    const path = `/api/v1/namespaces/${params.path.namespace}/limitranges`;
    return await this.get<LimitRangeList>(path, null, null, opts);
  }
  async createCoreV1NamespacedLimitRange(params: CreateCoreV1NamespacedLimitRangeRequest, opts?: APIClientRequestOpts): Promise<LimitRange> {
    const path = `/api/v1/namespaces/${params.path.namespace}/limitranges`;
    return await this.post<LimitRange>(path, params.query, params.body, opts);
  }
  async deleteCoreV1CollectionNamespacedLimitRange(params: DeleteCoreV1CollectionNamespacedLimitRangeRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/api/v1/namespaces/${params.path.namespace}/limitranges`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readCoreV1NamespacedLimitRange(params: ReadCoreV1NamespacedLimitRangeRequest, opts?: APIClientRequestOpts): Promise<LimitRange> {
    const path = `/api/v1/namespaces/${params.path.namespace}/limitranges/${params.path.name}`;
    return await this.get<LimitRange>(path, null, null, opts);
  }
  async replaceCoreV1NamespacedLimitRange(params: ReplaceCoreV1NamespacedLimitRangeRequest, opts?: APIClientRequestOpts): Promise<LimitRange> {
    const path = `/api/v1/namespaces/${params.path.namespace}/limitranges/${params.path.name}`;
    return await this.put<LimitRange>(path, params.query, params.body, opts);
  }
  async deleteCoreV1NamespacedLimitRange(params: DeleteCoreV1NamespacedLimitRangeRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/api/v1/namespaces/${params.path.namespace}/limitranges/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchCoreV1NamespacedLimitRange(params: PatchCoreV1NamespacedLimitRangeRequest, opts?: APIClientRequestOpts): Promise<LimitRange> {
    const path = `/api/v1/namespaces/${params.path.namespace}/limitranges/${params.path.name}`;
    return await this.patch<LimitRange>(path, params.query, null, opts);
  }
  async listCoreV1NamespacedPersistentVolumeClaim(params: ListCoreV1NamespacedPersistentVolumeClaimRequest, opts?: APIClientRequestOpts): Promise<PersistentVolumeClaimList> {
    const path = `/api/v1/namespaces/${params.path.namespace}/persistentvolumeclaims`;
    return await this.get<PersistentVolumeClaimList>(path, null, null, opts);
  }
  async createCoreV1NamespacedPersistentVolumeClaim(params: CreateCoreV1NamespacedPersistentVolumeClaimRequest, opts?: APIClientRequestOpts): Promise<PersistentVolumeClaim> {
    const path = `/api/v1/namespaces/${params.path.namespace}/persistentvolumeclaims`;
    return await this.post<PersistentVolumeClaim>(path, params.query, params.body, opts);
  }
  async deleteCoreV1CollectionNamespacedPersistentVolumeClaim(params: DeleteCoreV1CollectionNamespacedPersistentVolumeClaimRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/api/v1/namespaces/${params.path.namespace}/persistentvolumeclaims`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readCoreV1NamespacedPersistentVolumeClaim(params: ReadCoreV1NamespacedPersistentVolumeClaimRequest, opts?: APIClientRequestOpts): Promise<PersistentVolumeClaim> {
    const path = `/api/v1/namespaces/${params.path.namespace}/persistentvolumeclaims/${params.path.name}`;
    return await this.get<PersistentVolumeClaim>(path, null, null, opts);
  }
  async replaceCoreV1NamespacedPersistentVolumeClaim(params: ReplaceCoreV1NamespacedPersistentVolumeClaimRequest, opts?: APIClientRequestOpts): Promise<PersistentVolumeClaim> {
    const path = `/api/v1/namespaces/${params.path.namespace}/persistentvolumeclaims/${params.path.name}`;
    return await this.put<PersistentVolumeClaim>(path, params.query, params.body, opts);
  }
  async deleteCoreV1NamespacedPersistentVolumeClaim(params: DeleteCoreV1NamespacedPersistentVolumeClaimRequest, opts?: APIClientRequestOpts): Promise<PersistentVolumeClaim> {
    const path = `/api/v1/namespaces/${params.path.namespace}/persistentvolumeclaims/${params.path.name}`;
    return await this.delete<PersistentVolumeClaim>(path, params.query, null, opts);
  }
  async patchCoreV1NamespacedPersistentVolumeClaim(params: PatchCoreV1NamespacedPersistentVolumeClaimRequest, opts?: APIClientRequestOpts): Promise<PersistentVolumeClaim> {
    const path = `/api/v1/namespaces/${params.path.namespace}/persistentvolumeclaims/${params.path.name}`;
    return await this.patch<PersistentVolumeClaim>(path, params.query, null, opts);
  }
  async readCoreV1NamespacedPersistentVolumeClaimStatus(params: ReadCoreV1NamespacedPersistentVolumeClaimStatusRequest, opts?: APIClientRequestOpts): Promise<PersistentVolumeClaim> {
    const path = `/api/v1/namespaces/${params.path.namespace}/persistentvolumeclaims/${params.path.name}/status`;
    return await this.get<PersistentVolumeClaim>(path, null, null, opts);
  }
  async replaceCoreV1NamespacedPersistentVolumeClaimStatus(params: ReplaceCoreV1NamespacedPersistentVolumeClaimStatusRequest, opts?: APIClientRequestOpts): Promise<PersistentVolumeClaim> {
    const path = `/api/v1/namespaces/${params.path.namespace}/persistentvolumeclaims/${params.path.name}/status`;
    return await this.put<PersistentVolumeClaim>(path, params.query, params.body, opts);
  }
  async patchCoreV1NamespacedPersistentVolumeClaimStatus(params: PatchCoreV1NamespacedPersistentVolumeClaimStatusRequest, opts?: APIClientRequestOpts): Promise<PersistentVolumeClaim> {
    const path = `/api/v1/namespaces/${params.path.namespace}/persistentvolumeclaims/${params.path.name}/status`;
    return await this.patch<PersistentVolumeClaim>(path, params.query, null, opts);
  }
  async listCoreV1NamespacedPod(params: ListCoreV1NamespacedPodRequest, opts?: APIClientRequestOpts): Promise<PodList> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods`;
    return await this.get<PodList>(path, null, null, opts);
  }
  async createCoreV1NamespacedPod(params: CreateCoreV1NamespacedPodRequest, opts?: APIClientRequestOpts): Promise<Pod> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods`;
    return await this.post<Pod>(path, params.query, params.body, opts);
  }
  async deleteCoreV1CollectionNamespacedPod(params: DeleteCoreV1CollectionNamespacedPodRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readCoreV1NamespacedPod(params: ReadCoreV1NamespacedPodRequest, opts?: APIClientRequestOpts): Promise<Pod> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods/${params.path.name}`;
    return await this.get<Pod>(path, null, null, opts);
  }
  async replaceCoreV1NamespacedPod(params: ReplaceCoreV1NamespacedPodRequest, opts?: APIClientRequestOpts): Promise<Pod> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods/${params.path.name}`;
    return await this.put<Pod>(path, params.query, params.body, opts);
  }
  async deleteCoreV1NamespacedPod(params: DeleteCoreV1NamespacedPodRequest, opts?: APIClientRequestOpts): Promise<Pod> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods/${params.path.name}`;
    return await this.delete<Pod>(path, params.query, null, opts);
  }
  async patchCoreV1NamespacedPod(params: PatchCoreV1NamespacedPodRequest, opts?: APIClientRequestOpts): Promise<Pod> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods/${params.path.name}`;
    return await this.patch<Pod>(path, params.query, null, opts);
  }
  async connectCoreV1GetNamespacedPodAttach(params: ConnectCoreV1GetNamespacedPodAttachRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods/${params.path.name}/attach`;
    return await this.get<string>(path, null, null, opts);
  }
  async connectCoreV1PostNamespacedPodAttach(params: ConnectCoreV1PostNamespacedPodAttachRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods/${params.path.name}/attach`;
    return await this.post<string>(path, null, null, opts);
  }
  async createCoreV1NamespacedPodBinding(params: CreateCoreV1NamespacedPodBindingRequest, opts?: APIClientRequestOpts): Promise<Binding> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods/${params.path.name}/binding`;
    return await this.post<Binding>(path, null, params.body, opts);
  }
  async readCoreV1NamespacedPodEphemeralcontainers(params: ReadCoreV1NamespacedPodEphemeralcontainersRequest, opts?: APIClientRequestOpts): Promise<Pod> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods/${params.path.name}/ephemeralcontainers`;
    return await this.get<Pod>(path, null, null, opts);
  }
  async replaceCoreV1NamespacedPodEphemeralcontainers(params: ReplaceCoreV1NamespacedPodEphemeralcontainersRequest, opts?: APIClientRequestOpts): Promise<Pod> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods/${params.path.name}/ephemeralcontainers`;
    return await this.put<Pod>(path, params.query, params.body, opts);
  }
  async patchCoreV1NamespacedPodEphemeralcontainers(params: PatchCoreV1NamespacedPodEphemeralcontainersRequest, opts?: APIClientRequestOpts): Promise<Pod> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods/${params.path.name}/ephemeralcontainers`;
    return await this.patch<Pod>(path, params.query, null, opts);
  }
  async createCoreV1NamespacedPodEviction(params: CreateCoreV1NamespacedPodEvictionRequest, opts?: APIClientRequestOpts): Promise<PolicyV1Eviction> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods/${params.path.name}/eviction`;
    return await this.post<PolicyV1Eviction>(path, null, params.body, opts);
  }
  async connectCoreV1GetNamespacedPodExec(params: ConnectCoreV1GetNamespacedPodExecRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods/${params.path.name}/exec`;
    return await this.get<string>(path, null, null, opts);
  }
  async connectCoreV1PostNamespacedPodExec(params: ConnectCoreV1PostNamespacedPodExecRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods/${params.path.name}/exec`;
    return await this.post<string>(path, null, null, opts);
  }
  async readCoreV1NamespacedPodLog(params: ReadCoreV1NamespacedPodLogRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods/${params.path.name}/log`;
    return await this.get<string>(path, null, null, opts);
  }
  async connectCoreV1GetNamespacedPodPortforward(params: ConnectCoreV1GetNamespacedPodPortforwardRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods/${params.path.name}/portforward`;
    return await this.get<string>(path, null, null, opts);
  }
  async connectCoreV1PostNamespacedPodPortforward(params: ConnectCoreV1PostNamespacedPodPortforwardRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods/${params.path.name}/portforward`;
    return await this.post<string>(path, null, null, opts);
  }
  async connectCoreV1GetNamespacedPodProxy(params: ConnectCoreV1GetNamespacedPodProxyRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods/${params.path.name}/proxy`;
    return await this.get<string>(path, null, null, opts);
  }
  async connectCoreV1PostNamespacedPodProxy(params: ConnectCoreV1PostNamespacedPodProxyRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods/${params.path.name}/proxy`;
    return await this.post<string>(path, null, null, opts);
  }
  async connectCoreV1PutNamespacedPodProxy(params: ConnectCoreV1PutNamespacedPodProxyRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods/${params.path.name}/proxy`;
    return await this.put<string>(path, null, null, opts);
  }
  async connectCoreV1DeleteNamespacedPodProxy(params: ConnectCoreV1DeleteNamespacedPodProxyRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods/${params.path.name}/proxy`;
    return await this.delete<string>(path, null, null, opts);
  }
  async connectCoreV1PatchNamespacedPodProxy(params: ConnectCoreV1PatchNamespacedPodProxyRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods/${params.path.name}/proxy`;
    return await this.patch<string>(path, null, null, opts);
  }
  async connectCoreV1GetNamespacedPodProxyWithPath(params: ConnectCoreV1GetNamespacedPodProxyWithPathRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods/${params.path.name}/proxy/${params.path.path}`;
    return await this.get<string>(path, null, null, opts);
  }
  async connectCoreV1PostNamespacedPodProxyWithPath(params: ConnectCoreV1PostNamespacedPodProxyWithPathRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods/${params.path.name}/proxy/${params.path.path}`;
    return await this.post<string>(path, null, null, opts);
  }
  async connectCoreV1PutNamespacedPodProxyWithPath(params: ConnectCoreV1PutNamespacedPodProxyWithPathRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods/${params.path.name}/proxy/${params.path.path}`;
    return await this.put<string>(path, null, null, opts);
  }
  async connectCoreV1DeleteNamespacedPodProxyWithPath(params: ConnectCoreV1DeleteNamespacedPodProxyWithPathRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods/${params.path.name}/proxy/${params.path.path}`;
    return await this.delete<string>(path, null, null, opts);
  }
  async connectCoreV1PatchNamespacedPodProxyWithPath(params: ConnectCoreV1PatchNamespacedPodProxyWithPathRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods/${params.path.name}/proxy/${params.path.path}`;
    return await this.patch<string>(path, null, null, opts);
  }
  async readCoreV1NamespacedPodStatus(params: ReadCoreV1NamespacedPodStatusRequest, opts?: APIClientRequestOpts): Promise<Pod> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods/${params.path.name}/status`;
    return await this.get<Pod>(path, null, null, opts);
  }
  async replaceCoreV1NamespacedPodStatus(params: ReplaceCoreV1NamespacedPodStatusRequest, opts?: APIClientRequestOpts): Promise<Pod> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods/${params.path.name}/status`;
    return await this.put<Pod>(path, params.query, params.body, opts);
  }
  async patchCoreV1NamespacedPodStatus(params: PatchCoreV1NamespacedPodStatusRequest, opts?: APIClientRequestOpts): Promise<Pod> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods/${params.path.name}/status`;
    return await this.patch<Pod>(path, params.query, null, opts);
  }
  async listCoreV1NamespacedPodTemplate(params: ListCoreV1NamespacedPodTemplateRequest, opts?: APIClientRequestOpts): Promise<PodTemplateList> {
    const path = `/api/v1/namespaces/${params.path.namespace}/podtemplates`;
    return await this.get<PodTemplateList>(path, null, null, opts);
  }
  async createCoreV1NamespacedPodTemplate(params: CreateCoreV1NamespacedPodTemplateRequest, opts?: APIClientRequestOpts): Promise<PodTemplate> {
    const path = `/api/v1/namespaces/${params.path.namespace}/podtemplates`;
    return await this.post<PodTemplate>(path, params.query, params.body, opts);
  }
  async deleteCoreV1CollectionNamespacedPodTemplate(params: DeleteCoreV1CollectionNamespacedPodTemplateRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/api/v1/namespaces/${params.path.namespace}/podtemplates`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readCoreV1NamespacedPodTemplate(params: ReadCoreV1NamespacedPodTemplateRequest, opts?: APIClientRequestOpts): Promise<PodTemplate> {
    const path = `/api/v1/namespaces/${params.path.namespace}/podtemplates/${params.path.name}`;
    return await this.get<PodTemplate>(path, null, null, opts);
  }
  async replaceCoreV1NamespacedPodTemplate(params: ReplaceCoreV1NamespacedPodTemplateRequest, opts?: APIClientRequestOpts): Promise<PodTemplate> {
    const path = `/api/v1/namespaces/${params.path.namespace}/podtemplates/${params.path.name}`;
    return await this.put<PodTemplate>(path, params.query, params.body, opts);
  }
  async deleteCoreV1NamespacedPodTemplate(params: DeleteCoreV1NamespacedPodTemplateRequest, opts?: APIClientRequestOpts): Promise<PodTemplate> {
    const path = `/api/v1/namespaces/${params.path.namespace}/podtemplates/${params.path.name}`;
    return await this.delete<PodTemplate>(path, params.query, null, opts);
  }
  async patchCoreV1NamespacedPodTemplate(params: PatchCoreV1NamespacedPodTemplateRequest, opts?: APIClientRequestOpts): Promise<PodTemplate> {
    const path = `/api/v1/namespaces/${params.path.namespace}/podtemplates/${params.path.name}`;
    return await this.patch<PodTemplate>(path, params.query, null, opts);
  }
  async listCoreV1NamespacedReplicationController(params: ListCoreV1NamespacedReplicationControllerRequest, opts?: APIClientRequestOpts): Promise<ReplicationControllerList> {
    const path = `/api/v1/namespaces/${params.path.namespace}/replicationcontrollers`;
    return await this.get<ReplicationControllerList>(path, null, null, opts);
  }
  async createCoreV1NamespacedReplicationController(params: CreateCoreV1NamespacedReplicationControllerRequest, opts?: APIClientRequestOpts): Promise<ReplicationController> {
    const path = `/api/v1/namespaces/${params.path.namespace}/replicationcontrollers`;
    return await this.post<ReplicationController>(path, params.query, params.body, opts);
  }
  async deleteCoreV1CollectionNamespacedReplicationController(params: DeleteCoreV1CollectionNamespacedReplicationControllerRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/api/v1/namespaces/${params.path.namespace}/replicationcontrollers`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readCoreV1NamespacedReplicationController(params: ReadCoreV1NamespacedReplicationControllerRequest, opts?: APIClientRequestOpts): Promise<ReplicationController> {
    const path = `/api/v1/namespaces/${params.path.namespace}/replicationcontrollers/${params.path.name}`;
    return await this.get<ReplicationController>(path, null, null, opts);
  }
  async replaceCoreV1NamespacedReplicationController(params: ReplaceCoreV1NamespacedReplicationControllerRequest, opts?: APIClientRequestOpts): Promise<ReplicationController> {
    const path = `/api/v1/namespaces/${params.path.namespace}/replicationcontrollers/${params.path.name}`;
    return await this.put<ReplicationController>(path, params.query, params.body, opts);
  }
  async deleteCoreV1NamespacedReplicationController(params: DeleteCoreV1NamespacedReplicationControllerRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/api/v1/namespaces/${params.path.namespace}/replicationcontrollers/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchCoreV1NamespacedReplicationController(params: PatchCoreV1NamespacedReplicationControllerRequest, opts?: APIClientRequestOpts): Promise<ReplicationController> {
    const path = `/api/v1/namespaces/${params.path.namespace}/replicationcontrollers/${params.path.name}`;
    return await this.patch<ReplicationController>(path, params.query, null, opts);
  }
  async readCoreV1NamespacedReplicationControllerScale(params: ReadCoreV1NamespacedReplicationControllerScaleRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1Scale> {
    const path = `/api/v1/namespaces/${params.path.namespace}/replicationcontrollers/${params.path.name}/scale`;
    return await this.get<AutoscalingV1Scale>(path, null, null, opts);
  }
  async replaceCoreV1NamespacedReplicationControllerScale(params: ReplaceCoreV1NamespacedReplicationControllerScaleRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1Scale> {
    const path = `/api/v1/namespaces/${params.path.namespace}/replicationcontrollers/${params.path.name}/scale`;
    return await this.put<AutoscalingV1Scale>(path, params.query, params.body, opts);
  }
  async patchCoreV1NamespacedReplicationControllerScale(params: PatchCoreV1NamespacedReplicationControllerScaleRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1Scale> {
    const path = `/api/v1/namespaces/${params.path.namespace}/replicationcontrollers/${params.path.name}/scale`;
    return await this.patch<AutoscalingV1Scale>(path, params.query, null, opts);
  }
  async readCoreV1NamespacedReplicationControllerStatus(params: ReadCoreV1NamespacedReplicationControllerStatusRequest, opts?: APIClientRequestOpts): Promise<ReplicationController> {
    const path = `/api/v1/namespaces/${params.path.namespace}/replicationcontrollers/${params.path.name}/status`;
    return await this.get<ReplicationController>(path, null, null, opts);
  }
  async replaceCoreV1NamespacedReplicationControllerStatus(params: ReplaceCoreV1NamespacedReplicationControllerStatusRequest, opts?: APIClientRequestOpts): Promise<ReplicationController> {
    const path = `/api/v1/namespaces/${params.path.namespace}/replicationcontrollers/${params.path.name}/status`;
    return await this.put<ReplicationController>(path, params.query, params.body, opts);
  }
  async patchCoreV1NamespacedReplicationControllerStatus(params: PatchCoreV1NamespacedReplicationControllerStatusRequest, opts?: APIClientRequestOpts): Promise<ReplicationController> {
    const path = `/api/v1/namespaces/${params.path.namespace}/replicationcontrollers/${params.path.name}/status`;
    return await this.patch<ReplicationController>(path, params.query, null, opts);
  }
  async listCoreV1NamespacedResourceQuota(params: ListCoreV1NamespacedResourceQuotaRequest, opts?: APIClientRequestOpts): Promise<ResourceQuotaList> {
    const path = `/api/v1/namespaces/${params.path.namespace}/resourcequotas`;
    return await this.get<ResourceQuotaList>(path, null, null, opts);
  }
  async createCoreV1NamespacedResourceQuota(params: CreateCoreV1NamespacedResourceQuotaRequest, opts?: APIClientRequestOpts): Promise<ResourceQuota> {
    const path = `/api/v1/namespaces/${params.path.namespace}/resourcequotas`;
    return await this.post<ResourceQuota>(path, params.query, params.body, opts);
  }
  async deleteCoreV1CollectionNamespacedResourceQuota(params: DeleteCoreV1CollectionNamespacedResourceQuotaRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/api/v1/namespaces/${params.path.namespace}/resourcequotas`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readCoreV1NamespacedResourceQuota(params: ReadCoreV1NamespacedResourceQuotaRequest, opts?: APIClientRequestOpts): Promise<ResourceQuota> {
    const path = `/api/v1/namespaces/${params.path.namespace}/resourcequotas/${params.path.name}`;
    return await this.get<ResourceQuota>(path, null, null, opts);
  }
  async replaceCoreV1NamespacedResourceQuota(params: ReplaceCoreV1NamespacedResourceQuotaRequest, opts?: APIClientRequestOpts): Promise<ResourceQuota> {
    const path = `/api/v1/namespaces/${params.path.namespace}/resourcequotas/${params.path.name}`;
    return await this.put<ResourceQuota>(path, params.query, params.body, opts);
  }
  async deleteCoreV1NamespacedResourceQuota(params: DeleteCoreV1NamespacedResourceQuotaRequest, opts?: APIClientRequestOpts): Promise<ResourceQuota> {
    const path = `/api/v1/namespaces/${params.path.namespace}/resourcequotas/${params.path.name}`;
    return await this.delete<ResourceQuota>(path, params.query, null, opts);
  }
  async patchCoreV1NamespacedResourceQuota(params: PatchCoreV1NamespacedResourceQuotaRequest, opts?: APIClientRequestOpts): Promise<ResourceQuota> {
    const path = `/api/v1/namespaces/${params.path.namespace}/resourcequotas/${params.path.name}`;
    return await this.patch<ResourceQuota>(path, params.query, null, opts);
  }
  async readCoreV1NamespacedResourceQuotaStatus(params: ReadCoreV1NamespacedResourceQuotaStatusRequest, opts?: APIClientRequestOpts): Promise<ResourceQuota> {
    const path = `/api/v1/namespaces/${params.path.namespace}/resourcequotas/${params.path.name}/status`;
    return await this.get<ResourceQuota>(path, null, null, opts);
  }
  async replaceCoreV1NamespacedResourceQuotaStatus(params: ReplaceCoreV1NamespacedResourceQuotaStatusRequest, opts?: APIClientRequestOpts): Promise<ResourceQuota> {
    const path = `/api/v1/namespaces/${params.path.namespace}/resourcequotas/${params.path.name}/status`;
    return await this.put<ResourceQuota>(path, params.query, params.body, opts);
  }
  async patchCoreV1NamespacedResourceQuotaStatus(params: PatchCoreV1NamespacedResourceQuotaStatusRequest, opts?: APIClientRequestOpts): Promise<ResourceQuota> {
    const path = `/api/v1/namespaces/${params.path.namespace}/resourcequotas/${params.path.name}/status`;
    return await this.patch<ResourceQuota>(path, params.query, null, opts);
  }
  async listCoreV1NamespacedSecret(params: ListCoreV1NamespacedSecretRequest, opts?: APIClientRequestOpts): Promise<SecretList> {
    const path = `/api/v1/namespaces/${params.path.namespace}/secrets`;
    return await this.get<SecretList>(path, null, null, opts);
  }
  async createCoreV1NamespacedSecret(params: CreateCoreV1NamespacedSecretRequest, opts?: APIClientRequestOpts): Promise<Secret> {
    const path = `/api/v1/namespaces/${params.path.namespace}/secrets`;
    return await this.post<Secret>(path, params.query, params.body, opts);
  }
  async deleteCoreV1CollectionNamespacedSecret(params: DeleteCoreV1CollectionNamespacedSecretRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/api/v1/namespaces/${params.path.namespace}/secrets`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readCoreV1NamespacedSecret(params: ReadCoreV1NamespacedSecretRequest, opts?: APIClientRequestOpts): Promise<Secret> {
    const path = `/api/v1/namespaces/${params.path.namespace}/secrets/${params.path.name}`;
    return await this.get<Secret>(path, null, null, opts);
  }
  async replaceCoreV1NamespacedSecret(params: ReplaceCoreV1NamespacedSecretRequest, opts?: APIClientRequestOpts): Promise<Secret> {
    const path = `/api/v1/namespaces/${params.path.namespace}/secrets/${params.path.name}`;
    return await this.put<Secret>(path, params.query, params.body, opts);
  }
  async deleteCoreV1NamespacedSecret(params: DeleteCoreV1NamespacedSecretRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/api/v1/namespaces/${params.path.namespace}/secrets/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchCoreV1NamespacedSecret(params: PatchCoreV1NamespacedSecretRequest, opts?: APIClientRequestOpts): Promise<Secret> {
    const path = `/api/v1/namespaces/${params.path.namespace}/secrets/${params.path.name}`;
    return await this.patch<Secret>(path, params.query, null, opts);
  }
  async listCoreV1NamespacedServiceAccount(params: ListCoreV1NamespacedServiceAccountRequest, opts?: APIClientRequestOpts): Promise<ServiceAccountList> {
    const path = `/api/v1/namespaces/${params.path.namespace}/serviceaccounts`;
    return await this.get<ServiceAccountList>(path, null, null, opts);
  }
  async createCoreV1NamespacedServiceAccount(params: CreateCoreV1NamespacedServiceAccountRequest, opts?: APIClientRequestOpts): Promise<ServiceAccount> {
    const path = `/api/v1/namespaces/${params.path.namespace}/serviceaccounts`;
    return await this.post<ServiceAccount>(path, params.query, params.body, opts);
  }
  async deleteCoreV1CollectionNamespacedServiceAccount(params: DeleteCoreV1CollectionNamespacedServiceAccountRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/api/v1/namespaces/${params.path.namespace}/serviceaccounts`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readCoreV1NamespacedServiceAccount(params: ReadCoreV1NamespacedServiceAccountRequest, opts?: APIClientRequestOpts): Promise<ServiceAccount> {
    const path = `/api/v1/namespaces/${params.path.namespace}/serviceaccounts/${params.path.name}`;
    return await this.get<ServiceAccount>(path, null, null, opts);
  }
  async replaceCoreV1NamespacedServiceAccount(params: ReplaceCoreV1NamespacedServiceAccountRequest, opts?: APIClientRequestOpts): Promise<ServiceAccount> {
    const path = `/api/v1/namespaces/${params.path.namespace}/serviceaccounts/${params.path.name}`;
    return await this.put<ServiceAccount>(path, params.query, params.body, opts);
  }
  async deleteCoreV1NamespacedServiceAccount(params: DeleteCoreV1NamespacedServiceAccountRequest, opts?: APIClientRequestOpts): Promise<ServiceAccount> {
    const path = `/api/v1/namespaces/${params.path.namespace}/serviceaccounts/${params.path.name}`;
    return await this.delete<ServiceAccount>(path, params.query, null, opts);
  }
  async patchCoreV1NamespacedServiceAccount(params: PatchCoreV1NamespacedServiceAccountRequest, opts?: APIClientRequestOpts): Promise<ServiceAccount> {
    const path = `/api/v1/namespaces/${params.path.namespace}/serviceaccounts/${params.path.name}`;
    return await this.patch<ServiceAccount>(path, params.query, null, opts);
  }
  async createCoreV1NamespacedServiceAccountToken(params: CreateCoreV1NamespacedServiceAccountTokenRequest, opts?: APIClientRequestOpts): Promise<AuthenticationK8sIoV1TokenRequest> {
    const path = `/api/v1/namespaces/${params.path.namespace}/serviceaccounts/${params.path.name}/token`;
    return await this.post<AuthenticationK8sIoV1TokenRequest>(path, null, params.body, opts);
  }
  async listCoreV1NamespacedService(params: ListCoreV1NamespacedServiceRequest, opts?: APIClientRequestOpts): Promise<ServiceList> {
    const path = `/api/v1/namespaces/${params.path.namespace}/services`;
    return await this.get<ServiceList>(path, null, null, opts);
  }
  async createCoreV1NamespacedService(params: CreateCoreV1NamespacedServiceRequest, opts?: APIClientRequestOpts): Promise<Service> {
    const path = `/api/v1/namespaces/${params.path.namespace}/services`;
    return await this.post<Service>(path, params.query, params.body, opts);
  }
  async deleteCoreV1CollectionNamespacedService(params: DeleteCoreV1CollectionNamespacedServiceRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/api/v1/namespaces/${params.path.namespace}/services`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readCoreV1NamespacedService(params: ReadCoreV1NamespacedServiceRequest, opts?: APIClientRequestOpts): Promise<Service> {
    const path = `/api/v1/namespaces/${params.path.namespace}/services/${params.path.name}`;
    return await this.get<Service>(path, null, null, opts);
  }
  async replaceCoreV1NamespacedService(params: ReplaceCoreV1NamespacedServiceRequest, opts?: APIClientRequestOpts): Promise<Service> {
    const path = `/api/v1/namespaces/${params.path.namespace}/services/${params.path.name}`;
    return await this.put<Service>(path, params.query, params.body, opts);
  }
  async deleteCoreV1NamespacedService(params: DeleteCoreV1NamespacedServiceRequest, opts?: APIClientRequestOpts): Promise<Service> {
    const path = `/api/v1/namespaces/${params.path.namespace}/services/${params.path.name}`;
    return await this.delete<Service>(path, params.query, null, opts);
  }
  async patchCoreV1NamespacedService(params: PatchCoreV1NamespacedServiceRequest, opts?: APIClientRequestOpts): Promise<Service> {
    const path = `/api/v1/namespaces/${params.path.namespace}/services/${params.path.name}`;
    return await this.patch<Service>(path, params.query, null, opts);
  }
  async connectCoreV1GetNamespacedServiceProxy(params: ConnectCoreV1GetNamespacedServiceProxyRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/namespaces/${params.path.namespace}/services/${params.path.name}/proxy`;
    return await this.get<string>(path, null, null, opts);
  }
  async connectCoreV1PostNamespacedServiceProxy(params: ConnectCoreV1PostNamespacedServiceProxyRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/namespaces/${params.path.namespace}/services/${params.path.name}/proxy`;
    return await this.post<string>(path, null, null, opts);
  }
  async connectCoreV1PutNamespacedServiceProxy(params: ConnectCoreV1PutNamespacedServiceProxyRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/namespaces/${params.path.namespace}/services/${params.path.name}/proxy`;
    return await this.put<string>(path, null, null, opts);
  }
  async connectCoreV1DeleteNamespacedServiceProxy(params: ConnectCoreV1DeleteNamespacedServiceProxyRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/namespaces/${params.path.namespace}/services/${params.path.name}/proxy`;
    return await this.delete<string>(path, null, null, opts);
  }
  async connectCoreV1PatchNamespacedServiceProxy(params: ConnectCoreV1PatchNamespacedServiceProxyRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/namespaces/${params.path.namespace}/services/${params.path.name}/proxy`;
    return await this.patch<string>(path, null, null, opts);
  }
  async connectCoreV1GetNamespacedServiceProxyWithPath(params: ConnectCoreV1GetNamespacedServiceProxyWithPathRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/namespaces/${params.path.namespace}/services/${params.path.name}/proxy/${params.path.path}`;
    return await this.get<string>(path, null, null, opts);
  }
  async connectCoreV1PostNamespacedServiceProxyWithPath(params: ConnectCoreV1PostNamespacedServiceProxyWithPathRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/namespaces/${params.path.namespace}/services/${params.path.name}/proxy/${params.path.path}`;
    return await this.post<string>(path, null, null, opts);
  }
  async connectCoreV1PutNamespacedServiceProxyWithPath(params: ConnectCoreV1PutNamespacedServiceProxyWithPathRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/namespaces/${params.path.namespace}/services/${params.path.name}/proxy/${params.path.path}`;
    return await this.put<string>(path, null, null, opts);
  }
  async connectCoreV1DeleteNamespacedServiceProxyWithPath(params: ConnectCoreV1DeleteNamespacedServiceProxyWithPathRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/namespaces/${params.path.namespace}/services/${params.path.name}/proxy/${params.path.path}`;
    return await this.delete<string>(path, null, null, opts);
  }
  async connectCoreV1PatchNamespacedServiceProxyWithPath(params: ConnectCoreV1PatchNamespacedServiceProxyWithPathRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/namespaces/${params.path.namespace}/services/${params.path.name}/proxy/${params.path.path}`;
    return await this.patch<string>(path, null, null, opts);
  }
  async readCoreV1NamespacedServiceStatus(params: ReadCoreV1NamespacedServiceStatusRequest, opts?: APIClientRequestOpts): Promise<Service> {
    const path = `/api/v1/namespaces/${params.path.namespace}/services/${params.path.name}/status`;
    return await this.get<Service>(path, null, null, opts);
  }
  async replaceCoreV1NamespacedServiceStatus(params: ReplaceCoreV1NamespacedServiceStatusRequest, opts?: APIClientRequestOpts): Promise<Service> {
    const path = `/api/v1/namespaces/${params.path.namespace}/services/${params.path.name}/status`;
    return await this.put<Service>(path, params.query, params.body, opts);
  }
  async patchCoreV1NamespacedServiceStatus(params: PatchCoreV1NamespacedServiceStatusRequest, opts?: APIClientRequestOpts): Promise<Service> {
    const path = `/api/v1/namespaces/${params.path.namespace}/services/${params.path.name}/status`;
    return await this.patch<Service>(path, params.query, null, opts);
  }
  async readCoreV1Namespace(params: ReadCoreV1NamespaceRequest, opts?: APIClientRequestOpts): Promise<Namespace> {
    const path = `/api/v1/namespaces/${params.path.name}`;
    return await this.get<Namespace>(path, null, null, opts);
  }
  async replaceCoreV1Namespace(params: ReplaceCoreV1NamespaceRequest, opts?: APIClientRequestOpts): Promise<Namespace> {
    const path = `/api/v1/namespaces/${params.path.name}`;
    return await this.put<Namespace>(path, params.query, params.body, opts);
  }
  async deleteCoreV1Namespace(params: DeleteCoreV1NamespaceRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/api/v1/namespaces/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchCoreV1Namespace(params: PatchCoreV1NamespaceRequest, opts?: APIClientRequestOpts): Promise<Namespace> {
    const path = `/api/v1/namespaces/${params.path.name}`;
    return await this.patch<Namespace>(path, params.query, null, opts);
  }
  async replaceCoreV1NamespaceFinalize(params: ReplaceCoreV1NamespaceFinalizeRequest, opts?: APIClientRequestOpts): Promise<Namespace> {
    const path = `/api/v1/namespaces/${params.path.name}/finalize`;
    return await this.put<Namespace>(path, null, params.body, opts);
  }
  async readCoreV1NamespaceStatus(params: ReadCoreV1NamespaceStatusRequest, opts?: APIClientRequestOpts): Promise<Namespace> {
    const path = `/api/v1/namespaces/${params.path.name}/status`;
    return await this.get<Namespace>(path, null, null, opts);
  }
  async replaceCoreV1NamespaceStatus(params: ReplaceCoreV1NamespaceStatusRequest, opts?: APIClientRequestOpts): Promise<Namespace> {
    const path = `/api/v1/namespaces/${params.path.name}/status`;
    return await this.put<Namespace>(path, params.query, params.body, opts);
  }
  async patchCoreV1NamespaceStatus(params: PatchCoreV1NamespaceStatusRequest, opts?: APIClientRequestOpts): Promise<Namespace> {
    const path = `/api/v1/namespaces/${params.path.name}/status`;
    return await this.patch<Namespace>(path, params.query, null, opts);
  }
  async listCoreV1Node(params: ListCoreV1NodeRequest, opts?: APIClientRequestOpts): Promise<NodeList> {
    const path = `/api/v1/nodes`;
    return await this.get<NodeList>(path, null, null, opts);
  }
  async createCoreV1Node(params: CreateCoreV1NodeRequest, opts?: APIClientRequestOpts): Promise<Node> {
    const path = `/api/v1/nodes`;
    return await this.post<Node>(path, params.query, params.body, opts);
  }
  async deleteCoreV1CollectionNode(params: DeleteCoreV1CollectionNodeRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/api/v1/nodes`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readCoreV1Node(params: ReadCoreV1NodeRequest, opts?: APIClientRequestOpts): Promise<Node> {
    const path = `/api/v1/nodes/${params.path.name}`;
    return await this.get<Node>(path, null, null, opts);
  }
  async replaceCoreV1Node(params: ReplaceCoreV1NodeRequest, opts?: APIClientRequestOpts): Promise<Node> {
    const path = `/api/v1/nodes/${params.path.name}`;
    return await this.put<Node>(path, params.query, params.body, opts);
  }
  async deleteCoreV1Node(params: DeleteCoreV1NodeRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/api/v1/nodes/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchCoreV1Node(params: PatchCoreV1NodeRequest, opts?: APIClientRequestOpts): Promise<Node> {
    const path = `/api/v1/nodes/${params.path.name}`;
    return await this.patch<Node>(path, params.query, null, opts);
  }
  async connectCoreV1GetNodeProxy(params: ConnectCoreV1GetNodeProxyRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/nodes/${params.path.name}/proxy`;
    return await this.get<string>(path, null, null, opts);
  }
  async connectCoreV1PostNodeProxy(params: ConnectCoreV1PostNodeProxyRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/nodes/${params.path.name}/proxy`;
    return await this.post<string>(path, null, null, opts);
  }
  async connectCoreV1PutNodeProxy(params: ConnectCoreV1PutNodeProxyRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/nodes/${params.path.name}/proxy`;
    return await this.put<string>(path, null, null, opts);
  }
  async connectCoreV1DeleteNodeProxy(params: ConnectCoreV1DeleteNodeProxyRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/nodes/${params.path.name}/proxy`;
    return await this.delete<string>(path, null, null, opts);
  }
  async connectCoreV1PatchNodeProxy(params: ConnectCoreV1PatchNodeProxyRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/nodes/${params.path.name}/proxy`;
    return await this.patch<string>(path, null, null, opts);
  }
  async connectCoreV1GetNodeProxyWithPath(params: ConnectCoreV1GetNodeProxyWithPathRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/nodes/${params.path.name}/proxy/${params.path.path}`;
    return await this.get<string>(path, null, null, opts);
  }
  async connectCoreV1PostNodeProxyWithPath(params: ConnectCoreV1PostNodeProxyWithPathRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/nodes/${params.path.name}/proxy/${params.path.path}`;
    return await this.post<string>(path, null, null, opts);
  }
  async connectCoreV1PutNodeProxyWithPath(params: ConnectCoreV1PutNodeProxyWithPathRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/nodes/${params.path.name}/proxy/${params.path.path}`;
    return await this.put<string>(path, null, null, opts);
  }
  async connectCoreV1DeleteNodeProxyWithPath(params: ConnectCoreV1DeleteNodeProxyWithPathRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/nodes/${params.path.name}/proxy/${params.path.path}`;
    return await this.delete<string>(path, null, null, opts);
  }
  async connectCoreV1PatchNodeProxyWithPath(params: ConnectCoreV1PatchNodeProxyWithPathRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/nodes/${params.path.name}/proxy/${params.path.path}`;
    return await this.patch<string>(path, null, null, opts);
  }
  async readCoreV1NodeStatus(params: ReadCoreV1NodeStatusRequest, opts?: APIClientRequestOpts): Promise<Node> {
    const path = `/api/v1/nodes/${params.path.name}/status`;
    return await this.get<Node>(path, null, null, opts);
  }
  async replaceCoreV1NodeStatus(params: ReplaceCoreV1NodeStatusRequest, opts?: APIClientRequestOpts): Promise<Node> {
    const path = `/api/v1/nodes/${params.path.name}/status`;
    return await this.put<Node>(path, params.query, params.body, opts);
  }
  async patchCoreV1NodeStatus(params: PatchCoreV1NodeStatusRequest, opts?: APIClientRequestOpts): Promise<Node> {
    const path = `/api/v1/nodes/${params.path.name}/status`;
    return await this.patch<Node>(path, params.query, null, opts);
  }
  async listCoreV1PersistentVolumeClaimForAllNamespaces(params: ListCoreV1PersistentVolumeClaimForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<PersistentVolumeClaimList> {
    const path = `/api/v1/persistentvolumeclaims`;
    return await this.get<PersistentVolumeClaimList>(path, null, null, opts);
  }
  async listCoreV1PersistentVolume(params: ListCoreV1PersistentVolumeRequest, opts?: APIClientRequestOpts): Promise<PersistentVolumeList> {
    const path = `/api/v1/persistentvolumes`;
    return await this.get<PersistentVolumeList>(path, null, null, opts);
  }
  async createCoreV1PersistentVolume(params: CreateCoreV1PersistentVolumeRequest, opts?: APIClientRequestOpts): Promise<PersistentVolume> {
    const path = `/api/v1/persistentvolumes`;
    return await this.post<PersistentVolume>(path, params.query, params.body, opts);
  }
  async deleteCoreV1CollectionPersistentVolume(params: DeleteCoreV1CollectionPersistentVolumeRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/api/v1/persistentvolumes`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readCoreV1PersistentVolume(params: ReadCoreV1PersistentVolumeRequest, opts?: APIClientRequestOpts): Promise<PersistentVolume> {
    const path = `/api/v1/persistentvolumes/${params.path.name}`;
    return await this.get<PersistentVolume>(path, null, null, opts);
  }
  async replaceCoreV1PersistentVolume(params: ReplaceCoreV1PersistentVolumeRequest, opts?: APIClientRequestOpts): Promise<PersistentVolume> {
    const path = `/api/v1/persistentvolumes/${params.path.name}`;
    return await this.put<PersistentVolume>(path, params.query, params.body, opts);
  }
  async deleteCoreV1PersistentVolume(params: DeleteCoreV1PersistentVolumeRequest, opts?: APIClientRequestOpts): Promise<PersistentVolume> {
    const path = `/api/v1/persistentvolumes/${params.path.name}`;
    return await this.delete<PersistentVolume>(path, params.query, null, opts);
  }
  async patchCoreV1PersistentVolume(params: PatchCoreV1PersistentVolumeRequest, opts?: APIClientRequestOpts): Promise<PersistentVolume> {
    const path = `/api/v1/persistentvolumes/${params.path.name}`;
    return await this.patch<PersistentVolume>(path, params.query, null, opts);
  }
  async readCoreV1PersistentVolumeStatus(params: ReadCoreV1PersistentVolumeStatusRequest, opts?: APIClientRequestOpts): Promise<PersistentVolume> {
    const path = `/api/v1/persistentvolumes/${params.path.name}/status`;
    return await this.get<PersistentVolume>(path, null, null, opts);
  }
  async replaceCoreV1PersistentVolumeStatus(params: ReplaceCoreV1PersistentVolumeStatusRequest, opts?: APIClientRequestOpts): Promise<PersistentVolume> {
    const path = `/api/v1/persistentvolumes/${params.path.name}/status`;
    return await this.put<PersistentVolume>(path, params.query, params.body, opts);
  }
  async patchCoreV1PersistentVolumeStatus(params: PatchCoreV1PersistentVolumeStatusRequest, opts?: APIClientRequestOpts): Promise<PersistentVolume> {
    const path = `/api/v1/persistentvolumes/${params.path.name}/status`;
    return await this.patch<PersistentVolume>(path, params.query, null, opts);
  }
  async listCoreV1PodForAllNamespaces(params: ListCoreV1PodForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<PodList> {
    const path = `/api/v1/pods`;
    return await this.get<PodList>(path, null, null, opts);
  }
  async listCoreV1PodTemplateForAllNamespaces(params: ListCoreV1PodTemplateForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<PodTemplateList> {
    const path = `/api/v1/podtemplates`;
    return await this.get<PodTemplateList>(path, null, null, opts);
  }
  async listCoreV1ReplicationControllerForAllNamespaces(params: ListCoreV1ReplicationControllerForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<ReplicationControllerList> {
    const path = `/api/v1/replicationcontrollers`;
    return await this.get<ReplicationControllerList>(path, null, null, opts);
  }
  async listCoreV1ResourceQuotaForAllNamespaces(params: ListCoreV1ResourceQuotaForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<ResourceQuotaList> {
    const path = `/api/v1/resourcequotas`;
    return await this.get<ResourceQuotaList>(path, null, null, opts);
  }
  async listCoreV1SecretForAllNamespaces(params: ListCoreV1SecretForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<SecretList> {
    const path = `/api/v1/secrets`;
    return await this.get<SecretList>(path, null, null, opts);
  }
  async listCoreV1ServiceAccountForAllNamespaces(params: ListCoreV1ServiceAccountForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<ServiceAccountList> {
    const path = `/api/v1/serviceaccounts`;
    return await this.get<ServiceAccountList>(path, null, null, opts);
  }
  async listCoreV1ServiceForAllNamespaces(params: ListCoreV1ServiceForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<ServiceList> {
    const path = `/api/v1/services`;
    return await this.get<ServiceList>(path, null, null, opts);
  }
  async watchCoreV1ConfigMapListForAllNamespaces(params: WatchCoreV1ConfigMapListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/configmaps`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1EndpointsListForAllNamespaces(params: WatchCoreV1EndpointsListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/endpoints`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1EventListForAllNamespaces(params: WatchCoreV1EventListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/events`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1LimitRangeListForAllNamespaces(params: WatchCoreV1LimitRangeListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/limitranges`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1NamespaceList(params: WatchCoreV1NamespaceListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/namespaces`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1NamespacedConfigMapList(params: WatchCoreV1NamespacedConfigMapListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/namespaces/${params.path.namespace}/configmaps`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1NamespacedConfigMap(params: WatchCoreV1NamespacedConfigMapRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/namespaces/${params.path.namespace}/configmaps/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1NamespacedEndpointsList(params: WatchCoreV1NamespacedEndpointsListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/namespaces/${params.path.namespace}/endpoints`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1NamespacedEndpoints(params: WatchCoreV1NamespacedEndpointsRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/namespaces/${params.path.namespace}/endpoints/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1NamespacedEventList(params: WatchCoreV1NamespacedEventListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/namespaces/${params.path.namespace}/events`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1NamespacedEvent(params: WatchCoreV1NamespacedEventRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/namespaces/${params.path.namespace}/events/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1NamespacedLimitRangeList(params: WatchCoreV1NamespacedLimitRangeListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/namespaces/${params.path.namespace}/limitranges`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1NamespacedLimitRange(params: WatchCoreV1NamespacedLimitRangeRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/namespaces/${params.path.namespace}/limitranges/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1NamespacedPersistentVolumeClaimList(params: WatchCoreV1NamespacedPersistentVolumeClaimListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/namespaces/${params.path.namespace}/persistentvolumeclaims`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1NamespacedPersistentVolumeClaim(params: WatchCoreV1NamespacedPersistentVolumeClaimRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/namespaces/${params.path.namespace}/persistentvolumeclaims/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1NamespacedPodList(params: WatchCoreV1NamespacedPodListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/namespaces/${params.path.namespace}/pods`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1NamespacedPod(params: WatchCoreV1NamespacedPodRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/namespaces/${params.path.namespace}/pods/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1NamespacedPodTemplateList(params: WatchCoreV1NamespacedPodTemplateListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/namespaces/${params.path.namespace}/podtemplates`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1NamespacedPodTemplate(params: WatchCoreV1NamespacedPodTemplateRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/namespaces/${params.path.namespace}/podtemplates/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1NamespacedReplicationControllerList(params: WatchCoreV1NamespacedReplicationControllerListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/namespaces/${params.path.namespace}/replicationcontrollers`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1NamespacedReplicationController(params: WatchCoreV1NamespacedReplicationControllerRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/namespaces/${params.path.namespace}/replicationcontrollers/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1NamespacedResourceQuotaList(params: WatchCoreV1NamespacedResourceQuotaListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/namespaces/${params.path.namespace}/resourcequotas`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1NamespacedResourceQuota(params: WatchCoreV1NamespacedResourceQuotaRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/namespaces/${params.path.namespace}/resourcequotas/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1NamespacedSecretList(params: WatchCoreV1NamespacedSecretListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/namespaces/${params.path.namespace}/secrets`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1NamespacedSecret(params: WatchCoreV1NamespacedSecretRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/namespaces/${params.path.namespace}/secrets/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1NamespacedServiceAccountList(params: WatchCoreV1NamespacedServiceAccountListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/namespaces/${params.path.namespace}/serviceaccounts`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1NamespacedServiceAccount(params: WatchCoreV1NamespacedServiceAccountRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/namespaces/${params.path.namespace}/serviceaccounts/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1NamespacedServiceList(params: WatchCoreV1NamespacedServiceListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/namespaces/${params.path.namespace}/services`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1NamespacedService(params: WatchCoreV1NamespacedServiceRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/namespaces/${params.path.namespace}/services/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1Namespace(params: WatchCoreV1NamespaceRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/namespaces/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1NodeList(params: WatchCoreV1NodeListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/nodes`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1Node(params: WatchCoreV1NodeRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/nodes/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1PersistentVolumeClaimListForAllNamespaces(params: WatchCoreV1PersistentVolumeClaimListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/persistentvolumeclaims`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1PersistentVolumeList(params: WatchCoreV1PersistentVolumeListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/persistentvolumes`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1PersistentVolume(params: WatchCoreV1PersistentVolumeRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/persistentvolumes/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1PodListForAllNamespaces(params: WatchCoreV1PodListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/pods`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1PodTemplateListForAllNamespaces(params: WatchCoreV1PodTemplateListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/podtemplates`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1ReplicationControllerListForAllNamespaces(params: WatchCoreV1ReplicationControllerListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/replicationcontrollers`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1ResourceQuotaListForAllNamespaces(params: WatchCoreV1ResourceQuotaListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/resourcequotas`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1SecretListForAllNamespaces(params: WatchCoreV1SecretListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/secrets`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1ServiceAccountListForAllNamespaces(params: WatchCoreV1ServiceAccountListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/serviceaccounts`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1ServiceListForAllNamespaces(params: WatchCoreV1ServiceListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/services`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async getAPIVersions(params: GetAPIVersionsRequest, opts?: APIClientRequestOpts): Promise<APIGroupList> {
    const path = `/apis/`;
    return await this.get<APIGroupList>(path, null, null, opts);
  }
  async listAcmeCertManagerIoV1ChallengeForAllNamespaces(params: ListAcmeCertManagerIoV1ChallengeForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<AcmeCertManagerIoV1ChallengeList> {
    const path = `/apis/acme.cert-manager.io/v1/challenges`;
    return await this.get<AcmeCertManagerIoV1ChallengeList>(path, null, null, opts);
  }
  async listAcmeCertManagerIoV1NamespacedChallenge(params: ListAcmeCertManagerIoV1NamespacedChallengeRequest, opts?: APIClientRequestOpts): Promise<AcmeCertManagerIoV1ChallengeList> {
    const path = `/apis/acme.cert-manager.io/v1/namespaces/${params.path.namespace}/challenges`;
    return await this.get<AcmeCertManagerIoV1ChallengeList>(path, null, null, opts);
  }
  async createAcmeCertManagerIoV1NamespacedChallenge(params: CreateAcmeCertManagerIoV1NamespacedChallengeRequest, opts?: APIClientRequestOpts): Promise<AcmeCertManagerIoV1Challenge> {
    const path = `/apis/acme.cert-manager.io/v1/namespaces/${params.path.namespace}/challenges`;
    return await this.post<AcmeCertManagerIoV1Challenge>(path, params.query, params.body, opts);
  }
  async deleteAcmeCertManagerIoV1CollectionNamespacedChallenge(params: DeleteAcmeCertManagerIoV1CollectionNamespacedChallengeRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/acme.cert-manager.io/v1/namespaces/${params.path.namespace}/challenges`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readAcmeCertManagerIoV1NamespacedChallenge(params: ReadAcmeCertManagerIoV1NamespacedChallengeRequest, opts?: APIClientRequestOpts): Promise<AcmeCertManagerIoV1Challenge> {
    const path = `/apis/acme.cert-manager.io/v1/namespaces/${params.path.namespace}/challenges/${params.path.name}`;
    return await this.get<AcmeCertManagerIoV1Challenge>(path, null, null, opts);
  }
  async replaceAcmeCertManagerIoV1NamespacedChallenge(params: ReplaceAcmeCertManagerIoV1NamespacedChallengeRequest, opts?: APIClientRequestOpts): Promise<AcmeCertManagerIoV1Challenge> {
    const path = `/apis/acme.cert-manager.io/v1/namespaces/${params.path.namespace}/challenges/${params.path.name}`;
    return await this.put<AcmeCertManagerIoV1Challenge>(path, params.query, params.body, opts);
  }
  async deleteAcmeCertManagerIoV1NamespacedChallenge(params: DeleteAcmeCertManagerIoV1NamespacedChallengeRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/acme.cert-manager.io/v1/namespaces/${params.path.namespace}/challenges/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchAcmeCertManagerIoV1NamespacedChallenge(params: PatchAcmeCertManagerIoV1NamespacedChallengeRequest, opts?: APIClientRequestOpts): Promise<AcmeCertManagerIoV1Challenge> {
    const path = `/apis/acme.cert-manager.io/v1/namespaces/${params.path.namespace}/challenges/${params.path.name}`;
    return await this.patch<AcmeCertManagerIoV1Challenge>(path, params.query, null, opts);
  }
  async readAcmeCertManagerIoV1NamespacedChallengeStatus(params: ReadAcmeCertManagerIoV1NamespacedChallengeStatusRequest, opts?: APIClientRequestOpts): Promise<AcmeCertManagerIoV1Challenge> {
    const path = `/apis/acme.cert-manager.io/v1/namespaces/${params.path.namespace}/challenges/${params.path.name}/status`;
    return await this.get<AcmeCertManagerIoV1Challenge>(path, null, null, opts);
  }
  async replaceAcmeCertManagerIoV1NamespacedChallengeStatus(params: ReplaceAcmeCertManagerIoV1NamespacedChallengeStatusRequest, opts?: APIClientRequestOpts): Promise<AcmeCertManagerIoV1Challenge> {
    const path = `/apis/acme.cert-manager.io/v1/namespaces/${params.path.namespace}/challenges/${params.path.name}/status`;
    return await this.put<AcmeCertManagerIoV1Challenge>(path, params.query, params.body, opts);
  }
  async patchAcmeCertManagerIoV1NamespacedChallengeStatus(params: PatchAcmeCertManagerIoV1NamespacedChallengeStatusRequest, opts?: APIClientRequestOpts): Promise<AcmeCertManagerIoV1Challenge> {
    const path = `/apis/acme.cert-manager.io/v1/namespaces/${params.path.namespace}/challenges/${params.path.name}/status`;
    return await this.patch<AcmeCertManagerIoV1Challenge>(path, params.query, null, opts);
  }
  async listAcmeCertManagerIoV1NamespacedOrder(params: ListAcmeCertManagerIoV1NamespacedOrderRequest, opts?: APIClientRequestOpts): Promise<AcmeCertManagerIoV1OrderList> {
    const path = `/apis/acme.cert-manager.io/v1/namespaces/${params.path.namespace}/orders`;
    return await this.get<AcmeCertManagerIoV1OrderList>(path, null, null, opts);
  }
  async createAcmeCertManagerIoV1NamespacedOrder(params: CreateAcmeCertManagerIoV1NamespacedOrderRequest, opts?: APIClientRequestOpts): Promise<AcmeCertManagerIoV1Order> {
    const path = `/apis/acme.cert-manager.io/v1/namespaces/${params.path.namespace}/orders`;
    return await this.post<AcmeCertManagerIoV1Order>(path, params.query, params.body, opts);
  }
  async deleteAcmeCertManagerIoV1CollectionNamespacedOrder(params: DeleteAcmeCertManagerIoV1CollectionNamespacedOrderRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/acme.cert-manager.io/v1/namespaces/${params.path.namespace}/orders`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readAcmeCertManagerIoV1NamespacedOrder(params: ReadAcmeCertManagerIoV1NamespacedOrderRequest, opts?: APIClientRequestOpts): Promise<AcmeCertManagerIoV1Order> {
    const path = `/apis/acme.cert-manager.io/v1/namespaces/${params.path.namespace}/orders/${params.path.name}`;
    return await this.get<AcmeCertManagerIoV1Order>(path, null, null, opts);
  }
  async replaceAcmeCertManagerIoV1NamespacedOrder(params: ReplaceAcmeCertManagerIoV1NamespacedOrderRequest, opts?: APIClientRequestOpts): Promise<AcmeCertManagerIoV1Order> {
    const path = `/apis/acme.cert-manager.io/v1/namespaces/${params.path.namespace}/orders/${params.path.name}`;
    return await this.put<AcmeCertManagerIoV1Order>(path, params.query, params.body, opts);
  }
  async deleteAcmeCertManagerIoV1NamespacedOrder(params: DeleteAcmeCertManagerIoV1NamespacedOrderRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/acme.cert-manager.io/v1/namespaces/${params.path.namespace}/orders/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchAcmeCertManagerIoV1NamespacedOrder(params: PatchAcmeCertManagerIoV1NamespacedOrderRequest, opts?: APIClientRequestOpts): Promise<AcmeCertManagerIoV1Order> {
    const path = `/apis/acme.cert-manager.io/v1/namespaces/${params.path.namespace}/orders/${params.path.name}`;
    return await this.patch<AcmeCertManagerIoV1Order>(path, params.query, null, opts);
  }
  async readAcmeCertManagerIoV1NamespacedOrderStatus(params: ReadAcmeCertManagerIoV1NamespacedOrderStatusRequest, opts?: APIClientRequestOpts): Promise<AcmeCertManagerIoV1Order> {
    const path = `/apis/acme.cert-manager.io/v1/namespaces/${params.path.namespace}/orders/${params.path.name}/status`;
    return await this.get<AcmeCertManagerIoV1Order>(path, null, null, opts);
  }
  async replaceAcmeCertManagerIoV1NamespacedOrderStatus(params: ReplaceAcmeCertManagerIoV1NamespacedOrderStatusRequest, opts?: APIClientRequestOpts): Promise<AcmeCertManagerIoV1Order> {
    const path = `/apis/acme.cert-manager.io/v1/namespaces/${params.path.namespace}/orders/${params.path.name}/status`;
    return await this.put<AcmeCertManagerIoV1Order>(path, params.query, params.body, opts);
  }
  async patchAcmeCertManagerIoV1NamespacedOrderStatus(params: PatchAcmeCertManagerIoV1NamespacedOrderStatusRequest, opts?: APIClientRequestOpts): Promise<AcmeCertManagerIoV1Order> {
    const path = `/apis/acme.cert-manager.io/v1/namespaces/${params.path.namespace}/orders/${params.path.name}/status`;
    return await this.patch<AcmeCertManagerIoV1Order>(path, params.query, null, opts);
  }
  async listAcmeCertManagerIoV1OrderForAllNamespaces(params: ListAcmeCertManagerIoV1OrderForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<AcmeCertManagerIoV1OrderList> {
    const path = `/apis/acme.cert-manager.io/v1/orders`;
    return await this.get<AcmeCertManagerIoV1OrderList>(path, null, null, opts);
  }
  async getAdmissionregistrationAPIGroup(params: GetAdmissionregistrationAPIGroupRequest, opts?: APIClientRequestOpts): Promise<APIGroup> {
    const path = `/apis/admissionregistration.k8s.io/`;
    return await this.get<APIGroup>(path, null, null, opts);
  }
  async getAdmissionregistrationV1APIResources(params: GetAdmissionregistrationV1APIResourcesRequest, opts?: APIClientRequestOpts): Promise<APIResourceList> {
    const path = `/apis/admissionregistration.k8s.io/v1/`;
    return await this.get<APIResourceList>(path, null, null, opts);
  }
  async listAdmissionregistrationV1MutatingWebhookConfiguration(params: ListAdmissionregistrationV1MutatingWebhookConfigurationRequest, opts?: APIClientRequestOpts): Promise<AdmissionregistrationK8sIoV1MutatingWebhookConfigurationList> {
    const path = `/apis/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations`;
    return await this.get<AdmissionregistrationK8sIoV1MutatingWebhookConfigurationList>(path, null, null, opts);
  }
  async createAdmissionregistrationV1MutatingWebhookConfiguration(params: CreateAdmissionregistrationV1MutatingWebhookConfigurationRequest, opts?: APIClientRequestOpts): Promise<AdmissionregistrationK8sIoV1MutatingWebhookConfiguration> {
    const path = `/apis/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations`;
    return await this.post<AdmissionregistrationK8sIoV1MutatingWebhookConfiguration>(path, params.query, params.body, opts);
  }
  async deleteAdmissionregistrationV1CollectionMutatingWebhookConfiguration(params: DeleteAdmissionregistrationV1CollectionMutatingWebhookConfigurationRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readAdmissionregistrationV1MutatingWebhookConfiguration(params: ReadAdmissionregistrationV1MutatingWebhookConfigurationRequest, opts?: APIClientRequestOpts): Promise<AdmissionregistrationK8sIoV1MutatingWebhookConfiguration> {
    const path = `/apis/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations/${params.path.name}`;
    return await this.get<AdmissionregistrationK8sIoV1MutatingWebhookConfiguration>(path, null, null, opts);
  }
  async replaceAdmissionregistrationV1MutatingWebhookConfiguration(params: ReplaceAdmissionregistrationV1MutatingWebhookConfigurationRequest, opts?: APIClientRequestOpts): Promise<AdmissionregistrationK8sIoV1MutatingWebhookConfiguration> {
    const path = `/apis/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations/${params.path.name}`;
    return await this.put<AdmissionregistrationK8sIoV1MutatingWebhookConfiguration>(path, params.query, params.body, opts);
  }
  async deleteAdmissionregistrationV1MutatingWebhookConfiguration(params: DeleteAdmissionregistrationV1MutatingWebhookConfigurationRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchAdmissionregistrationV1MutatingWebhookConfiguration(params: PatchAdmissionregistrationV1MutatingWebhookConfigurationRequest, opts?: APIClientRequestOpts): Promise<AdmissionregistrationK8sIoV1MutatingWebhookConfiguration> {
    const path = `/apis/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations/${params.path.name}`;
    return await this.patch<AdmissionregistrationK8sIoV1MutatingWebhookConfiguration>(path, params.query, null, opts);
  }
  async listAdmissionregistrationV1ValidatingAdmissionPolicy(params: ListAdmissionregistrationV1ValidatingAdmissionPolicyRequest, opts?: APIClientRequestOpts): Promise<AdmissionregistrationK8sIoV1ValidatingAdmissionPolicyList> {
    const path = `/apis/admissionregistration.k8s.io/v1/validatingadmissionpolicies`;
    return await this.get<AdmissionregistrationK8sIoV1ValidatingAdmissionPolicyList>(path, null, null, opts);
  }
  async createAdmissionregistrationV1ValidatingAdmissionPolicy(params: CreateAdmissionregistrationV1ValidatingAdmissionPolicyRequest, opts?: APIClientRequestOpts): Promise<AdmissionregistrationK8sIoV1ValidatingAdmissionPolicy> {
    const path = `/apis/admissionregistration.k8s.io/v1/validatingadmissionpolicies`;
    return await this.post<AdmissionregistrationK8sIoV1ValidatingAdmissionPolicy>(path, params.query, params.body, opts);
  }
  async deleteAdmissionregistrationV1CollectionValidatingAdmissionPolicy(params: DeleteAdmissionregistrationV1CollectionValidatingAdmissionPolicyRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/admissionregistration.k8s.io/v1/validatingadmissionpolicies`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readAdmissionregistrationV1ValidatingAdmissionPolicy(params: ReadAdmissionregistrationV1ValidatingAdmissionPolicyRequest, opts?: APIClientRequestOpts): Promise<AdmissionregistrationK8sIoV1ValidatingAdmissionPolicy> {
    const path = `/apis/admissionregistration.k8s.io/v1/validatingadmissionpolicies/${params.path.name}`;
    return await this.get<AdmissionregistrationK8sIoV1ValidatingAdmissionPolicy>(path, null, null, opts);
  }
  async replaceAdmissionregistrationV1ValidatingAdmissionPolicy(params: ReplaceAdmissionregistrationV1ValidatingAdmissionPolicyRequest, opts?: APIClientRequestOpts): Promise<AdmissionregistrationK8sIoV1ValidatingAdmissionPolicy> {
    const path = `/apis/admissionregistration.k8s.io/v1/validatingadmissionpolicies/${params.path.name}`;
    return await this.put<AdmissionregistrationK8sIoV1ValidatingAdmissionPolicy>(path, params.query, params.body, opts);
  }
  async deleteAdmissionregistrationV1ValidatingAdmissionPolicy(params: DeleteAdmissionregistrationV1ValidatingAdmissionPolicyRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/admissionregistration.k8s.io/v1/validatingadmissionpolicies/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchAdmissionregistrationV1ValidatingAdmissionPolicy(params: PatchAdmissionregistrationV1ValidatingAdmissionPolicyRequest, opts?: APIClientRequestOpts): Promise<AdmissionregistrationK8sIoV1ValidatingAdmissionPolicy> {
    const path = `/apis/admissionregistration.k8s.io/v1/validatingadmissionpolicies/${params.path.name}`;
    return await this.patch<AdmissionregistrationK8sIoV1ValidatingAdmissionPolicy>(path, params.query, null, opts);
  }
  async readAdmissionregistrationV1ValidatingAdmissionPolicyStatus(params: ReadAdmissionregistrationV1ValidatingAdmissionPolicyStatusRequest, opts?: APIClientRequestOpts): Promise<AdmissionregistrationK8sIoV1ValidatingAdmissionPolicy> {
    const path = `/apis/admissionregistration.k8s.io/v1/validatingadmissionpolicies/${params.path.name}/status`;
    return await this.get<AdmissionregistrationK8sIoV1ValidatingAdmissionPolicy>(path, null, null, opts);
  }
  async replaceAdmissionregistrationV1ValidatingAdmissionPolicyStatus(params: ReplaceAdmissionregistrationV1ValidatingAdmissionPolicyStatusRequest, opts?: APIClientRequestOpts): Promise<AdmissionregistrationK8sIoV1ValidatingAdmissionPolicy> {
    const path = `/apis/admissionregistration.k8s.io/v1/validatingadmissionpolicies/${params.path.name}/status`;
    return await this.put<AdmissionregistrationK8sIoV1ValidatingAdmissionPolicy>(path, params.query, params.body, opts);
  }
  async patchAdmissionregistrationV1ValidatingAdmissionPolicyStatus(params: PatchAdmissionregistrationV1ValidatingAdmissionPolicyStatusRequest, opts?: APIClientRequestOpts): Promise<AdmissionregistrationK8sIoV1ValidatingAdmissionPolicy> {
    const path = `/apis/admissionregistration.k8s.io/v1/validatingadmissionpolicies/${params.path.name}/status`;
    return await this.patch<AdmissionregistrationK8sIoV1ValidatingAdmissionPolicy>(path, params.query, null, opts);
  }
  async listAdmissionregistrationV1ValidatingAdmissionPolicyBinding(params: ListAdmissionregistrationV1ValidatingAdmissionPolicyBindingRequest, opts?: APIClientRequestOpts): Promise<AdmissionregistrationK8sIoV1ValidatingAdmissionPolicyBindingList> {
    const path = `/apis/admissionregistration.k8s.io/v1/validatingadmissionpolicybindings`;
    return await this.get<AdmissionregistrationK8sIoV1ValidatingAdmissionPolicyBindingList>(path, null, null, opts);
  }
  async createAdmissionregistrationV1ValidatingAdmissionPolicyBinding(params: CreateAdmissionregistrationV1ValidatingAdmissionPolicyBindingRequest, opts?: APIClientRequestOpts): Promise<AdmissionregistrationK8sIoV1ValidatingAdmissionPolicyBinding> {
    const path = `/apis/admissionregistration.k8s.io/v1/validatingadmissionpolicybindings`;
    return await this.post<AdmissionregistrationK8sIoV1ValidatingAdmissionPolicyBinding>(path, params.query, params.body, opts);
  }
  async deleteAdmissionregistrationV1CollectionValidatingAdmissionPolicyBinding(params: DeleteAdmissionregistrationV1CollectionValidatingAdmissionPolicyBindingRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/admissionregistration.k8s.io/v1/validatingadmissionpolicybindings`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readAdmissionregistrationV1ValidatingAdmissionPolicyBinding(params: ReadAdmissionregistrationV1ValidatingAdmissionPolicyBindingRequest, opts?: APIClientRequestOpts): Promise<AdmissionregistrationK8sIoV1ValidatingAdmissionPolicyBinding> {
    const path = `/apis/admissionregistration.k8s.io/v1/validatingadmissionpolicybindings/${params.path.name}`;
    return await this.get<AdmissionregistrationK8sIoV1ValidatingAdmissionPolicyBinding>(path, null, null, opts);
  }
  async replaceAdmissionregistrationV1ValidatingAdmissionPolicyBinding(params: ReplaceAdmissionregistrationV1ValidatingAdmissionPolicyBindingRequest, opts?: APIClientRequestOpts): Promise<AdmissionregistrationK8sIoV1ValidatingAdmissionPolicyBinding> {
    const path = `/apis/admissionregistration.k8s.io/v1/validatingadmissionpolicybindings/${params.path.name}`;
    return await this.put<AdmissionregistrationK8sIoV1ValidatingAdmissionPolicyBinding>(path, params.query, params.body, opts);
  }
  async deleteAdmissionregistrationV1ValidatingAdmissionPolicyBinding(params: DeleteAdmissionregistrationV1ValidatingAdmissionPolicyBindingRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/admissionregistration.k8s.io/v1/validatingadmissionpolicybindings/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchAdmissionregistrationV1ValidatingAdmissionPolicyBinding(params: PatchAdmissionregistrationV1ValidatingAdmissionPolicyBindingRequest, opts?: APIClientRequestOpts): Promise<AdmissionregistrationK8sIoV1ValidatingAdmissionPolicyBinding> {
    const path = `/apis/admissionregistration.k8s.io/v1/validatingadmissionpolicybindings/${params.path.name}`;
    return await this.patch<AdmissionregistrationK8sIoV1ValidatingAdmissionPolicyBinding>(path, params.query, null, opts);
  }
  async listAdmissionregistrationV1ValidatingWebhookConfiguration(params: ListAdmissionregistrationV1ValidatingWebhookConfigurationRequest, opts?: APIClientRequestOpts): Promise<AdmissionregistrationK8sIoV1ValidatingWebhookConfigurationList> {
    const path = `/apis/admissionregistration.k8s.io/v1/validatingwebhookconfigurations`;
    return await this.get<AdmissionregistrationK8sIoV1ValidatingWebhookConfigurationList>(path, null, null, opts);
  }
  async createAdmissionregistrationV1ValidatingWebhookConfiguration(params: CreateAdmissionregistrationV1ValidatingWebhookConfigurationRequest, opts?: APIClientRequestOpts): Promise<AdmissionregistrationK8sIoV1ValidatingWebhookConfiguration> {
    const path = `/apis/admissionregistration.k8s.io/v1/validatingwebhookconfigurations`;
    return await this.post<AdmissionregistrationK8sIoV1ValidatingWebhookConfiguration>(path, params.query, params.body, opts);
  }
  async deleteAdmissionregistrationV1CollectionValidatingWebhookConfiguration(params: DeleteAdmissionregistrationV1CollectionValidatingWebhookConfigurationRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/admissionregistration.k8s.io/v1/validatingwebhookconfigurations`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readAdmissionregistrationV1ValidatingWebhookConfiguration(params: ReadAdmissionregistrationV1ValidatingWebhookConfigurationRequest, opts?: APIClientRequestOpts): Promise<AdmissionregistrationK8sIoV1ValidatingWebhookConfiguration> {
    const path = `/apis/admissionregistration.k8s.io/v1/validatingwebhookconfigurations/${params.path.name}`;
    return await this.get<AdmissionregistrationK8sIoV1ValidatingWebhookConfiguration>(path, null, null, opts);
  }
  async replaceAdmissionregistrationV1ValidatingWebhookConfiguration(params: ReplaceAdmissionregistrationV1ValidatingWebhookConfigurationRequest, opts?: APIClientRequestOpts): Promise<AdmissionregistrationK8sIoV1ValidatingWebhookConfiguration> {
    const path = `/apis/admissionregistration.k8s.io/v1/validatingwebhookconfigurations/${params.path.name}`;
    return await this.put<AdmissionregistrationK8sIoV1ValidatingWebhookConfiguration>(path, params.query, params.body, opts);
  }
  async deleteAdmissionregistrationV1ValidatingWebhookConfiguration(params: DeleteAdmissionregistrationV1ValidatingWebhookConfigurationRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/admissionregistration.k8s.io/v1/validatingwebhookconfigurations/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchAdmissionregistrationV1ValidatingWebhookConfiguration(params: PatchAdmissionregistrationV1ValidatingWebhookConfigurationRequest, opts?: APIClientRequestOpts): Promise<AdmissionregistrationK8sIoV1ValidatingWebhookConfiguration> {
    const path = `/apis/admissionregistration.k8s.io/v1/validatingwebhookconfigurations/${params.path.name}`;
    return await this.patch<AdmissionregistrationK8sIoV1ValidatingWebhookConfiguration>(path, params.query, null, opts);
  }
  async watchAdmissionregistrationV1MutatingWebhookConfigurationList(params: WatchAdmissionregistrationV1MutatingWebhookConfigurationListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/admissionregistration.k8s.io/v1/watch/mutatingwebhookconfigurations`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchAdmissionregistrationV1MutatingWebhookConfiguration(params: WatchAdmissionregistrationV1MutatingWebhookConfigurationRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/admissionregistration.k8s.io/v1/watch/mutatingwebhookconfigurations/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchAdmissionregistrationV1ValidatingAdmissionPolicyList(params: WatchAdmissionregistrationV1ValidatingAdmissionPolicyListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/admissionregistration.k8s.io/v1/watch/validatingadmissionpolicies`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchAdmissionregistrationV1ValidatingAdmissionPolicy(params: WatchAdmissionregistrationV1ValidatingAdmissionPolicyRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/admissionregistration.k8s.io/v1/watch/validatingadmissionpolicies/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchAdmissionregistrationV1ValidatingAdmissionPolicyBindingList(params: WatchAdmissionregistrationV1ValidatingAdmissionPolicyBindingListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/admissionregistration.k8s.io/v1/watch/validatingadmissionpolicybindings`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchAdmissionregistrationV1ValidatingAdmissionPolicyBinding(params: WatchAdmissionregistrationV1ValidatingAdmissionPolicyBindingRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/admissionregistration.k8s.io/v1/watch/validatingadmissionpolicybindings/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchAdmissionregistrationV1ValidatingWebhookConfigurationList(params: WatchAdmissionregistrationV1ValidatingWebhookConfigurationListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/admissionregistration.k8s.io/v1/watch/validatingwebhookconfigurations`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchAdmissionregistrationV1ValidatingWebhookConfiguration(params: WatchAdmissionregistrationV1ValidatingWebhookConfigurationRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/admissionregistration.k8s.io/v1/watch/validatingwebhookconfigurations/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async getApiextensionsAPIGroup(params: GetApiextensionsAPIGroupRequest, opts?: APIClientRequestOpts): Promise<APIGroup> {
    const path = `/apis/apiextensions.k8s.io/`;
    return await this.get<APIGroup>(path, null, null, opts);
  }
  async getApiextensionsV1APIResources(params: GetApiextensionsV1APIResourcesRequest, opts?: APIClientRequestOpts): Promise<APIResourceList> {
    const path = `/apis/apiextensions.k8s.io/v1/`;
    return await this.get<APIResourceList>(path, null, null, opts);
  }
  async listApiextensionsV1CustomResourceDefinition(params: ListApiextensionsV1CustomResourceDefinitionRequest, opts?: APIClientRequestOpts): Promise<ApiextensionsK8sIoV1CustomResourceDefinitionList> {
    const path = `/apis/apiextensions.k8s.io/v1/customresourcedefinitions`;
    return await this.get<ApiextensionsK8sIoV1CustomResourceDefinitionList>(path, null, null, opts);
  }
  async createApiextensionsV1CustomResourceDefinition(params: CreateApiextensionsV1CustomResourceDefinitionRequest, opts?: APIClientRequestOpts): Promise<ApiextensionsK8sIoV1CustomResourceDefinition> {
    const path = `/apis/apiextensions.k8s.io/v1/customresourcedefinitions`;
    return await this.post<ApiextensionsK8sIoV1CustomResourceDefinition>(path, params.query, params.body, opts);
  }
  async deleteApiextensionsV1CollectionCustomResourceDefinition(params: DeleteApiextensionsV1CollectionCustomResourceDefinitionRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/apiextensions.k8s.io/v1/customresourcedefinitions`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readApiextensionsV1CustomResourceDefinition(params: ReadApiextensionsV1CustomResourceDefinitionRequest, opts?: APIClientRequestOpts): Promise<ApiextensionsK8sIoV1CustomResourceDefinition> {
    const path = `/apis/apiextensions.k8s.io/v1/customresourcedefinitions/${params.path.name}`;
    return await this.get<ApiextensionsK8sIoV1CustomResourceDefinition>(path, null, null, opts);
  }
  async replaceApiextensionsV1CustomResourceDefinition(params: ReplaceApiextensionsV1CustomResourceDefinitionRequest, opts?: APIClientRequestOpts): Promise<ApiextensionsK8sIoV1CustomResourceDefinition> {
    const path = `/apis/apiextensions.k8s.io/v1/customresourcedefinitions/${params.path.name}`;
    return await this.put<ApiextensionsK8sIoV1CustomResourceDefinition>(path, params.query, params.body, opts);
  }
  async deleteApiextensionsV1CustomResourceDefinition(params: DeleteApiextensionsV1CustomResourceDefinitionRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/apiextensions.k8s.io/v1/customresourcedefinitions/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchApiextensionsV1CustomResourceDefinition(params: PatchApiextensionsV1CustomResourceDefinitionRequest, opts?: APIClientRequestOpts): Promise<ApiextensionsK8sIoV1CustomResourceDefinition> {
    const path = `/apis/apiextensions.k8s.io/v1/customresourcedefinitions/${params.path.name}`;
    return await this.patch<ApiextensionsK8sIoV1CustomResourceDefinition>(path, params.query, null, opts);
  }
  async readApiextensionsV1CustomResourceDefinitionStatus(params: ReadApiextensionsV1CustomResourceDefinitionStatusRequest, opts?: APIClientRequestOpts): Promise<ApiextensionsK8sIoV1CustomResourceDefinition> {
    const path = `/apis/apiextensions.k8s.io/v1/customresourcedefinitions/${params.path.name}/status`;
    return await this.get<ApiextensionsK8sIoV1CustomResourceDefinition>(path, null, null, opts);
  }
  async replaceApiextensionsV1CustomResourceDefinitionStatus(params: ReplaceApiextensionsV1CustomResourceDefinitionStatusRequest, opts?: APIClientRequestOpts): Promise<ApiextensionsK8sIoV1CustomResourceDefinition> {
    const path = `/apis/apiextensions.k8s.io/v1/customresourcedefinitions/${params.path.name}/status`;
    return await this.put<ApiextensionsK8sIoV1CustomResourceDefinition>(path, params.query, params.body, opts);
  }
  async patchApiextensionsV1CustomResourceDefinitionStatus(params: PatchApiextensionsV1CustomResourceDefinitionStatusRequest, opts?: APIClientRequestOpts): Promise<ApiextensionsK8sIoV1CustomResourceDefinition> {
    const path = `/apis/apiextensions.k8s.io/v1/customresourcedefinitions/${params.path.name}/status`;
    return await this.patch<ApiextensionsK8sIoV1CustomResourceDefinition>(path, params.query, null, opts);
  }
  async watchApiextensionsV1CustomResourceDefinitionList(params: WatchApiextensionsV1CustomResourceDefinitionListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/apiextensions.k8s.io/v1/watch/customresourcedefinitions`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchApiextensionsV1CustomResourceDefinition(params: WatchApiextensionsV1CustomResourceDefinitionRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/apiextensions.k8s.io/v1/watch/customresourcedefinitions/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async getApiregistrationAPIGroup(params: GetApiregistrationAPIGroupRequest, opts?: APIClientRequestOpts): Promise<APIGroup> {
    const path = `/apis/apiregistration.k8s.io/`;
    return await this.get<APIGroup>(path, null, null, opts);
  }
  async getApiregistrationV1APIResources(params: GetApiregistrationV1APIResourcesRequest, opts?: APIClientRequestOpts): Promise<APIResourceList> {
    const path = `/apis/apiregistration.k8s.io/v1/`;
    return await this.get<APIResourceList>(path, null, null, opts);
  }
  async listApiregistrationV1APIService(params: ListApiregistrationV1APIServiceRequest, opts?: APIClientRequestOpts): Promise<ApiregistrationK8sIoV1APIServiceList> {
    const path = `/apis/apiregistration.k8s.io/v1/apiservices`;
    return await this.get<ApiregistrationK8sIoV1APIServiceList>(path, null, null, opts);
  }
  async createApiregistrationV1APIService(params: CreateApiregistrationV1APIServiceRequest, opts?: APIClientRequestOpts): Promise<ApiregistrationK8sIoV1APIService> {
    const path = `/apis/apiregistration.k8s.io/v1/apiservices`;
    return await this.post<ApiregistrationK8sIoV1APIService>(path, params.query, params.body, opts);
  }
  async deleteApiregistrationV1CollectionAPIService(params: DeleteApiregistrationV1CollectionAPIServiceRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/apiregistration.k8s.io/v1/apiservices`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readApiregistrationV1APIService(params: ReadApiregistrationV1APIServiceRequest, opts?: APIClientRequestOpts): Promise<ApiregistrationK8sIoV1APIService> {
    const path = `/apis/apiregistration.k8s.io/v1/apiservices/${params.path.name}`;
    return await this.get<ApiregistrationK8sIoV1APIService>(path, null, null, opts);
  }
  async replaceApiregistrationV1APIService(params: ReplaceApiregistrationV1APIServiceRequest, opts?: APIClientRequestOpts): Promise<ApiregistrationK8sIoV1APIService> {
    const path = `/apis/apiregistration.k8s.io/v1/apiservices/${params.path.name}`;
    return await this.put<ApiregistrationK8sIoV1APIService>(path, params.query, params.body, opts);
  }
  async deleteApiregistrationV1APIService(params: DeleteApiregistrationV1APIServiceRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/apiregistration.k8s.io/v1/apiservices/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchApiregistrationV1APIService(params: PatchApiregistrationV1APIServiceRequest, opts?: APIClientRequestOpts): Promise<ApiregistrationK8sIoV1APIService> {
    const path = `/apis/apiregistration.k8s.io/v1/apiservices/${params.path.name}`;
    return await this.patch<ApiregistrationK8sIoV1APIService>(path, params.query, null, opts);
  }
  async readApiregistrationV1APIServiceStatus(params: ReadApiregistrationV1APIServiceStatusRequest, opts?: APIClientRequestOpts): Promise<ApiregistrationK8sIoV1APIService> {
    const path = `/apis/apiregistration.k8s.io/v1/apiservices/${params.path.name}/status`;
    return await this.get<ApiregistrationK8sIoV1APIService>(path, null, null, opts);
  }
  async replaceApiregistrationV1APIServiceStatus(params: ReplaceApiregistrationV1APIServiceStatusRequest, opts?: APIClientRequestOpts): Promise<ApiregistrationK8sIoV1APIService> {
    const path = `/apis/apiregistration.k8s.io/v1/apiservices/${params.path.name}/status`;
    return await this.put<ApiregistrationK8sIoV1APIService>(path, params.query, params.body, opts);
  }
  async patchApiregistrationV1APIServiceStatus(params: PatchApiregistrationV1APIServiceStatusRequest, opts?: APIClientRequestOpts): Promise<ApiregistrationK8sIoV1APIService> {
    const path = `/apis/apiregistration.k8s.io/v1/apiservices/${params.path.name}/status`;
    return await this.patch<ApiregistrationK8sIoV1APIService>(path, params.query, null, opts);
  }
  async watchApiregistrationV1APIServiceList(params: WatchApiregistrationV1APIServiceListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/apiregistration.k8s.io/v1/watch/apiservices`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchApiregistrationV1APIService(params: WatchApiregistrationV1APIServiceRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/apiregistration.k8s.io/v1/watch/apiservices/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async getAppsAPIGroup(params: GetAppsAPIGroupRequest, opts?: APIClientRequestOpts): Promise<APIGroup> {
    const path = `/apis/apps/`;
    return await this.get<APIGroup>(path, null, null, opts);
  }
  async getAppsV1APIResources(params: GetAppsV1APIResourcesRequest, opts?: APIClientRequestOpts): Promise<APIResourceList> {
    const path = `/apis/apps/v1/`;
    return await this.get<APIResourceList>(path, null, null, opts);
  }
  async listAppsV1ControllerRevisionForAllNamespaces(params: ListAppsV1ControllerRevisionForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<AppsV1ControllerRevisionList> {
    const path = `/apis/apps/v1/controllerrevisions`;
    return await this.get<AppsV1ControllerRevisionList>(path, null, null, opts);
  }
  async listAppsV1DaemonSetForAllNamespaces(params: ListAppsV1DaemonSetForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<AppsV1DaemonSetList> {
    const path = `/apis/apps/v1/daemonsets`;
    return await this.get<AppsV1DaemonSetList>(path, null, null, opts);
  }
  async listAppsV1DeploymentForAllNamespaces(params: ListAppsV1DeploymentForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<AppsV1DeploymentList> {
    const path = `/apis/apps/v1/deployments`;
    return await this.get<AppsV1DeploymentList>(path, null, null, opts);
  }
  async listAppsV1NamespacedControllerRevision(params: ListAppsV1NamespacedControllerRevisionRequest, opts?: APIClientRequestOpts): Promise<AppsV1ControllerRevisionList> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/controllerrevisions`;
    return await this.get<AppsV1ControllerRevisionList>(path, null, null, opts);
  }
  async createAppsV1NamespacedControllerRevision(params: CreateAppsV1NamespacedControllerRevisionRequest, opts?: APIClientRequestOpts): Promise<AppsV1ControllerRevision> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/controllerrevisions`;
    return await this.post<AppsV1ControllerRevision>(path, params.query, params.body, opts);
  }
  async deleteAppsV1CollectionNamespacedControllerRevision(params: DeleteAppsV1CollectionNamespacedControllerRevisionRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/controllerrevisions`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readAppsV1NamespacedControllerRevision(params: ReadAppsV1NamespacedControllerRevisionRequest, opts?: APIClientRequestOpts): Promise<AppsV1ControllerRevision> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/controllerrevisions/${params.path.name}`;
    return await this.get<AppsV1ControllerRevision>(path, null, null, opts);
  }
  async replaceAppsV1NamespacedControllerRevision(params: ReplaceAppsV1NamespacedControllerRevisionRequest, opts?: APIClientRequestOpts): Promise<AppsV1ControllerRevision> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/controllerrevisions/${params.path.name}`;
    return await this.put<AppsV1ControllerRevision>(path, params.query, params.body, opts);
  }
  async deleteAppsV1NamespacedControllerRevision(params: DeleteAppsV1NamespacedControllerRevisionRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/controllerrevisions/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchAppsV1NamespacedControllerRevision(params: PatchAppsV1NamespacedControllerRevisionRequest, opts?: APIClientRequestOpts): Promise<AppsV1ControllerRevision> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/controllerrevisions/${params.path.name}`;
    return await this.patch<AppsV1ControllerRevision>(path, params.query, null, opts);
  }
  async listAppsV1NamespacedDaemonSet(params: ListAppsV1NamespacedDaemonSetRequest, opts?: APIClientRequestOpts): Promise<AppsV1DaemonSetList> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/daemonsets`;
    return await this.get<AppsV1DaemonSetList>(path, null, null, opts);
  }
  async createAppsV1NamespacedDaemonSet(params: CreateAppsV1NamespacedDaemonSetRequest, opts?: APIClientRequestOpts): Promise<AppsV1DaemonSet> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/daemonsets`;
    return await this.post<AppsV1DaemonSet>(path, params.query, params.body, opts);
  }
  async deleteAppsV1CollectionNamespacedDaemonSet(params: DeleteAppsV1CollectionNamespacedDaemonSetRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/daemonsets`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readAppsV1NamespacedDaemonSet(params: ReadAppsV1NamespacedDaemonSetRequest, opts?: APIClientRequestOpts): Promise<AppsV1DaemonSet> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/daemonsets/${params.path.name}`;
    return await this.get<AppsV1DaemonSet>(path, null, null, opts);
  }
  async replaceAppsV1NamespacedDaemonSet(params: ReplaceAppsV1NamespacedDaemonSetRequest, opts?: APIClientRequestOpts): Promise<AppsV1DaemonSet> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/daemonsets/${params.path.name}`;
    return await this.put<AppsV1DaemonSet>(path, params.query, params.body, opts);
  }
  async deleteAppsV1NamespacedDaemonSet(params: DeleteAppsV1NamespacedDaemonSetRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/daemonsets/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchAppsV1NamespacedDaemonSet(params: PatchAppsV1NamespacedDaemonSetRequest, opts?: APIClientRequestOpts): Promise<AppsV1DaemonSet> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/daemonsets/${params.path.name}`;
    return await this.patch<AppsV1DaemonSet>(path, params.query, null, opts);
  }
  async readAppsV1NamespacedDaemonSetStatus(params: ReadAppsV1NamespacedDaemonSetStatusRequest, opts?: APIClientRequestOpts): Promise<AppsV1DaemonSet> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/daemonsets/${params.path.name}/status`;
    return await this.get<AppsV1DaemonSet>(path, null, null, opts);
  }
  async replaceAppsV1NamespacedDaemonSetStatus(params: ReplaceAppsV1NamespacedDaemonSetStatusRequest, opts?: APIClientRequestOpts): Promise<AppsV1DaemonSet> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/daemonsets/${params.path.name}/status`;
    return await this.put<AppsV1DaemonSet>(path, params.query, params.body, opts);
  }
  async patchAppsV1NamespacedDaemonSetStatus(params: PatchAppsV1NamespacedDaemonSetStatusRequest, opts?: APIClientRequestOpts): Promise<AppsV1DaemonSet> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/daemonsets/${params.path.name}/status`;
    return await this.patch<AppsV1DaemonSet>(path, params.query, null, opts);
  }
  async listAppsV1NamespacedDeployment(params: ListAppsV1NamespacedDeploymentRequest, opts?: APIClientRequestOpts): Promise<AppsV1DeploymentList> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/deployments`;
    return await this.get<AppsV1DeploymentList>(path, null, null, opts);
  }
  async createAppsV1NamespacedDeployment(params: CreateAppsV1NamespacedDeploymentRequest, opts?: APIClientRequestOpts): Promise<AppsV1Deployment> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/deployments`;
    return await this.post<AppsV1Deployment>(path, params.query, params.body, opts);
  }
  async deleteAppsV1CollectionNamespacedDeployment(params: DeleteAppsV1CollectionNamespacedDeploymentRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/deployments`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readAppsV1NamespacedDeployment(params: ReadAppsV1NamespacedDeploymentRequest, opts?: APIClientRequestOpts): Promise<AppsV1Deployment> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/deployments/${params.path.name}`;
    return await this.get<AppsV1Deployment>(path, null, null, opts);
  }
  async replaceAppsV1NamespacedDeployment(params: ReplaceAppsV1NamespacedDeploymentRequest, opts?: APIClientRequestOpts): Promise<AppsV1Deployment> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/deployments/${params.path.name}`;
    return await this.put<AppsV1Deployment>(path, params.query, params.body, opts);
  }
  async deleteAppsV1NamespacedDeployment(params: DeleteAppsV1NamespacedDeploymentRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/deployments/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchAppsV1NamespacedDeployment(params: PatchAppsV1NamespacedDeploymentRequest, opts?: APIClientRequestOpts): Promise<AppsV1Deployment> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/deployments/${params.path.name}`;
    return await this.patch<AppsV1Deployment>(path, params.query, null, opts);
  }
  async readAppsV1NamespacedDeploymentScale(params: ReadAppsV1NamespacedDeploymentScaleRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1Scale> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/deployments/${params.path.name}/scale`;
    return await this.get<AutoscalingV1Scale>(path, null, null, opts);
  }
  async replaceAppsV1NamespacedDeploymentScale(params: ReplaceAppsV1NamespacedDeploymentScaleRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1Scale> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/deployments/${params.path.name}/scale`;
    return await this.put<AutoscalingV1Scale>(path, params.query, params.body, opts);
  }
  async patchAppsV1NamespacedDeploymentScale(params: PatchAppsV1NamespacedDeploymentScaleRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1Scale> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/deployments/${params.path.name}/scale`;
    return await this.patch<AutoscalingV1Scale>(path, params.query, null, opts);
  }
  async readAppsV1NamespacedDeploymentStatus(params: ReadAppsV1NamespacedDeploymentStatusRequest, opts?: APIClientRequestOpts): Promise<AppsV1Deployment> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/deployments/${params.path.name}/status`;
    return await this.get<AppsV1Deployment>(path, null, null, opts);
  }
  async replaceAppsV1NamespacedDeploymentStatus(params: ReplaceAppsV1NamespacedDeploymentStatusRequest, opts?: APIClientRequestOpts): Promise<AppsV1Deployment> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/deployments/${params.path.name}/status`;
    return await this.put<AppsV1Deployment>(path, params.query, params.body, opts);
  }
  async patchAppsV1NamespacedDeploymentStatus(params: PatchAppsV1NamespacedDeploymentStatusRequest, opts?: APIClientRequestOpts): Promise<AppsV1Deployment> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/deployments/${params.path.name}/status`;
    return await this.patch<AppsV1Deployment>(path, params.query, null, opts);
  }
  async listAppsV1NamespacedReplicaSet(params: ListAppsV1NamespacedReplicaSetRequest, opts?: APIClientRequestOpts): Promise<AppsV1ReplicaSetList> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/replicasets`;
    return await this.get<AppsV1ReplicaSetList>(path, null, null, opts);
  }
  async createAppsV1NamespacedReplicaSet(params: CreateAppsV1NamespacedReplicaSetRequest, opts?: APIClientRequestOpts): Promise<AppsV1ReplicaSet> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/replicasets`;
    return await this.post<AppsV1ReplicaSet>(path, params.query, params.body, opts);
  }
  async deleteAppsV1CollectionNamespacedReplicaSet(params: DeleteAppsV1CollectionNamespacedReplicaSetRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/replicasets`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readAppsV1NamespacedReplicaSet(params: ReadAppsV1NamespacedReplicaSetRequest, opts?: APIClientRequestOpts): Promise<AppsV1ReplicaSet> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/replicasets/${params.path.name}`;
    return await this.get<AppsV1ReplicaSet>(path, null, null, opts);
  }
  async replaceAppsV1NamespacedReplicaSet(params: ReplaceAppsV1NamespacedReplicaSetRequest, opts?: APIClientRequestOpts): Promise<AppsV1ReplicaSet> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/replicasets/${params.path.name}`;
    return await this.put<AppsV1ReplicaSet>(path, params.query, params.body, opts);
  }
  async deleteAppsV1NamespacedReplicaSet(params: DeleteAppsV1NamespacedReplicaSetRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/replicasets/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchAppsV1NamespacedReplicaSet(params: PatchAppsV1NamespacedReplicaSetRequest, opts?: APIClientRequestOpts): Promise<AppsV1ReplicaSet> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/replicasets/${params.path.name}`;
    return await this.patch<AppsV1ReplicaSet>(path, params.query, null, opts);
  }
  async readAppsV1NamespacedReplicaSetScale(params: ReadAppsV1NamespacedReplicaSetScaleRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1Scale> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/replicasets/${params.path.name}/scale`;
    return await this.get<AutoscalingV1Scale>(path, null, null, opts);
  }
  async replaceAppsV1NamespacedReplicaSetScale(params: ReplaceAppsV1NamespacedReplicaSetScaleRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1Scale> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/replicasets/${params.path.name}/scale`;
    return await this.put<AutoscalingV1Scale>(path, params.query, params.body, opts);
  }
  async patchAppsV1NamespacedReplicaSetScale(params: PatchAppsV1NamespacedReplicaSetScaleRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1Scale> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/replicasets/${params.path.name}/scale`;
    return await this.patch<AutoscalingV1Scale>(path, params.query, null, opts);
  }
  async readAppsV1NamespacedReplicaSetStatus(params: ReadAppsV1NamespacedReplicaSetStatusRequest, opts?: APIClientRequestOpts): Promise<AppsV1ReplicaSet> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/replicasets/${params.path.name}/status`;
    return await this.get<AppsV1ReplicaSet>(path, null, null, opts);
  }
  async replaceAppsV1NamespacedReplicaSetStatus(params: ReplaceAppsV1NamespacedReplicaSetStatusRequest, opts?: APIClientRequestOpts): Promise<AppsV1ReplicaSet> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/replicasets/${params.path.name}/status`;
    return await this.put<AppsV1ReplicaSet>(path, params.query, params.body, opts);
  }
  async patchAppsV1NamespacedReplicaSetStatus(params: PatchAppsV1NamespacedReplicaSetStatusRequest, opts?: APIClientRequestOpts): Promise<AppsV1ReplicaSet> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/replicasets/${params.path.name}/status`;
    return await this.patch<AppsV1ReplicaSet>(path, params.query, null, opts);
  }
  async listAppsV1NamespacedStatefulSet(params: ListAppsV1NamespacedStatefulSetRequest, opts?: APIClientRequestOpts): Promise<AppsV1StatefulSetList> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/statefulsets`;
    return await this.get<AppsV1StatefulSetList>(path, null, null, opts);
  }
  async createAppsV1NamespacedStatefulSet(params: CreateAppsV1NamespacedStatefulSetRequest, opts?: APIClientRequestOpts): Promise<AppsV1StatefulSet> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/statefulsets`;
    return await this.post<AppsV1StatefulSet>(path, params.query, params.body, opts);
  }
  async deleteAppsV1CollectionNamespacedStatefulSet(params: DeleteAppsV1CollectionNamespacedStatefulSetRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/statefulsets`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readAppsV1NamespacedStatefulSet(params: ReadAppsV1NamespacedStatefulSetRequest, opts?: APIClientRequestOpts): Promise<AppsV1StatefulSet> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/statefulsets/${params.path.name}`;
    return await this.get<AppsV1StatefulSet>(path, null, null, opts);
  }
  async replaceAppsV1NamespacedStatefulSet(params: ReplaceAppsV1NamespacedStatefulSetRequest, opts?: APIClientRequestOpts): Promise<AppsV1StatefulSet> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/statefulsets/${params.path.name}`;
    return await this.put<AppsV1StatefulSet>(path, params.query, params.body, opts);
  }
  async deleteAppsV1NamespacedStatefulSet(params: DeleteAppsV1NamespacedStatefulSetRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/statefulsets/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchAppsV1NamespacedStatefulSet(params: PatchAppsV1NamespacedStatefulSetRequest, opts?: APIClientRequestOpts): Promise<AppsV1StatefulSet> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/statefulsets/${params.path.name}`;
    return await this.patch<AppsV1StatefulSet>(path, params.query, null, opts);
  }
  async readAppsV1NamespacedStatefulSetScale(params: ReadAppsV1NamespacedStatefulSetScaleRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1Scale> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/statefulsets/${params.path.name}/scale`;
    return await this.get<AutoscalingV1Scale>(path, null, null, opts);
  }
  async replaceAppsV1NamespacedStatefulSetScale(params: ReplaceAppsV1NamespacedStatefulSetScaleRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1Scale> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/statefulsets/${params.path.name}/scale`;
    return await this.put<AutoscalingV1Scale>(path, params.query, params.body, opts);
  }
  async patchAppsV1NamespacedStatefulSetScale(params: PatchAppsV1NamespacedStatefulSetScaleRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1Scale> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/statefulsets/${params.path.name}/scale`;
    return await this.patch<AutoscalingV1Scale>(path, params.query, null, opts);
  }
  async readAppsV1NamespacedStatefulSetStatus(params: ReadAppsV1NamespacedStatefulSetStatusRequest, opts?: APIClientRequestOpts): Promise<AppsV1StatefulSet> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/statefulsets/${params.path.name}/status`;
    return await this.get<AppsV1StatefulSet>(path, null, null, opts);
  }
  async replaceAppsV1NamespacedStatefulSetStatus(params: ReplaceAppsV1NamespacedStatefulSetStatusRequest, opts?: APIClientRequestOpts): Promise<AppsV1StatefulSet> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/statefulsets/${params.path.name}/status`;
    return await this.put<AppsV1StatefulSet>(path, params.query, params.body, opts);
  }
  async patchAppsV1NamespacedStatefulSetStatus(params: PatchAppsV1NamespacedStatefulSetStatusRequest, opts?: APIClientRequestOpts): Promise<AppsV1StatefulSet> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/statefulsets/${params.path.name}/status`;
    return await this.patch<AppsV1StatefulSet>(path, params.query, null, opts);
  }
  async listAppsV1ReplicaSetForAllNamespaces(params: ListAppsV1ReplicaSetForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<AppsV1ReplicaSetList> {
    const path = `/apis/apps/v1/replicasets`;
    return await this.get<AppsV1ReplicaSetList>(path, null, null, opts);
  }
  async listAppsV1StatefulSetForAllNamespaces(params: ListAppsV1StatefulSetForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<AppsV1StatefulSetList> {
    const path = `/apis/apps/v1/statefulsets`;
    return await this.get<AppsV1StatefulSetList>(path, null, null, opts);
  }
  async watchAppsV1ControllerRevisionListForAllNamespaces(params: WatchAppsV1ControllerRevisionListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/apps/v1/watch/controllerrevisions`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchAppsV1DaemonSetListForAllNamespaces(params: WatchAppsV1DaemonSetListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/apps/v1/watch/daemonsets`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchAppsV1DeploymentListForAllNamespaces(params: WatchAppsV1DeploymentListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/apps/v1/watch/deployments`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchAppsV1NamespacedControllerRevisionList(params: WatchAppsV1NamespacedControllerRevisionListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/apps/v1/watch/namespaces/${params.path.namespace}/controllerrevisions`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchAppsV1NamespacedControllerRevision(params: WatchAppsV1NamespacedControllerRevisionRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/apps/v1/watch/namespaces/${params.path.namespace}/controllerrevisions/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchAppsV1NamespacedDaemonSetList(params: WatchAppsV1NamespacedDaemonSetListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/apps/v1/watch/namespaces/${params.path.namespace}/daemonsets`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchAppsV1NamespacedDaemonSet(params: WatchAppsV1NamespacedDaemonSetRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/apps/v1/watch/namespaces/${params.path.namespace}/daemonsets/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchAppsV1NamespacedDeploymentList(params: WatchAppsV1NamespacedDeploymentListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/apps/v1/watch/namespaces/${params.path.namespace}/deployments`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchAppsV1NamespacedDeployment(params: WatchAppsV1NamespacedDeploymentRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/apps/v1/watch/namespaces/${params.path.namespace}/deployments/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchAppsV1NamespacedReplicaSetList(params: WatchAppsV1NamespacedReplicaSetListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/apps/v1/watch/namespaces/${params.path.namespace}/replicasets`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchAppsV1NamespacedReplicaSet(params: WatchAppsV1NamespacedReplicaSetRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/apps/v1/watch/namespaces/${params.path.namespace}/replicasets/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchAppsV1NamespacedStatefulSetList(params: WatchAppsV1NamespacedStatefulSetListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/apps/v1/watch/namespaces/${params.path.namespace}/statefulsets`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchAppsV1NamespacedStatefulSet(params: WatchAppsV1NamespacedStatefulSetRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/apps/v1/watch/namespaces/${params.path.namespace}/statefulsets/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchAppsV1ReplicaSetListForAllNamespaces(params: WatchAppsV1ReplicaSetListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/apps/v1/watch/replicasets`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchAppsV1StatefulSetListForAllNamespaces(params: WatchAppsV1StatefulSetListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/apps/v1/watch/statefulsets`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async getAuthenticationAPIGroup(params: GetAuthenticationAPIGroupRequest, opts?: APIClientRequestOpts): Promise<APIGroup> {
    const path = `/apis/authentication.k8s.io/`;
    return await this.get<APIGroup>(path, null, null, opts);
  }
  async getAuthenticationV1APIResources(params: GetAuthenticationV1APIResourcesRequest, opts?: APIClientRequestOpts): Promise<APIResourceList> {
    const path = `/apis/authentication.k8s.io/v1/`;
    return await this.get<APIResourceList>(path, null, null, opts);
  }
  async createAuthenticationV1SelfSubjectReview(params: CreateAuthenticationV1SelfSubjectReviewRequest, opts?: APIClientRequestOpts): Promise<AuthenticationK8sIoV1SelfSubjectReview> {
    const path = `/apis/authentication.k8s.io/v1/selfsubjectreviews`;
    return await this.post<AuthenticationK8sIoV1SelfSubjectReview>(path, null, params.body, opts);
  }
  async createAuthenticationV1TokenReview(params: CreateAuthenticationV1TokenReviewRequest, opts?: APIClientRequestOpts): Promise<AuthenticationK8sIoV1TokenReview> {
    const path = `/apis/authentication.k8s.io/v1/tokenreviews`;
    return await this.post<AuthenticationK8sIoV1TokenReview>(path, null, params.body, opts);
  }
  async getAuthorizationAPIGroup(params: GetAuthorizationAPIGroupRequest, opts?: APIClientRequestOpts): Promise<APIGroup> {
    const path = `/apis/authorization.k8s.io/`;
    return await this.get<APIGroup>(path, null, null, opts);
  }
  async getAuthorizationV1APIResources(params: GetAuthorizationV1APIResourcesRequest, opts?: APIClientRequestOpts): Promise<APIResourceList> {
    const path = `/apis/authorization.k8s.io/v1/`;
    return await this.get<APIResourceList>(path, null, null, opts);
  }
  async createAuthorizationV1NamespacedLocalSubjectAccessReview(params: CreateAuthorizationV1NamespacedLocalSubjectAccessReviewRequest, opts?: APIClientRequestOpts): Promise<AuthorizationK8sIoV1LocalSubjectAccessReview> {
    const path = `/apis/authorization.k8s.io/v1/namespaces/${params.path.namespace}/localsubjectaccessreviews`;
    return await this.post<AuthorizationK8sIoV1LocalSubjectAccessReview>(path, null, params.body, opts);
  }
  async createAuthorizationV1SelfSubjectAccessReview(params: CreateAuthorizationV1SelfSubjectAccessReviewRequest, opts?: APIClientRequestOpts): Promise<AuthorizationK8sIoV1SelfSubjectAccessReview> {
    const path = `/apis/authorization.k8s.io/v1/selfsubjectaccessreviews`;
    return await this.post<AuthorizationK8sIoV1SelfSubjectAccessReview>(path, null, params.body, opts);
  }
  async createAuthorizationV1SelfSubjectRulesReview(params: CreateAuthorizationV1SelfSubjectRulesReviewRequest, opts?: APIClientRequestOpts): Promise<AuthorizationK8sIoV1SelfSubjectRulesReview> {
    const path = `/apis/authorization.k8s.io/v1/selfsubjectrulesreviews`;
    return await this.post<AuthorizationK8sIoV1SelfSubjectRulesReview>(path, null, params.body, opts);
  }
  async createAuthorizationV1SubjectAccessReview(params: CreateAuthorizationV1SubjectAccessReviewRequest, opts?: APIClientRequestOpts): Promise<AuthorizationK8sIoV1SubjectAccessReview> {
    const path = `/apis/authorization.k8s.io/v1/subjectaccessreviews`;
    return await this.post<AuthorizationK8sIoV1SubjectAccessReview>(path, null, params.body, opts);
  }
  async listAutoscalingInternalKnativeDevV1alpha1MetricForAllNamespaces(params: ListAutoscalingInternalKnativeDevV1alpha1MetricForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<AutoscalingInternalKnativeDevV1alpha1MetricList> {
    const path = `/apis/autoscaling.internal.knative.dev/v1alpha1/metrics`;
    return await this.get<AutoscalingInternalKnativeDevV1alpha1MetricList>(path, null, null, opts);
  }
  async listAutoscalingInternalKnativeDevV1alpha1NamespacedMetric(params: ListAutoscalingInternalKnativeDevV1alpha1NamespacedMetricRequest, opts?: APIClientRequestOpts): Promise<AutoscalingInternalKnativeDevV1alpha1MetricList> {
    const path = `/apis/autoscaling.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/metrics`;
    return await this.get<AutoscalingInternalKnativeDevV1alpha1MetricList>(path, null, null, opts);
  }
  async createAutoscalingInternalKnativeDevV1alpha1NamespacedMetric(params: CreateAutoscalingInternalKnativeDevV1alpha1NamespacedMetricRequest, opts?: APIClientRequestOpts): Promise<AutoscalingInternalKnativeDevV1alpha1Metric> {
    const path = `/apis/autoscaling.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/metrics`;
    return await this.post<AutoscalingInternalKnativeDevV1alpha1Metric>(path, params.query, params.body, opts);
  }
  async deleteAutoscalingInternalKnativeDevV1alpha1CollectionNamespacedMetric(params: DeleteAutoscalingInternalKnativeDevV1alpha1CollectionNamespacedMetricRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/autoscaling.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/metrics`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readAutoscalingInternalKnativeDevV1alpha1NamespacedMetric(params: ReadAutoscalingInternalKnativeDevV1alpha1NamespacedMetricRequest, opts?: APIClientRequestOpts): Promise<AutoscalingInternalKnativeDevV1alpha1Metric> {
    const path = `/apis/autoscaling.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/metrics/${params.path.name}`;
    return await this.get<AutoscalingInternalKnativeDevV1alpha1Metric>(path, null, null, opts);
  }
  async replaceAutoscalingInternalKnativeDevV1alpha1NamespacedMetric(params: ReplaceAutoscalingInternalKnativeDevV1alpha1NamespacedMetricRequest, opts?: APIClientRequestOpts): Promise<AutoscalingInternalKnativeDevV1alpha1Metric> {
    const path = `/apis/autoscaling.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/metrics/${params.path.name}`;
    return await this.put<AutoscalingInternalKnativeDevV1alpha1Metric>(path, params.query, params.body, opts);
  }
  async deleteAutoscalingInternalKnativeDevV1alpha1NamespacedMetric(params: DeleteAutoscalingInternalKnativeDevV1alpha1NamespacedMetricRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/autoscaling.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/metrics/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchAutoscalingInternalKnativeDevV1alpha1NamespacedMetric(params: PatchAutoscalingInternalKnativeDevV1alpha1NamespacedMetricRequest, opts?: APIClientRequestOpts): Promise<AutoscalingInternalKnativeDevV1alpha1Metric> {
    const path = `/apis/autoscaling.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/metrics/${params.path.name}`;
    return await this.patch<AutoscalingInternalKnativeDevV1alpha1Metric>(path, params.query, null, opts);
  }
  async readAutoscalingInternalKnativeDevV1alpha1NamespacedMetricStatus(params: ReadAutoscalingInternalKnativeDevV1alpha1NamespacedMetricStatusRequest, opts?: APIClientRequestOpts): Promise<AutoscalingInternalKnativeDevV1alpha1Metric> {
    const path = `/apis/autoscaling.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/metrics/${params.path.name}/status`;
    return await this.get<AutoscalingInternalKnativeDevV1alpha1Metric>(path, null, null, opts);
  }
  async replaceAutoscalingInternalKnativeDevV1alpha1NamespacedMetricStatus(params: ReplaceAutoscalingInternalKnativeDevV1alpha1NamespacedMetricStatusRequest, opts?: APIClientRequestOpts): Promise<AutoscalingInternalKnativeDevV1alpha1Metric> {
    const path = `/apis/autoscaling.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/metrics/${params.path.name}/status`;
    return await this.put<AutoscalingInternalKnativeDevV1alpha1Metric>(path, params.query, params.body, opts);
  }
  async patchAutoscalingInternalKnativeDevV1alpha1NamespacedMetricStatus(params: PatchAutoscalingInternalKnativeDevV1alpha1NamespacedMetricStatusRequest, opts?: APIClientRequestOpts): Promise<AutoscalingInternalKnativeDevV1alpha1Metric> {
    const path = `/apis/autoscaling.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/metrics/${params.path.name}/status`;
    return await this.patch<AutoscalingInternalKnativeDevV1alpha1Metric>(path, params.query, null, opts);
  }
  async listAutoscalingInternalKnativeDevV1alpha1NamespacedPodAutoscaler(params: ListAutoscalingInternalKnativeDevV1alpha1NamespacedPodAutoscalerRequest, opts?: APIClientRequestOpts): Promise<AutoscalingInternalKnativeDevV1alpha1PodAutoscalerList> {
    const path = `/apis/autoscaling.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/podautoscalers`;
    return await this.get<AutoscalingInternalKnativeDevV1alpha1PodAutoscalerList>(path, null, null, opts);
  }
  async createAutoscalingInternalKnativeDevV1alpha1NamespacedPodAutoscaler(params: CreateAutoscalingInternalKnativeDevV1alpha1NamespacedPodAutoscalerRequest, opts?: APIClientRequestOpts): Promise<AutoscalingInternalKnativeDevV1alpha1PodAutoscaler> {
    const path = `/apis/autoscaling.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/podautoscalers`;
    return await this.post<AutoscalingInternalKnativeDevV1alpha1PodAutoscaler>(path, params.query, params.body, opts);
  }
  async deleteAutoscalingInternalKnativeDevV1alpha1CollectionNamespacedPodAutoscaler(params: DeleteAutoscalingInternalKnativeDevV1alpha1CollectionNamespacedPodAutoscalerRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/autoscaling.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/podautoscalers`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readAutoscalingInternalKnativeDevV1alpha1NamespacedPodAutoscaler(params: ReadAutoscalingInternalKnativeDevV1alpha1NamespacedPodAutoscalerRequest, opts?: APIClientRequestOpts): Promise<AutoscalingInternalKnativeDevV1alpha1PodAutoscaler> {
    const path = `/apis/autoscaling.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/podautoscalers/${params.path.name}`;
    return await this.get<AutoscalingInternalKnativeDevV1alpha1PodAutoscaler>(path, null, null, opts);
  }
  async replaceAutoscalingInternalKnativeDevV1alpha1NamespacedPodAutoscaler(params: ReplaceAutoscalingInternalKnativeDevV1alpha1NamespacedPodAutoscalerRequest, opts?: APIClientRequestOpts): Promise<AutoscalingInternalKnativeDevV1alpha1PodAutoscaler> {
    const path = `/apis/autoscaling.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/podautoscalers/${params.path.name}`;
    return await this.put<AutoscalingInternalKnativeDevV1alpha1PodAutoscaler>(path, params.query, params.body, opts);
  }
  async deleteAutoscalingInternalKnativeDevV1alpha1NamespacedPodAutoscaler(params: DeleteAutoscalingInternalKnativeDevV1alpha1NamespacedPodAutoscalerRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/autoscaling.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/podautoscalers/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchAutoscalingInternalKnativeDevV1alpha1NamespacedPodAutoscaler(params: PatchAutoscalingInternalKnativeDevV1alpha1NamespacedPodAutoscalerRequest, opts?: APIClientRequestOpts): Promise<AutoscalingInternalKnativeDevV1alpha1PodAutoscaler> {
    const path = `/apis/autoscaling.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/podautoscalers/${params.path.name}`;
    return await this.patch<AutoscalingInternalKnativeDevV1alpha1PodAutoscaler>(path, params.query, null, opts);
  }
  async readAutoscalingInternalKnativeDevV1alpha1NamespacedPodAutoscalerStatus(params: ReadAutoscalingInternalKnativeDevV1alpha1NamespacedPodAutoscalerStatusRequest, opts?: APIClientRequestOpts): Promise<AutoscalingInternalKnativeDevV1alpha1PodAutoscaler> {
    const path = `/apis/autoscaling.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/podautoscalers/${params.path.name}/status`;
    return await this.get<AutoscalingInternalKnativeDevV1alpha1PodAutoscaler>(path, null, null, opts);
  }
  async replaceAutoscalingInternalKnativeDevV1alpha1NamespacedPodAutoscalerStatus(params: ReplaceAutoscalingInternalKnativeDevV1alpha1NamespacedPodAutoscalerStatusRequest, opts?: APIClientRequestOpts): Promise<AutoscalingInternalKnativeDevV1alpha1PodAutoscaler> {
    const path = `/apis/autoscaling.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/podautoscalers/${params.path.name}/status`;
    return await this.put<AutoscalingInternalKnativeDevV1alpha1PodAutoscaler>(path, params.query, params.body, opts);
  }
  async patchAutoscalingInternalKnativeDevV1alpha1NamespacedPodAutoscalerStatus(params: PatchAutoscalingInternalKnativeDevV1alpha1NamespacedPodAutoscalerStatusRequest, opts?: APIClientRequestOpts): Promise<AutoscalingInternalKnativeDevV1alpha1PodAutoscaler> {
    const path = `/apis/autoscaling.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/podautoscalers/${params.path.name}/status`;
    return await this.patch<AutoscalingInternalKnativeDevV1alpha1PodAutoscaler>(path, params.query, null, opts);
  }
  async listAutoscalingInternalKnativeDevV1alpha1PodAutoscalerForAllNamespaces(params: ListAutoscalingInternalKnativeDevV1alpha1PodAutoscalerForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<AutoscalingInternalKnativeDevV1alpha1PodAutoscalerList> {
    const path = `/apis/autoscaling.internal.knative.dev/v1alpha1/podautoscalers`;
    return await this.get<AutoscalingInternalKnativeDevV1alpha1PodAutoscalerList>(path, null, null, opts);
  }
  async getAutoscalingAPIGroup(params: GetAutoscalingAPIGroupRequest, opts?: APIClientRequestOpts): Promise<APIGroup> {
    const path = `/apis/autoscaling/`;
    return await this.get<APIGroup>(path, null, null, opts);
  }
  async getAutoscalingV1APIResources(params: GetAutoscalingV1APIResourcesRequest, opts?: APIClientRequestOpts): Promise<APIResourceList> {
    const path = `/apis/autoscaling/v1/`;
    return await this.get<APIResourceList>(path, null, null, opts);
  }
  async listAutoscalingV1HorizontalPodAutoscalerForAllNamespaces(params: ListAutoscalingV1HorizontalPodAutoscalerForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1HorizontalPodAutoscalerList> {
    const path = `/apis/autoscaling/v1/horizontalpodautoscalers`;
    return await this.get<AutoscalingV1HorizontalPodAutoscalerList>(path, null, null, opts);
  }
  async listAutoscalingV1NamespacedHorizontalPodAutoscaler(params: ListAutoscalingV1NamespacedHorizontalPodAutoscalerRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1HorizontalPodAutoscalerList> {
    const path = `/apis/autoscaling/v1/namespaces/${params.path.namespace}/horizontalpodautoscalers`;
    return await this.get<AutoscalingV1HorizontalPodAutoscalerList>(path, null, null, opts);
  }
  async createAutoscalingV1NamespacedHorizontalPodAutoscaler(params: CreateAutoscalingV1NamespacedHorizontalPodAutoscalerRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1HorizontalPodAutoscaler> {
    const path = `/apis/autoscaling/v1/namespaces/${params.path.namespace}/horizontalpodautoscalers`;
    return await this.post<AutoscalingV1HorizontalPodAutoscaler>(path, params.query, params.body, opts);
  }
  async deleteAutoscalingV1CollectionNamespacedHorizontalPodAutoscaler(params: DeleteAutoscalingV1CollectionNamespacedHorizontalPodAutoscalerRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/autoscaling/v1/namespaces/${params.path.namespace}/horizontalpodautoscalers`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readAutoscalingV1NamespacedHorizontalPodAutoscaler(params: ReadAutoscalingV1NamespacedHorizontalPodAutoscalerRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1HorizontalPodAutoscaler> {
    const path = `/apis/autoscaling/v1/namespaces/${params.path.namespace}/horizontalpodautoscalers/${params.path.name}`;
    return await this.get<AutoscalingV1HorizontalPodAutoscaler>(path, null, null, opts);
  }
  async replaceAutoscalingV1NamespacedHorizontalPodAutoscaler(params: ReplaceAutoscalingV1NamespacedHorizontalPodAutoscalerRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1HorizontalPodAutoscaler> {
    const path = `/apis/autoscaling/v1/namespaces/${params.path.namespace}/horizontalpodautoscalers/${params.path.name}`;
    return await this.put<AutoscalingV1HorizontalPodAutoscaler>(path, params.query, params.body, opts);
  }
  async deleteAutoscalingV1NamespacedHorizontalPodAutoscaler(params: DeleteAutoscalingV1NamespacedHorizontalPodAutoscalerRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/autoscaling/v1/namespaces/${params.path.namespace}/horizontalpodautoscalers/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchAutoscalingV1NamespacedHorizontalPodAutoscaler(params: PatchAutoscalingV1NamespacedHorizontalPodAutoscalerRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1HorizontalPodAutoscaler> {
    const path = `/apis/autoscaling/v1/namespaces/${params.path.namespace}/horizontalpodautoscalers/${params.path.name}`;
    return await this.patch<AutoscalingV1HorizontalPodAutoscaler>(path, params.query, null, opts);
  }
  async readAutoscalingV1NamespacedHorizontalPodAutoscalerStatus(params: ReadAutoscalingV1NamespacedHorizontalPodAutoscalerStatusRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1HorizontalPodAutoscaler> {
    const path = `/apis/autoscaling/v1/namespaces/${params.path.namespace}/horizontalpodautoscalers/${params.path.name}/status`;
    return await this.get<AutoscalingV1HorizontalPodAutoscaler>(path, null, null, opts);
  }
  async replaceAutoscalingV1NamespacedHorizontalPodAutoscalerStatus(params: ReplaceAutoscalingV1NamespacedHorizontalPodAutoscalerStatusRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1HorizontalPodAutoscaler> {
    const path = `/apis/autoscaling/v1/namespaces/${params.path.namespace}/horizontalpodautoscalers/${params.path.name}/status`;
    return await this.put<AutoscalingV1HorizontalPodAutoscaler>(path, params.query, params.body, opts);
  }
  async patchAutoscalingV1NamespacedHorizontalPodAutoscalerStatus(params: PatchAutoscalingV1NamespacedHorizontalPodAutoscalerStatusRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1HorizontalPodAutoscaler> {
    const path = `/apis/autoscaling/v1/namespaces/${params.path.namespace}/horizontalpodautoscalers/${params.path.name}/status`;
    return await this.patch<AutoscalingV1HorizontalPodAutoscaler>(path, params.query, null, opts);
  }
  async watchAutoscalingV1HorizontalPodAutoscalerListForAllNamespaces(params: WatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/autoscaling/v1/watch/horizontalpodautoscalers`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchAutoscalingV1NamespacedHorizontalPodAutoscalerList(params: WatchAutoscalingV1NamespacedHorizontalPodAutoscalerListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/autoscaling/v1/watch/namespaces/${params.path.namespace}/horizontalpodautoscalers`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchAutoscalingV1NamespacedHorizontalPodAutoscaler(params: WatchAutoscalingV1NamespacedHorizontalPodAutoscalerRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/autoscaling/v1/watch/namespaces/${params.path.namespace}/horizontalpodautoscalers/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async getAutoscalingV2APIResources(params: GetAutoscalingV2APIResourcesRequest, opts?: APIClientRequestOpts): Promise<APIResourceList> {
    const path = `/apis/autoscaling/v2/`;
    return await this.get<APIResourceList>(path, null, null, opts);
  }
  async listAutoscalingV2HorizontalPodAutoscalerForAllNamespaces(params: ListAutoscalingV2HorizontalPodAutoscalerForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV2HorizontalPodAutoscalerList> {
    const path = `/apis/autoscaling/v2/horizontalpodautoscalers`;
    return await this.get<AutoscalingV2HorizontalPodAutoscalerList>(path, null, null, opts);
  }
  async listAutoscalingV2NamespacedHorizontalPodAutoscaler(params: ListAutoscalingV2NamespacedHorizontalPodAutoscalerRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV2HorizontalPodAutoscalerList> {
    const path = `/apis/autoscaling/v2/namespaces/${params.path.namespace}/horizontalpodautoscalers`;
    return await this.get<AutoscalingV2HorizontalPodAutoscalerList>(path, null, null, opts);
  }
  async createAutoscalingV2NamespacedHorizontalPodAutoscaler(params: CreateAutoscalingV2NamespacedHorizontalPodAutoscalerRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV2HorizontalPodAutoscaler> {
    const path = `/apis/autoscaling/v2/namespaces/${params.path.namespace}/horizontalpodautoscalers`;
    return await this.post<AutoscalingV2HorizontalPodAutoscaler>(path, params.query, params.body, opts);
  }
  async deleteAutoscalingV2CollectionNamespacedHorizontalPodAutoscaler(params: DeleteAutoscalingV2CollectionNamespacedHorizontalPodAutoscalerRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/autoscaling/v2/namespaces/${params.path.namespace}/horizontalpodautoscalers`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readAutoscalingV2NamespacedHorizontalPodAutoscaler(params: ReadAutoscalingV2NamespacedHorizontalPodAutoscalerRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV2HorizontalPodAutoscaler> {
    const path = `/apis/autoscaling/v2/namespaces/${params.path.namespace}/horizontalpodautoscalers/${params.path.name}`;
    return await this.get<AutoscalingV2HorizontalPodAutoscaler>(path, null, null, opts);
  }
  async replaceAutoscalingV2NamespacedHorizontalPodAutoscaler(params: ReplaceAutoscalingV2NamespacedHorizontalPodAutoscalerRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV2HorizontalPodAutoscaler> {
    const path = `/apis/autoscaling/v2/namespaces/${params.path.namespace}/horizontalpodautoscalers/${params.path.name}`;
    return await this.put<AutoscalingV2HorizontalPodAutoscaler>(path, params.query, params.body, opts);
  }
  async deleteAutoscalingV2NamespacedHorizontalPodAutoscaler(params: DeleteAutoscalingV2NamespacedHorizontalPodAutoscalerRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/autoscaling/v2/namespaces/${params.path.namespace}/horizontalpodautoscalers/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchAutoscalingV2NamespacedHorizontalPodAutoscaler(params: PatchAutoscalingV2NamespacedHorizontalPodAutoscalerRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV2HorizontalPodAutoscaler> {
    const path = `/apis/autoscaling/v2/namespaces/${params.path.namespace}/horizontalpodautoscalers/${params.path.name}`;
    return await this.patch<AutoscalingV2HorizontalPodAutoscaler>(path, params.query, null, opts);
  }
  async readAutoscalingV2NamespacedHorizontalPodAutoscalerStatus(params: ReadAutoscalingV2NamespacedHorizontalPodAutoscalerStatusRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV2HorizontalPodAutoscaler> {
    const path = `/apis/autoscaling/v2/namespaces/${params.path.namespace}/horizontalpodautoscalers/${params.path.name}/status`;
    return await this.get<AutoscalingV2HorizontalPodAutoscaler>(path, null, null, opts);
  }
  async replaceAutoscalingV2NamespacedHorizontalPodAutoscalerStatus(params: ReplaceAutoscalingV2NamespacedHorizontalPodAutoscalerStatusRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV2HorizontalPodAutoscaler> {
    const path = `/apis/autoscaling/v2/namespaces/${params.path.namespace}/horizontalpodautoscalers/${params.path.name}/status`;
    return await this.put<AutoscalingV2HorizontalPodAutoscaler>(path, params.query, params.body, opts);
  }
  async patchAutoscalingV2NamespacedHorizontalPodAutoscalerStatus(params: PatchAutoscalingV2NamespacedHorizontalPodAutoscalerStatusRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV2HorizontalPodAutoscaler> {
    const path = `/apis/autoscaling/v2/namespaces/${params.path.namespace}/horizontalpodautoscalers/${params.path.name}/status`;
    return await this.patch<AutoscalingV2HorizontalPodAutoscaler>(path, params.query, null, opts);
  }
  async watchAutoscalingV2HorizontalPodAutoscalerListForAllNamespaces(params: WatchAutoscalingV2HorizontalPodAutoscalerListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/autoscaling/v2/watch/horizontalpodautoscalers`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchAutoscalingV2NamespacedHorizontalPodAutoscalerList(params: WatchAutoscalingV2NamespacedHorizontalPodAutoscalerListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/autoscaling/v2/watch/namespaces/${params.path.namespace}/horizontalpodautoscalers`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchAutoscalingV2NamespacedHorizontalPodAutoscaler(params: WatchAutoscalingV2NamespacedHorizontalPodAutoscalerRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/autoscaling/v2/watch/namespaces/${params.path.namespace}/horizontalpodautoscalers/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async getBatchAPIGroup(params: GetBatchAPIGroupRequest, opts?: APIClientRequestOpts): Promise<APIGroup> {
    const path = `/apis/batch/`;
    return await this.get<APIGroup>(path, null, null, opts);
  }
  async getBatchV1APIResources(params: GetBatchV1APIResourcesRequest, opts?: APIClientRequestOpts): Promise<APIResourceList> {
    const path = `/apis/batch/v1/`;
    return await this.get<APIResourceList>(path, null, null, opts);
  }
  async listBatchV1CronJobForAllNamespaces(params: ListBatchV1CronJobForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<BatchV1CronJobList> {
    const path = `/apis/batch/v1/cronjobs`;
    return await this.get<BatchV1CronJobList>(path, null, null, opts);
  }
  async listBatchV1JobForAllNamespaces(params: ListBatchV1JobForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<BatchV1JobList> {
    const path = `/apis/batch/v1/jobs`;
    return await this.get<BatchV1JobList>(path, null, null, opts);
  }
  async listBatchV1NamespacedCronJob(params: ListBatchV1NamespacedCronJobRequest, opts?: APIClientRequestOpts): Promise<BatchV1CronJobList> {
    const path = `/apis/batch/v1/namespaces/${params.path.namespace}/cronjobs`;
    return await this.get<BatchV1CronJobList>(path, null, null, opts);
  }
  async createBatchV1NamespacedCronJob(params: CreateBatchV1NamespacedCronJobRequest, opts?: APIClientRequestOpts): Promise<BatchV1CronJob> {
    const path = `/apis/batch/v1/namespaces/${params.path.namespace}/cronjobs`;
    return await this.post<BatchV1CronJob>(path, params.query, params.body, opts);
  }
  async deleteBatchV1CollectionNamespacedCronJob(params: DeleteBatchV1CollectionNamespacedCronJobRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/batch/v1/namespaces/${params.path.namespace}/cronjobs`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readBatchV1NamespacedCronJob(params: ReadBatchV1NamespacedCronJobRequest, opts?: APIClientRequestOpts): Promise<BatchV1CronJob> {
    const path = `/apis/batch/v1/namespaces/${params.path.namespace}/cronjobs/${params.path.name}`;
    return await this.get<BatchV1CronJob>(path, null, null, opts);
  }
  async replaceBatchV1NamespacedCronJob(params: ReplaceBatchV1NamespacedCronJobRequest, opts?: APIClientRequestOpts): Promise<BatchV1CronJob> {
    const path = `/apis/batch/v1/namespaces/${params.path.namespace}/cronjobs/${params.path.name}`;
    return await this.put<BatchV1CronJob>(path, params.query, params.body, opts);
  }
  async deleteBatchV1NamespacedCronJob(params: DeleteBatchV1NamespacedCronJobRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/batch/v1/namespaces/${params.path.namespace}/cronjobs/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchBatchV1NamespacedCronJob(params: PatchBatchV1NamespacedCronJobRequest, opts?: APIClientRequestOpts): Promise<BatchV1CronJob> {
    const path = `/apis/batch/v1/namespaces/${params.path.namespace}/cronjobs/${params.path.name}`;
    return await this.patch<BatchV1CronJob>(path, params.query, null, opts);
  }
  async readBatchV1NamespacedCronJobStatus(params: ReadBatchV1NamespacedCronJobStatusRequest, opts?: APIClientRequestOpts): Promise<BatchV1CronJob> {
    const path = `/apis/batch/v1/namespaces/${params.path.namespace}/cronjobs/${params.path.name}/status`;
    return await this.get<BatchV1CronJob>(path, null, null, opts);
  }
  async replaceBatchV1NamespacedCronJobStatus(params: ReplaceBatchV1NamespacedCronJobStatusRequest, opts?: APIClientRequestOpts): Promise<BatchV1CronJob> {
    const path = `/apis/batch/v1/namespaces/${params.path.namespace}/cronjobs/${params.path.name}/status`;
    return await this.put<BatchV1CronJob>(path, params.query, params.body, opts);
  }
  async patchBatchV1NamespacedCronJobStatus(params: PatchBatchV1NamespacedCronJobStatusRequest, opts?: APIClientRequestOpts): Promise<BatchV1CronJob> {
    const path = `/apis/batch/v1/namespaces/${params.path.namespace}/cronjobs/${params.path.name}/status`;
    return await this.patch<BatchV1CronJob>(path, params.query, null, opts);
  }
  async listBatchV1NamespacedJob(params: ListBatchV1NamespacedJobRequest, opts?: APIClientRequestOpts): Promise<BatchV1JobList> {
    const path = `/apis/batch/v1/namespaces/${params.path.namespace}/jobs`;
    return await this.get<BatchV1JobList>(path, null, null, opts);
  }
  async createBatchV1NamespacedJob(params: CreateBatchV1NamespacedJobRequest, opts?: APIClientRequestOpts): Promise<BatchV1Job> {
    const path = `/apis/batch/v1/namespaces/${params.path.namespace}/jobs`;
    return await this.post<BatchV1Job>(path, params.query, params.body, opts);
  }
  async deleteBatchV1CollectionNamespacedJob(params: DeleteBatchV1CollectionNamespacedJobRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/batch/v1/namespaces/${params.path.namespace}/jobs`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readBatchV1NamespacedJob(params: ReadBatchV1NamespacedJobRequest, opts?: APIClientRequestOpts): Promise<BatchV1Job> {
    const path = `/apis/batch/v1/namespaces/${params.path.namespace}/jobs/${params.path.name}`;
    return await this.get<BatchV1Job>(path, null, null, opts);
  }
  async replaceBatchV1NamespacedJob(params: ReplaceBatchV1NamespacedJobRequest, opts?: APIClientRequestOpts): Promise<BatchV1Job> {
    const path = `/apis/batch/v1/namespaces/${params.path.namespace}/jobs/${params.path.name}`;
    return await this.put<BatchV1Job>(path, params.query, params.body, opts);
  }
  async deleteBatchV1NamespacedJob(params: DeleteBatchV1NamespacedJobRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/batch/v1/namespaces/${params.path.namespace}/jobs/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchBatchV1NamespacedJob(params: PatchBatchV1NamespacedJobRequest, opts?: APIClientRequestOpts): Promise<BatchV1Job> {
    const path = `/apis/batch/v1/namespaces/${params.path.namespace}/jobs/${params.path.name}`;
    return await this.patch<BatchV1Job>(path, params.query, null, opts);
  }
  async readBatchV1NamespacedJobStatus(params: ReadBatchV1NamespacedJobStatusRequest, opts?: APIClientRequestOpts): Promise<BatchV1Job> {
    const path = `/apis/batch/v1/namespaces/${params.path.namespace}/jobs/${params.path.name}/status`;
    return await this.get<BatchV1Job>(path, null, null, opts);
  }
  async replaceBatchV1NamespacedJobStatus(params: ReplaceBatchV1NamespacedJobStatusRequest, opts?: APIClientRequestOpts): Promise<BatchV1Job> {
    const path = `/apis/batch/v1/namespaces/${params.path.namespace}/jobs/${params.path.name}/status`;
    return await this.put<BatchV1Job>(path, params.query, params.body, opts);
  }
  async patchBatchV1NamespacedJobStatus(params: PatchBatchV1NamespacedJobStatusRequest, opts?: APIClientRequestOpts): Promise<BatchV1Job> {
    const path = `/apis/batch/v1/namespaces/${params.path.namespace}/jobs/${params.path.name}/status`;
    return await this.patch<BatchV1Job>(path, params.query, null, opts);
  }
  async watchBatchV1CronJobListForAllNamespaces(params: WatchBatchV1CronJobListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/batch/v1/watch/cronjobs`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchBatchV1JobListForAllNamespaces(params: WatchBatchV1JobListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/batch/v1/watch/jobs`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchBatchV1NamespacedCronJobList(params: WatchBatchV1NamespacedCronJobListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/batch/v1/watch/namespaces/${params.path.namespace}/cronjobs`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchBatchV1NamespacedCronJob(params: WatchBatchV1NamespacedCronJobRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/batch/v1/watch/namespaces/${params.path.namespace}/cronjobs/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchBatchV1NamespacedJobList(params: WatchBatchV1NamespacedJobListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/batch/v1/watch/namespaces/${params.path.namespace}/jobs`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchBatchV1NamespacedJob(params: WatchBatchV1NamespacedJobRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/batch/v1/watch/namespaces/${params.path.namespace}/jobs/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async listCachingInternalKnativeDevV1alpha1ImageForAllNamespaces(params: ListCachingInternalKnativeDevV1alpha1ImageForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<CachingInternalKnativeDevV1alpha1ImageList> {
    const path = `/apis/caching.internal.knative.dev/v1alpha1/images`;
    return await this.get<CachingInternalKnativeDevV1alpha1ImageList>(path, null, null, opts);
  }
  async listCachingInternalKnativeDevV1alpha1NamespacedImage(params: ListCachingInternalKnativeDevV1alpha1NamespacedImageRequest, opts?: APIClientRequestOpts): Promise<CachingInternalKnativeDevV1alpha1ImageList> {
    const path = `/apis/caching.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/images`;
    return await this.get<CachingInternalKnativeDevV1alpha1ImageList>(path, null, null, opts);
  }
  async createCachingInternalKnativeDevV1alpha1NamespacedImage(params: CreateCachingInternalKnativeDevV1alpha1NamespacedImageRequest, opts?: APIClientRequestOpts): Promise<CachingInternalKnativeDevV1alpha1Image> {
    const path = `/apis/caching.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/images`;
    return await this.post<CachingInternalKnativeDevV1alpha1Image>(path, params.query, params.body, opts);
  }
  async deleteCachingInternalKnativeDevV1alpha1CollectionNamespacedImage(params: DeleteCachingInternalKnativeDevV1alpha1CollectionNamespacedImageRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/caching.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/images`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readCachingInternalKnativeDevV1alpha1NamespacedImage(params: ReadCachingInternalKnativeDevV1alpha1NamespacedImageRequest, opts?: APIClientRequestOpts): Promise<CachingInternalKnativeDevV1alpha1Image> {
    const path = `/apis/caching.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/images/${params.path.name}`;
    return await this.get<CachingInternalKnativeDevV1alpha1Image>(path, null, null, opts);
  }
  async replaceCachingInternalKnativeDevV1alpha1NamespacedImage(params: ReplaceCachingInternalKnativeDevV1alpha1NamespacedImageRequest, opts?: APIClientRequestOpts): Promise<CachingInternalKnativeDevV1alpha1Image> {
    const path = `/apis/caching.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/images/${params.path.name}`;
    return await this.put<CachingInternalKnativeDevV1alpha1Image>(path, params.query, params.body, opts);
  }
  async deleteCachingInternalKnativeDevV1alpha1NamespacedImage(params: DeleteCachingInternalKnativeDevV1alpha1NamespacedImageRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/caching.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/images/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchCachingInternalKnativeDevV1alpha1NamespacedImage(params: PatchCachingInternalKnativeDevV1alpha1NamespacedImageRequest, opts?: APIClientRequestOpts): Promise<CachingInternalKnativeDevV1alpha1Image> {
    const path = `/apis/caching.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/images/${params.path.name}`;
    return await this.patch<CachingInternalKnativeDevV1alpha1Image>(path, params.query, null, opts);
  }
  async readCachingInternalKnativeDevV1alpha1NamespacedImageStatus(params: ReadCachingInternalKnativeDevV1alpha1NamespacedImageStatusRequest, opts?: APIClientRequestOpts): Promise<CachingInternalKnativeDevV1alpha1Image> {
    const path = `/apis/caching.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/images/${params.path.name}/status`;
    return await this.get<CachingInternalKnativeDevV1alpha1Image>(path, null, null, opts);
  }
  async replaceCachingInternalKnativeDevV1alpha1NamespacedImageStatus(params: ReplaceCachingInternalKnativeDevV1alpha1NamespacedImageStatusRequest, opts?: APIClientRequestOpts): Promise<CachingInternalKnativeDevV1alpha1Image> {
    const path = `/apis/caching.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/images/${params.path.name}/status`;
    return await this.put<CachingInternalKnativeDevV1alpha1Image>(path, params.query, params.body, opts);
  }
  async patchCachingInternalKnativeDevV1alpha1NamespacedImageStatus(params: PatchCachingInternalKnativeDevV1alpha1NamespacedImageStatusRequest, opts?: APIClientRequestOpts): Promise<CachingInternalKnativeDevV1alpha1Image> {
    const path = `/apis/caching.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/images/${params.path.name}/status`;
    return await this.patch<CachingInternalKnativeDevV1alpha1Image>(path, params.query, null, opts);
  }
  async listCertManagerIoV1CertificateRequestForAllNamespaces(params: ListCertManagerIoV1CertificateRequestForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1CertificateRequestList> {
    const path = `/apis/cert-manager.io/v1/certificaterequests`;
    return await this.get<CertManagerIoV1CertificateRequestList>(path, null, null, opts);
  }
  async listCertManagerIoV1CertificateForAllNamespaces(params: ListCertManagerIoV1CertificateForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1CertificateList> {
    const path = `/apis/cert-manager.io/v1/certificates`;
    return await this.get<CertManagerIoV1CertificateList>(path, null, null, opts);
  }
  async listCertManagerIoV1ClusterIssuer(params: ListCertManagerIoV1ClusterIssuerRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1ClusterIssuerList> {
    const path = `/apis/cert-manager.io/v1/clusterissuers`;
    return await this.get<CertManagerIoV1ClusterIssuerList>(path, null, null, opts);
  }
  async createCertManagerIoV1ClusterIssuer(params: CreateCertManagerIoV1ClusterIssuerRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1ClusterIssuer> {
    const path = `/apis/cert-manager.io/v1/clusterissuers`;
    return await this.post<CertManagerIoV1ClusterIssuer>(path, params.query, params.body, opts);
  }
  async deleteCertManagerIoV1CollectionClusterIssuer(params: DeleteCertManagerIoV1CollectionClusterIssuerRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/cert-manager.io/v1/clusterissuers`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readCertManagerIoV1ClusterIssuer(params: ReadCertManagerIoV1ClusterIssuerRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1ClusterIssuer> {
    const path = `/apis/cert-manager.io/v1/clusterissuers/${params.path.name}`;
    return await this.get<CertManagerIoV1ClusterIssuer>(path, null, null, opts);
  }
  async replaceCertManagerIoV1ClusterIssuer(params: ReplaceCertManagerIoV1ClusterIssuerRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1ClusterIssuer> {
    const path = `/apis/cert-manager.io/v1/clusterissuers/${params.path.name}`;
    return await this.put<CertManagerIoV1ClusterIssuer>(path, params.query, params.body, opts);
  }
  async deleteCertManagerIoV1ClusterIssuer(params: DeleteCertManagerIoV1ClusterIssuerRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/cert-manager.io/v1/clusterissuers/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchCertManagerIoV1ClusterIssuer(params: PatchCertManagerIoV1ClusterIssuerRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1ClusterIssuer> {
    const path = `/apis/cert-manager.io/v1/clusterissuers/${params.path.name}`;
    return await this.patch<CertManagerIoV1ClusterIssuer>(path, params.query, null, opts);
  }
  async readCertManagerIoV1ClusterIssuerStatus(params: ReadCertManagerIoV1ClusterIssuerStatusRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1ClusterIssuer> {
    const path = `/apis/cert-manager.io/v1/clusterissuers/${params.path.name}/status`;
    return await this.get<CertManagerIoV1ClusterIssuer>(path, null, null, opts);
  }
  async replaceCertManagerIoV1ClusterIssuerStatus(params: ReplaceCertManagerIoV1ClusterIssuerStatusRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1ClusterIssuer> {
    const path = `/apis/cert-manager.io/v1/clusterissuers/${params.path.name}/status`;
    return await this.put<CertManagerIoV1ClusterIssuer>(path, params.query, params.body, opts);
  }
  async patchCertManagerIoV1ClusterIssuerStatus(params: PatchCertManagerIoV1ClusterIssuerStatusRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1ClusterIssuer> {
    const path = `/apis/cert-manager.io/v1/clusterissuers/${params.path.name}/status`;
    return await this.patch<CertManagerIoV1ClusterIssuer>(path, params.query, null, opts);
  }
  async listCertManagerIoV1IssuerForAllNamespaces(params: ListCertManagerIoV1IssuerForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1IssuerList> {
    const path = `/apis/cert-manager.io/v1/issuers`;
    return await this.get<CertManagerIoV1IssuerList>(path, null, null, opts);
  }
  async listCertManagerIoV1NamespacedCertificateRequest(params: ListCertManagerIoV1NamespacedCertificateRequestRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1CertificateRequestList> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/certificaterequests`;
    return await this.get<CertManagerIoV1CertificateRequestList>(path, null, null, opts);
  }
  async createCertManagerIoV1NamespacedCertificateRequest(params: CreateCertManagerIoV1NamespacedCertificateRequestRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1CertificateRequest> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/certificaterequests`;
    return await this.post<CertManagerIoV1CertificateRequest>(path, params.query, params.body, opts);
  }
  async deleteCertManagerIoV1CollectionNamespacedCertificateRequest(params: DeleteCertManagerIoV1CollectionNamespacedCertificateRequestRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/certificaterequests`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readCertManagerIoV1NamespacedCertificateRequest(params: ReadCertManagerIoV1NamespacedCertificateRequestRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1CertificateRequest> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/certificaterequests/${params.path.name}`;
    return await this.get<CertManagerIoV1CertificateRequest>(path, null, null, opts);
  }
  async replaceCertManagerIoV1NamespacedCertificateRequest(params: ReplaceCertManagerIoV1NamespacedCertificateRequestRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1CertificateRequest> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/certificaterequests/${params.path.name}`;
    return await this.put<CertManagerIoV1CertificateRequest>(path, params.query, params.body, opts);
  }
  async deleteCertManagerIoV1NamespacedCertificateRequest(params: DeleteCertManagerIoV1NamespacedCertificateRequestRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/certificaterequests/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchCertManagerIoV1NamespacedCertificateRequest(params: PatchCertManagerIoV1NamespacedCertificateRequestRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1CertificateRequest> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/certificaterequests/${params.path.name}`;
    return await this.patch<CertManagerIoV1CertificateRequest>(path, params.query, null, opts);
  }
  async readCertManagerIoV1NamespacedCertificateRequestStatus(params: ReadCertManagerIoV1NamespacedCertificateRequestStatusRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1CertificateRequest> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/certificaterequests/${params.path.name}/status`;
    return await this.get<CertManagerIoV1CertificateRequest>(path, null, null, opts);
  }
  async replaceCertManagerIoV1NamespacedCertificateRequestStatus(params: ReplaceCertManagerIoV1NamespacedCertificateRequestStatusRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1CertificateRequest> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/certificaterequests/${params.path.name}/status`;
    return await this.put<CertManagerIoV1CertificateRequest>(path, params.query, params.body, opts);
  }
  async patchCertManagerIoV1NamespacedCertificateRequestStatus(params: PatchCertManagerIoV1NamespacedCertificateRequestStatusRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1CertificateRequest> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/certificaterequests/${params.path.name}/status`;
    return await this.patch<CertManagerIoV1CertificateRequest>(path, params.query, null, opts);
  }
  async listCertManagerIoV1NamespacedCertificate(params: ListCertManagerIoV1NamespacedCertificateRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1CertificateList> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/certificates`;
    return await this.get<CertManagerIoV1CertificateList>(path, null, null, opts);
  }
  async createCertManagerIoV1NamespacedCertificate(params: CreateCertManagerIoV1NamespacedCertificateRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1Certificate> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/certificates`;
    return await this.post<CertManagerIoV1Certificate>(path, params.query, params.body, opts);
  }
  async deleteCertManagerIoV1CollectionNamespacedCertificate(params: DeleteCertManagerIoV1CollectionNamespacedCertificateRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/certificates`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readCertManagerIoV1NamespacedCertificate(params: ReadCertManagerIoV1NamespacedCertificateRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1Certificate> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/certificates/${params.path.name}`;
    return await this.get<CertManagerIoV1Certificate>(path, null, null, opts);
  }
  async replaceCertManagerIoV1NamespacedCertificate(params: ReplaceCertManagerIoV1NamespacedCertificateRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1Certificate> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/certificates/${params.path.name}`;
    return await this.put<CertManagerIoV1Certificate>(path, params.query, params.body, opts);
  }
  async deleteCertManagerIoV1NamespacedCertificate(params: DeleteCertManagerIoV1NamespacedCertificateRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/certificates/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchCertManagerIoV1NamespacedCertificate(params: PatchCertManagerIoV1NamespacedCertificateRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1Certificate> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/certificates/${params.path.name}`;
    return await this.patch<CertManagerIoV1Certificate>(path, params.query, null, opts);
  }
  async readCertManagerIoV1NamespacedCertificateStatus(params: ReadCertManagerIoV1NamespacedCertificateStatusRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1Certificate> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/certificates/${params.path.name}/status`;
    return await this.get<CertManagerIoV1Certificate>(path, null, null, opts);
  }
  async replaceCertManagerIoV1NamespacedCertificateStatus(params: ReplaceCertManagerIoV1NamespacedCertificateStatusRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1Certificate> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/certificates/${params.path.name}/status`;
    return await this.put<CertManagerIoV1Certificate>(path, params.query, params.body, opts);
  }
  async patchCertManagerIoV1NamespacedCertificateStatus(params: PatchCertManagerIoV1NamespacedCertificateStatusRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1Certificate> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/certificates/${params.path.name}/status`;
    return await this.patch<CertManagerIoV1Certificate>(path, params.query, null, opts);
  }
  async listCertManagerIoV1NamespacedIssuer(params: ListCertManagerIoV1NamespacedIssuerRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1IssuerList> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/issuers`;
    return await this.get<CertManagerIoV1IssuerList>(path, null, null, opts);
  }
  async createCertManagerIoV1NamespacedIssuer(params: CreateCertManagerIoV1NamespacedIssuerRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1Issuer> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/issuers`;
    return await this.post<CertManagerIoV1Issuer>(path, params.query, params.body, opts);
  }
  async deleteCertManagerIoV1CollectionNamespacedIssuer(params: DeleteCertManagerIoV1CollectionNamespacedIssuerRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/issuers`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readCertManagerIoV1NamespacedIssuer(params: ReadCertManagerIoV1NamespacedIssuerRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1Issuer> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/issuers/${params.path.name}`;
    return await this.get<CertManagerIoV1Issuer>(path, null, null, opts);
  }
  async replaceCertManagerIoV1NamespacedIssuer(params: ReplaceCertManagerIoV1NamespacedIssuerRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1Issuer> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/issuers/${params.path.name}`;
    return await this.put<CertManagerIoV1Issuer>(path, params.query, params.body, opts);
  }
  async deleteCertManagerIoV1NamespacedIssuer(params: DeleteCertManagerIoV1NamespacedIssuerRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/issuers/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchCertManagerIoV1NamespacedIssuer(params: PatchCertManagerIoV1NamespacedIssuerRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1Issuer> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/issuers/${params.path.name}`;
    return await this.patch<CertManagerIoV1Issuer>(path, params.query, null, opts);
  }
  async readCertManagerIoV1NamespacedIssuerStatus(params: ReadCertManagerIoV1NamespacedIssuerStatusRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1Issuer> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/issuers/${params.path.name}/status`;
    return await this.get<CertManagerIoV1Issuer>(path, null, null, opts);
  }
  async replaceCertManagerIoV1NamespacedIssuerStatus(params: ReplaceCertManagerIoV1NamespacedIssuerStatusRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1Issuer> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/issuers/${params.path.name}/status`;
    return await this.put<CertManagerIoV1Issuer>(path, params.query, params.body, opts);
  }
  async patchCertManagerIoV1NamespacedIssuerStatus(params: PatchCertManagerIoV1NamespacedIssuerStatusRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1Issuer> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/issuers/${params.path.name}/status`;
    return await this.patch<CertManagerIoV1Issuer>(path, params.query, null, opts);
  }
  async getCertificatesAPIGroup(params: GetCertificatesAPIGroupRequest, opts?: APIClientRequestOpts): Promise<APIGroup> {
    const path = `/apis/certificates.k8s.io/`;
    return await this.get<APIGroup>(path, null, null, opts);
  }
  async getCertificatesV1APIResources(params: GetCertificatesV1APIResourcesRequest, opts?: APIClientRequestOpts): Promise<APIResourceList> {
    const path = `/apis/certificates.k8s.io/v1/`;
    return await this.get<APIResourceList>(path, null, null, opts);
  }
  async listCertificatesV1CertificateSigningRequest(params: ListCertificatesV1CertificateSigningRequestRequest, opts?: APIClientRequestOpts): Promise<CertificatesK8sIoV1CertificateSigningRequestList> {
    const path = `/apis/certificates.k8s.io/v1/certificatesigningrequests`;
    return await this.get<CertificatesK8sIoV1CertificateSigningRequestList>(path, null, null, opts);
  }
  async createCertificatesV1CertificateSigningRequest(params: CreateCertificatesV1CertificateSigningRequestRequest, opts?: APIClientRequestOpts): Promise<CertificatesK8sIoV1CertificateSigningRequest> {
    const path = `/apis/certificates.k8s.io/v1/certificatesigningrequests`;
    return await this.post<CertificatesK8sIoV1CertificateSigningRequest>(path, params.query, params.body, opts);
  }
  async deleteCertificatesV1CollectionCertificateSigningRequest(params: DeleteCertificatesV1CollectionCertificateSigningRequestRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/certificates.k8s.io/v1/certificatesigningrequests`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readCertificatesV1CertificateSigningRequest(params: ReadCertificatesV1CertificateSigningRequestRequest, opts?: APIClientRequestOpts): Promise<CertificatesK8sIoV1CertificateSigningRequest> {
    const path = `/apis/certificates.k8s.io/v1/certificatesigningrequests/${params.path.name}`;
    return await this.get<CertificatesK8sIoV1CertificateSigningRequest>(path, null, null, opts);
  }
  async replaceCertificatesV1CertificateSigningRequest(params: ReplaceCertificatesV1CertificateSigningRequestRequest, opts?: APIClientRequestOpts): Promise<CertificatesK8sIoV1CertificateSigningRequest> {
    const path = `/apis/certificates.k8s.io/v1/certificatesigningrequests/${params.path.name}`;
    return await this.put<CertificatesK8sIoV1CertificateSigningRequest>(path, params.query, params.body, opts);
  }
  async deleteCertificatesV1CertificateSigningRequest(params: DeleteCertificatesV1CertificateSigningRequestRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/certificates.k8s.io/v1/certificatesigningrequests/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchCertificatesV1CertificateSigningRequest(params: PatchCertificatesV1CertificateSigningRequestRequest, opts?: APIClientRequestOpts): Promise<CertificatesK8sIoV1CertificateSigningRequest> {
    const path = `/apis/certificates.k8s.io/v1/certificatesigningrequests/${params.path.name}`;
    return await this.patch<CertificatesK8sIoV1CertificateSigningRequest>(path, params.query, null, opts);
  }
  async readCertificatesV1CertificateSigningRequestApproval(params: ReadCertificatesV1CertificateSigningRequestApprovalRequest, opts?: APIClientRequestOpts): Promise<CertificatesK8sIoV1CertificateSigningRequest> {
    const path = `/apis/certificates.k8s.io/v1/certificatesigningrequests/${params.path.name}/approval`;
    return await this.get<CertificatesK8sIoV1CertificateSigningRequest>(path, null, null, opts);
  }
  async replaceCertificatesV1CertificateSigningRequestApproval(params: ReplaceCertificatesV1CertificateSigningRequestApprovalRequest, opts?: APIClientRequestOpts): Promise<CertificatesK8sIoV1CertificateSigningRequest> {
    const path = `/apis/certificates.k8s.io/v1/certificatesigningrequests/${params.path.name}/approval`;
    return await this.put<CertificatesK8sIoV1CertificateSigningRequest>(path, params.query, params.body, opts);
  }
  async patchCertificatesV1CertificateSigningRequestApproval(params: PatchCertificatesV1CertificateSigningRequestApprovalRequest, opts?: APIClientRequestOpts): Promise<CertificatesK8sIoV1CertificateSigningRequest> {
    const path = `/apis/certificates.k8s.io/v1/certificatesigningrequests/${params.path.name}/approval`;
    return await this.patch<CertificatesK8sIoV1CertificateSigningRequest>(path, params.query, null, opts);
  }
  async readCertificatesV1CertificateSigningRequestStatus(params: ReadCertificatesV1CertificateSigningRequestStatusRequest, opts?: APIClientRequestOpts): Promise<CertificatesK8sIoV1CertificateSigningRequest> {
    const path = `/apis/certificates.k8s.io/v1/certificatesigningrequests/${params.path.name}/status`;
    return await this.get<CertificatesK8sIoV1CertificateSigningRequest>(path, null, null, opts);
  }
  async replaceCertificatesV1CertificateSigningRequestStatus(params: ReplaceCertificatesV1CertificateSigningRequestStatusRequest, opts?: APIClientRequestOpts): Promise<CertificatesK8sIoV1CertificateSigningRequest> {
    const path = `/apis/certificates.k8s.io/v1/certificatesigningrequests/${params.path.name}/status`;
    return await this.put<CertificatesK8sIoV1CertificateSigningRequest>(path, params.query, params.body, opts);
  }
  async patchCertificatesV1CertificateSigningRequestStatus(params: PatchCertificatesV1CertificateSigningRequestStatusRequest, opts?: APIClientRequestOpts): Promise<CertificatesK8sIoV1CertificateSigningRequest> {
    const path = `/apis/certificates.k8s.io/v1/certificatesigningrequests/${params.path.name}/status`;
    return await this.patch<CertificatesK8sIoV1CertificateSigningRequest>(path, params.query, null, opts);
  }
  async watchCertificatesV1CertificateSigningRequestList(params: WatchCertificatesV1CertificateSigningRequestListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/certificates.k8s.io/v1/watch/certificatesigningrequests`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCertificatesV1CertificateSigningRequest(params: WatchCertificatesV1CertificateSigningRequestRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/certificates.k8s.io/v1/watch/certificatesigningrequests/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async getCoordinationAPIGroup(params: GetCoordinationAPIGroupRequest, opts?: APIClientRequestOpts): Promise<APIGroup> {
    const path = `/apis/coordination.k8s.io/`;
    return await this.get<APIGroup>(path, null, null, opts);
  }
  async getCoordinationV1APIResources(params: GetCoordinationV1APIResourcesRequest, opts?: APIClientRequestOpts): Promise<APIResourceList> {
    const path = `/apis/coordination.k8s.io/v1/`;
    return await this.get<APIResourceList>(path, null, null, opts);
  }
  async listCoordinationV1LeaseForAllNamespaces(params: ListCoordinationV1LeaseForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<CoordinationK8sIoV1LeaseList> {
    const path = `/apis/coordination.k8s.io/v1/leases`;
    return await this.get<CoordinationK8sIoV1LeaseList>(path, null, null, opts);
  }
  async listCoordinationV1NamespacedLease(params: ListCoordinationV1NamespacedLeaseRequest, opts?: APIClientRequestOpts): Promise<CoordinationK8sIoV1LeaseList> {
    const path = `/apis/coordination.k8s.io/v1/namespaces/${params.path.namespace}/leases`;
    return await this.get<CoordinationK8sIoV1LeaseList>(path, null, null, opts);
  }
  async createCoordinationV1NamespacedLease(params: CreateCoordinationV1NamespacedLeaseRequest, opts?: APIClientRequestOpts): Promise<CoordinationK8sIoV1Lease> {
    const path = `/apis/coordination.k8s.io/v1/namespaces/${params.path.namespace}/leases`;
    return await this.post<CoordinationK8sIoV1Lease>(path, params.query, params.body, opts);
  }
  async deleteCoordinationV1CollectionNamespacedLease(params: DeleteCoordinationV1CollectionNamespacedLeaseRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/coordination.k8s.io/v1/namespaces/${params.path.namespace}/leases`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readCoordinationV1NamespacedLease(params: ReadCoordinationV1NamespacedLeaseRequest, opts?: APIClientRequestOpts): Promise<CoordinationK8sIoV1Lease> {
    const path = `/apis/coordination.k8s.io/v1/namespaces/${params.path.namespace}/leases/${params.path.name}`;
    return await this.get<CoordinationK8sIoV1Lease>(path, null, null, opts);
  }
  async replaceCoordinationV1NamespacedLease(params: ReplaceCoordinationV1NamespacedLeaseRequest, opts?: APIClientRequestOpts): Promise<CoordinationK8sIoV1Lease> {
    const path = `/apis/coordination.k8s.io/v1/namespaces/${params.path.namespace}/leases/${params.path.name}`;
    return await this.put<CoordinationK8sIoV1Lease>(path, params.query, params.body, opts);
  }
  async deleteCoordinationV1NamespacedLease(params: DeleteCoordinationV1NamespacedLeaseRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/coordination.k8s.io/v1/namespaces/${params.path.namespace}/leases/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchCoordinationV1NamespacedLease(params: PatchCoordinationV1NamespacedLeaseRequest, opts?: APIClientRequestOpts): Promise<CoordinationK8sIoV1Lease> {
    const path = `/apis/coordination.k8s.io/v1/namespaces/${params.path.namespace}/leases/${params.path.name}`;
    return await this.patch<CoordinationK8sIoV1Lease>(path, params.query, null, opts);
  }
  async watchCoordinationV1LeaseListForAllNamespaces(params: WatchCoordinationV1LeaseListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/coordination.k8s.io/v1/watch/leases`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoordinationV1NamespacedLeaseList(params: WatchCoordinationV1NamespacedLeaseListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/coordination.k8s.io/v1/watch/namespaces/${params.path.namespace}/leases`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoordinationV1NamespacedLease(params: WatchCoordinationV1NamespacedLeaseRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/coordination.k8s.io/v1/watch/namespaces/${params.path.namespace}/leases/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async getDiscoveryAPIGroup(params: GetDiscoveryAPIGroupRequest, opts?: APIClientRequestOpts): Promise<APIGroup> {
    const path = `/apis/discovery.k8s.io/`;
    return await this.get<APIGroup>(path, null, null, opts);
  }
  async getDiscoveryV1APIResources(params: GetDiscoveryV1APIResourcesRequest, opts?: APIClientRequestOpts): Promise<APIResourceList> {
    const path = `/apis/discovery.k8s.io/v1/`;
    return await this.get<APIResourceList>(path, null, null, opts);
  }
  async listDiscoveryV1EndpointSliceForAllNamespaces(params: ListDiscoveryV1EndpointSliceForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<DiscoveryK8sIoV1EndpointSliceList> {
    const path = `/apis/discovery.k8s.io/v1/endpointslices`;
    return await this.get<DiscoveryK8sIoV1EndpointSliceList>(path, null, null, opts);
  }
  async listDiscoveryV1NamespacedEndpointSlice(params: ListDiscoveryV1NamespacedEndpointSliceRequest, opts?: APIClientRequestOpts): Promise<DiscoveryK8sIoV1EndpointSliceList> {
    const path = `/apis/discovery.k8s.io/v1/namespaces/${params.path.namespace}/endpointslices`;
    return await this.get<DiscoveryK8sIoV1EndpointSliceList>(path, null, null, opts);
  }
  async createDiscoveryV1NamespacedEndpointSlice(params: CreateDiscoveryV1NamespacedEndpointSliceRequest, opts?: APIClientRequestOpts): Promise<DiscoveryK8sIoV1EndpointSlice> {
    const path = `/apis/discovery.k8s.io/v1/namespaces/${params.path.namespace}/endpointslices`;
    return await this.post<DiscoveryK8sIoV1EndpointSlice>(path, params.query, params.body, opts);
  }
  async deleteDiscoveryV1CollectionNamespacedEndpointSlice(params: DeleteDiscoveryV1CollectionNamespacedEndpointSliceRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/discovery.k8s.io/v1/namespaces/${params.path.namespace}/endpointslices`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readDiscoveryV1NamespacedEndpointSlice(params: ReadDiscoveryV1NamespacedEndpointSliceRequest, opts?: APIClientRequestOpts): Promise<DiscoveryK8sIoV1EndpointSlice> {
    const path = `/apis/discovery.k8s.io/v1/namespaces/${params.path.namespace}/endpointslices/${params.path.name}`;
    return await this.get<DiscoveryK8sIoV1EndpointSlice>(path, null, null, opts);
  }
  async replaceDiscoveryV1NamespacedEndpointSlice(params: ReplaceDiscoveryV1NamespacedEndpointSliceRequest, opts?: APIClientRequestOpts): Promise<DiscoveryK8sIoV1EndpointSlice> {
    const path = `/apis/discovery.k8s.io/v1/namespaces/${params.path.namespace}/endpointslices/${params.path.name}`;
    return await this.put<DiscoveryK8sIoV1EndpointSlice>(path, params.query, params.body, opts);
  }
  async deleteDiscoveryV1NamespacedEndpointSlice(params: DeleteDiscoveryV1NamespacedEndpointSliceRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/discovery.k8s.io/v1/namespaces/${params.path.namespace}/endpointslices/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchDiscoveryV1NamespacedEndpointSlice(params: PatchDiscoveryV1NamespacedEndpointSliceRequest, opts?: APIClientRequestOpts): Promise<DiscoveryK8sIoV1EndpointSlice> {
    const path = `/apis/discovery.k8s.io/v1/namespaces/${params.path.namespace}/endpointslices/${params.path.name}`;
    return await this.patch<DiscoveryK8sIoV1EndpointSlice>(path, params.query, null, opts);
  }
  async watchDiscoveryV1EndpointSliceListForAllNamespaces(params: WatchDiscoveryV1EndpointSliceListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/discovery.k8s.io/v1/watch/endpointslices`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchDiscoveryV1NamespacedEndpointSliceList(params: WatchDiscoveryV1NamespacedEndpointSliceListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/discovery.k8s.io/v1/watch/namespaces/${params.path.namespace}/endpointslices`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchDiscoveryV1NamespacedEndpointSlice(params: WatchDiscoveryV1NamespacedEndpointSliceRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/discovery.k8s.io/v1/watch/namespaces/${params.path.namespace}/endpointslices/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async getEventsAPIGroup(params: GetEventsAPIGroupRequest, opts?: APIClientRequestOpts): Promise<APIGroup> {
    const path = `/apis/events.k8s.io/`;
    return await this.get<APIGroup>(path, null, null, opts);
  }
  async getEventsV1APIResources(params: GetEventsV1APIResourcesRequest, opts?: APIClientRequestOpts): Promise<APIResourceList> {
    const path = `/apis/events.k8s.io/v1/`;
    return await this.get<APIResourceList>(path, null, null, opts);
  }
  async listEventsV1EventForAllNamespaces(params: ListEventsV1EventForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<EventsK8sIoV1EventList> {
    const path = `/apis/events.k8s.io/v1/events`;
    return await this.get<EventsK8sIoV1EventList>(path, null, null, opts);
  }
  async listEventsV1NamespacedEvent(params: ListEventsV1NamespacedEventRequest, opts?: APIClientRequestOpts): Promise<EventsK8sIoV1EventList> {
    const path = `/apis/events.k8s.io/v1/namespaces/${params.path.namespace}/events`;
    return await this.get<EventsK8sIoV1EventList>(path, null, null, opts);
  }
  async createEventsV1NamespacedEvent(params: CreateEventsV1NamespacedEventRequest, opts?: APIClientRequestOpts): Promise<EventsK8sIoV1Event> {
    const path = `/apis/events.k8s.io/v1/namespaces/${params.path.namespace}/events`;
    return await this.post<EventsK8sIoV1Event>(path, params.query, params.body, opts);
  }
  async deleteEventsV1CollectionNamespacedEvent(params: DeleteEventsV1CollectionNamespacedEventRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/events.k8s.io/v1/namespaces/${params.path.namespace}/events`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readEventsV1NamespacedEvent(params: ReadEventsV1NamespacedEventRequest, opts?: APIClientRequestOpts): Promise<EventsK8sIoV1Event> {
    const path = `/apis/events.k8s.io/v1/namespaces/${params.path.namespace}/events/${params.path.name}`;
    return await this.get<EventsK8sIoV1Event>(path, null, null, opts);
  }
  async replaceEventsV1NamespacedEvent(params: ReplaceEventsV1NamespacedEventRequest, opts?: APIClientRequestOpts): Promise<EventsK8sIoV1Event> {
    const path = `/apis/events.k8s.io/v1/namespaces/${params.path.namespace}/events/${params.path.name}`;
    return await this.put<EventsK8sIoV1Event>(path, params.query, params.body, opts);
  }
  async deleteEventsV1NamespacedEvent(params: DeleteEventsV1NamespacedEventRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/events.k8s.io/v1/namespaces/${params.path.namespace}/events/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchEventsV1NamespacedEvent(params: PatchEventsV1NamespacedEventRequest, opts?: APIClientRequestOpts): Promise<EventsK8sIoV1Event> {
    const path = `/apis/events.k8s.io/v1/namespaces/${params.path.namespace}/events/${params.path.name}`;
    return await this.patch<EventsK8sIoV1Event>(path, params.query, null, opts);
  }
  async watchEventsV1EventListForAllNamespaces(params: WatchEventsV1EventListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/events.k8s.io/v1/watch/events`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchEventsV1NamespacedEventList(params: WatchEventsV1NamespacedEventListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/events.k8s.io/v1/watch/namespaces/${params.path.namespace}/events`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchEventsV1NamespacedEvent(params: WatchEventsV1NamespacedEventRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/events.k8s.io/v1/watch/namespaces/${params.path.namespace}/events/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async getFlowcontrolApiserverAPIGroup(params: GetFlowcontrolApiserverAPIGroupRequest, opts?: APIClientRequestOpts): Promise<APIGroup> {
    const path = `/apis/flowcontrol.apiserver.k8s.io/`;
    return await this.get<APIGroup>(path, null, null, opts);
  }
  async getFlowcontrolApiserverV1APIResources(params: GetFlowcontrolApiserverV1APIResourcesRequest, opts?: APIClientRequestOpts): Promise<APIResourceList> {
    const path = `/apis/flowcontrol.apiserver.k8s.io/v1/`;
    return await this.get<APIResourceList>(path, null, null, opts);
  }
  async listFlowcontrolApiserverV1FlowSchema(params: ListFlowcontrolApiserverV1FlowSchemaRequest, opts?: APIClientRequestOpts): Promise<FlowcontrolApiserverK8sIoV1FlowSchemaList> {
    const path = `/apis/flowcontrol.apiserver.k8s.io/v1/flowschemas`;
    return await this.get<FlowcontrolApiserverK8sIoV1FlowSchemaList>(path, null, null, opts);
  }
  async createFlowcontrolApiserverV1FlowSchema(params: CreateFlowcontrolApiserverV1FlowSchemaRequest, opts?: APIClientRequestOpts): Promise<FlowcontrolApiserverK8sIoV1FlowSchema> {
    const path = `/apis/flowcontrol.apiserver.k8s.io/v1/flowschemas`;
    return await this.post<FlowcontrolApiserverK8sIoV1FlowSchema>(path, params.query, params.body, opts);
  }
  async deleteFlowcontrolApiserverV1CollectionFlowSchema(params: DeleteFlowcontrolApiserverV1CollectionFlowSchemaRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/flowcontrol.apiserver.k8s.io/v1/flowschemas`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readFlowcontrolApiserverV1FlowSchema(params: ReadFlowcontrolApiserverV1FlowSchemaRequest, opts?: APIClientRequestOpts): Promise<FlowcontrolApiserverK8sIoV1FlowSchema> {
    const path = `/apis/flowcontrol.apiserver.k8s.io/v1/flowschemas/${params.path.name}`;
    return await this.get<FlowcontrolApiserverK8sIoV1FlowSchema>(path, null, null, opts);
  }
  async replaceFlowcontrolApiserverV1FlowSchema(params: ReplaceFlowcontrolApiserverV1FlowSchemaRequest, opts?: APIClientRequestOpts): Promise<FlowcontrolApiserverK8sIoV1FlowSchema> {
    const path = `/apis/flowcontrol.apiserver.k8s.io/v1/flowschemas/${params.path.name}`;
    return await this.put<FlowcontrolApiserverK8sIoV1FlowSchema>(path, params.query, params.body, opts);
  }
  async deleteFlowcontrolApiserverV1FlowSchema(params: DeleteFlowcontrolApiserverV1FlowSchemaRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/flowcontrol.apiserver.k8s.io/v1/flowschemas/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchFlowcontrolApiserverV1FlowSchema(params: PatchFlowcontrolApiserverV1FlowSchemaRequest, opts?: APIClientRequestOpts): Promise<FlowcontrolApiserverK8sIoV1FlowSchema> {
    const path = `/apis/flowcontrol.apiserver.k8s.io/v1/flowschemas/${params.path.name}`;
    return await this.patch<FlowcontrolApiserverK8sIoV1FlowSchema>(path, params.query, null, opts);
  }
  async readFlowcontrolApiserverV1FlowSchemaStatus(params: ReadFlowcontrolApiserverV1FlowSchemaStatusRequest, opts?: APIClientRequestOpts): Promise<FlowcontrolApiserverK8sIoV1FlowSchema> {
    const path = `/apis/flowcontrol.apiserver.k8s.io/v1/flowschemas/${params.path.name}/status`;
    return await this.get<FlowcontrolApiserverK8sIoV1FlowSchema>(path, null, null, opts);
  }
  async replaceFlowcontrolApiserverV1FlowSchemaStatus(params: ReplaceFlowcontrolApiserverV1FlowSchemaStatusRequest, opts?: APIClientRequestOpts): Promise<FlowcontrolApiserverK8sIoV1FlowSchema> {
    const path = `/apis/flowcontrol.apiserver.k8s.io/v1/flowschemas/${params.path.name}/status`;
    return await this.put<FlowcontrolApiserverK8sIoV1FlowSchema>(path, params.query, params.body, opts);
  }
  async patchFlowcontrolApiserverV1FlowSchemaStatus(params: PatchFlowcontrolApiserverV1FlowSchemaStatusRequest, opts?: APIClientRequestOpts): Promise<FlowcontrolApiserverK8sIoV1FlowSchema> {
    const path = `/apis/flowcontrol.apiserver.k8s.io/v1/flowschemas/${params.path.name}/status`;
    return await this.patch<FlowcontrolApiserverK8sIoV1FlowSchema>(path, params.query, null, opts);
  }
  async listFlowcontrolApiserverV1PriorityLevelConfiguration(params: ListFlowcontrolApiserverV1PriorityLevelConfigurationRequest, opts?: APIClientRequestOpts): Promise<FlowcontrolApiserverK8sIoV1PriorityLevelConfigurationList> {
    const path = `/apis/flowcontrol.apiserver.k8s.io/v1/prioritylevelconfigurations`;
    return await this.get<FlowcontrolApiserverK8sIoV1PriorityLevelConfigurationList>(path, null, null, opts);
  }
  async createFlowcontrolApiserverV1PriorityLevelConfiguration(params: CreateFlowcontrolApiserverV1PriorityLevelConfigurationRequest, opts?: APIClientRequestOpts): Promise<FlowcontrolApiserverK8sIoV1PriorityLevelConfiguration> {
    const path = `/apis/flowcontrol.apiserver.k8s.io/v1/prioritylevelconfigurations`;
    return await this.post<FlowcontrolApiserverK8sIoV1PriorityLevelConfiguration>(path, params.query, params.body, opts);
  }
  async deleteFlowcontrolApiserverV1CollectionPriorityLevelConfiguration(params: DeleteFlowcontrolApiserverV1CollectionPriorityLevelConfigurationRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/flowcontrol.apiserver.k8s.io/v1/prioritylevelconfigurations`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readFlowcontrolApiserverV1PriorityLevelConfiguration(params: ReadFlowcontrolApiserverV1PriorityLevelConfigurationRequest, opts?: APIClientRequestOpts): Promise<FlowcontrolApiserverK8sIoV1PriorityLevelConfiguration> {
    const path = `/apis/flowcontrol.apiserver.k8s.io/v1/prioritylevelconfigurations/${params.path.name}`;
    return await this.get<FlowcontrolApiserverK8sIoV1PriorityLevelConfiguration>(path, null, null, opts);
  }
  async replaceFlowcontrolApiserverV1PriorityLevelConfiguration(params: ReplaceFlowcontrolApiserverV1PriorityLevelConfigurationRequest, opts?: APIClientRequestOpts): Promise<FlowcontrolApiserverK8sIoV1PriorityLevelConfiguration> {
    const path = `/apis/flowcontrol.apiserver.k8s.io/v1/prioritylevelconfigurations/${params.path.name}`;
    return await this.put<FlowcontrolApiserverK8sIoV1PriorityLevelConfiguration>(path, params.query, params.body, opts);
  }
  async deleteFlowcontrolApiserverV1PriorityLevelConfiguration(params: DeleteFlowcontrolApiserverV1PriorityLevelConfigurationRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/flowcontrol.apiserver.k8s.io/v1/prioritylevelconfigurations/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchFlowcontrolApiserverV1PriorityLevelConfiguration(params: PatchFlowcontrolApiserverV1PriorityLevelConfigurationRequest, opts?: APIClientRequestOpts): Promise<FlowcontrolApiserverK8sIoV1PriorityLevelConfiguration> {
    const path = `/apis/flowcontrol.apiserver.k8s.io/v1/prioritylevelconfigurations/${params.path.name}`;
    return await this.patch<FlowcontrolApiserverK8sIoV1PriorityLevelConfiguration>(path, params.query, null, opts);
  }
  async readFlowcontrolApiserverV1PriorityLevelConfigurationStatus(params: ReadFlowcontrolApiserverV1PriorityLevelConfigurationStatusRequest, opts?: APIClientRequestOpts): Promise<FlowcontrolApiserverK8sIoV1PriorityLevelConfiguration> {
    const path = `/apis/flowcontrol.apiserver.k8s.io/v1/prioritylevelconfigurations/${params.path.name}/status`;
    return await this.get<FlowcontrolApiserverK8sIoV1PriorityLevelConfiguration>(path, null, null, opts);
  }
  async replaceFlowcontrolApiserverV1PriorityLevelConfigurationStatus(params: ReplaceFlowcontrolApiserverV1PriorityLevelConfigurationStatusRequest, opts?: APIClientRequestOpts): Promise<FlowcontrolApiserverK8sIoV1PriorityLevelConfiguration> {
    const path = `/apis/flowcontrol.apiserver.k8s.io/v1/prioritylevelconfigurations/${params.path.name}/status`;
    return await this.put<FlowcontrolApiserverK8sIoV1PriorityLevelConfiguration>(path, params.query, params.body, opts);
  }
  async patchFlowcontrolApiserverV1PriorityLevelConfigurationStatus(params: PatchFlowcontrolApiserverV1PriorityLevelConfigurationStatusRequest, opts?: APIClientRequestOpts): Promise<FlowcontrolApiserverK8sIoV1PriorityLevelConfiguration> {
    const path = `/apis/flowcontrol.apiserver.k8s.io/v1/prioritylevelconfigurations/${params.path.name}/status`;
    return await this.patch<FlowcontrolApiserverK8sIoV1PriorityLevelConfiguration>(path, params.query, null, opts);
  }
  async watchFlowcontrolApiserverV1FlowSchemaList(params: WatchFlowcontrolApiserverV1FlowSchemaListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/flowcontrol.apiserver.k8s.io/v1/watch/flowschemas`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchFlowcontrolApiserverV1FlowSchema(params: WatchFlowcontrolApiserverV1FlowSchemaRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/flowcontrol.apiserver.k8s.io/v1/watch/flowschemas/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchFlowcontrolApiserverV1PriorityLevelConfigurationList(params: WatchFlowcontrolApiserverV1PriorityLevelConfigurationListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/flowcontrol.apiserver.k8s.io/v1/watch/prioritylevelconfigurations`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchFlowcontrolApiserverV1PriorityLevelConfiguration(params: WatchFlowcontrolApiserverV1PriorityLevelConfigurationRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/flowcontrol.apiserver.k8s.io/v1/watch/prioritylevelconfigurations/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async listMonitoringCoreosComV1AlertmanagerForAllNamespaces(params: ListMonitoringCoreosComV1AlertmanagerForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1AlertmanagerList> {
    const path = `/apis/monitoring.coreos.com/v1/alertmanagers`;
    return await this.get<MonitoringCoreosComV1AlertmanagerList>(path, null, null, opts);
  }
  async listMonitoringCoreosComV1NamespacedAlertmanager(params: ListMonitoringCoreosComV1NamespacedAlertmanagerRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1AlertmanagerList> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/alertmanagers`;
    return await this.get<MonitoringCoreosComV1AlertmanagerList>(path, null, null, opts);
  }
  async createMonitoringCoreosComV1NamespacedAlertmanager(params: CreateMonitoringCoreosComV1NamespacedAlertmanagerRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1Alertmanager> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/alertmanagers`;
    return await this.post<MonitoringCoreosComV1Alertmanager>(path, params.query, params.body, opts);
  }
  async deleteMonitoringCoreosComV1CollectionNamespacedAlertmanager(params: DeleteMonitoringCoreosComV1CollectionNamespacedAlertmanagerRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/alertmanagers`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readMonitoringCoreosComV1NamespacedAlertmanager(params: ReadMonitoringCoreosComV1NamespacedAlertmanagerRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1Alertmanager> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/alertmanagers/${params.path.name}`;
    return await this.get<MonitoringCoreosComV1Alertmanager>(path, null, null, opts);
  }
  async replaceMonitoringCoreosComV1NamespacedAlertmanager(params: ReplaceMonitoringCoreosComV1NamespacedAlertmanagerRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1Alertmanager> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/alertmanagers/${params.path.name}`;
    return await this.put<MonitoringCoreosComV1Alertmanager>(path, params.query, params.body, opts);
  }
  async deleteMonitoringCoreosComV1NamespacedAlertmanager(params: DeleteMonitoringCoreosComV1NamespacedAlertmanagerRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/alertmanagers/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchMonitoringCoreosComV1NamespacedAlertmanager(params: PatchMonitoringCoreosComV1NamespacedAlertmanagerRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1Alertmanager> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/alertmanagers/${params.path.name}`;
    return await this.patch<MonitoringCoreosComV1Alertmanager>(path, params.query, null, opts);
  }
  async readMonitoringCoreosComV1NamespacedAlertmanagerScale(params: ReadMonitoringCoreosComV1NamespacedAlertmanagerScaleRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1Scale> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/alertmanagers/${params.path.name}/scale`;
    return await this.get<AutoscalingV1Scale>(path, null, null, opts);
  }
  async replaceMonitoringCoreosComV1NamespacedAlertmanagerScale(params: ReplaceMonitoringCoreosComV1NamespacedAlertmanagerScaleRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1Scale> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/alertmanagers/${params.path.name}/scale`;
    return await this.put<AutoscalingV1Scale>(path, params.query, params.body, opts);
  }
  async patchMonitoringCoreosComV1NamespacedAlertmanagerScale(params: PatchMonitoringCoreosComV1NamespacedAlertmanagerScaleRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1Scale> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/alertmanagers/${params.path.name}/scale`;
    return await this.patch<AutoscalingV1Scale>(path, params.query, null, opts);
  }
  async readMonitoringCoreosComV1NamespacedAlertmanagerStatus(params: ReadMonitoringCoreosComV1NamespacedAlertmanagerStatusRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1Alertmanager> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/alertmanagers/${params.path.name}/status`;
    return await this.get<MonitoringCoreosComV1Alertmanager>(path, null, null, opts);
  }
  async replaceMonitoringCoreosComV1NamespacedAlertmanagerStatus(params: ReplaceMonitoringCoreosComV1NamespacedAlertmanagerStatusRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1Alertmanager> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/alertmanagers/${params.path.name}/status`;
    return await this.put<MonitoringCoreosComV1Alertmanager>(path, params.query, params.body, opts);
  }
  async patchMonitoringCoreosComV1NamespacedAlertmanagerStatus(params: PatchMonitoringCoreosComV1NamespacedAlertmanagerStatusRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1Alertmanager> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/alertmanagers/${params.path.name}/status`;
    return await this.patch<MonitoringCoreosComV1Alertmanager>(path, params.query, null, opts);
  }
  async listMonitoringCoreosComV1NamespacedPodMonitor(params: ListMonitoringCoreosComV1NamespacedPodMonitorRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1PodMonitorList> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/podmonitors`;
    return await this.get<MonitoringCoreosComV1PodMonitorList>(path, null, null, opts);
  }
  async createMonitoringCoreosComV1NamespacedPodMonitor(params: CreateMonitoringCoreosComV1NamespacedPodMonitorRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1PodMonitor> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/podmonitors`;
    return await this.post<MonitoringCoreosComV1PodMonitor>(path, params.query, params.body, opts);
  }
  async deleteMonitoringCoreosComV1CollectionNamespacedPodMonitor(params: DeleteMonitoringCoreosComV1CollectionNamespacedPodMonitorRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/podmonitors`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readMonitoringCoreosComV1NamespacedPodMonitor(params: ReadMonitoringCoreosComV1NamespacedPodMonitorRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1PodMonitor> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/podmonitors/${params.path.name}`;
    return await this.get<MonitoringCoreosComV1PodMonitor>(path, null, null, opts);
  }
  async replaceMonitoringCoreosComV1NamespacedPodMonitor(params: ReplaceMonitoringCoreosComV1NamespacedPodMonitorRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1PodMonitor> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/podmonitors/${params.path.name}`;
    return await this.put<MonitoringCoreosComV1PodMonitor>(path, params.query, params.body, opts);
  }
  async deleteMonitoringCoreosComV1NamespacedPodMonitor(params: DeleteMonitoringCoreosComV1NamespacedPodMonitorRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/podmonitors/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchMonitoringCoreosComV1NamespacedPodMonitor(params: PatchMonitoringCoreosComV1NamespacedPodMonitorRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1PodMonitor> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/podmonitors/${params.path.name}`;
    return await this.patch<MonitoringCoreosComV1PodMonitor>(path, params.query, null, opts);
  }
  async listMonitoringCoreosComV1NamespacedProbe(params: ListMonitoringCoreosComV1NamespacedProbeRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1ProbeList> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/probes`;
    return await this.get<MonitoringCoreosComV1ProbeList>(path, null, null, opts);
  }
  async createMonitoringCoreosComV1NamespacedProbe(params: CreateMonitoringCoreosComV1NamespacedProbeRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1Probe> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/probes`;
    return await this.post<MonitoringCoreosComV1Probe>(path, params.query, params.body, opts);
  }
  async deleteMonitoringCoreosComV1CollectionNamespacedProbe(params: DeleteMonitoringCoreosComV1CollectionNamespacedProbeRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/probes`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readMonitoringCoreosComV1NamespacedProbe(params: ReadMonitoringCoreosComV1NamespacedProbeRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1Probe> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/probes/${params.path.name}`;
    return await this.get<MonitoringCoreosComV1Probe>(path, null, null, opts);
  }
  async replaceMonitoringCoreosComV1NamespacedProbe(params: ReplaceMonitoringCoreosComV1NamespacedProbeRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1Probe> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/probes/${params.path.name}`;
    return await this.put<MonitoringCoreosComV1Probe>(path, params.query, params.body, opts);
  }
  async deleteMonitoringCoreosComV1NamespacedProbe(params: DeleteMonitoringCoreosComV1NamespacedProbeRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/probes/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchMonitoringCoreosComV1NamespacedProbe(params: PatchMonitoringCoreosComV1NamespacedProbeRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1Probe> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/probes/${params.path.name}`;
    return await this.patch<MonitoringCoreosComV1Probe>(path, params.query, null, opts);
  }
  async listMonitoringCoreosComV1NamespacedPrometheus(params: ListMonitoringCoreosComV1NamespacedPrometheusRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1PrometheusList> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/prometheuses`;
    return await this.get<MonitoringCoreosComV1PrometheusList>(path, null, null, opts);
  }
  async createMonitoringCoreosComV1NamespacedPrometheus(params: CreateMonitoringCoreosComV1NamespacedPrometheusRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1Prometheus> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/prometheuses`;
    return await this.post<MonitoringCoreosComV1Prometheus>(path, params.query, params.body, opts);
  }
  async deleteMonitoringCoreosComV1CollectionNamespacedPrometheus(params: DeleteMonitoringCoreosComV1CollectionNamespacedPrometheusRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/prometheuses`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readMonitoringCoreosComV1NamespacedPrometheus(params: ReadMonitoringCoreosComV1NamespacedPrometheusRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1Prometheus> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/prometheuses/${params.path.name}`;
    return await this.get<MonitoringCoreosComV1Prometheus>(path, null, null, opts);
  }
  async replaceMonitoringCoreosComV1NamespacedPrometheus(params: ReplaceMonitoringCoreosComV1NamespacedPrometheusRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1Prometheus> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/prometheuses/${params.path.name}`;
    return await this.put<MonitoringCoreosComV1Prometheus>(path, params.query, params.body, opts);
  }
  async deleteMonitoringCoreosComV1NamespacedPrometheus(params: DeleteMonitoringCoreosComV1NamespacedPrometheusRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/prometheuses/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchMonitoringCoreosComV1NamespacedPrometheus(params: PatchMonitoringCoreosComV1NamespacedPrometheusRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1Prometheus> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/prometheuses/${params.path.name}`;
    return await this.patch<MonitoringCoreosComV1Prometheus>(path, params.query, null, opts);
  }
  async readMonitoringCoreosComV1NamespacedPrometheusScale(params: ReadMonitoringCoreosComV1NamespacedPrometheusScaleRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1Scale> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/prometheuses/${params.path.name}/scale`;
    return await this.get<AutoscalingV1Scale>(path, null, null, opts);
  }
  async replaceMonitoringCoreosComV1NamespacedPrometheusScale(params: ReplaceMonitoringCoreosComV1NamespacedPrometheusScaleRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1Scale> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/prometheuses/${params.path.name}/scale`;
    return await this.put<AutoscalingV1Scale>(path, params.query, params.body, opts);
  }
  async patchMonitoringCoreosComV1NamespacedPrometheusScale(params: PatchMonitoringCoreosComV1NamespacedPrometheusScaleRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1Scale> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/prometheuses/${params.path.name}/scale`;
    return await this.patch<AutoscalingV1Scale>(path, params.query, null, opts);
  }
  async readMonitoringCoreosComV1NamespacedPrometheusStatus(params: ReadMonitoringCoreosComV1NamespacedPrometheusStatusRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1Prometheus> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/prometheuses/${params.path.name}/status`;
    return await this.get<MonitoringCoreosComV1Prometheus>(path, null, null, opts);
  }
  async replaceMonitoringCoreosComV1NamespacedPrometheusStatus(params: ReplaceMonitoringCoreosComV1NamespacedPrometheusStatusRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1Prometheus> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/prometheuses/${params.path.name}/status`;
    return await this.put<MonitoringCoreosComV1Prometheus>(path, params.query, params.body, opts);
  }
  async patchMonitoringCoreosComV1NamespacedPrometheusStatus(params: PatchMonitoringCoreosComV1NamespacedPrometheusStatusRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1Prometheus> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/prometheuses/${params.path.name}/status`;
    return await this.patch<MonitoringCoreosComV1Prometheus>(path, params.query, null, opts);
  }
  async listMonitoringCoreosComV1NamespacedPrometheusRule(params: ListMonitoringCoreosComV1NamespacedPrometheusRuleRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1PrometheusRuleList> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/prometheusrules`;
    return await this.get<MonitoringCoreosComV1PrometheusRuleList>(path, null, null, opts);
  }
  async createMonitoringCoreosComV1NamespacedPrometheusRule(params: CreateMonitoringCoreosComV1NamespacedPrometheusRuleRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1PrometheusRule> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/prometheusrules`;
    return await this.post<MonitoringCoreosComV1PrometheusRule>(path, params.query, params.body, opts);
  }
  async deleteMonitoringCoreosComV1CollectionNamespacedPrometheusRule(params: DeleteMonitoringCoreosComV1CollectionNamespacedPrometheusRuleRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/prometheusrules`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readMonitoringCoreosComV1NamespacedPrometheusRule(params: ReadMonitoringCoreosComV1NamespacedPrometheusRuleRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1PrometheusRule> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/prometheusrules/${params.path.name}`;
    return await this.get<MonitoringCoreosComV1PrometheusRule>(path, null, null, opts);
  }
  async replaceMonitoringCoreosComV1NamespacedPrometheusRule(params: ReplaceMonitoringCoreosComV1NamespacedPrometheusRuleRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1PrometheusRule> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/prometheusrules/${params.path.name}`;
    return await this.put<MonitoringCoreosComV1PrometheusRule>(path, params.query, params.body, opts);
  }
  async deleteMonitoringCoreosComV1NamespacedPrometheusRule(params: DeleteMonitoringCoreosComV1NamespacedPrometheusRuleRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/prometheusrules/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchMonitoringCoreosComV1NamespacedPrometheusRule(params: PatchMonitoringCoreosComV1NamespacedPrometheusRuleRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1PrometheusRule> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/prometheusrules/${params.path.name}`;
    return await this.patch<MonitoringCoreosComV1PrometheusRule>(path, params.query, null, opts);
  }
  async listMonitoringCoreosComV1NamespacedServiceMonitor(params: ListMonitoringCoreosComV1NamespacedServiceMonitorRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1ServiceMonitorList> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/servicemonitors`;
    return await this.get<MonitoringCoreosComV1ServiceMonitorList>(path, null, null, opts);
  }
  async createMonitoringCoreosComV1NamespacedServiceMonitor(params: CreateMonitoringCoreosComV1NamespacedServiceMonitorRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1ServiceMonitor> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/servicemonitors`;
    return await this.post<MonitoringCoreosComV1ServiceMonitor>(path, params.query, params.body, opts);
  }
  async deleteMonitoringCoreosComV1CollectionNamespacedServiceMonitor(params: DeleteMonitoringCoreosComV1CollectionNamespacedServiceMonitorRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/servicemonitors`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readMonitoringCoreosComV1NamespacedServiceMonitor(params: ReadMonitoringCoreosComV1NamespacedServiceMonitorRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1ServiceMonitor> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/servicemonitors/${params.path.name}`;
    return await this.get<MonitoringCoreosComV1ServiceMonitor>(path, null, null, opts);
  }
  async replaceMonitoringCoreosComV1NamespacedServiceMonitor(params: ReplaceMonitoringCoreosComV1NamespacedServiceMonitorRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1ServiceMonitor> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/servicemonitors/${params.path.name}`;
    return await this.put<MonitoringCoreosComV1ServiceMonitor>(path, params.query, params.body, opts);
  }
  async deleteMonitoringCoreosComV1NamespacedServiceMonitor(params: DeleteMonitoringCoreosComV1NamespacedServiceMonitorRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/servicemonitors/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchMonitoringCoreosComV1NamespacedServiceMonitor(params: PatchMonitoringCoreosComV1NamespacedServiceMonitorRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1ServiceMonitor> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/servicemonitors/${params.path.name}`;
    return await this.patch<MonitoringCoreosComV1ServiceMonitor>(path, params.query, null, opts);
  }
  async readMonitoringCoreosComV1NamespacedServiceMonitorStatus(params: ReadMonitoringCoreosComV1NamespacedServiceMonitorStatusRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1ServiceMonitor> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/servicemonitors/${params.path.name}/status`;
    return await this.get<MonitoringCoreosComV1ServiceMonitor>(path, null, null, opts);
  }
  async replaceMonitoringCoreosComV1NamespacedServiceMonitorStatus(params: ReplaceMonitoringCoreosComV1NamespacedServiceMonitorStatusRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1ServiceMonitor> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/servicemonitors/${params.path.name}/status`;
    return await this.put<MonitoringCoreosComV1ServiceMonitor>(path, params.query, params.body, opts);
  }
  async patchMonitoringCoreosComV1NamespacedServiceMonitorStatus(params: PatchMonitoringCoreosComV1NamespacedServiceMonitorStatusRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1ServiceMonitor> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/servicemonitors/${params.path.name}/status`;
    return await this.patch<MonitoringCoreosComV1ServiceMonitor>(path, params.query, null, opts);
  }
  async listMonitoringCoreosComV1NamespacedThanosRuler(params: ListMonitoringCoreosComV1NamespacedThanosRulerRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1ThanosRulerList> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/thanosrulers`;
    return await this.get<MonitoringCoreosComV1ThanosRulerList>(path, null, null, opts);
  }
  async createMonitoringCoreosComV1NamespacedThanosRuler(params: CreateMonitoringCoreosComV1NamespacedThanosRulerRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1ThanosRuler> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/thanosrulers`;
    return await this.post<MonitoringCoreosComV1ThanosRuler>(path, params.query, params.body, opts);
  }
  async deleteMonitoringCoreosComV1CollectionNamespacedThanosRuler(params: DeleteMonitoringCoreosComV1CollectionNamespacedThanosRulerRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/thanosrulers`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readMonitoringCoreosComV1NamespacedThanosRuler(params: ReadMonitoringCoreosComV1NamespacedThanosRulerRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1ThanosRuler> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/thanosrulers/${params.path.name}`;
    return await this.get<MonitoringCoreosComV1ThanosRuler>(path, null, null, opts);
  }
  async replaceMonitoringCoreosComV1NamespacedThanosRuler(params: ReplaceMonitoringCoreosComV1NamespacedThanosRulerRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1ThanosRuler> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/thanosrulers/${params.path.name}`;
    return await this.put<MonitoringCoreosComV1ThanosRuler>(path, params.query, params.body, opts);
  }
  async deleteMonitoringCoreosComV1NamespacedThanosRuler(params: DeleteMonitoringCoreosComV1NamespacedThanosRulerRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/thanosrulers/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchMonitoringCoreosComV1NamespacedThanosRuler(params: PatchMonitoringCoreosComV1NamespacedThanosRulerRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1ThanosRuler> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/thanosrulers/${params.path.name}`;
    return await this.patch<MonitoringCoreosComV1ThanosRuler>(path, params.query, null, opts);
  }
  async readMonitoringCoreosComV1NamespacedThanosRulerStatus(params: ReadMonitoringCoreosComV1NamespacedThanosRulerStatusRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1ThanosRuler> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/thanosrulers/${params.path.name}/status`;
    return await this.get<MonitoringCoreosComV1ThanosRuler>(path, null, null, opts);
  }
  async replaceMonitoringCoreosComV1NamespacedThanosRulerStatus(params: ReplaceMonitoringCoreosComV1NamespacedThanosRulerStatusRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1ThanosRuler> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/thanosrulers/${params.path.name}/status`;
    return await this.put<MonitoringCoreosComV1ThanosRuler>(path, params.query, params.body, opts);
  }
  async patchMonitoringCoreosComV1NamespacedThanosRulerStatus(params: PatchMonitoringCoreosComV1NamespacedThanosRulerStatusRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1ThanosRuler> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/thanosrulers/${params.path.name}/status`;
    return await this.patch<MonitoringCoreosComV1ThanosRuler>(path, params.query, null, opts);
  }
  async listMonitoringCoreosComV1PodMonitorForAllNamespaces(params: ListMonitoringCoreosComV1PodMonitorForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1PodMonitorList> {
    const path = `/apis/monitoring.coreos.com/v1/podmonitors`;
    return await this.get<MonitoringCoreosComV1PodMonitorList>(path, null, null, opts);
  }
  async listMonitoringCoreosComV1ProbeForAllNamespaces(params: ListMonitoringCoreosComV1ProbeForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1ProbeList> {
    const path = `/apis/monitoring.coreos.com/v1/probes`;
    return await this.get<MonitoringCoreosComV1ProbeList>(path, null, null, opts);
  }
  async listMonitoringCoreosComV1PrometheusForAllNamespaces(params: ListMonitoringCoreosComV1PrometheusForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1PrometheusList> {
    const path = `/apis/monitoring.coreos.com/v1/prometheuses`;
    return await this.get<MonitoringCoreosComV1PrometheusList>(path, null, null, opts);
  }
  async listMonitoringCoreosComV1PrometheusRuleForAllNamespaces(params: ListMonitoringCoreosComV1PrometheusRuleForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1PrometheusRuleList> {
    const path = `/apis/monitoring.coreos.com/v1/prometheusrules`;
    return await this.get<MonitoringCoreosComV1PrometheusRuleList>(path, null, null, opts);
  }
  async listMonitoringCoreosComV1ServiceMonitorForAllNamespaces(params: ListMonitoringCoreosComV1ServiceMonitorForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1ServiceMonitorList> {
    const path = `/apis/monitoring.coreos.com/v1/servicemonitors`;
    return await this.get<MonitoringCoreosComV1ServiceMonitorList>(path, null, null, opts);
  }
  async listMonitoringCoreosComV1ThanosRulerForAllNamespaces(params: ListMonitoringCoreosComV1ThanosRulerForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1ThanosRulerList> {
    const path = `/apis/monitoring.coreos.com/v1/thanosrulers`;
    return await this.get<MonitoringCoreosComV1ThanosRulerList>(path, null, null, opts);
  }
  async listMonitoringCoreosComV1alpha1AlertmanagerConfigForAllNamespaces(params: ListMonitoringCoreosComV1alpha1AlertmanagerConfigForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1alpha1AlertmanagerConfigList> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/alertmanagerconfigs`;
    return await this.get<MonitoringCoreosComV1alpha1AlertmanagerConfigList>(path, null, null, opts);
  }
  async listMonitoringCoreosComV1alpha1NamespacedAlertmanagerConfig(params: ListMonitoringCoreosComV1alpha1NamespacedAlertmanagerConfigRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1alpha1AlertmanagerConfigList> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/namespaces/${params.path.namespace}/alertmanagerconfigs`;
    return await this.get<MonitoringCoreosComV1alpha1AlertmanagerConfigList>(path, null, null, opts);
  }
  async createMonitoringCoreosComV1alpha1NamespacedAlertmanagerConfig(params: CreateMonitoringCoreosComV1alpha1NamespacedAlertmanagerConfigRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1alpha1AlertmanagerConfig> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/namespaces/${params.path.namespace}/alertmanagerconfigs`;
    return await this.post<MonitoringCoreosComV1alpha1AlertmanagerConfig>(path, params.query, params.body, opts);
  }
  async deleteMonitoringCoreosComV1alpha1CollectionNamespacedAlertmanagerConfig(params: DeleteMonitoringCoreosComV1alpha1CollectionNamespacedAlertmanagerConfigRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/namespaces/${params.path.namespace}/alertmanagerconfigs`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readMonitoringCoreosComV1alpha1NamespacedAlertmanagerConfig(params: ReadMonitoringCoreosComV1alpha1NamespacedAlertmanagerConfigRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1alpha1AlertmanagerConfig> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/namespaces/${params.path.namespace}/alertmanagerconfigs/${params.path.name}`;
    return await this.get<MonitoringCoreosComV1alpha1AlertmanagerConfig>(path, null, null, opts);
  }
  async replaceMonitoringCoreosComV1alpha1NamespacedAlertmanagerConfig(params: ReplaceMonitoringCoreosComV1alpha1NamespacedAlertmanagerConfigRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1alpha1AlertmanagerConfig> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/namespaces/${params.path.namespace}/alertmanagerconfigs/${params.path.name}`;
    return await this.put<MonitoringCoreosComV1alpha1AlertmanagerConfig>(path, params.query, params.body, opts);
  }
  async deleteMonitoringCoreosComV1alpha1NamespacedAlertmanagerConfig(params: DeleteMonitoringCoreosComV1alpha1NamespacedAlertmanagerConfigRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/namespaces/${params.path.namespace}/alertmanagerconfigs/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchMonitoringCoreosComV1alpha1NamespacedAlertmanagerConfig(params: PatchMonitoringCoreosComV1alpha1NamespacedAlertmanagerConfigRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1alpha1AlertmanagerConfig> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/namespaces/${params.path.namespace}/alertmanagerconfigs/${params.path.name}`;
    return await this.patch<MonitoringCoreosComV1alpha1AlertmanagerConfig>(path, params.query, null, opts);
  }
  async listMonitoringCoreosComV1alpha1NamespacedPrometheusAgent(params: ListMonitoringCoreosComV1alpha1NamespacedPrometheusAgentRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1alpha1PrometheusAgentList> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/namespaces/${params.path.namespace}/prometheusagents`;
    return await this.get<MonitoringCoreosComV1alpha1PrometheusAgentList>(path, null, null, opts);
  }
  async createMonitoringCoreosComV1alpha1NamespacedPrometheusAgent(params: CreateMonitoringCoreosComV1alpha1NamespacedPrometheusAgentRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1alpha1PrometheusAgent> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/namespaces/${params.path.namespace}/prometheusagents`;
    return await this.post<MonitoringCoreosComV1alpha1PrometheusAgent>(path, params.query, params.body, opts);
  }
  async deleteMonitoringCoreosComV1alpha1CollectionNamespacedPrometheusAgent(params: DeleteMonitoringCoreosComV1alpha1CollectionNamespacedPrometheusAgentRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/namespaces/${params.path.namespace}/prometheusagents`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readMonitoringCoreosComV1alpha1NamespacedPrometheusAgent(params: ReadMonitoringCoreosComV1alpha1NamespacedPrometheusAgentRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1alpha1PrometheusAgent> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/namespaces/${params.path.namespace}/prometheusagents/${params.path.name}`;
    return await this.get<MonitoringCoreosComV1alpha1PrometheusAgent>(path, null, null, opts);
  }
  async replaceMonitoringCoreosComV1alpha1NamespacedPrometheusAgent(params: ReplaceMonitoringCoreosComV1alpha1NamespacedPrometheusAgentRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1alpha1PrometheusAgent> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/namespaces/${params.path.namespace}/prometheusagents/${params.path.name}`;
    return await this.put<MonitoringCoreosComV1alpha1PrometheusAgent>(path, params.query, params.body, opts);
  }
  async deleteMonitoringCoreosComV1alpha1NamespacedPrometheusAgent(params: DeleteMonitoringCoreosComV1alpha1NamespacedPrometheusAgentRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/namespaces/${params.path.namespace}/prometheusagents/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchMonitoringCoreosComV1alpha1NamespacedPrometheusAgent(params: PatchMonitoringCoreosComV1alpha1NamespacedPrometheusAgentRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1alpha1PrometheusAgent> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/namespaces/${params.path.namespace}/prometheusagents/${params.path.name}`;
    return await this.patch<MonitoringCoreosComV1alpha1PrometheusAgent>(path, params.query, null, opts);
  }
  async readMonitoringCoreosComV1alpha1NamespacedPrometheusAgentScale(params: ReadMonitoringCoreosComV1alpha1NamespacedPrometheusAgentScaleRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1Scale> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/namespaces/${params.path.namespace}/prometheusagents/${params.path.name}/scale`;
    return await this.get<AutoscalingV1Scale>(path, null, null, opts);
  }
  async replaceMonitoringCoreosComV1alpha1NamespacedPrometheusAgentScale(params: ReplaceMonitoringCoreosComV1alpha1NamespacedPrometheusAgentScaleRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1Scale> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/namespaces/${params.path.namespace}/prometheusagents/${params.path.name}/scale`;
    return await this.put<AutoscalingV1Scale>(path, params.query, params.body, opts);
  }
  async patchMonitoringCoreosComV1alpha1NamespacedPrometheusAgentScale(params: PatchMonitoringCoreosComV1alpha1NamespacedPrometheusAgentScaleRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1Scale> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/namespaces/${params.path.namespace}/prometheusagents/${params.path.name}/scale`;
    return await this.patch<AutoscalingV1Scale>(path, params.query, null, opts);
  }
  async readMonitoringCoreosComV1alpha1NamespacedPrometheusAgentStatus(params: ReadMonitoringCoreosComV1alpha1NamespacedPrometheusAgentStatusRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1alpha1PrometheusAgent> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/namespaces/${params.path.namespace}/prometheusagents/${params.path.name}/status`;
    return await this.get<MonitoringCoreosComV1alpha1PrometheusAgent>(path, null, null, opts);
  }
  async replaceMonitoringCoreosComV1alpha1NamespacedPrometheusAgentStatus(params: ReplaceMonitoringCoreosComV1alpha1NamespacedPrometheusAgentStatusRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1alpha1PrometheusAgent> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/namespaces/${params.path.namespace}/prometheusagents/${params.path.name}/status`;
    return await this.put<MonitoringCoreosComV1alpha1PrometheusAgent>(path, params.query, params.body, opts);
  }
  async patchMonitoringCoreosComV1alpha1NamespacedPrometheusAgentStatus(params: PatchMonitoringCoreosComV1alpha1NamespacedPrometheusAgentStatusRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1alpha1PrometheusAgent> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/namespaces/${params.path.namespace}/prometheusagents/${params.path.name}/status`;
    return await this.patch<MonitoringCoreosComV1alpha1PrometheusAgent>(path, params.query, null, opts);
  }
  async listMonitoringCoreosComV1alpha1NamespacedScrapeConfig(params: ListMonitoringCoreosComV1alpha1NamespacedScrapeConfigRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1alpha1ScrapeConfigList> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/namespaces/${params.path.namespace}/scrapeconfigs`;
    return await this.get<MonitoringCoreosComV1alpha1ScrapeConfigList>(path, null, null, opts);
  }
  async createMonitoringCoreosComV1alpha1NamespacedScrapeConfig(params: CreateMonitoringCoreosComV1alpha1NamespacedScrapeConfigRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1alpha1ScrapeConfig> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/namespaces/${params.path.namespace}/scrapeconfigs`;
    return await this.post<MonitoringCoreosComV1alpha1ScrapeConfig>(path, params.query, params.body, opts);
  }
  async deleteMonitoringCoreosComV1alpha1CollectionNamespacedScrapeConfig(params: DeleteMonitoringCoreosComV1alpha1CollectionNamespacedScrapeConfigRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/namespaces/${params.path.namespace}/scrapeconfigs`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readMonitoringCoreosComV1alpha1NamespacedScrapeConfig(params: ReadMonitoringCoreosComV1alpha1NamespacedScrapeConfigRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1alpha1ScrapeConfig> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/namespaces/${params.path.namespace}/scrapeconfigs/${params.path.name}`;
    return await this.get<MonitoringCoreosComV1alpha1ScrapeConfig>(path, null, null, opts);
  }
  async replaceMonitoringCoreosComV1alpha1NamespacedScrapeConfig(params: ReplaceMonitoringCoreosComV1alpha1NamespacedScrapeConfigRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1alpha1ScrapeConfig> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/namespaces/${params.path.namespace}/scrapeconfigs/${params.path.name}`;
    return await this.put<MonitoringCoreosComV1alpha1ScrapeConfig>(path, params.query, params.body, opts);
  }
  async deleteMonitoringCoreosComV1alpha1NamespacedScrapeConfig(params: DeleteMonitoringCoreosComV1alpha1NamespacedScrapeConfigRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/namespaces/${params.path.namespace}/scrapeconfigs/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchMonitoringCoreosComV1alpha1NamespacedScrapeConfig(params: PatchMonitoringCoreosComV1alpha1NamespacedScrapeConfigRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1alpha1ScrapeConfig> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/namespaces/${params.path.namespace}/scrapeconfigs/${params.path.name}`;
    return await this.patch<MonitoringCoreosComV1alpha1ScrapeConfig>(path, params.query, null, opts);
  }
  async listMonitoringCoreosComV1alpha1PrometheusAgentForAllNamespaces(params: ListMonitoringCoreosComV1alpha1PrometheusAgentForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1alpha1PrometheusAgentList> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/prometheusagents`;
    return await this.get<MonitoringCoreosComV1alpha1PrometheusAgentList>(path, null, null, opts);
  }
  async listMonitoringCoreosComV1alpha1ScrapeConfigForAllNamespaces(params: ListMonitoringCoreosComV1alpha1ScrapeConfigForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1alpha1ScrapeConfigList> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/scrapeconfigs`;
    return await this.get<MonitoringCoreosComV1alpha1ScrapeConfigList>(path, null, null, opts);
  }
  async listNetworkingInternalKnativeDevV1alpha1CertificateForAllNamespaces(params: ListNetworkingInternalKnativeDevV1alpha1CertificateForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1CertificateList> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/certificates`;
    return await this.get<NetworkingInternalKnativeDevV1alpha1CertificateList>(path, null, null, opts);
  }
  async listNetworkingInternalKnativeDevV1alpha1ClusterDomainClaim(params: ListNetworkingInternalKnativeDevV1alpha1ClusterDomainClaimRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1ClusterDomainClaimList> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/clusterdomainclaims`;
    return await this.get<NetworkingInternalKnativeDevV1alpha1ClusterDomainClaimList>(path, null, null, opts);
  }
  async createNetworkingInternalKnativeDevV1alpha1ClusterDomainClaim(params: CreateNetworkingInternalKnativeDevV1alpha1ClusterDomainClaimRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1ClusterDomainClaim> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/clusterdomainclaims`;
    return await this.post<NetworkingInternalKnativeDevV1alpha1ClusterDomainClaim>(path, params.query, params.body, opts);
  }
  async deleteNetworkingInternalKnativeDevV1alpha1CollectionClusterDomainClaim(params: DeleteNetworkingInternalKnativeDevV1alpha1CollectionClusterDomainClaimRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/clusterdomainclaims`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readNetworkingInternalKnativeDevV1alpha1ClusterDomainClaim(params: ReadNetworkingInternalKnativeDevV1alpha1ClusterDomainClaimRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1ClusterDomainClaim> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/clusterdomainclaims/${params.path.name}`;
    return await this.get<NetworkingInternalKnativeDevV1alpha1ClusterDomainClaim>(path, null, null, opts);
  }
  async replaceNetworkingInternalKnativeDevV1alpha1ClusterDomainClaim(params: ReplaceNetworkingInternalKnativeDevV1alpha1ClusterDomainClaimRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1ClusterDomainClaim> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/clusterdomainclaims/${params.path.name}`;
    return await this.put<NetworkingInternalKnativeDevV1alpha1ClusterDomainClaim>(path, params.query, params.body, opts);
  }
  async deleteNetworkingInternalKnativeDevV1alpha1ClusterDomainClaim(params: DeleteNetworkingInternalKnativeDevV1alpha1ClusterDomainClaimRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/clusterdomainclaims/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchNetworkingInternalKnativeDevV1alpha1ClusterDomainClaim(params: PatchNetworkingInternalKnativeDevV1alpha1ClusterDomainClaimRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1ClusterDomainClaim> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/clusterdomainclaims/${params.path.name}`;
    return await this.patch<NetworkingInternalKnativeDevV1alpha1ClusterDomainClaim>(path, params.query, null, opts);
  }
  async readNetworkingInternalKnativeDevV1alpha1ClusterDomainClaimStatus(params: ReadNetworkingInternalKnativeDevV1alpha1ClusterDomainClaimStatusRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1ClusterDomainClaim> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/clusterdomainclaims/${params.path.name}/status`;
    return await this.get<NetworkingInternalKnativeDevV1alpha1ClusterDomainClaim>(path, null, null, opts);
  }
  async replaceNetworkingInternalKnativeDevV1alpha1ClusterDomainClaimStatus(params: ReplaceNetworkingInternalKnativeDevV1alpha1ClusterDomainClaimStatusRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1ClusterDomainClaim> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/clusterdomainclaims/${params.path.name}/status`;
    return await this.put<NetworkingInternalKnativeDevV1alpha1ClusterDomainClaim>(path, params.query, params.body, opts);
  }
  async patchNetworkingInternalKnativeDevV1alpha1ClusterDomainClaimStatus(params: PatchNetworkingInternalKnativeDevV1alpha1ClusterDomainClaimStatusRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1ClusterDomainClaim> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/clusterdomainclaims/${params.path.name}/status`;
    return await this.patch<NetworkingInternalKnativeDevV1alpha1ClusterDomainClaim>(path, params.query, null, opts);
  }
  async listNetworkingInternalKnativeDevV1alpha1IngressForAllNamespaces(params: ListNetworkingInternalKnativeDevV1alpha1IngressForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1IngressList> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/ingresses`;
    return await this.get<NetworkingInternalKnativeDevV1alpha1IngressList>(path, null, null, opts);
  }
  async listNetworkingInternalKnativeDevV1alpha1NamespacedCertificate(params: ListNetworkingInternalKnativeDevV1alpha1NamespacedCertificateRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1CertificateList> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/certificates`;
    return await this.get<NetworkingInternalKnativeDevV1alpha1CertificateList>(path, null, null, opts);
  }
  async createNetworkingInternalKnativeDevV1alpha1NamespacedCertificate(params: CreateNetworkingInternalKnativeDevV1alpha1NamespacedCertificateRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1Certificate> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/certificates`;
    return await this.post<NetworkingInternalKnativeDevV1alpha1Certificate>(path, params.query, params.body, opts);
  }
  async deleteNetworkingInternalKnativeDevV1alpha1CollectionNamespacedCertificate(params: DeleteNetworkingInternalKnativeDevV1alpha1CollectionNamespacedCertificateRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/certificates`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readNetworkingInternalKnativeDevV1alpha1NamespacedCertificate(params: ReadNetworkingInternalKnativeDevV1alpha1NamespacedCertificateRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1Certificate> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/certificates/${params.path.name}`;
    return await this.get<NetworkingInternalKnativeDevV1alpha1Certificate>(path, null, null, opts);
  }
  async replaceNetworkingInternalKnativeDevV1alpha1NamespacedCertificate(params: ReplaceNetworkingInternalKnativeDevV1alpha1NamespacedCertificateRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1Certificate> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/certificates/${params.path.name}`;
    return await this.put<NetworkingInternalKnativeDevV1alpha1Certificate>(path, params.query, params.body, opts);
  }
  async deleteNetworkingInternalKnativeDevV1alpha1NamespacedCertificate(params: DeleteNetworkingInternalKnativeDevV1alpha1NamespacedCertificateRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/certificates/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchNetworkingInternalKnativeDevV1alpha1NamespacedCertificate(params: PatchNetworkingInternalKnativeDevV1alpha1NamespacedCertificateRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1Certificate> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/certificates/${params.path.name}`;
    return await this.patch<NetworkingInternalKnativeDevV1alpha1Certificate>(path, params.query, null, opts);
  }
  async readNetworkingInternalKnativeDevV1alpha1NamespacedCertificateStatus(params: ReadNetworkingInternalKnativeDevV1alpha1NamespacedCertificateStatusRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1Certificate> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/certificates/${params.path.name}/status`;
    return await this.get<NetworkingInternalKnativeDevV1alpha1Certificate>(path, null, null, opts);
  }
  async replaceNetworkingInternalKnativeDevV1alpha1NamespacedCertificateStatus(params: ReplaceNetworkingInternalKnativeDevV1alpha1NamespacedCertificateStatusRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1Certificate> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/certificates/${params.path.name}/status`;
    return await this.put<NetworkingInternalKnativeDevV1alpha1Certificate>(path, params.query, params.body, opts);
  }
  async patchNetworkingInternalKnativeDevV1alpha1NamespacedCertificateStatus(params: PatchNetworkingInternalKnativeDevV1alpha1NamespacedCertificateStatusRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1Certificate> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/certificates/${params.path.name}/status`;
    return await this.patch<NetworkingInternalKnativeDevV1alpha1Certificate>(path, params.query, null, opts);
  }
  async listNetworkingInternalKnativeDevV1alpha1NamespacedIngress(params: ListNetworkingInternalKnativeDevV1alpha1NamespacedIngressRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1IngressList> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/ingresses`;
    return await this.get<NetworkingInternalKnativeDevV1alpha1IngressList>(path, null, null, opts);
  }
  async createNetworkingInternalKnativeDevV1alpha1NamespacedIngress(params: CreateNetworkingInternalKnativeDevV1alpha1NamespacedIngressRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1Ingress> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/ingresses`;
    return await this.post<NetworkingInternalKnativeDevV1alpha1Ingress>(path, params.query, params.body, opts);
  }
  async deleteNetworkingInternalKnativeDevV1alpha1CollectionNamespacedIngress(params: DeleteNetworkingInternalKnativeDevV1alpha1CollectionNamespacedIngressRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/ingresses`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readNetworkingInternalKnativeDevV1alpha1NamespacedIngress(params: ReadNetworkingInternalKnativeDevV1alpha1NamespacedIngressRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1Ingress> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/ingresses/${params.path.name}`;
    return await this.get<NetworkingInternalKnativeDevV1alpha1Ingress>(path, null, null, opts);
  }
  async replaceNetworkingInternalKnativeDevV1alpha1NamespacedIngress(params: ReplaceNetworkingInternalKnativeDevV1alpha1NamespacedIngressRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1Ingress> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/ingresses/${params.path.name}`;
    return await this.put<NetworkingInternalKnativeDevV1alpha1Ingress>(path, params.query, params.body, opts);
  }
  async deleteNetworkingInternalKnativeDevV1alpha1NamespacedIngress(params: DeleteNetworkingInternalKnativeDevV1alpha1NamespacedIngressRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/ingresses/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchNetworkingInternalKnativeDevV1alpha1NamespacedIngress(params: PatchNetworkingInternalKnativeDevV1alpha1NamespacedIngressRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1Ingress> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/ingresses/${params.path.name}`;
    return await this.patch<NetworkingInternalKnativeDevV1alpha1Ingress>(path, params.query, null, opts);
  }
  async readNetworkingInternalKnativeDevV1alpha1NamespacedIngressStatus(params: ReadNetworkingInternalKnativeDevV1alpha1NamespacedIngressStatusRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1Ingress> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/ingresses/${params.path.name}/status`;
    return await this.get<NetworkingInternalKnativeDevV1alpha1Ingress>(path, null, null, opts);
  }
  async replaceNetworkingInternalKnativeDevV1alpha1NamespacedIngressStatus(params: ReplaceNetworkingInternalKnativeDevV1alpha1NamespacedIngressStatusRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1Ingress> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/ingresses/${params.path.name}/status`;
    return await this.put<NetworkingInternalKnativeDevV1alpha1Ingress>(path, params.query, params.body, opts);
  }
  async patchNetworkingInternalKnativeDevV1alpha1NamespacedIngressStatus(params: PatchNetworkingInternalKnativeDevV1alpha1NamespacedIngressStatusRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1Ingress> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/ingresses/${params.path.name}/status`;
    return await this.patch<NetworkingInternalKnativeDevV1alpha1Ingress>(path, params.query, null, opts);
  }
  async listNetworkingInternalKnativeDevV1alpha1NamespacedServerlessService(params: ListNetworkingInternalKnativeDevV1alpha1NamespacedServerlessServiceRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1ServerlessServiceList> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/serverlessservices`;
    return await this.get<NetworkingInternalKnativeDevV1alpha1ServerlessServiceList>(path, null, null, opts);
  }
  async createNetworkingInternalKnativeDevV1alpha1NamespacedServerlessService(params: CreateNetworkingInternalKnativeDevV1alpha1NamespacedServerlessServiceRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1ServerlessService> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/serverlessservices`;
    return await this.post<NetworkingInternalKnativeDevV1alpha1ServerlessService>(path, params.query, params.body, opts);
  }
  async deleteNetworkingInternalKnativeDevV1alpha1CollectionNamespacedServerlessService(params: DeleteNetworkingInternalKnativeDevV1alpha1CollectionNamespacedServerlessServiceRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/serverlessservices`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readNetworkingInternalKnativeDevV1alpha1NamespacedServerlessService(params: ReadNetworkingInternalKnativeDevV1alpha1NamespacedServerlessServiceRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1ServerlessService> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/serverlessservices/${params.path.name}`;
    return await this.get<NetworkingInternalKnativeDevV1alpha1ServerlessService>(path, null, null, opts);
  }
  async replaceNetworkingInternalKnativeDevV1alpha1NamespacedServerlessService(params: ReplaceNetworkingInternalKnativeDevV1alpha1NamespacedServerlessServiceRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1ServerlessService> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/serverlessservices/${params.path.name}`;
    return await this.put<NetworkingInternalKnativeDevV1alpha1ServerlessService>(path, params.query, params.body, opts);
  }
  async deleteNetworkingInternalKnativeDevV1alpha1NamespacedServerlessService(params: DeleteNetworkingInternalKnativeDevV1alpha1NamespacedServerlessServiceRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/serverlessservices/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchNetworkingInternalKnativeDevV1alpha1NamespacedServerlessService(params: PatchNetworkingInternalKnativeDevV1alpha1NamespacedServerlessServiceRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1ServerlessService> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/serverlessservices/${params.path.name}`;
    return await this.patch<NetworkingInternalKnativeDevV1alpha1ServerlessService>(path, params.query, null, opts);
  }
  async readNetworkingInternalKnativeDevV1alpha1NamespacedServerlessServiceStatus(params: ReadNetworkingInternalKnativeDevV1alpha1NamespacedServerlessServiceStatusRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1ServerlessService> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/serverlessservices/${params.path.name}/status`;
    return await this.get<NetworkingInternalKnativeDevV1alpha1ServerlessService>(path, null, null, opts);
  }
  async replaceNetworkingInternalKnativeDevV1alpha1NamespacedServerlessServiceStatus(params: ReplaceNetworkingInternalKnativeDevV1alpha1NamespacedServerlessServiceStatusRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1ServerlessService> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/serverlessservices/${params.path.name}/status`;
    return await this.put<NetworkingInternalKnativeDevV1alpha1ServerlessService>(path, params.query, params.body, opts);
  }
  async patchNetworkingInternalKnativeDevV1alpha1NamespacedServerlessServiceStatus(params: PatchNetworkingInternalKnativeDevV1alpha1NamespacedServerlessServiceStatusRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1ServerlessService> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/serverlessservices/${params.path.name}/status`;
    return await this.patch<NetworkingInternalKnativeDevV1alpha1ServerlessService>(path, params.query, null, opts);
  }
  async listNetworkingInternalKnativeDevV1alpha1ServerlessServiceForAllNamespaces(params: ListNetworkingInternalKnativeDevV1alpha1ServerlessServiceForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1ServerlessServiceList> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/serverlessservices`;
    return await this.get<NetworkingInternalKnativeDevV1alpha1ServerlessServiceList>(path, null, null, opts);
  }
  async getNetworkingAPIGroup(params: GetNetworkingAPIGroupRequest, opts?: APIClientRequestOpts): Promise<APIGroup> {
    const path = `/apis/networking.k8s.io/`;
    return await this.get<APIGroup>(path, null, null, opts);
  }
  async getNetworkingV1APIResources(params: GetNetworkingV1APIResourcesRequest, opts?: APIClientRequestOpts): Promise<APIResourceList> {
    const path = `/apis/networking.k8s.io/v1/`;
    return await this.get<APIResourceList>(path, null, null, opts);
  }
  async listNetworkingV1IngressClass(params: ListNetworkingV1IngressClassRequest, opts?: APIClientRequestOpts): Promise<NetworkingK8sIoV1IngressClassList> {
    const path = `/apis/networking.k8s.io/v1/ingressclasses`;
    return await this.get<NetworkingK8sIoV1IngressClassList>(path, null, null, opts);
  }
  async createNetworkingV1IngressClass(params: CreateNetworkingV1IngressClassRequest, opts?: APIClientRequestOpts): Promise<NetworkingK8sIoV1IngressClass> {
    const path = `/apis/networking.k8s.io/v1/ingressclasses`;
    return await this.post<NetworkingK8sIoV1IngressClass>(path, params.query, params.body, opts);
  }
  async deleteNetworkingV1CollectionIngressClass(params: DeleteNetworkingV1CollectionIngressClassRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/networking.k8s.io/v1/ingressclasses`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readNetworkingV1IngressClass(params: ReadNetworkingV1IngressClassRequest, opts?: APIClientRequestOpts): Promise<NetworkingK8sIoV1IngressClass> {
    const path = `/apis/networking.k8s.io/v1/ingressclasses/${params.path.name}`;
    return await this.get<NetworkingK8sIoV1IngressClass>(path, null, null, opts);
  }
  async replaceNetworkingV1IngressClass(params: ReplaceNetworkingV1IngressClassRequest, opts?: APIClientRequestOpts): Promise<NetworkingK8sIoV1IngressClass> {
    const path = `/apis/networking.k8s.io/v1/ingressclasses/${params.path.name}`;
    return await this.put<NetworkingK8sIoV1IngressClass>(path, params.query, params.body, opts);
  }
  async deleteNetworkingV1IngressClass(params: DeleteNetworkingV1IngressClassRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/networking.k8s.io/v1/ingressclasses/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchNetworkingV1IngressClass(params: PatchNetworkingV1IngressClassRequest, opts?: APIClientRequestOpts): Promise<NetworkingK8sIoV1IngressClass> {
    const path = `/apis/networking.k8s.io/v1/ingressclasses/${params.path.name}`;
    return await this.patch<NetworkingK8sIoV1IngressClass>(path, params.query, null, opts);
  }
  async listNetworkingV1IngressForAllNamespaces(params: ListNetworkingV1IngressForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<NetworkingK8sIoV1IngressList> {
    const path = `/apis/networking.k8s.io/v1/ingresses`;
    return await this.get<NetworkingK8sIoV1IngressList>(path, null, null, opts);
  }
  async listNetworkingV1NamespacedIngress(params: ListNetworkingV1NamespacedIngressRequest, opts?: APIClientRequestOpts): Promise<NetworkingK8sIoV1IngressList> {
    const path = `/apis/networking.k8s.io/v1/namespaces/${params.path.namespace}/ingresses`;
    return await this.get<NetworkingK8sIoV1IngressList>(path, null, null, opts);
  }
  async createNetworkingV1NamespacedIngress(params: CreateNetworkingV1NamespacedIngressRequest, opts?: APIClientRequestOpts): Promise<NetworkingK8sIoV1Ingress> {
    const path = `/apis/networking.k8s.io/v1/namespaces/${params.path.namespace}/ingresses`;
    return await this.post<NetworkingK8sIoV1Ingress>(path, params.query, params.body, opts);
  }
  async deleteNetworkingV1CollectionNamespacedIngress(params: DeleteNetworkingV1CollectionNamespacedIngressRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/networking.k8s.io/v1/namespaces/${params.path.namespace}/ingresses`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readNetworkingV1NamespacedIngress(params: ReadNetworkingV1NamespacedIngressRequest, opts?: APIClientRequestOpts): Promise<NetworkingK8sIoV1Ingress> {
    const path = `/apis/networking.k8s.io/v1/namespaces/${params.path.namespace}/ingresses/${params.path.name}`;
    return await this.get<NetworkingK8sIoV1Ingress>(path, null, null, opts);
  }
  async replaceNetworkingV1NamespacedIngress(params: ReplaceNetworkingV1NamespacedIngressRequest, opts?: APIClientRequestOpts): Promise<NetworkingK8sIoV1Ingress> {
    const path = `/apis/networking.k8s.io/v1/namespaces/${params.path.namespace}/ingresses/${params.path.name}`;
    return await this.put<NetworkingK8sIoV1Ingress>(path, params.query, params.body, opts);
  }
  async deleteNetworkingV1NamespacedIngress(params: DeleteNetworkingV1NamespacedIngressRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/networking.k8s.io/v1/namespaces/${params.path.namespace}/ingresses/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchNetworkingV1NamespacedIngress(params: PatchNetworkingV1NamespacedIngressRequest, opts?: APIClientRequestOpts): Promise<NetworkingK8sIoV1Ingress> {
    const path = `/apis/networking.k8s.io/v1/namespaces/${params.path.namespace}/ingresses/${params.path.name}`;
    return await this.patch<NetworkingK8sIoV1Ingress>(path, params.query, null, opts);
  }
  async readNetworkingV1NamespacedIngressStatus(params: ReadNetworkingV1NamespacedIngressStatusRequest, opts?: APIClientRequestOpts): Promise<NetworkingK8sIoV1Ingress> {
    const path = `/apis/networking.k8s.io/v1/namespaces/${params.path.namespace}/ingresses/${params.path.name}/status`;
    return await this.get<NetworkingK8sIoV1Ingress>(path, null, null, opts);
  }
  async replaceNetworkingV1NamespacedIngressStatus(params: ReplaceNetworkingV1NamespacedIngressStatusRequest, opts?: APIClientRequestOpts): Promise<NetworkingK8sIoV1Ingress> {
    const path = `/apis/networking.k8s.io/v1/namespaces/${params.path.namespace}/ingresses/${params.path.name}/status`;
    return await this.put<NetworkingK8sIoV1Ingress>(path, params.query, params.body, opts);
  }
  async patchNetworkingV1NamespacedIngressStatus(params: PatchNetworkingV1NamespacedIngressStatusRequest, opts?: APIClientRequestOpts): Promise<NetworkingK8sIoV1Ingress> {
    const path = `/apis/networking.k8s.io/v1/namespaces/${params.path.namespace}/ingresses/${params.path.name}/status`;
    return await this.patch<NetworkingK8sIoV1Ingress>(path, params.query, null, opts);
  }
  async listNetworkingV1NamespacedNetworkPolicy(params: ListNetworkingV1NamespacedNetworkPolicyRequest, opts?: APIClientRequestOpts): Promise<NetworkingK8sIoV1NetworkPolicyList> {
    const path = `/apis/networking.k8s.io/v1/namespaces/${params.path.namespace}/networkpolicies`;
    return await this.get<NetworkingK8sIoV1NetworkPolicyList>(path, null, null, opts);
  }
  async createNetworkingV1NamespacedNetworkPolicy(params: CreateNetworkingV1NamespacedNetworkPolicyRequest, opts?: APIClientRequestOpts): Promise<NetworkingK8sIoV1NetworkPolicy> {
    const path = `/apis/networking.k8s.io/v1/namespaces/${params.path.namespace}/networkpolicies`;
    return await this.post<NetworkingK8sIoV1NetworkPolicy>(path, params.query, params.body, opts);
  }
  async deleteNetworkingV1CollectionNamespacedNetworkPolicy(params: DeleteNetworkingV1CollectionNamespacedNetworkPolicyRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/networking.k8s.io/v1/namespaces/${params.path.namespace}/networkpolicies`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readNetworkingV1NamespacedNetworkPolicy(params: ReadNetworkingV1NamespacedNetworkPolicyRequest, opts?: APIClientRequestOpts): Promise<NetworkingK8sIoV1NetworkPolicy> {
    const path = `/apis/networking.k8s.io/v1/namespaces/${params.path.namespace}/networkpolicies/${params.path.name}`;
    return await this.get<NetworkingK8sIoV1NetworkPolicy>(path, null, null, opts);
  }
  async replaceNetworkingV1NamespacedNetworkPolicy(params: ReplaceNetworkingV1NamespacedNetworkPolicyRequest, opts?: APIClientRequestOpts): Promise<NetworkingK8sIoV1NetworkPolicy> {
    const path = `/apis/networking.k8s.io/v1/namespaces/${params.path.namespace}/networkpolicies/${params.path.name}`;
    return await this.put<NetworkingK8sIoV1NetworkPolicy>(path, params.query, params.body, opts);
  }
  async deleteNetworkingV1NamespacedNetworkPolicy(params: DeleteNetworkingV1NamespacedNetworkPolicyRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/networking.k8s.io/v1/namespaces/${params.path.namespace}/networkpolicies/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchNetworkingV1NamespacedNetworkPolicy(params: PatchNetworkingV1NamespacedNetworkPolicyRequest, opts?: APIClientRequestOpts): Promise<NetworkingK8sIoV1NetworkPolicy> {
    const path = `/apis/networking.k8s.io/v1/namespaces/${params.path.namespace}/networkpolicies/${params.path.name}`;
    return await this.patch<NetworkingK8sIoV1NetworkPolicy>(path, params.query, null, opts);
  }
  async listNetworkingV1NetworkPolicyForAllNamespaces(params: ListNetworkingV1NetworkPolicyForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<NetworkingK8sIoV1NetworkPolicyList> {
    const path = `/apis/networking.k8s.io/v1/networkpolicies`;
    return await this.get<NetworkingK8sIoV1NetworkPolicyList>(path, null, null, opts);
  }
  async watchNetworkingV1IngressClassList(params: WatchNetworkingV1IngressClassListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/networking.k8s.io/v1/watch/ingressclasses`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchNetworkingV1IngressClass(params: WatchNetworkingV1IngressClassRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/networking.k8s.io/v1/watch/ingressclasses/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchNetworkingV1IngressListForAllNamespaces(params: WatchNetworkingV1IngressListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/networking.k8s.io/v1/watch/ingresses`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchNetworkingV1NamespacedIngressList(params: WatchNetworkingV1NamespacedIngressListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/networking.k8s.io/v1/watch/namespaces/${params.path.namespace}/ingresses`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchNetworkingV1NamespacedIngress(params: WatchNetworkingV1NamespacedIngressRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/networking.k8s.io/v1/watch/namespaces/${params.path.namespace}/ingresses/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchNetworkingV1NamespacedNetworkPolicyList(params: WatchNetworkingV1NamespacedNetworkPolicyListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/networking.k8s.io/v1/watch/namespaces/${params.path.namespace}/networkpolicies`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchNetworkingV1NamespacedNetworkPolicy(params: WatchNetworkingV1NamespacedNetworkPolicyRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/networking.k8s.io/v1/watch/namespaces/${params.path.namespace}/networkpolicies/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchNetworkingV1NetworkPolicyListForAllNamespaces(params: WatchNetworkingV1NetworkPolicyListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/networking.k8s.io/v1/watch/networkpolicies`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async getNodeAPIGroup(params: GetNodeAPIGroupRequest, opts?: APIClientRequestOpts): Promise<APIGroup> {
    const path = `/apis/node.k8s.io/`;
    return await this.get<APIGroup>(path, null, null, opts);
  }
  async getNodeV1APIResources(params: GetNodeV1APIResourcesRequest, opts?: APIClientRequestOpts): Promise<APIResourceList> {
    const path = `/apis/node.k8s.io/v1/`;
    return await this.get<APIResourceList>(path, null, null, opts);
  }
  async listNodeV1RuntimeClass(params: ListNodeV1RuntimeClassRequest, opts?: APIClientRequestOpts): Promise<NodeK8sIoV1RuntimeClassList> {
    const path = `/apis/node.k8s.io/v1/runtimeclasses`;
    return await this.get<NodeK8sIoV1RuntimeClassList>(path, null, null, opts);
  }
  async createNodeV1RuntimeClass(params: CreateNodeV1RuntimeClassRequest, opts?: APIClientRequestOpts): Promise<NodeK8sIoV1RuntimeClass> {
    const path = `/apis/node.k8s.io/v1/runtimeclasses`;
    return await this.post<NodeK8sIoV1RuntimeClass>(path, params.query, params.body, opts);
  }
  async deleteNodeV1CollectionRuntimeClass(params: DeleteNodeV1CollectionRuntimeClassRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/node.k8s.io/v1/runtimeclasses`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readNodeV1RuntimeClass(params: ReadNodeV1RuntimeClassRequest, opts?: APIClientRequestOpts): Promise<NodeK8sIoV1RuntimeClass> {
    const path = `/apis/node.k8s.io/v1/runtimeclasses/${params.path.name}`;
    return await this.get<NodeK8sIoV1RuntimeClass>(path, null, null, opts);
  }
  async replaceNodeV1RuntimeClass(params: ReplaceNodeV1RuntimeClassRequest, opts?: APIClientRequestOpts): Promise<NodeK8sIoV1RuntimeClass> {
    const path = `/apis/node.k8s.io/v1/runtimeclasses/${params.path.name}`;
    return await this.put<NodeK8sIoV1RuntimeClass>(path, params.query, params.body, opts);
  }
  async deleteNodeV1RuntimeClass(params: DeleteNodeV1RuntimeClassRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/node.k8s.io/v1/runtimeclasses/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchNodeV1RuntimeClass(params: PatchNodeV1RuntimeClassRequest, opts?: APIClientRequestOpts): Promise<NodeK8sIoV1RuntimeClass> {
    const path = `/apis/node.k8s.io/v1/runtimeclasses/${params.path.name}`;
    return await this.patch<NodeK8sIoV1RuntimeClass>(path, params.query, null, opts);
  }
  async watchNodeV1RuntimeClassList(params: WatchNodeV1RuntimeClassListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/node.k8s.io/v1/watch/runtimeclasses`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchNodeV1RuntimeClass(params: WatchNodeV1RuntimeClassRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/node.k8s.io/v1/watch/runtimeclasses/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async getPolicyAPIGroup(params: GetPolicyAPIGroupRequest, opts?: APIClientRequestOpts): Promise<APIGroup> {
    const path = `/apis/policy/`;
    return await this.get<APIGroup>(path, null, null, opts);
  }
  async getPolicyV1APIResources(params: GetPolicyV1APIResourcesRequest, opts?: APIClientRequestOpts): Promise<APIResourceList> {
    const path = `/apis/policy/v1/`;
    return await this.get<APIResourceList>(path, null, null, opts);
  }
  async listPolicyV1NamespacedPodDisruptionBudget(params: ListPolicyV1NamespacedPodDisruptionBudgetRequest, opts?: APIClientRequestOpts): Promise<PolicyV1PodDisruptionBudgetList> {
    const path = `/apis/policy/v1/namespaces/${params.path.namespace}/poddisruptionbudgets`;
    return await this.get<PolicyV1PodDisruptionBudgetList>(path, null, null, opts);
  }
  async createPolicyV1NamespacedPodDisruptionBudget(params: CreatePolicyV1NamespacedPodDisruptionBudgetRequest, opts?: APIClientRequestOpts): Promise<PolicyV1PodDisruptionBudget> {
    const path = `/apis/policy/v1/namespaces/${params.path.namespace}/poddisruptionbudgets`;
    return await this.post<PolicyV1PodDisruptionBudget>(path, params.query, params.body, opts);
  }
  async deletePolicyV1CollectionNamespacedPodDisruptionBudget(params: DeletePolicyV1CollectionNamespacedPodDisruptionBudgetRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/policy/v1/namespaces/${params.path.namespace}/poddisruptionbudgets`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readPolicyV1NamespacedPodDisruptionBudget(params: ReadPolicyV1NamespacedPodDisruptionBudgetRequest, opts?: APIClientRequestOpts): Promise<PolicyV1PodDisruptionBudget> {
    const path = `/apis/policy/v1/namespaces/${params.path.namespace}/poddisruptionbudgets/${params.path.name}`;
    return await this.get<PolicyV1PodDisruptionBudget>(path, null, null, opts);
  }
  async replacePolicyV1NamespacedPodDisruptionBudget(params: ReplacePolicyV1NamespacedPodDisruptionBudgetRequest, opts?: APIClientRequestOpts): Promise<PolicyV1PodDisruptionBudget> {
    const path = `/apis/policy/v1/namespaces/${params.path.namespace}/poddisruptionbudgets/${params.path.name}`;
    return await this.put<PolicyV1PodDisruptionBudget>(path, params.query, params.body, opts);
  }
  async deletePolicyV1NamespacedPodDisruptionBudget(params: DeletePolicyV1NamespacedPodDisruptionBudgetRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/policy/v1/namespaces/${params.path.namespace}/poddisruptionbudgets/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchPolicyV1NamespacedPodDisruptionBudget(params: PatchPolicyV1NamespacedPodDisruptionBudgetRequest, opts?: APIClientRequestOpts): Promise<PolicyV1PodDisruptionBudget> {
    const path = `/apis/policy/v1/namespaces/${params.path.namespace}/poddisruptionbudgets/${params.path.name}`;
    return await this.patch<PolicyV1PodDisruptionBudget>(path, params.query, null, opts);
  }
  async readPolicyV1NamespacedPodDisruptionBudgetStatus(params: ReadPolicyV1NamespacedPodDisruptionBudgetStatusRequest, opts?: APIClientRequestOpts): Promise<PolicyV1PodDisruptionBudget> {
    const path = `/apis/policy/v1/namespaces/${params.path.namespace}/poddisruptionbudgets/${params.path.name}/status`;
    return await this.get<PolicyV1PodDisruptionBudget>(path, null, null, opts);
  }
  async replacePolicyV1NamespacedPodDisruptionBudgetStatus(params: ReplacePolicyV1NamespacedPodDisruptionBudgetStatusRequest, opts?: APIClientRequestOpts): Promise<PolicyV1PodDisruptionBudget> {
    const path = `/apis/policy/v1/namespaces/${params.path.namespace}/poddisruptionbudgets/${params.path.name}/status`;
    return await this.put<PolicyV1PodDisruptionBudget>(path, params.query, params.body, opts);
  }
  async patchPolicyV1NamespacedPodDisruptionBudgetStatus(params: PatchPolicyV1NamespacedPodDisruptionBudgetStatusRequest, opts?: APIClientRequestOpts): Promise<PolicyV1PodDisruptionBudget> {
    const path = `/apis/policy/v1/namespaces/${params.path.namespace}/poddisruptionbudgets/${params.path.name}/status`;
    return await this.patch<PolicyV1PodDisruptionBudget>(path, params.query, null, opts);
  }
  async listPolicyV1PodDisruptionBudgetForAllNamespaces(params: ListPolicyV1PodDisruptionBudgetForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<PolicyV1PodDisruptionBudgetList> {
    const path = `/apis/policy/v1/poddisruptionbudgets`;
    return await this.get<PolicyV1PodDisruptionBudgetList>(path, null, null, opts);
  }
  async watchPolicyV1NamespacedPodDisruptionBudgetList(params: WatchPolicyV1NamespacedPodDisruptionBudgetListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/policy/v1/watch/namespaces/${params.path.namespace}/poddisruptionbudgets`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchPolicyV1NamespacedPodDisruptionBudget(params: WatchPolicyV1NamespacedPodDisruptionBudgetRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/policy/v1/watch/namespaces/${params.path.namespace}/poddisruptionbudgets/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchPolicyV1PodDisruptionBudgetListForAllNamespaces(params: WatchPolicyV1PodDisruptionBudgetListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/policy/v1/watch/poddisruptionbudgets`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async listPostgresqlCnpgIoV1BackupForAllNamespaces(params: ListPostgresqlCnpgIoV1BackupForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1BackupList> {
    const path = `/apis/postgresql.cnpg.io/v1/backups`;
    return await this.get<PostgresqlCnpgIoV1BackupList>(path, null, null, opts);
  }
  async listPostgresqlCnpgIoV1ClusterImageCatalog(params: ListPostgresqlCnpgIoV1ClusterImageCatalogRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1ClusterImageCatalogList> {
    const path = `/apis/postgresql.cnpg.io/v1/clusterimagecatalogs`;
    return await this.get<PostgresqlCnpgIoV1ClusterImageCatalogList>(path, null, null, opts);
  }
  async createPostgresqlCnpgIoV1ClusterImageCatalog(params: CreatePostgresqlCnpgIoV1ClusterImageCatalogRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1ClusterImageCatalog> {
    const path = `/apis/postgresql.cnpg.io/v1/clusterimagecatalogs`;
    return await this.post<PostgresqlCnpgIoV1ClusterImageCatalog>(path, params.query, params.body, opts);
  }
  async deletePostgresqlCnpgIoV1CollectionClusterImageCatalog(params: DeletePostgresqlCnpgIoV1CollectionClusterImageCatalogRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/postgresql.cnpg.io/v1/clusterimagecatalogs`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readPostgresqlCnpgIoV1ClusterImageCatalog(params: ReadPostgresqlCnpgIoV1ClusterImageCatalogRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1ClusterImageCatalog> {
    const path = `/apis/postgresql.cnpg.io/v1/clusterimagecatalogs/${params.path.name}`;
    return await this.get<PostgresqlCnpgIoV1ClusterImageCatalog>(path, null, null, opts);
  }
  async replacePostgresqlCnpgIoV1ClusterImageCatalog(params: ReplacePostgresqlCnpgIoV1ClusterImageCatalogRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1ClusterImageCatalog> {
    const path = `/apis/postgresql.cnpg.io/v1/clusterimagecatalogs/${params.path.name}`;
    return await this.put<PostgresqlCnpgIoV1ClusterImageCatalog>(path, params.query, params.body, opts);
  }
  async deletePostgresqlCnpgIoV1ClusterImageCatalog(params: DeletePostgresqlCnpgIoV1ClusterImageCatalogRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/postgresql.cnpg.io/v1/clusterimagecatalogs/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchPostgresqlCnpgIoV1ClusterImageCatalog(params: PatchPostgresqlCnpgIoV1ClusterImageCatalogRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1ClusterImageCatalog> {
    const path = `/apis/postgresql.cnpg.io/v1/clusterimagecatalogs/${params.path.name}`;
    return await this.patch<PostgresqlCnpgIoV1ClusterImageCatalog>(path, params.query, null, opts);
  }
  async listPostgresqlCnpgIoV1ClusterForAllNamespaces(params: ListPostgresqlCnpgIoV1ClusterForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1ClusterList> {
    const path = `/apis/postgresql.cnpg.io/v1/clusters`;
    return await this.get<PostgresqlCnpgIoV1ClusterList>(path, null, null, opts);
  }
  async listPostgresqlCnpgIoV1DatabaseForAllNamespaces(params: ListPostgresqlCnpgIoV1DatabaseForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1DatabaseList> {
    const path = `/apis/postgresql.cnpg.io/v1/databases`;
    return await this.get<PostgresqlCnpgIoV1DatabaseList>(path, null, null, opts);
  }
  async listPostgresqlCnpgIoV1ImageCatalogForAllNamespaces(params: ListPostgresqlCnpgIoV1ImageCatalogForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1ImageCatalogList> {
    const path = `/apis/postgresql.cnpg.io/v1/imagecatalogs`;
    return await this.get<PostgresqlCnpgIoV1ImageCatalogList>(path, null, null, opts);
  }
  async listPostgresqlCnpgIoV1NamespacedBackup(params: ListPostgresqlCnpgIoV1NamespacedBackupRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1BackupList> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/backups`;
    return await this.get<PostgresqlCnpgIoV1BackupList>(path, null, null, opts);
  }
  async createPostgresqlCnpgIoV1NamespacedBackup(params: CreatePostgresqlCnpgIoV1NamespacedBackupRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Backup> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/backups`;
    return await this.post<PostgresqlCnpgIoV1Backup>(path, params.query, params.body, opts);
  }
  async deletePostgresqlCnpgIoV1CollectionNamespacedBackup(params: DeletePostgresqlCnpgIoV1CollectionNamespacedBackupRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/backups`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readPostgresqlCnpgIoV1NamespacedBackup(params: ReadPostgresqlCnpgIoV1NamespacedBackupRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Backup> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/backups/${params.path.name}`;
    return await this.get<PostgresqlCnpgIoV1Backup>(path, null, null, opts);
  }
  async replacePostgresqlCnpgIoV1NamespacedBackup(params: ReplacePostgresqlCnpgIoV1NamespacedBackupRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Backup> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/backups/${params.path.name}`;
    return await this.put<PostgresqlCnpgIoV1Backup>(path, params.query, params.body, opts);
  }
  async deletePostgresqlCnpgIoV1NamespacedBackup(params: DeletePostgresqlCnpgIoV1NamespacedBackupRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/backups/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchPostgresqlCnpgIoV1NamespacedBackup(params: PatchPostgresqlCnpgIoV1NamespacedBackupRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Backup> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/backups/${params.path.name}`;
    return await this.patch<PostgresqlCnpgIoV1Backup>(path, params.query, null, opts);
  }
  async readPostgresqlCnpgIoV1NamespacedBackupStatus(params: ReadPostgresqlCnpgIoV1NamespacedBackupStatusRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Backup> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/backups/${params.path.name}/status`;
    return await this.get<PostgresqlCnpgIoV1Backup>(path, null, null, opts);
  }
  async replacePostgresqlCnpgIoV1NamespacedBackupStatus(params: ReplacePostgresqlCnpgIoV1NamespacedBackupStatusRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Backup> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/backups/${params.path.name}/status`;
    return await this.put<PostgresqlCnpgIoV1Backup>(path, params.query, params.body, opts);
  }
  async patchPostgresqlCnpgIoV1NamespacedBackupStatus(params: PatchPostgresqlCnpgIoV1NamespacedBackupStatusRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Backup> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/backups/${params.path.name}/status`;
    return await this.patch<PostgresqlCnpgIoV1Backup>(path, params.query, null, opts);
  }
  async listPostgresqlCnpgIoV1NamespacedCluster(params: ListPostgresqlCnpgIoV1NamespacedClusterRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1ClusterList> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/clusters`;
    return await this.get<PostgresqlCnpgIoV1ClusterList>(path, null, null, opts);
  }
  async createPostgresqlCnpgIoV1NamespacedCluster(params: CreatePostgresqlCnpgIoV1NamespacedClusterRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Cluster> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/clusters`;
    return await this.post<PostgresqlCnpgIoV1Cluster>(path, params.query, params.body, opts);
  }
  async deletePostgresqlCnpgIoV1CollectionNamespacedCluster(params: DeletePostgresqlCnpgIoV1CollectionNamespacedClusterRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/clusters`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readPostgresqlCnpgIoV1NamespacedCluster(params: ReadPostgresqlCnpgIoV1NamespacedClusterRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Cluster> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/clusters/${params.path.name}`;
    return await this.get<PostgresqlCnpgIoV1Cluster>(path, null, null, opts);
  }
  async replacePostgresqlCnpgIoV1NamespacedCluster(params: ReplacePostgresqlCnpgIoV1NamespacedClusterRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Cluster> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/clusters/${params.path.name}`;
    return await this.put<PostgresqlCnpgIoV1Cluster>(path, params.query, params.body, opts);
  }
  async deletePostgresqlCnpgIoV1NamespacedCluster(params: DeletePostgresqlCnpgIoV1NamespacedClusterRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/clusters/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchPostgresqlCnpgIoV1NamespacedCluster(params: PatchPostgresqlCnpgIoV1NamespacedClusterRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Cluster> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/clusters/${params.path.name}`;
    return await this.patch<PostgresqlCnpgIoV1Cluster>(path, params.query, null, opts);
  }
  async readPostgresqlCnpgIoV1NamespacedClusterScale(params: ReadPostgresqlCnpgIoV1NamespacedClusterScaleRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1Scale> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/clusters/${params.path.name}/scale`;
    return await this.get<AutoscalingV1Scale>(path, null, null, opts);
  }
  async replacePostgresqlCnpgIoV1NamespacedClusterScale(params: ReplacePostgresqlCnpgIoV1NamespacedClusterScaleRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1Scale> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/clusters/${params.path.name}/scale`;
    return await this.put<AutoscalingV1Scale>(path, params.query, params.body, opts);
  }
  async patchPostgresqlCnpgIoV1NamespacedClusterScale(params: PatchPostgresqlCnpgIoV1NamespacedClusterScaleRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1Scale> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/clusters/${params.path.name}/scale`;
    return await this.patch<AutoscalingV1Scale>(path, params.query, null, opts);
  }
  async readPostgresqlCnpgIoV1NamespacedClusterStatus(params: ReadPostgresqlCnpgIoV1NamespacedClusterStatusRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Cluster> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/clusters/${params.path.name}/status`;
    return await this.get<PostgresqlCnpgIoV1Cluster>(path, null, null, opts);
  }
  async replacePostgresqlCnpgIoV1NamespacedClusterStatus(params: ReplacePostgresqlCnpgIoV1NamespacedClusterStatusRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Cluster> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/clusters/${params.path.name}/status`;
    return await this.put<PostgresqlCnpgIoV1Cluster>(path, params.query, params.body, opts);
  }
  async patchPostgresqlCnpgIoV1NamespacedClusterStatus(params: PatchPostgresqlCnpgIoV1NamespacedClusterStatusRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Cluster> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/clusters/${params.path.name}/status`;
    return await this.patch<PostgresqlCnpgIoV1Cluster>(path, params.query, null, opts);
  }
  async listPostgresqlCnpgIoV1NamespacedDatabase(params: ListPostgresqlCnpgIoV1NamespacedDatabaseRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1DatabaseList> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/databases`;
    return await this.get<PostgresqlCnpgIoV1DatabaseList>(path, null, null, opts);
  }
  async createPostgresqlCnpgIoV1NamespacedDatabase(params: CreatePostgresqlCnpgIoV1NamespacedDatabaseRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Database> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/databases`;
    return await this.post<PostgresqlCnpgIoV1Database>(path, params.query, params.body, opts);
  }
  async deletePostgresqlCnpgIoV1CollectionNamespacedDatabase(params: DeletePostgresqlCnpgIoV1CollectionNamespacedDatabaseRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/databases`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readPostgresqlCnpgIoV1NamespacedDatabase(params: ReadPostgresqlCnpgIoV1NamespacedDatabaseRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Database> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/databases/${params.path.name}`;
    return await this.get<PostgresqlCnpgIoV1Database>(path, null, null, opts);
  }
  async replacePostgresqlCnpgIoV1NamespacedDatabase(params: ReplacePostgresqlCnpgIoV1NamespacedDatabaseRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Database> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/databases/${params.path.name}`;
    return await this.put<PostgresqlCnpgIoV1Database>(path, params.query, params.body, opts);
  }
  async deletePostgresqlCnpgIoV1NamespacedDatabase(params: DeletePostgresqlCnpgIoV1NamespacedDatabaseRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/databases/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchPostgresqlCnpgIoV1NamespacedDatabase(params: PatchPostgresqlCnpgIoV1NamespacedDatabaseRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Database> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/databases/${params.path.name}`;
    return await this.patch<PostgresqlCnpgIoV1Database>(path, params.query, null, opts);
  }
  async readPostgresqlCnpgIoV1NamespacedDatabaseStatus(params: ReadPostgresqlCnpgIoV1NamespacedDatabaseStatusRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Database> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/databases/${params.path.name}/status`;
    return await this.get<PostgresqlCnpgIoV1Database>(path, null, null, opts);
  }
  async replacePostgresqlCnpgIoV1NamespacedDatabaseStatus(params: ReplacePostgresqlCnpgIoV1NamespacedDatabaseStatusRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Database> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/databases/${params.path.name}/status`;
    return await this.put<PostgresqlCnpgIoV1Database>(path, params.query, params.body, opts);
  }
  async patchPostgresqlCnpgIoV1NamespacedDatabaseStatus(params: PatchPostgresqlCnpgIoV1NamespacedDatabaseStatusRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Database> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/databases/${params.path.name}/status`;
    return await this.patch<PostgresqlCnpgIoV1Database>(path, params.query, null, opts);
  }
  async listPostgresqlCnpgIoV1NamespacedImageCatalog(params: ListPostgresqlCnpgIoV1NamespacedImageCatalogRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1ImageCatalogList> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/imagecatalogs`;
    return await this.get<PostgresqlCnpgIoV1ImageCatalogList>(path, null, null, opts);
  }
  async createPostgresqlCnpgIoV1NamespacedImageCatalog(params: CreatePostgresqlCnpgIoV1NamespacedImageCatalogRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1ImageCatalog> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/imagecatalogs`;
    return await this.post<PostgresqlCnpgIoV1ImageCatalog>(path, params.query, params.body, opts);
  }
  async deletePostgresqlCnpgIoV1CollectionNamespacedImageCatalog(params: DeletePostgresqlCnpgIoV1CollectionNamespacedImageCatalogRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/imagecatalogs`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readPostgresqlCnpgIoV1NamespacedImageCatalog(params: ReadPostgresqlCnpgIoV1NamespacedImageCatalogRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1ImageCatalog> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/imagecatalogs/${params.path.name}`;
    return await this.get<PostgresqlCnpgIoV1ImageCatalog>(path, null, null, opts);
  }
  async replacePostgresqlCnpgIoV1NamespacedImageCatalog(params: ReplacePostgresqlCnpgIoV1NamespacedImageCatalogRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1ImageCatalog> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/imagecatalogs/${params.path.name}`;
    return await this.put<PostgresqlCnpgIoV1ImageCatalog>(path, params.query, params.body, opts);
  }
  async deletePostgresqlCnpgIoV1NamespacedImageCatalog(params: DeletePostgresqlCnpgIoV1NamespacedImageCatalogRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/imagecatalogs/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchPostgresqlCnpgIoV1NamespacedImageCatalog(params: PatchPostgresqlCnpgIoV1NamespacedImageCatalogRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1ImageCatalog> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/imagecatalogs/${params.path.name}`;
    return await this.patch<PostgresqlCnpgIoV1ImageCatalog>(path, params.query, null, opts);
  }
  async listPostgresqlCnpgIoV1NamespacedPooler(params: ListPostgresqlCnpgIoV1NamespacedPoolerRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1PoolerList> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/poolers`;
    return await this.get<PostgresqlCnpgIoV1PoolerList>(path, null, null, opts);
  }
  async createPostgresqlCnpgIoV1NamespacedPooler(params: CreatePostgresqlCnpgIoV1NamespacedPoolerRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Pooler> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/poolers`;
    return await this.post<PostgresqlCnpgIoV1Pooler>(path, params.query, params.body, opts);
  }
  async deletePostgresqlCnpgIoV1CollectionNamespacedPooler(params: DeletePostgresqlCnpgIoV1CollectionNamespacedPoolerRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/poolers`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readPostgresqlCnpgIoV1NamespacedPooler(params: ReadPostgresqlCnpgIoV1NamespacedPoolerRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Pooler> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/poolers/${params.path.name}`;
    return await this.get<PostgresqlCnpgIoV1Pooler>(path, null, null, opts);
  }
  async replacePostgresqlCnpgIoV1NamespacedPooler(params: ReplacePostgresqlCnpgIoV1NamespacedPoolerRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Pooler> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/poolers/${params.path.name}`;
    return await this.put<PostgresqlCnpgIoV1Pooler>(path, params.query, params.body, opts);
  }
  async deletePostgresqlCnpgIoV1NamespacedPooler(params: DeletePostgresqlCnpgIoV1NamespacedPoolerRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/poolers/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchPostgresqlCnpgIoV1NamespacedPooler(params: PatchPostgresqlCnpgIoV1NamespacedPoolerRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Pooler> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/poolers/${params.path.name}`;
    return await this.patch<PostgresqlCnpgIoV1Pooler>(path, params.query, null, opts);
  }
  async readPostgresqlCnpgIoV1NamespacedPoolerScale(params: ReadPostgresqlCnpgIoV1NamespacedPoolerScaleRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1Scale> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/poolers/${params.path.name}/scale`;
    return await this.get<AutoscalingV1Scale>(path, null, null, opts);
  }
  async replacePostgresqlCnpgIoV1NamespacedPoolerScale(params: ReplacePostgresqlCnpgIoV1NamespacedPoolerScaleRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1Scale> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/poolers/${params.path.name}/scale`;
    return await this.put<AutoscalingV1Scale>(path, params.query, params.body, opts);
  }
  async patchPostgresqlCnpgIoV1NamespacedPoolerScale(params: PatchPostgresqlCnpgIoV1NamespacedPoolerScaleRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1Scale> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/poolers/${params.path.name}/scale`;
    return await this.patch<AutoscalingV1Scale>(path, params.query, null, opts);
  }
  async readPostgresqlCnpgIoV1NamespacedPoolerStatus(params: ReadPostgresqlCnpgIoV1NamespacedPoolerStatusRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Pooler> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/poolers/${params.path.name}/status`;
    return await this.get<PostgresqlCnpgIoV1Pooler>(path, null, null, opts);
  }
  async replacePostgresqlCnpgIoV1NamespacedPoolerStatus(params: ReplacePostgresqlCnpgIoV1NamespacedPoolerStatusRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Pooler> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/poolers/${params.path.name}/status`;
    return await this.put<PostgresqlCnpgIoV1Pooler>(path, params.query, params.body, opts);
  }
  async patchPostgresqlCnpgIoV1NamespacedPoolerStatus(params: PatchPostgresqlCnpgIoV1NamespacedPoolerStatusRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Pooler> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/poolers/${params.path.name}/status`;
    return await this.patch<PostgresqlCnpgIoV1Pooler>(path, params.query, null, opts);
  }
  async listPostgresqlCnpgIoV1NamespacedPublication(params: ListPostgresqlCnpgIoV1NamespacedPublicationRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1PublicationList> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/publications`;
    return await this.get<PostgresqlCnpgIoV1PublicationList>(path, null, null, opts);
  }
  async createPostgresqlCnpgIoV1NamespacedPublication(params: CreatePostgresqlCnpgIoV1NamespacedPublicationRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Publication> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/publications`;
    return await this.post<PostgresqlCnpgIoV1Publication>(path, params.query, params.body, opts);
  }
  async deletePostgresqlCnpgIoV1CollectionNamespacedPublication(params: DeletePostgresqlCnpgIoV1CollectionNamespacedPublicationRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/publications`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readPostgresqlCnpgIoV1NamespacedPublication(params: ReadPostgresqlCnpgIoV1NamespacedPublicationRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Publication> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/publications/${params.path.name}`;
    return await this.get<PostgresqlCnpgIoV1Publication>(path, null, null, opts);
  }
  async replacePostgresqlCnpgIoV1NamespacedPublication(params: ReplacePostgresqlCnpgIoV1NamespacedPublicationRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Publication> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/publications/${params.path.name}`;
    return await this.put<PostgresqlCnpgIoV1Publication>(path, params.query, params.body, opts);
  }
  async deletePostgresqlCnpgIoV1NamespacedPublication(params: DeletePostgresqlCnpgIoV1NamespacedPublicationRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/publications/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchPostgresqlCnpgIoV1NamespacedPublication(params: PatchPostgresqlCnpgIoV1NamespacedPublicationRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Publication> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/publications/${params.path.name}`;
    return await this.patch<PostgresqlCnpgIoV1Publication>(path, params.query, null, opts);
  }
  async readPostgresqlCnpgIoV1NamespacedPublicationStatus(params: ReadPostgresqlCnpgIoV1NamespacedPublicationStatusRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Publication> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/publications/${params.path.name}/status`;
    return await this.get<PostgresqlCnpgIoV1Publication>(path, null, null, opts);
  }
  async replacePostgresqlCnpgIoV1NamespacedPublicationStatus(params: ReplacePostgresqlCnpgIoV1NamespacedPublicationStatusRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Publication> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/publications/${params.path.name}/status`;
    return await this.put<PostgresqlCnpgIoV1Publication>(path, params.query, params.body, opts);
  }
  async patchPostgresqlCnpgIoV1NamespacedPublicationStatus(params: PatchPostgresqlCnpgIoV1NamespacedPublicationStatusRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Publication> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/publications/${params.path.name}/status`;
    return await this.patch<PostgresqlCnpgIoV1Publication>(path, params.query, null, opts);
  }
  async listPostgresqlCnpgIoV1NamespacedScheduledBackup(params: ListPostgresqlCnpgIoV1NamespacedScheduledBackupRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1ScheduledBackupList> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/scheduledbackups`;
    return await this.get<PostgresqlCnpgIoV1ScheduledBackupList>(path, null, null, opts);
  }
  async createPostgresqlCnpgIoV1NamespacedScheduledBackup(params: CreatePostgresqlCnpgIoV1NamespacedScheduledBackupRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1ScheduledBackup> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/scheduledbackups`;
    return await this.post<PostgresqlCnpgIoV1ScheduledBackup>(path, params.query, params.body, opts);
  }
  async deletePostgresqlCnpgIoV1CollectionNamespacedScheduledBackup(params: DeletePostgresqlCnpgIoV1CollectionNamespacedScheduledBackupRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/scheduledbackups`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readPostgresqlCnpgIoV1NamespacedScheduledBackup(params: ReadPostgresqlCnpgIoV1NamespacedScheduledBackupRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1ScheduledBackup> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/scheduledbackups/${params.path.name}`;
    return await this.get<PostgresqlCnpgIoV1ScheduledBackup>(path, null, null, opts);
  }
  async replacePostgresqlCnpgIoV1NamespacedScheduledBackup(params: ReplacePostgresqlCnpgIoV1NamespacedScheduledBackupRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1ScheduledBackup> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/scheduledbackups/${params.path.name}`;
    return await this.put<PostgresqlCnpgIoV1ScheduledBackup>(path, params.query, params.body, opts);
  }
  async deletePostgresqlCnpgIoV1NamespacedScheduledBackup(params: DeletePostgresqlCnpgIoV1NamespacedScheduledBackupRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/scheduledbackups/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchPostgresqlCnpgIoV1NamespacedScheduledBackup(params: PatchPostgresqlCnpgIoV1NamespacedScheduledBackupRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1ScheduledBackup> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/scheduledbackups/${params.path.name}`;
    return await this.patch<PostgresqlCnpgIoV1ScheduledBackup>(path, params.query, null, opts);
  }
  async readPostgresqlCnpgIoV1NamespacedScheduledBackupStatus(params: ReadPostgresqlCnpgIoV1NamespacedScheduledBackupStatusRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1ScheduledBackup> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/scheduledbackups/${params.path.name}/status`;
    return await this.get<PostgresqlCnpgIoV1ScheduledBackup>(path, null, null, opts);
  }
  async replacePostgresqlCnpgIoV1NamespacedScheduledBackupStatus(params: ReplacePostgresqlCnpgIoV1NamespacedScheduledBackupStatusRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1ScheduledBackup> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/scheduledbackups/${params.path.name}/status`;
    return await this.put<PostgresqlCnpgIoV1ScheduledBackup>(path, params.query, params.body, opts);
  }
  async patchPostgresqlCnpgIoV1NamespacedScheduledBackupStatus(params: PatchPostgresqlCnpgIoV1NamespacedScheduledBackupStatusRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1ScheduledBackup> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/scheduledbackups/${params.path.name}/status`;
    return await this.patch<PostgresqlCnpgIoV1ScheduledBackup>(path, params.query, null, opts);
  }
  async listPostgresqlCnpgIoV1NamespacedSubscription(params: ListPostgresqlCnpgIoV1NamespacedSubscriptionRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1SubscriptionList> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/subscriptions`;
    return await this.get<PostgresqlCnpgIoV1SubscriptionList>(path, null, null, opts);
  }
  async createPostgresqlCnpgIoV1NamespacedSubscription(params: CreatePostgresqlCnpgIoV1NamespacedSubscriptionRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Subscription> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/subscriptions`;
    return await this.post<PostgresqlCnpgIoV1Subscription>(path, params.query, params.body, opts);
  }
  async deletePostgresqlCnpgIoV1CollectionNamespacedSubscription(params: DeletePostgresqlCnpgIoV1CollectionNamespacedSubscriptionRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/subscriptions`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readPostgresqlCnpgIoV1NamespacedSubscription(params: ReadPostgresqlCnpgIoV1NamespacedSubscriptionRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Subscription> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/subscriptions/${params.path.name}`;
    return await this.get<PostgresqlCnpgIoV1Subscription>(path, null, null, opts);
  }
  async replacePostgresqlCnpgIoV1NamespacedSubscription(params: ReplacePostgresqlCnpgIoV1NamespacedSubscriptionRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Subscription> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/subscriptions/${params.path.name}`;
    return await this.put<PostgresqlCnpgIoV1Subscription>(path, params.query, params.body, opts);
  }
  async deletePostgresqlCnpgIoV1NamespacedSubscription(params: DeletePostgresqlCnpgIoV1NamespacedSubscriptionRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/subscriptions/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchPostgresqlCnpgIoV1NamespacedSubscription(params: PatchPostgresqlCnpgIoV1NamespacedSubscriptionRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Subscription> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/subscriptions/${params.path.name}`;
    return await this.patch<PostgresqlCnpgIoV1Subscription>(path, params.query, null, opts);
  }
  async readPostgresqlCnpgIoV1NamespacedSubscriptionStatus(params: ReadPostgresqlCnpgIoV1NamespacedSubscriptionStatusRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Subscription> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/subscriptions/${params.path.name}/status`;
    return await this.get<PostgresqlCnpgIoV1Subscription>(path, null, null, opts);
  }
  async replacePostgresqlCnpgIoV1NamespacedSubscriptionStatus(params: ReplacePostgresqlCnpgIoV1NamespacedSubscriptionStatusRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Subscription> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/subscriptions/${params.path.name}/status`;
    return await this.put<PostgresqlCnpgIoV1Subscription>(path, params.query, params.body, opts);
  }
  async patchPostgresqlCnpgIoV1NamespacedSubscriptionStatus(params: PatchPostgresqlCnpgIoV1NamespacedSubscriptionStatusRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Subscription> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/subscriptions/${params.path.name}/status`;
    return await this.patch<PostgresqlCnpgIoV1Subscription>(path, params.query, null, opts);
  }
  async listPostgresqlCnpgIoV1PoolerForAllNamespaces(params: ListPostgresqlCnpgIoV1PoolerForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1PoolerList> {
    const path = `/apis/postgresql.cnpg.io/v1/poolers`;
    return await this.get<PostgresqlCnpgIoV1PoolerList>(path, null, null, opts);
  }
  async listPostgresqlCnpgIoV1PublicationForAllNamespaces(params: ListPostgresqlCnpgIoV1PublicationForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1PublicationList> {
    const path = `/apis/postgresql.cnpg.io/v1/publications`;
    return await this.get<PostgresqlCnpgIoV1PublicationList>(path, null, null, opts);
  }
  async listPostgresqlCnpgIoV1ScheduledBackupForAllNamespaces(params: ListPostgresqlCnpgIoV1ScheduledBackupForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1ScheduledBackupList> {
    const path = `/apis/postgresql.cnpg.io/v1/scheduledbackups`;
    return await this.get<PostgresqlCnpgIoV1ScheduledBackupList>(path, null, null, opts);
  }
  async listPostgresqlCnpgIoV1SubscriptionForAllNamespaces(params: ListPostgresqlCnpgIoV1SubscriptionForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1SubscriptionList> {
    const path = `/apis/postgresql.cnpg.io/v1/subscriptions`;
    return await this.get<PostgresqlCnpgIoV1SubscriptionList>(path, null, null, opts);
  }
  async getRbacAuthorizationAPIGroup(params: GetRbacAuthorizationAPIGroupRequest, opts?: APIClientRequestOpts): Promise<APIGroup> {
    const path = `/apis/rbac.authorization.k8s.io/`;
    return await this.get<APIGroup>(path, null, null, opts);
  }
  async getRbacAuthorizationV1APIResources(params: GetRbacAuthorizationV1APIResourcesRequest, opts?: APIClientRequestOpts): Promise<APIResourceList> {
    const path = `/apis/rbac.authorization.k8s.io/v1/`;
    return await this.get<APIResourceList>(path, null, null, opts);
  }
  async listRbacAuthorizationV1ClusterRoleBinding(params: ListRbacAuthorizationV1ClusterRoleBindingRequest, opts?: APIClientRequestOpts): Promise<RbacAuthorizationK8sIoV1ClusterRoleBindingList> {
    const path = `/apis/rbac.authorization.k8s.io/v1/clusterrolebindings`;
    return await this.get<RbacAuthorizationK8sIoV1ClusterRoleBindingList>(path, null, null, opts);
  }
  async createRbacAuthorizationV1ClusterRoleBinding(params: CreateRbacAuthorizationV1ClusterRoleBindingRequest, opts?: APIClientRequestOpts): Promise<RbacAuthorizationK8sIoV1ClusterRoleBinding> {
    const path = `/apis/rbac.authorization.k8s.io/v1/clusterrolebindings`;
    return await this.post<RbacAuthorizationK8sIoV1ClusterRoleBinding>(path, params.query, params.body, opts);
  }
  async deleteRbacAuthorizationV1CollectionClusterRoleBinding(params: DeleteRbacAuthorizationV1CollectionClusterRoleBindingRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/rbac.authorization.k8s.io/v1/clusterrolebindings`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readRbacAuthorizationV1ClusterRoleBinding(params: ReadRbacAuthorizationV1ClusterRoleBindingRequest, opts?: APIClientRequestOpts): Promise<RbacAuthorizationK8sIoV1ClusterRoleBinding> {
    const path = `/apis/rbac.authorization.k8s.io/v1/clusterrolebindings/${params.path.name}`;
    return await this.get<RbacAuthorizationK8sIoV1ClusterRoleBinding>(path, null, null, opts);
  }
  async replaceRbacAuthorizationV1ClusterRoleBinding(params: ReplaceRbacAuthorizationV1ClusterRoleBindingRequest, opts?: APIClientRequestOpts): Promise<RbacAuthorizationK8sIoV1ClusterRoleBinding> {
    const path = `/apis/rbac.authorization.k8s.io/v1/clusterrolebindings/${params.path.name}`;
    return await this.put<RbacAuthorizationK8sIoV1ClusterRoleBinding>(path, params.query, params.body, opts);
  }
  async deleteRbacAuthorizationV1ClusterRoleBinding(params: DeleteRbacAuthorizationV1ClusterRoleBindingRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/rbac.authorization.k8s.io/v1/clusterrolebindings/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchRbacAuthorizationV1ClusterRoleBinding(params: PatchRbacAuthorizationV1ClusterRoleBindingRequest, opts?: APIClientRequestOpts): Promise<RbacAuthorizationK8sIoV1ClusterRoleBinding> {
    const path = `/apis/rbac.authorization.k8s.io/v1/clusterrolebindings/${params.path.name}`;
    return await this.patch<RbacAuthorizationK8sIoV1ClusterRoleBinding>(path, params.query, null, opts);
  }
  async listRbacAuthorizationV1ClusterRole(params: ListRbacAuthorizationV1ClusterRoleRequest, opts?: APIClientRequestOpts): Promise<RbacAuthorizationK8sIoV1ClusterRoleList> {
    const path = `/apis/rbac.authorization.k8s.io/v1/clusterroles`;
    return await this.get<RbacAuthorizationK8sIoV1ClusterRoleList>(path, null, null, opts);
  }
  async createRbacAuthorizationV1ClusterRole(params: CreateRbacAuthorizationV1ClusterRoleRequest, opts?: APIClientRequestOpts): Promise<RbacAuthorizationK8sIoV1ClusterRole> {
    const path = `/apis/rbac.authorization.k8s.io/v1/clusterroles`;
    return await this.post<RbacAuthorizationK8sIoV1ClusterRole>(path, params.query, params.body, opts);
  }
  async deleteRbacAuthorizationV1CollectionClusterRole(params: DeleteRbacAuthorizationV1CollectionClusterRoleRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/rbac.authorization.k8s.io/v1/clusterroles`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readRbacAuthorizationV1ClusterRole(params: ReadRbacAuthorizationV1ClusterRoleRequest, opts?: APIClientRequestOpts): Promise<RbacAuthorizationK8sIoV1ClusterRole> {
    const path = `/apis/rbac.authorization.k8s.io/v1/clusterroles/${params.path.name}`;
    return await this.get<RbacAuthorizationK8sIoV1ClusterRole>(path, null, null, opts);
  }
  async replaceRbacAuthorizationV1ClusterRole(params: ReplaceRbacAuthorizationV1ClusterRoleRequest, opts?: APIClientRequestOpts): Promise<RbacAuthorizationK8sIoV1ClusterRole> {
    const path = `/apis/rbac.authorization.k8s.io/v1/clusterroles/${params.path.name}`;
    return await this.put<RbacAuthorizationK8sIoV1ClusterRole>(path, params.query, params.body, opts);
  }
  async deleteRbacAuthorizationV1ClusterRole(params: DeleteRbacAuthorizationV1ClusterRoleRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/rbac.authorization.k8s.io/v1/clusterroles/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchRbacAuthorizationV1ClusterRole(params: PatchRbacAuthorizationV1ClusterRoleRequest, opts?: APIClientRequestOpts): Promise<RbacAuthorizationK8sIoV1ClusterRole> {
    const path = `/apis/rbac.authorization.k8s.io/v1/clusterroles/${params.path.name}`;
    return await this.patch<RbacAuthorizationK8sIoV1ClusterRole>(path, params.query, null, opts);
  }
  async listRbacAuthorizationV1NamespacedRoleBinding(params: ListRbacAuthorizationV1NamespacedRoleBindingRequest, opts?: APIClientRequestOpts): Promise<RbacAuthorizationK8sIoV1RoleBindingList> {
    const path = `/apis/rbac.authorization.k8s.io/v1/namespaces/${params.path.namespace}/rolebindings`;
    return await this.get<RbacAuthorizationK8sIoV1RoleBindingList>(path, null, null, opts);
  }
  async createRbacAuthorizationV1NamespacedRoleBinding(params: CreateRbacAuthorizationV1NamespacedRoleBindingRequest, opts?: APIClientRequestOpts): Promise<RbacAuthorizationK8sIoV1RoleBinding> {
    const path = `/apis/rbac.authorization.k8s.io/v1/namespaces/${params.path.namespace}/rolebindings`;
    return await this.post<RbacAuthorizationK8sIoV1RoleBinding>(path, params.query, params.body, opts);
  }
  async deleteRbacAuthorizationV1CollectionNamespacedRoleBinding(params: DeleteRbacAuthorizationV1CollectionNamespacedRoleBindingRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/rbac.authorization.k8s.io/v1/namespaces/${params.path.namespace}/rolebindings`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readRbacAuthorizationV1NamespacedRoleBinding(params: ReadRbacAuthorizationV1NamespacedRoleBindingRequest, opts?: APIClientRequestOpts): Promise<RbacAuthorizationK8sIoV1RoleBinding> {
    const path = `/apis/rbac.authorization.k8s.io/v1/namespaces/${params.path.namespace}/rolebindings/${params.path.name}`;
    return await this.get<RbacAuthorizationK8sIoV1RoleBinding>(path, null, null, opts);
  }
  async replaceRbacAuthorizationV1NamespacedRoleBinding(params: ReplaceRbacAuthorizationV1NamespacedRoleBindingRequest, opts?: APIClientRequestOpts): Promise<RbacAuthorizationK8sIoV1RoleBinding> {
    const path = `/apis/rbac.authorization.k8s.io/v1/namespaces/${params.path.namespace}/rolebindings/${params.path.name}`;
    return await this.put<RbacAuthorizationK8sIoV1RoleBinding>(path, params.query, params.body, opts);
  }
  async deleteRbacAuthorizationV1NamespacedRoleBinding(params: DeleteRbacAuthorizationV1NamespacedRoleBindingRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/rbac.authorization.k8s.io/v1/namespaces/${params.path.namespace}/rolebindings/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchRbacAuthorizationV1NamespacedRoleBinding(params: PatchRbacAuthorizationV1NamespacedRoleBindingRequest, opts?: APIClientRequestOpts): Promise<RbacAuthorizationK8sIoV1RoleBinding> {
    const path = `/apis/rbac.authorization.k8s.io/v1/namespaces/${params.path.namespace}/rolebindings/${params.path.name}`;
    return await this.patch<RbacAuthorizationK8sIoV1RoleBinding>(path, params.query, null, opts);
  }
  async listRbacAuthorizationV1NamespacedRole(params: ListRbacAuthorizationV1NamespacedRoleRequest, opts?: APIClientRequestOpts): Promise<RbacAuthorizationK8sIoV1RoleList> {
    const path = `/apis/rbac.authorization.k8s.io/v1/namespaces/${params.path.namespace}/roles`;
    return await this.get<RbacAuthorizationK8sIoV1RoleList>(path, null, null, opts);
  }
  async createRbacAuthorizationV1NamespacedRole(params: CreateRbacAuthorizationV1NamespacedRoleRequest, opts?: APIClientRequestOpts): Promise<RbacAuthorizationK8sIoV1Role> {
    const path = `/apis/rbac.authorization.k8s.io/v1/namespaces/${params.path.namespace}/roles`;
    return await this.post<RbacAuthorizationK8sIoV1Role>(path, params.query, params.body, opts);
  }
  async deleteRbacAuthorizationV1CollectionNamespacedRole(params: DeleteRbacAuthorizationV1CollectionNamespacedRoleRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/rbac.authorization.k8s.io/v1/namespaces/${params.path.namespace}/roles`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readRbacAuthorizationV1NamespacedRole(params: ReadRbacAuthorizationV1NamespacedRoleRequest, opts?: APIClientRequestOpts): Promise<RbacAuthorizationK8sIoV1Role> {
    const path = `/apis/rbac.authorization.k8s.io/v1/namespaces/${params.path.namespace}/roles/${params.path.name}`;
    return await this.get<RbacAuthorizationK8sIoV1Role>(path, null, null, opts);
  }
  async replaceRbacAuthorizationV1NamespacedRole(params: ReplaceRbacAuthorizationV1NamespacedRoleRequest, opts?: APIClientRequestOpts): Promise<RbacAuthorizationK8sIoV1Role> {
    const path = `/apis/rbac.authorization.k8s.io/v1/namespaces/${params.path.namespace}/roles/${params.path.name}`;
    return await this.put<RbacAuthorizationK8sIoV1Role>(path, params.query, params.body, opts);
  }
  async deleteRbacAuthorizationV1NamespacedRole(params: DeleteRbacAuthorizationV1NamespacedRoleRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/rbac.authorization.k8s.io/v1/namespaces/${params.path.namespace}/roles/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchRbacAuthorizationV1NamespacedRole(params: PatchRbacAuthorizationV1NamespacedRoleRequest, opts?: APIClientRequestOpts): Promise<RbacAuthorizationK8sIoV1Role> {
    const path = `/apis/rbac.authorization.k8s.io/v1/namespaces/${params.path.namespace}/roles/${params.path.name}`;
    return await this.patch<RbacAuthorizationK8sIoV1Role>(path, params.query, null, opts);
  }
  async listRbacAuthorizationV1RoleBindingForAllNamespaces(params: ListRbacAuthorizationV1RoleBindingForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<RbacAuthorizationK8sIoV1RoleBindingList> {
    const path = `/apis/rbac.authorization.k8s.io/v1/rolebindings`;
    return await this.get<RbacAuthorizationK8sIoV1RoleBindingList>(path, null, null, opts);
  }
  async listRbacAuthorizationV1RoleForAllNamespaces(params: ListRbacAuthorizationV1RoleForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<RbacAuthorizationK8sIoV1RoleList> {
    const path = `/apis/rbac.authorization.k8s.io/v1/roles`;
    return await this.get<RbacAuthorizationK8sIoV1RoleList>(path, null, null, opts);
  }
  async watchRbacAuthorizationV1ClusterRoleBindingList(params: WatchRbacAuthorizationV1ClusterRoleBindingListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/rbac.authorization.k8s.io/v1/watch/clusterrolebindings`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchRbacAuthorizationV1ClusterRoleBinding(params: WatchRbacAuthorizationV1ClusterRoleBindingRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/rbac.authorization.k8s.io/v1/watch/clusterrolebindings/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchRbacAuthorizationV1ClusterRoleList(params: WatchRbacAuthorizationV1ClusterRoleListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/rbac.authorization.k8s.io/v1/watch/clusterroles`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchRbacAuthorizationV1ClusterRole(params: WatchRbacAuthorizationV1ClusterRoleRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/rbac.authorization.k8s.io/v1/watch/clusterroles/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchRbacAuthorizationV1NamespacedRoleBindingList(params: WatchRbacAuthorizationV1NamespacedRoleBindingListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/rbac.authorization.k8s.io/v1/watch/namespaces/${params.path.namespace}/rolebindings`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchRbacAuthorizationV1NamespacedRoleBinding(params: WatchRbacAuthorizationV1NamespacedRoleBindingRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/rbac.authorization.k8s.io/v1/watch/namespaces/${params.path.namespace}/rolebindings/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchRbacAuthorizationV1NamespacedRoleList(params: WatchRbacAuthorizationV1NamespacedRoleListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/rbac.authorization.k8s.io/v1/watch/namespaces/${params.path.namespace}/roles`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchRbacAuthorizationV1NamespacedRole(params: WatchRbacAuthorizationV1NamespacedRoleRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/rbac.authorization.k8s.io/v1/watch/namespaces/${params.path.namespace}/roles/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchRbacAuthorizationV1RoleBindingListForAllNamespaces(params: WatchRbacAuthorizationV1RoleBindingListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/rbac.authorization.k8s.io/v1/watch/rolebindings`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchRbacAuthorizationV1RoleListForAllNamespaces(params: WatchRbacAuthorizationV1RoleListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/rbac.authorization.k8s.io/v1/watch/roles`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async getSchedulingAPIGroup(params: GetSchedulingAPIGroupRequest, opts?: APIClientRequestOpts): Promise<APIGroup> {
    const path = `/apis/scheduling.k8s.io/`;
    return await this.get<APIGroup>(path, null, null, opts);
  }
  async getSchedulingV1APIResources(params: GetSchedulingV1APIResourcesRequest, opts?: APIClientRequestOpts): Promise<APIResourceList> {
    const path = `/apis/scheduling.k8s.io/v1/`;
    return await this.get<APIResourceList>(path, null, null, opts);
  }
  async listSchedulingV1PriorityClass(params: ListSchedulingV1PriorityClassRequest, opts?: APIClientRequestOpts): Promise<SchedulingK8sIoV1PriorityClassList> {
    const path = `/apis/scheduling.k8s.io/v1/priorityclasses`;
    return await this.get<SchedulingK8sIoV1PriorityClassList>(path, null, null, opts);
  }
  async createSchedulingV1PriorityClass(params: CreateSchedulingV1PriorityClassRequest, opts?: APIClientRequestOpts): Promise<SchedulingK8sIoV1PriorityClass> {
    const path = `/apis/scheduling.k8s.io/v1/priorityclasses`;
    return await this.post<SchedulingK8sIoV1PriorityClass>(path, params.query, params.body, opts);
  }
  async deleteSchedulingV1CollectionPriorityClass(params: DeleteSchedulingV1CollectionPriorityClassRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/scheduling.k8s.io/v1/priorityclasses`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readSchedulingV1PriorityClass(params: ReadSchedulingV1PriorityClassRequest, opts?: APIClientRequestOpts): Promise<SchedulingK8sIoV1PriorityClass> {
    const path = `/apis/scheduling.k8s.io/v1/priorityclasses/${params.path.name}`;
    return await this.get<SchedulingK8sIoV1PriorityClass>(path, null, null, opts);
  }
  async replaceSchedulingV1PriorityClass(params: ReplaceSchedulingV1PriorityClassRequest, opts?: APIClientRequestOpts): Promise<SchedulingK8sIoV1PriorityClass> {
    const path = `/apis/scheduling.k8s.io/v1/priorityclasses/${params.path.name}`;
    return await this.put<SchedulingK8sIoV1PriorityClass>(path, params.query, params.body, opts);
  }
  async deleteSchedulingV1PriorityClass(params: DeleteSchedulingV1PriorityClassRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/scheduling.k8s.io/v1/priorityclasses/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchSchedulingV1PriorityClass(params: PatchSchedulingV1PriorityClassRequest, opts?: APIClientRequestOpts): Promise<SchedulingK8sIoV1PriorityClass> {
    const path = `/apis/scheduling.k8s.io/v1/priorityclasses/${params.path.name}`;
    return await this.patch<SchedulingK8sIoV1PriorityClass>(path, params.query, null, opts);
  }
  async watchSchedulingV1PriorityClassList(params: WatchSchedulingV1PriorityClassListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/scheduling.k8s.io/v1/watch/priorityclasses`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchSchedulingV1PriorityClass(params: WatchSchedulingV1PriorityClassRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/scheduling.k8s.io/v1/watch/priorityclasses/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async listServingKnativeDevV1ConfigurationForAllNamespaces(params: ListServingKnativeDevV1ConfigurationForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1ConfigurationList> {
    const path = `/apis/serving.knative.dev/v1/configurations`;
    return await this.get<ServingKnativeDevV1ConfigurationList>(path, null, null, opts);
  }
  async listServingKnativeDevV1NamespacedConfiguration(params: ListServingKnativeDevV1NamespacedConfigurationRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1ConfigurationList> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/configurations`;
    return await this.get<ServingKnativeDevV1ConfigurationList>(path, null, null, opts);
  }
  async createServingKnativeDevV1NamespacedConfiguration(params: CreateServingKnativeDevV1NamespacedConfigurationRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1Configuration> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/configurations`;
    return await this.post<ServingKnativeDevV1Configuration>(path, params.query, params.body, opts);
  }
  async deleteServingKnativeDevV1CollectionNamespacedConfiguration(params: DeleteServingKnativeDevV1CollectionNamespacedConfigurationRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/configurations`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readServingKnativeDevV1NamespacedConfiguration(params: ReadServingKnativeDevV1NamespacedConfigurationRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1Configuration> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/configurations/${params.path.name}`;
    return await this.get<ServingKnativeDevV1Configuration>(path, null, null, opts);
  }
  async replaceServingKnativeDevV1NamespacedConfiguration(params: ReplaceServingKnativeDevV1NamespacedConfigurationRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1Configuration> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/configurations/${params.path.name}`;
    return await this.put<ServingKnativeDevV1Configuration>(path, params.query, params.body, opts);
  }
  async deleteServingKnativeDevV1NamespacedConfiguration(params: DeleteServingKnativeDevV1NamespacedConfigurationRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/configurations/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchServingKnativeDevV1NamespacedConfiguration(params: PatchServingKnativeDevV1NamespacedConfigurationRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1Configuration> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/configurations/${params.path.name}`;
    return await this.patch<ServingKnativeDevV1Configuration>(path, params.query, null, opts);
  }
  async readServingKnativeDevV1NamespacedConfigurationStatus(params: ReadServingKnativeDevV1NamespacedConfigurationStatusRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1Configuration> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/configurations/${params.path.name}/status`;
    return await this.get<ServingKnativeDevV1Configuration>(path, null, null, opts);
  }
  async replaceServingKnativeDevV1NamespacedConfigurationStatus(params: ReplaceServingKnativeDevV1NamespacedConfigurationStatusRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1Configuration> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/configurations/${params.path.name}/status`;
    return await this.put<ServingKnativeDevV1Configuration>(path, params.query, params.body, opts);
  }
  async patchServingKnativeDevV1NamespacedConfigurationStatus(params: PatchServingKnativeDevV1NamespacedConfigurationStatusRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1Configuration> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/configurations/${params.path.name}/status`;
    return await this.patch<ServingKnativeDevV1Configuration>(path, params.query, null, opts);
  }
  async listServingKnativeDevV1NamespacedRevision(params: ListServingKnativeDevV1NamespacedRevisionRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1RevisionList> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/revisions`;
    return await this.get<ServingKnativeDevV1RevisionList>(path, null, null, opts);
  }
  async createServingKnativeDevV1NamespacedRevision(params: CreateServingKnativeDevV1NamespacedRevisionRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1Revision> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/revisions`;
    return await this.post<ServingKnativeDevV1Revision>(path, params.query, params.body, opts);
  }
  async deleteServingKnativeDevV1CollectionNamespacedRevision(params: DeleteServingKnativeDevV1CollectionNamespacedRevisionRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/revisions`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readServingKnativeDevV1NamespacedRevision(params: ReadServingKnativeDevV1NamespacedRevisionRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1Revision> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/revisions/${params.path.name}`;
    return await this.get<ServingKnativeDevV1Revision>(path, null, null, opts);
  }
  async replaceServingKnativeDevV1NamespacedRevision(params: ReplaceServingKnativeDevV1NamespacedRevisionRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1Revision> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/revisions/${params.path.name}`;
    return await this.put<ServingKnativeDevV1Revision>(path, params.query, params.body, opts);
  }
  async deleteServingKnativeDevV1NamespacedRevision(params: DeleteServingKnativeDevV1NamespacedRevisionRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/revisions/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchServingKnativeDevV1NamespacedRevision(params: PatchServingKnativeDevV1NamespacedRevisionRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1Revision> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/revisions/${params.path.name}`;
    return await this.patch<ServingKnativeDevV1Revision>(path, params.query, null, opts);
  }
  async readServingKnativeDevV1NamespacedRevisionStatus(params: ReadServingKnativeDevV1NamespacedRevisionStatusRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1Revision> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/revisions/${params.path.name}/status`;
    return await this.get<ServingKnativeDevV1Revision>(path, null, null, opts);
  }
  async replaceServingKnativeDevV1NamespacedRevisionStatus(params: ReplaceServingKnativeDevV1NamespacedRevisionStatusRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1Revision> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/revisions/${params.path.name}/status`;
    return await this.put<ServingKnativeDevV1Revision>(path, params.query, params.body, opts);
  }
  async patchServingKnativeDevV1NamespacedRevisionStatus(params: PatchServingKnativeDevV1NamespacedRevisionStatusRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1Revision> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/revisions/${params.path.name}/status`;
    return await this.patch<ServingKnativeDevV1Revision>(path, params.query, null, opts);
  }
  async listServingKnativeDevV1NamespacedRoute(params: ListServingKnativeDevV1NamespacedRouteRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1RouteList> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/routes`;
    return await this.get<ServingKnativeDevV1RouteList>(path, null, null, opts);
  }
  async createServingKnativeDevV1NamespacedRoute(params: CreateServingKnativeDevV1NamespacedRouteRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1Route> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/routes`;
    return await this.post<ServingKnativeDevV1Route>(path, params.query, params.body, opts);
  }
  async deleteServingKnativeDevV1CollectionNamespacedRoute(params: DeleteServingKnativeDevV1CollectionNamespacedRouteRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/routes`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readServingKnativeDevV1NamespacedRoute(params: ReadServingKnativeDevV1NamespacedRouteRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1Route> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/routes/${params.path.name}`;
    return await this.get<ServingKnativeDevV1Route>(path, null, null, opts);
  }
  async replaceServingKnativeDevV1NamespacedRoute(params: ReplaceServingKnativeDevV1NamespacedRouteRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1Route> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/routes/${params.path.name}`;
    return await this.put<ServingKnativeDevV1Route>(path, params.query, params.body, opts);
  }
  async deleteServingKnativeDevV1NamespacedRoute(params: DeleteServingKnativeDevV1NamespacedRouteRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/routes/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchServingKnativeDevV1NamespacedRoute(params: PatchServingKnativeDevV1NamespacedRouteRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1Route> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/routes/${params.path.name}`;
    return await this.patch<ServingKnativeDevV1Route>(path, params.query, null, opts);
  }
  async readServingKnativeDevV1NamespacedRouteStatus(params: ReadServingKnativeDevV1NamespacedRouteStatusRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1Route> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/routes/${params.path.name}/status`;
    return await this.get<ServingKnativeDevV1Route>(path, null, null, opts);
  }
  async replaceServingKnativeDevV1NamespacedRouteStatus(params: ReplaceServingKnativeDevV1NamespacedRouteStatusRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1Route> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/routes/${params.path.name}/status`;
    return await this.put<ServingKnativeDevV1Route>(path, params.query, params.body, opts);
  }
  async patchServingKnativeDevV1NamespacedRouteStatus(params: PatchServingKnativeDevV1NamespacedRouteStatusRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1Route> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/routes/${params.path.name}/status`;
    return await this.patch<ServingKnativeDevV1Route>(path, params.query, null, opts);
  }
  async listServingKnativeDevV1NamespacedService(params: ListServingKnativeDevV1NamespacedServiceRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1ServiceList> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/services`;
    return await this.get<ServingKnativeDevV1ServiceList>(path, null, null, opts);
  }
  async createServingKnativeDevV1NamespacedService(params: CreateServingKnativeDevV1NamespacedServiceRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1Service> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/services`;
    return await this.post<ServingKnativeDevV1Service>(path, params.query, params.body, opts);
  }
  async deleteServingKnativeDevV1CollectionNamespacedService(params: DeleteServingKnativeDevV1CollectionNamespacedServiceRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/services`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readServingKnativeDevV1NamespacedService(params: ReadServingKnativeDevV1NamespacedServiceRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1Service> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/services/${params.path.name}`;
    return await this.get<ServingKnativeDevV1Service>(path, null, null, opts);
  }
  async replaceServingKnativeDevV1NamespacedService(params: ReplaceServingKnativeDevV1NamespacedServiceRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1Service> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/services/${params.path.name}`;
    return await this.put<ServingKnativeDevV1Service>(path, params.query, params.body, opts);
  }
  async deleteServingKnativeDevV1NamespacedService(params: DeleteServingKnativeDevV1NamespacedServiceRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/services/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchServingKnativeDevV1NamespacedService(params: PatchServingKnativeDevV1NamespacedServiceRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1Service> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/services/${params.path.name}`;
    return await this.patch<ServingKnativeDevV1Service>(path, params.query, null, opts);
  }
  async readServingKnativeDevV1NamespacedServiceStatus(params: ReadServingKnativeDevV1NamespacedServiceStatusRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1Service> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/services/${params.path.name}/status`;
    return await this.get<ServingKnativeDevV1Service>(path, null, null, opts);
  }
  async replaceServingKnativeDevV1NamespacedServiceStatus(params: ReplaceServingKnativeDevV1NamespacedServiceStatusRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1Service> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/services/${params.path.name}/status`;
    return await this.put<ServingKnativeDevV1Service>(path, params.query, params.body, opts);
  }
  async patchServingKnativeDevV1NamespacedServiceStatus(params: PatchServingKnativeDevV1NamespacedServiceStatusRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1Service> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/services/${params.path.name}/status`;
    return await this.patch<ServingKnativeDevV1Service>(path, params.query, null, opts);
  }
  async listServingKnativeDevV1RevisionForAllNamespaces(params: ListServingKnativeDevV1RevisionForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1RevisionList> {
    const path = `/apis/serving.knative.dev/v1/revisions`;
    return await this.get<ServingKnativeDevV1RevisionList>(path, null, null, opts);
  }
  async listServingKnativeDevV1RouteForAllNamespaces(params: ListServingKnativeDevV1RouteForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1RouteList> {
    const path = `/apis/serving.knative.dev/v1/routes`;
    return await this.get<ServingKnativeDevV1RouteList>(path, null, null, opts);
  }
  async listServingKnativeDevV1ServiceForAllNamespaces(params: ListServingKnativeDevV1ServiceForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1ServiceList> {
    const path = `/apis/serving.knative.dev/v1/services`;
    return await this.get<ServingKnativeDevV1ServiceList>(path, null, null, opts);
  }
  async getStorageAPIGroup(params: GetStorageAPIGroupRequest, opts?: APIClientRequestOpts): Promise<APIGroup> {
    const path = `/apis/storage.k8s.io/`;
    return await this.get<APIGroup>(path, null, null, opts);
  }
  async getStorageV1APIResources(params: GetStorageV1APIResourcesRequest, opts?: APIClientRequestOpts): Promise<APIResourceList> {
    const path = `/apis/storage.k8s.io/v1/`;
    return await this.get<APIResourceList>(path, null, null, opts);
  }
  async listStorageV1CSIDriver(params: ListStorageV1CSIDriverRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1CSIDriverList> {
    const path = `/apis/storage.k8s.io/v1/csidrivers`;
    return await this.get<StorageK8sIoV1CSIDriverList>(path, null, null, opts);
  }
  async createStorageV1CSIDriver(params: CreateStorageV1CSIDriverRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1CSIDriver> {
    const path = `/apis/storage.k8s.io/v1/csidrivers`;
    return await this.post<StorageK8sIoV1CSIDriver>(path, params.query, params.body, opts);
  }
  async deleteStorageV1CollectionCSIDriver(params: DeleteStorageV1CollectionCSIDriverRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/storage.k8s.io/v1/csidrivers`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readStorageV1CSIDriver(params: ReadStorageV1CSIDriverRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1CSIDriver> {
    const path = `/apis/storage.k8s.io/v1/csidrivers/${params.path.name}`;
    return await this.get<StorageK8sIoV1CSIDriver>(path, null, null, opts);
  }
  async replaceStorageV1CSIDriver(params: ReplaceStorageV1CSIDriverRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1CSIDriver> {
    const path = `/apis/storage.k8s.io/v1/csidrivers/${params.path.name}`;
    return await this.put<StorageK8sIoV1CSIDriver>(path, params.query, params.body, opts);
  }
  async deleteStorageV1CSIDriver(params: DeleteStorageV1CSIDriverRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1CSIDriver> {
    const path = `/apis/storage.k8s.io/v1/csidrivers/${params.path.name}`;
    return await this.delete<StorageK8sIoV1CSIDriver>(path, params.query, null, opts);
  }
  async patchStorageV1CSIDriver(params: PatchStorageV1CSIDriverRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1CSIDriver> {
    const path = `/apis/storage.k8s.io/v1/csidrivers/${params.path.name}`;
    return await this.patch<StorageK8sIoV1CSIDriver>(path, params.query, null, opts);
  }
  async listStorageV1CSINode(params: ListStorageV1CSINodeRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1CSINodeList> {
    const path = `/apis/storage.k8s.io/v1/csinodes`;
    return await this.get<StorageK8sIoV1CSINodeList>(path, null, null, opts);
  }
  async createStorageV1CSINode(params: CreateStorageV1CSINodeRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1CSINode> {
    const path = `/apis/storage.k8s.io/v1/csinodes`;
    return await this.post<StorageK8sIoV1CSINode>(path, params.query, params.body, opts);
  }
  async deleteStorageV1CollectionCSINode(params: DeleteStorageV1CollectionCSINodeRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/storage.k8s.io/v1/csinodes`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readStorageV1CSINode(params: ReadStorageV1CSINodeRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1CSINode> {
    const path = `/apis/storage.k8s.io/v1/csinodes/${params.path.name}`;
    return await this.get<StorageK8sIoV1CSINode>(path, null, null, opts);
  }
  async replaceStorageV1CSINode(params: ReplaceStorageV1CSINodeRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1CSINode> {
    const path = `/apis/storage.k8s.io/v1/csinodes/${params.path.name}`;
    return await this.put<StorageK8sIoV1CSINode>(path, params.query, params.body, opts);
  }
  async deleteStorageV1CSINode(params: DeleteStorageV1CSINodeRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1CSINode> {
    const path = `/apis/storage.k8s.io/v1/csinodes/${params.path.name}`;
    return await this.delete<StorageK8sIoV1CSINode>(path, params.query, null, opts);
  }
  async patchStorageV1CSINode(params: PatchStorageV1CSINodeRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1CSINode> {
    const path = `/apis/storage.k8s.io/v1/csinodes/${params.path.name}`;
    return await this.patch<StorageK8sIoV1CSINode>(path, params.query, null, opts);
  }
  async listStorageV1CSIStorageCapacityForAllNamespaces(params: ListStorageV1CSIStorageCapacityForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1CSIStorageCapacityList> {
    const path = `/apis/storage.k8s.io/v1/csistoragecapacities`;
    return await this.get<StorageK8sIoV1CSIStorageCapacityList>(path, null, null, opts);
  }
  async listStorageV1NamespacedCSIStorageCapacity(params: ListStorageV1NamespacedCSIStorageCapacityRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1CSIStorageCapacityList> {
    const path = `/apis/storage.k8s.io/v1/namespaces/${params.path.namespace}/csistoragecapacities`;
    return await this.get<StorageK8sIoV1CSIStorageCapacityList>(path, null, null, opts);
  }
  async createStorageV1NamespacedCSIStorageCapacity(params: CreateStorageV1NamespacedCSIStorageCapacityRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1CSIStorageCapacity> {
    const path = `/apis/storage.k8s.io/v1/namespaces/${params.path.namespace}/csistoragecapacities`;
    return await this.post<StorageK8sIoV1CSIStorageCapacity>(path, params.query, params.body, opts);
  }
  async deleteStorageV1CollectionNamespacedCSIStorageCapacity(params: DeleteStorageV1CollectionNamespacedCSIStorageCapacityRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/storage.k8s.io/v1/namespaces/${params.path.namespace}/csistoragecapacities`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readStorageV1NamespacedCSIStorageCapacity(params: ReadStorageV1NamespacedCSIStorageCapacityRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1CSIStorageCapacity> {
    const path = `/apis/storage.k8s.io/v1/namespaces/${params.path.namespace}/csistoragecapacities/${params.path.name}`;
    return await this.get<StorageK8sIoV1CSIStorageCapacity>(path, null, null, opts);
  }
  async replaceStorageV1NamespacedCSIStorageCapacity(params: ReplaceStorageV1NamespacedCSIStorageCapacityRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1CSIStorageCapacity> {
    const path = `/apis/storage.k8s.io/v1/namespaces/${params.path.namespace}/csistoragecapacities/${params.path.name}`;
    return await this.put<StorageK8sIoV1CSIStorageCapacity>(path, params.query, params.body, opts);
  }
  async deleteStorageV1NamespacedCSIStorageCapacity(params: DeleteStorageV1NamespacedCSIStorageCapacityRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/storage.k8s.io/v1/namespaces/${params.path.namespace}/csistoragecapacities/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchStorageV1NamespacedCSIStorageCapacity(params: PatchStorageV1NamespacedCSIStorageCapacityRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1CSIStorageCapacity> {
    const path = `/apis/storage.k8s.io/v1/namespaces/${params.path.namespace}/csistoragecapacities/${params.path.name}`;
    return await this.patch<StorageK8sIoV1CSIStorageCapacity>(path, params.query, null, opts);
  }
  async listStorageV1StorageClass(params: ListStorageV1StorageClassRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1StorageClassList> {
    const path = `/apis/storage.k8s.io/v1/storageclasses`;
    return await this.get<StorageK8sIoV1StorageClassList>(path, null, null, opts);
  }
  async createStorageV1StorageClass(params: CreateStorageV1StorageClassRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1StorageClass> {
    const path = `/apis/storage.k8s.io/v1/storageclasses`;
    return await this.post<StorageK8sIoV1StorageClass>(path, params.query, params.body, opts);
  }
  async deleteStorageV1CollectionStorageClass(params: DeleteStorageV1CollectionStorageClassRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/storage.k8s.io/v1/storageclasses`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readStorageV1StorageClass(params: ReadStorageV1StorageClassRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1StorageClass> {
    const path = `/apis/storage.k8s.io/v1/storageclasses/${params.path.name}`;
    return await this.get<StorageK8sIoV1StorageClass>(path, null, null, opts);
  }
  async replaceStorageV1StorageClass(params: ReplaceStorageV1StorageClassRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1StorageClass> {
    const path = `/apis/storage.k8s.io/v1/storageclasses/${params.path.name}`;
    return await this.put<StorageK8sIoV1StorageClass>(path, params.query, params.body, opts);
  }
  async deleteStorageV1StorageClass(params: DeleteStorageV1StorageClassRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1StorageClass> {
    const path = `/apis/storage.k8s.io/v1/storageclasses/${params.path.name}`;
    return await this.delete<StorageK8sIoV1StorageClass>(path, params.query, null, opts);
  }
  async patchStorageV1StorageClass(params: PatchStorageV1StorageClassRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1StorageClass> {
    const path = `/apis/storage.k8s.io/v1/storageclasses/${params.path.name}`;
    return await this.patch<StorageK8sIoV1StorageClass>(path, params.query, null, opts);
  }
  async listStorageV1VolumeAttachment(params: ListStorageV1VolumeAttachmentRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1VolumeAttachmentList> {
    const path = `/apis/storage.k8s.io/v1/volumeattachments`;
    return await this.get<StorageK8sIoV1VolumeAttachmentList>(path, null, null, opts);
  }
  async createStorageV1VolumeAttachment(params: CreateStorageV1VolumeAttachmentRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1VolumeAttachment> {
    const path = `/apis/storage.k8s.io/v1/volumeattachments`;
    return await this.post<StorageK8sIoV1VolumeAttachment>(path, params.query, params.body, opts);
  }
  async deleteStorageV1CollectionVolumeAttachment(params: DeleteStorageV1CollectionVolumeAttachmentRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/storage.k8s.io/v1/volumeattachments`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readStorageV1VolumeAttachment(params: ReadStorageV1VolumeAttachmentRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1VolumeAttachment> {
    const path = `/apis/storage.k8s.io/v1/volumeattachments/${params.path.name}`;
    return await this.get<StorageK8sIoV1VolumeAttachment>(path, null, null, opts);
  }
  async replaceStorageV1VolumeAttachment(params: ReplaceStorageV1VolumeAttachmentRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1VolumeAttachment> {
    const path = `/apis/storage.k8s.io/v1/volumeattachments/${params.path.name}`;
    return await this.put<StorageK8sIoV1VolumeAttachment>(path, params.query, params.body, opts);
  }
  async deleteStorageV1VolumeAttachment(params: DeleteStorageV1VolumeAttachmentRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1VolumeAttachment> {
    const path = `/apis/storage.k8s.io/v1/volumeattachments/${params.path.name}`;
    return await this.delete<StorageK8sIoV1VolumeAttachment>(path, params.query, null, opts);
  }
  async patchStorageV1VolumeAttachment(params: PatchStorageV1VolumeAttachmentRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1VolumeAttachment> {
    const path = `/apis/storage.k8s.io/v1/volumeattachments/${params.path.name}`;
    return await this.patch<StorageK8sIoV1VolumeAttachment>(path, params.query, null, opts);
  }
  async readStorageV1VolumeAttachmentStatus(params: ReadStorageV1VolumeAttachmentStatusRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1VolumeAttachment> {
    const path = `/apis/storage.k8s.io/v1/volumeattachments/${params.path.name}/status`;
    return await this.get<StorageK8sIoV1VolumeAttachment>(path, null, null, opts);
  }
  async replaceStorageV1VolumeAttachmentStatus(params: ReplaceStorageV1VolumeAttachmentStatusRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1VolumeAttachment> {
    const path = `/apis/storage.k8s.io/v1/volumeattachments/${params.path.name}/status`;
    return await this.put<StorageK8sIoV1VolumeAttachment>(path, params.query, params.body, opts);
  }
  async patchStorageV1VolumeAttachmentStatus(params: PatchStorageV1VolumeAttachmentStatusRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1VolumeAttachment> {
    const path = `/apis/storage.k8s.io/v1/volumeattachments/${params.path.name}/status`;
    return await this.patch<StorageK8sIoV1VolumeAttachment>(path, params.query, null, opts);
  }
  async watchStorageV1CSIDriverList(params: WatchStorageV1CSIDriverListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/storage.k8s.io/v1/watch/csidrivers`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchStorageV1CSIDriver(params: WatchStorageV1CSIDriverRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/storage.k8s.io/v1/watch/csidrivers/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchStorageV1CSINodeList(params: WatchStorageV1CSINodeListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/storage.k8s.io/v1/watch/csinodes`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchStorageV1CSINode(params: WatchStorageV1CSINodeRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/storage.k8s.io/v1/watch/csinodes/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchStorageV1CSIStorageCapacityListForAllNamespaces(params: WatchStorageV1CSIStorageCapacityListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/storage.k8s.io/v1/watch/csistoragecapacities`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchStorageV1NamespacedCSIStorageCapacityList(params: WatchStorageV1NamespacedCSIStorageCapacityListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/storage.k8s.io/v1/watch/namespaces/${params.path.namespace}/csistoragecapacities`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchStorageV1NamespacedCSIStorageCapacity(params: WatchStorageV1NamespacedCSIStorageCapacityRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/storage.k8s.io/v1/watch/namespaces/${params.path.namespace}/csistoragecapacities/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchStorageV1StorageClassList(params: WatchStorageV1StorageClassListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/storage.k8s.io/v1/watch/storageclasses`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchStorageV1StorageClass(params: WatchStorageV1StorageClassRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/storage.k8s.io/v1/watch/storageclasses/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchStorageV1VolumeAttachmentList(params: WatchStorageV1VolumeAttachmentListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/storage.k8s.io/v1/watch/volumeattachments`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchStorageV1VolumeAttachment(params: WatchStorageV1VolumeAttachmentRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/storage.k8s.io/v1/watch/volumeattachments/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async getServiceAccountIssuerOpenIDKeyset(params: GetServiceAccountIssuerOpenIDKeysetRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/openid/v1/jwks/`;
    return await this.get<string>(path, null, null, opts);
  }
  async getCodeVersion(params: GetCodeVersionRequest, opts?: APIClientRequestOpts): Promise<Info> {
    const path = `/version/`;
    return await this.get<Info>(path, null, null, opts);
  }
}
export interface GVK {
  group: string;
  version: string;
  kind: string;
}
export interface ResourceTypeMap {
  "core/v1/ComponentStatus": ComponentStatus;
  "core/v1/ConfigMap": ConfigMap;
  "core/v1/Endpoints": Endpoints;
  "core/v1/Event": Event;
  "core/v1/LimitRange": LimitRange;
  "core/v1/Namespace": Namespace;
  "core/v1/Binding": Binding;
  "core/v1/Status": Status;
  "core/v1/PersistentVolumeClaim": PersistentVolumeClaim;
  "core/v1/Pod": Pod;
  "core/v1/PodTemplate": PodTemplate;
  "core/v1/ReplicationController": ReplicationController;
  "core/v1/ResourceQuota": ResourceQuota;
  "core/v1/Secret": Secret;
  "core/v1/ServiceAccount": ServiceAccount;
  "core/v1/Service": Service;
  "core/v1/Node": Node;
  "core/v1/PersistentVolume": PersistentVolume;
  "acme.cert-manager.io/v1/Challenge": AcmeCertManagerIoV1Challenge;
  "acme.cert-manager.io/v1/Order": AcmeCertManagerIoV1Order;
  "admissionregistration.k8s.io/v1/MutatingWebhookConfiguration": AdmissionregistrationK8sIoV1MutatingWebhookConfiguration;
  "admissionregistration.k8s.io/v1/ValidatingAdmissionPolicy": AdmissionregistrationK8sIoV1ValidatingAdmissionPolicy;
  "admissionregistration.k8s.io/v1/ValidatingAdmissionPolicyBinding": AdmissionregistrationK8sIoV1ValidatingAdmissionPolicyBinding;
  "admissionregistration.k8s.io/v1/ValidatingWebhookConfiguration": AdmissionregistrationK8sIoV1ValidatingWebhookConfiguration;
  "apiextensions.k8s.io/v1/CustomResourceDefinition": ApiextensionsK8sIoV1CustomResourceDefinition;
  "apiregistration.k8s.io/v1/APIService": ApiregistrationK8sIoV1APIService;
  "apps/v1/ControllerRevision": AppsV1ControllerRevision;
  "apps/v1/DaemonSet": AppsV1DaemonSet;
  "apps/v1/Deployment": AppsV1Deployment;
  "apps/v1/ReplicaSet": AppsV1ReplicaSet;
  "apps/v1/StatefulSet": AppsV1StatefulSet;
  "autoscaling.internal.knative.dev/v1alpha1/Metric": AutoscalingInternalKnativeDevV1alpha1Metric;
  "autoscaling.internal.knative.dev/v1alpha1/PodAutoscaler": AutoscalingInternalKnativeDevV1alpha1PodAutoscaler;
  "autoscaling/v1/HorizontalPodAutoscaler": AutoscalingV1HorizontalPodAutoscaler;
  "autoscaling/v2/HorizontalPodAutoscaler": AutoscalingV2HorizontalPodAutoscaler;
  "batch/v1/CronJob": BatchV1CronJob;
  "batch/v1/Job": BatchV1Job;
  "caching.internal.knative.dev/v1alpha1/Image": CachingInternalKnativeDevV1alpha1Image;
  "cert-manager.io/v1/ClusterIssuer": CertManagerIoV1ClusterIssuer;
  "cert-manager.io/v1/CertificateRequest": CertManagerIoV1CertificateRequest;
  "cert-manager.io/v1/Certificate": CertManagerIoV1Certificate;
  "cert-manager.io/v1/Issuer": CertManagerIoV1Issuer;
  "certificates.k8s.io/v1/CertificateSigningRequest": CertificatesK8sIoV1CertificateSigningRequest;
  "coordination.k8s.io/v1/Lease": CoordinationK8sIoV1Lease;
  "discovery.k8s.io/v1/EndpointSlice": DiscoveryK8sIoV1EndpointSlice;
  "events.k8s.io/v1/Event": EventsK8sIoV1Event;
  "flowcontrol.apiserver.k8s.io/v1/FlowSchema": FlowcontrolApiserverK8sIoV1FlowSchema;
  "flowcontrol.apiserver.k8s.io/v1/PriorityLevelConfiguration": FlowcontrolApiserverK8sIoV1PriorityLevelConfiguration;
  "monitoring.coreos.com/v1/Alertmanager": MonitoringCoreosComV1Alertmanager;
  "monitoring.coreos.com/v1/PodMonitor": MonitoringCoreosComV1PodMonitor;
  "monitoring.coreos.com/v1/Probe": MonitoringCoreosComV1Probe;
  "monitoring.coreos.com/v1/Prometheus": MonitoringCoreosComV1Prometheus;
  "monitoring.coreos.com/v1/PrometheusRule": MonitoringCoreosComV1PrometheusRule;
  "monitoring.coreos.com/v1/ServiceMonitor": MonitoringCoreosComV1ServiceMonitor;
  "monitoring.coreos.com/v1/ThanosRuler": MonitoringCoreosComV1ThanosRuler;
  "monitoring.coreos.com/v1alpha1/AlertmanagerConfig": MonitoringCoreosComV1alpha1AlertmanagerConfig;
  "monitoring.coreos.com/v1alpha1/PrometheusAgent": MonitoringCoreosComV1alpha1PrometheusAgent;
  "monitoring.coreos.com/v1alpha1/ScrapeConfig": MonitoringCoreosComV1alpha1ScrapeConfig;
  "networking.internal.knative.dev/v1alpha1/ClusterDomainClaim": NetworkingInternalKnativeDevV1alpha1ClusterDomainClaim;
  "networking.internal.knative.dev/v1alpha1/Certificate": NetworkingInternalKnativeDevV1alpha1Certificate;
  "networking.internal.knative.dev/v1alpha1/Ingress": NetworkingInternalKnativeDevV1alpha1Ingress;
  "networking.internal.knative.dev/v1alpha1/ServerlessService": NetworkingInternalKnativeDevV1alpha1ServerlessService;
  "networking.k8s.io/v1/IngressClass": NetworkingK8sIoV1IngressClass;
  "networking.k8s.io/v1/Ingress": NetworkingK8sIoV1Ingress;
  "networking.k8s.io/v1/NetworkPolicy": NetworkingK8sIoV1NetworkPolicy;
  "node.k8s.io/v1/RuntimeClass": NodeK8sIoV1RuntimeClass;
  "policy/v1/PodDisruptionBudget": PolicyV1PodDisruptionBudget;
  "postgresql.cnpg.io/v1/ClusterImageCatalog": PostgresqlCnpgIoV1ClusterImageCatalog;
  "postgresql.cnpg.io/v1/Backup": PostgresqlCnpgIoV1Backup;
  "postgresql.cnpg.io/v1/Cluster": PostgresqlCnpgIoV1Cluster;
  "postgresql.cnpg.io/v1/Database": PostgresqlCnpgIoV1Database;
  "postgresql.cnpg.io/v1/ImageCatalog": PostgresqlCnpgIoV1ImageCatalog;
  "postgresql.cnpg.io/v1/Pooler": PostgresqlCnpgIoV1Pooler;
  "postgresql.cnpg.io/v1/Publication": PostgresqlCnpgIoV1Publication;
  "postgresql.cnpg.io/v1/ScheduledBackup": PostgresqlCnpgIoV1ScheduledBackup;
  "postgresql.cnpg.io/v1/Subscription": PostgresqlCnpgIoV1Subscription;
  "rbac.authorization.k8s.io/v1/ClusterRoleBinding": RbacAuthorizationK8sIoV1ClusterRoleBinding;
  "rbac.authorization.k8s.io/v1/ClusterRole": RbacAuthorizationK8sIoV1ClusterRole;
  "rbac.authorization.k8s.io/v1/RoleBinding": RbacAuthorizationK8sIoV1RoleBinding;
  "rbac.authorization.k8s.io/v1/Role": RbacAuthorizationK8sIoV1Role;
  "scheduling.k8s.io/v1/PriorityClass": SchedulingK8sIoV1PriorityClass;
  "serving.knative.dev/v1/Configuration": ServingKnativeDevV1Configuration;
  "serving.knative.dev/v1/Revision": ServingKnativeDevV1Revision;
  "serving.knative.dev/v1/Route": ServingKnativeDevV1Route;
  "serving.knative.dev/v1/Service": ServingKnativeDevV1Service;
  "storage.k8s.io/v1/CSIDriver": StorageK8sIoV1CSIDriver;
  "storage.k8s.io/v1/CSINode": StorageK8sIoV1CSINode;
  "storage.k8s.io/v1/CSIStorageCapacity": StorageK8sIoV1CSIStorageCapacity;
  "storage.k8s.io/v1/StorageClass": StorageK8sIoV1StorageClass;
  "storage.k8s.io/v1/VolumeAttachment": StorageK8sIoV1VolumeAttachment;
  "policy/v1/Eviction": PolicyV1Eviction;
  "autoscaling/v1/Scale": AutoscalingV1Scale;
  "authentication.k8s.io/v1/TokenRequest": AuthenticationK8sIoV1TokenRequest;
  "authentication.k8s.io/v1/SelfSubjectReview": AuthenticationK8sIoV1SelfSubjectReview;
  "authentication.k8s.io/v1/TokenReview": AuthenticationK8sIoV1TokenReview;
  "authorization.k8s.io/v1/LocalSubjectAccessReview": AuthorizationK8sIoV1LocalSubjectAccessReview;
  "authorization.k8s.io/v1/SelfSubjectAccessReview": AuthorizationK8sIoV1SelfSubjectAccessReview;
  "authorization.k8s.io/v1/SelfSubjectRulesReview": AuthorizationK8sIoV1SelfSubjectRulesReview;
  "authorization.k8s.io/v1/SubjectAccessReview": AuthorizationK8sIoV1SubjectAccessReview;
}
export type KubernetesResource = ComponentStatus | ConfigMap | Endpoints | Event | LimitRange | Namespace | Binding | Status | PersistentVolumeClaim | Pod | PodTemplate | ReplicationController | ResourceQuota | Secret | ServiceAccount | Service | Node | PersistentVolume | AcmeCertManagerIoV1Challenge | AcmeCertManagerIoV1Order | AdmissionregistrationK8sIoV1MutatingWebhookConfiguration | AdmissionregistrationK8sIoV1ValidatingAdmissionPolicy | AdmissionregistrationK8sIoV1ValidatingAdmissionPolicyBinding | AdmissionregistrationK8sIoV1ValidatingWebhookConfiguration | ApiextensionsK8sIoV1CustomResourceDefinition | ApiregistrationK8sIoV1APIService | AppsV1ControllerRevision | AppsV1DaemonSet | AppsV1Deployment | AppsV1ReplicaSet | AppsV1StatefulSet | AutoscalingInternalKnativeDevV1alpha1Metric | AutoscalingInternalKnativeDevV1alpha1PodAutoscaler | AutoscalingV1HorizontalPodAutoscaler | AutoscalingV2HorizontalPodAutoscaler | BatchV1CronJob | BatchV1Job | CachingInternalKnativeDevV1alpha1Image | CertManagerIoV1ClusterIssuer | CertManagerIoV1CertificateRequest | CertManagerIoV1Certificate | CertManagerIoV1Issuer | CertificatesK8sIoV1CertificateSigningRequest | CoordinationK8sIoV1Lease | DiscoveryK8sIoV1EndpointSlice | EventsK8sIoV1Event | FlowcontrolApiserverK8sIoV1FlowSchema | FlowcontrolApiserverK8sIoV1PriorityLevelConfiguration | MonitoringCoreosComV1Alertmanager | MonitoringCoreosComV1PodMonitor | MonitoringCoreosComV1Probe | MonitoringCoreosComV1Prometheus | MonitoringCoreosComV1PrometheusRule | MonitoringCoreosComV1ServiceMonitor | MonitoringCoreosComV1ThanosRuler | MonitoringCoreosComV1alpha1AlertmanagerConfig | MonitoringCoreosComV1alpha1PrometheusAgent | MonitoringCoreosComV1alpha1ScrapeConfig | NetworkingInternalKnativeDevV1alpha1ClusterDomainClaim | NetworkingInternalKnativeDevV1alpha1Certificate | NetworkingInternalKnativeDevV1alpha1Ingress | NetworkingInternalKnativeDevV1alpha1ServerlessService | NetworkingK8sIoV1IngressClass | NetworkingK8sIoV1Ingress | NetworkingK8sIoV1NetworkPolicy | NodeK8sIoV1RuntimeClass | PolicyV1PodDisruptionBudget | PostgresqlCnpgIoV1ClusterImageCatalog | PostgresqlCnpgIoV1Backup | PostgresqlCnpgIoV1Cluster | PostgresqlCnpgIoV1Database | PostgresqlCnpgIoV1ImageCatalog | PostgresqlCnpgIoV1Pooler | PostgresqlCnpgIoV1Publication | PostgresqlCnpgIoV1ScheduledBackup | PostgresqlCnpgIoV1Subscription | RbacAuthorizationK8sIoV1ClusterRoleBinding | RbacAuthorizationK8sIoV1ClusterRole | RbacAuthorizationK8sIoV1RoleBinding | RbacAuthorizationK8sIoV1Role | SchedulingK8sIoV1PriorityClass | ServingKnativeDevV1Configuration | ServingKnativeDevV1Revision | ServingKnativeDevV1Route | ServingKnativeDevV1Service | StorageK8sIoV1CSIDriver | StorageK8sIoV1CSINode | StorageK8sIoV1CSIStorageCapacity | StorageK8sIoV1StorageClass | StorageK8sIoV1VolumeAttachment | PolicyV1Eviction | AutoscalingV1Scale | AuthenticationK8sIoV1TokenRequest | AuthenticationK8sIoV1SelfSubjectReview | AuthenticationK8sIoV1TokenReview | AuthorizationK8sIoV1LocalSubjectAccessReview | AuthorizationK8sIoV1SelfSubjectAccessReview | AuthorizationK8sIoV1SelfSubjectRulesReview | AuthorizationK8sIoV1SubjectAccessReview;