import { APIClient, APIClientRequestOpts, APIClientOptions } from "@interweb/fetch-api-client";
/* com.coreos.monitoring.v1.Alertmanager */
/* The `Alertmanager` custom resource definition (CRD) defines a desired [Alertmanager](https://prometheus.io/docs/alerting) setup to run in a Kubernetes cluster. It allows to specify many options such as the number of replicas, persistent storage and many more.

For each `Alertmanager` resource, the Operator deploys a `StatefulSet` in the same namespace. When there are two or more configured replicas, the Operator runs the Alertmanager instances in high-availability mode.

The resource defines via label and namespace selectors which `AlertmanagerConfig` objects should be associated to the deployed Alertmanager instances. */
export interface MonitoringCoreosComV1Alertmanager {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec: {
    additionalArgs?: {
      name: string;
      value?: string;
    }[];
    additionalPeers?: string[];
    affinity?: {
      nodeAffinity?: {
        preferredDuringSchedulingIgnoredDuringExecution?: {
          preference: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchFields?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
          };
          weight: number;
        }[];
        requiredDuringSchedulingIgnoredDuringExecution?: {
          nodeSelectorTerms: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchFields?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
          }[];
        };
      };
      podAffinity?: {
        preferredDuringSchedulingIgnoredDuringExecution?: {
          podAffinityTerm: {
            labelSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            matchLabelKeys?: string[];
            mismatchLabelKeys?: string[];
            namespaceSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            namespaces?: string[];
            topologyKey: string;
          };
          weight: number;
        }[];
        requiredDuringSchedulingIgnoredDuringExecution?: {
          labelSelector?: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchLabels?: {
              [key: string]: unknown;
            };
          };
          matchLabelKeys?: string[];
          mismatchLabelKeys?: string[];
          namespaceSelector?: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchLabels?: {
              [key: string]: unknown;
            };
          };
          namespaces?: string[];
          topologyKey: string;
        }[];
      };
      podAntiAffinity?: {
        preferredDuringSchedulingIgnoredDuringExecution?: {
          podAffinityTerm: {
            labelSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            matchLabelKeys?: string[];
            mismatchLabelKeys?: string[];
            namespaceSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            namespaces?: string[];
            topologyKey: string;
          };
          weight: number;
        }[];
        requiredDuringSchedulingIgnoredDuringExecution?: {
          labelSelector?: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchLabels?: {
              [key: string]: unknown;
            };
          };
          matchLabelKeys?: string[];
          mismatchLabelKeys?: string[];
          namespaceSelector?: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchLabels?: {
              [key: string]: unknown;
            };
          };
          namespaces?: string[];
          topologyKey: string;
        }[];
      };
    };
    alertmanagerConfigMatcherStrategy?: {
      type?: "OnNamespace" | "OnNamespaceExceptForAlertmanagerNamespace" | "None";
    };
    alertmanagerConfigNamespaceSelector?: {
      matchExpressions?: {
        key: string;
        operator: string;
        values?: string[];
      }[];
      matchLabels?: {
        [key: string]: unknown;
      };
    };
    alertmanagerConfigSelector?: {
      matchExpressions?: {
        key: string;
        operator: string;
        values?: string[];
      }[];
      matchLabels?: {
        [key: string]: unknown;
      };
    };
    alertmanagerConfiguration?: {
      global?: {
        httpConfig?: {
          authorization?: {
            credentials?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            type?: string;
          };
          basicAuth?: {
            password?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            username?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          bearerTokenSecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          followRedirects?: boolean;
          noProxy?: string;
          oauth2?: {
            clientId: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            clientSecret: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            endpointParams?: {
              [key: string]: unknown;
            };
            noProxy?: string;
            proxyConnectHeader?: {
              [key: string]: unknown;
            };
            proxyFromEnvironment?: boolean;
            proxyUrl?: string;
            scopes?: string[];
            tlsConfig?: {
              ca?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              cert?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              insecureSkipVerify?: boolean;
              keySecret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              serverName?: string;
            };
            tokenUrl: string;
          };
          proxyConnectHeader?: {
            [key: string]: unknown;
          };
          proxyFromEnvironment?: boolean;
          proxyUrl?: string;
          tlsConfig?: {
            ca?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            cert?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            insecureSkipVerify?: boolean;
            keySecret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            serverName?: string;
          };
        };
        jira?: {
          apiURL?: string;
        };
        opsGenieApiKey?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        opsGenieApiUrl?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        pagerdutyUrl?: string;
        resolveTimeout?: string;
        rocketChat?: {
          apiURL?: string;
          token?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          tokenID?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        slackApiUrl?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        smtp?: {
          authIdentity?: string;
          authPassword?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          authSecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          authUsername?: string;
          from?: string;
          hello?: string;
          requireTLS?: boolean;
          smartHost?: {
            host: string;
            port: string;
          };
          tlsConfig?: {
            ca?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            cert?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            insecureSkipVerify?: boolean;
            keySecret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            serverName?: string;
          };
        };
        telegram?: {
          apiURL?: string;
        };
        victorops?: {
          apiKey?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          apiURL?: string;
        };
        webex?: {
          apiURL?: string;
        };
        wechat?: {
          apiCorpID?: string;
          apiSecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          apiURL?: string;
        };
      };
      name?: string;
      templates?: {
        configMap?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        secret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      }[];
    };
    automountServiceAccountToken?: boolean;
    baseImage?: string;
    clusterAdvertiseAddress?: string;
    clusterGossipInterval?: string;
    clusterLabel?: string;
    clusterPeerTimeout?: string;
    clusterPushpullInterval?: string;
    clusterTLS?: {
      client: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        insecureSkipVerify?: boolean;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
      server: {
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        certFile?: string;
        cipherSuites?: string[];
        clientAuthType?: string;
        clientCAFile?: string;
        client_ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        curvePreferences?: string[];
        keyFile?: string;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: string;
        minVersion?: string;
        preferServerCipherSuites?: boolean;
      };
    };
    configMaps?: string[];
    configSecret?: string;
    containers?: {
      args?: string[];
      command?: string[];
      env?: {
        name: string;
        value?: string;
        valueFrom?: {
          configMapKeyRef?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          fieldRef?: {
            apiVersion?: string;
            fieldPath: string;
          };
          resourceFieldRef?: {
            containerName?: string;
            divisor?: any;
            resource: string;
          };
          secretKeyRef?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
      }[];
      envFrom?: {
        configMapRef?: {
          name?: string;
          optional?: boolean;
        };
        prefix?: string;
        secretRef?: {
          name?: string;
          optional?: boolean;
        };
      }[];
      image?: string;
      imagePullPolicy?: string;
      lifecycle?: {
        postStart?: {
          exec?: {
            command?: string[];
          };
          httpGet?: {
            host?: string;
            httpHeaders?: {
              name: string;
              value: string;
            }[];
            path?: string;
            port: any;
            scheme?: string;
          };
          sleep?: {
            seconds: number;
          };
          tcpSocket?: {
            host?: string;
            port: any;
          };
        };
        preStop?: {
          exec?: {
            command?: string[];
          };
          httpGet?: {
            host?: string;
            httpHeaders?: {
              name: string;
              value: string;
            }[];
            path?: string;
            port: any;
            scheme?: string;
          };
          sleep?: {
            seconds: number;
          };
          tcpSocket?: {
            host?: string;
            port: any;
          };
        };
        stopSignal?: string;
      };
      livenessProbe?: {
        exec?: {
          command?: string[];
        };
        failureThreshold?: number;
        grpc?: {
          port: number;
          service?: string;
        };
        httpGet?: {
          host?: string;
          httpHeaders?: {
            name: string;
            value: string;
          }[];
          path?: string;
          port: any;
          scheme?: string;
        };
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        tcpSocket?: {
          host?: string;
          port: any;
        };
        terminationGracePeriodSeconds?: number;
        timeoutSeconds?: number;
      };
      name: string;
      ports?: {
        containerPort: number;
        hostIP?: string;
        hostPort?: number;
        name?: string;
        protocol?: string;
      }[];
      readinessProbe?: {
        exec?: {
          command?: string[];
        };
        failureThreshold?: number;
        grpc?: {
          port: number;
          service?: string;
        };
        httpGet?: {
          host?: string;
          httpHeaders?: {
            name: string;
            value: string;
          }[];
          path?: string;
          port: any;
          scheme?: string;
        };
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        tcpSocket?: {
          host?: string;
          port: any;
        };
        terminationGracePeriodSeconds?: number;
        timeoutSeconds?: number;
      };
      resizePolicy?: {
        resourceName: string;
        restartPolicy: string;
      }[];
      resources?: {
        claims?: {
          name: string;
          request?: string;
        }[];
        limits?: {
          [key: string]: unknown;
        };
        requests?: {
          [key: string]: unknown;
        };
      };
      restartPolicy?: string;
      securityContext?: {
        allowPrivilegeEscalation?: boolean;
        appArmorProfile?: {
          localhostProfile?: string;
          type: string;
        };
        capabilities?: {
          add?: string[];
          drop?: string[];
        };
        privileged?: boolean;
        procMount?: string;
        readOnlyRootFilesystem?: boolean;
        runAsGroup?: number;
        runAsNonRoot?: boolean;
        runAsUser?: number;
        seLinuxOptions?: {
          level?: string;
          role?: string;
          type?: string;
          user?: string;
        };
        seccompProfile?: {
          localhostProfile?: string;
          type: string;
        };
        windowsOptions?: {
          gmsaCredentialSpec?: string;
          gmsaCredentialSpecName?: string;
          hostProcess?: boolean;
          runAsUserName?: string;
        };
      };
      startupProbe?: {
        exec?: {
          command?: string[];
        };
        failureThreshold?: number;
        grpc?: {
          port: number;
          service?: string;
        };
        httpGet?: {
          host?: string;
          httpHeaders?: {
            name: string;
            value: string;
          }[];
          path?: string;
          port: any;
          scheme?: string;
        };
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        tcpSocket?: {
          host?: string;
          port: any;
        };
        terminationGracePeriodSeconds?: number;
        timeoutSeconds?: number;
      };
      stdin?: boolean;
      stdinOnce?: boolean;
      terminationMessagePath?: string;
      terminationMessagePolicy?: string;
      tty?: boolean;
      volumeDevices?: {
        devicePath: string;
        name: string;
      }[];
      volumeMounts?: {
        mountPath: string;
        mountPropagation?: string;
        name: string;
        readOnly?: boolean;
        recursiveReadOnly?: string;
        subPath?: string;
        subPathExpr?: string;
      }[];
      workingDir?: string;
    }[];
    dnsConfig?: {
      nameservers?: string[];
      options?: {
        name: string;
        value?: string;
      }[];
      searches?: string[];
    };
    dnsPolicy?: "ClusterFirstWithHostNet" | "ClusterFirst" | "Default" | "None";
    enableFeatures?: string[];
    enableServiceLinks?: boolean;
    externalUrl?: string;
    forceEnableClusterMode?: boolean;
    hostAliases?: {
      hostnames: string[];
      ip: string;
    }[];
    hostUsers?: boolean;
    image?: string;
    imagePullPolicy?: "" | "Always" | "Never" | "IfNotPresent";
    imagePullSecrets?: {
      name?: string;
    }[];
    initContainers?: {
      args?: string[];
      command?: string[];
      env?: {
        name: string;
        value?: string;
        valueFrom?: {
          configMapKeyRef?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          fieldRef?: {
            apiVersion?: string;
            fieldPath: string;
          };
          resourceFieldRef?: {
            containerName?: string;
            divisor?: any;
            resource: string;
          };
          secretKeyRef?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
      }[];
      envFrom?: {
        configMapRef?: {
          name?: string;
          optional?: boolean;
        };
        prefix?: string;
        secretRef?: {
          name?: string;
          optional?: boolean;
        };
      }[];
      image?: string;
      imagePullPolicy?: string;
      lifecycle?: {
        postStart?: {
          exec?: {
            command?: string[];
          };
          httpGet?: {
            host?: string;
            httpHeaders?: {
              name: string;
              value: string;
            }[];
            path?: string;
            port: any;
            scheme?: string;
          };
          sleep?: {
            seconds: number;
          };
          tcpSocket?: {
            host?: string;
            port: any;
          };
        };
        preStop?: {
          exec?: {
            command?: string[];
          };
          httpGet?: {
            host?: string;
            httpHeaders?: {
              name: string;
              value: string;
            }[];
            path?: string;
            port: any;
            scheme?: string;
          };
          sleep?: {
            seconds: number;
          };
          tcpSocket?: {
            host?: string;
            port: any;
          };
        };
        stopSignal?: string;
      };
      livenessProbe?: {
        exec?: {
          command?: string[];
        };
        failureThreshold?: number;
        grpc?: {
          port: number;
          service?: string;
        };
        httpGet?: {
          host?: string;
          httpHeaders?: {
            name: string;
            value: string;
          }[];
          path?: string;
          port: any;
          scheme?: string;
        };
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        tcpSocket?: {
          host?: string;
          port: any;
        };
        terminationGracePeriodSeconds?: number;
        timeoutSeconds?: number;
      };
      name: string;
      ports?: {
        containerPort: number;
        hostIP?: string;
        hostPort?: number;
        name?: string;
        protocol?: string;
      }[];
      readinessProbe?: {
        exec?: {
          command?: string[];
        };
        failureThreshold?: number;
        grpc?: {
          port: number;
          service?: string;
        };
        httpGet?: {
          host?: string;
          httpHeaders?: {
            name: string;
            value: string;
          }[];
          path?: string;
          port: any;
          scheme?: string;
        };
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        tcpSocket?: {
          host?: string;
          port: any;
        };
        terminationGracePeriodSeconds?: number;
        timeoutSeconds?: number;
      };
      resizePolicy?: {
        resourceName: string;
        restartPolicy: string;
      }[];
      resources?: {
        claims?: {
          name: string;
          request?: string;
        }[];
        limits?: {
          [key: string]: unknown;
        };
        requests?: {
          [key: string]: unknown;
        };
      };
      restartPolicy?: string;
      securityContext?: {
        allowPrivilegeEscalation?: boolean;
        appArmorProfile?: {
          localhostProfile?: string;
          type: string;
        };
        capabilities?: {
          add?: string[];
          drop?: string[];
        };
        privileged?: boolean;
        procMount?: string;
        readOnlyRootFilesystem?: boolean;
        runAsGroup?: number;
        runAsNonRoot?: boolean;
        runAsUser?: number;
        seLinuxOptions?: {
          level?: string;
          role?: string;
          type?: string;
          user?: string;
        };
        seccompProfile?: {
          localhostProfile?: string;
          type: string;
        };
        windowsOptions?: {
          gmsaCredentialSpec?: string;
          gmsaCredentialSpecName?: string;
          hostProcess?: boolean;
          runAsUserName?: string;
        };
      };
      startupProbe?: {
        exec?: {
          command?: string[];
        };
        failureThreshold?: number;
        grpc?: {
          port: number;
          service?: string;
        };
        httpGet?: {
          host?: string;
          httpHeaders?: {
            name: string;
            value: string;
          }[];
          path?: string;
          port: any;
          scheme?: string;
        };
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        tcpSocket?: {
          host?: string;
          port: any;
        };
        terminationGracePeriodSeconds?: number;
        timeoutSeconds?: number;
      };
      stdin?: boolean;
      stdinOnce?: boolean;
      terminationMessagePath?: string;
      terminationMessagePolicy?: string;
      tty?: boolean;
      volumeDevices?: {
        devicePath: string;
        name: string;
      }[];
      volumeMounts?: {
        mountPath: string;
        mountPropagation?: string;
        name: string;
        readOnly?: boolean;
        recursiveReadOnly?: string;
        subPath?: string;
        subPathExpr?: string;
      }[];
      workingDir?: string;
    }[];
    limits?: {
      maxPerSilenceBytes?: string;
      maxSilences?: number;
    };
    listenLocal?: boolean;
    logFormat?: "" | "logfmt" | "json";
    logLevel?: "" | "debug" | "info" | "warn" | "error";
    minReadySeconds?: number;
    nodeSelector?: {
      [key: string]: unknown;
    };
    paused?: boolean;
    persistentVolumeClaimRetentionPolicy?: {
      whenDeleted?: string;
      whenScaled?: string;
    };
    podMetadata?: {
      annotations?: {
        [key: string]: unknown;
      };
      labels?: {
        [key: string]: unknown;
      };
      name?: string;
    };
    portName?: string;
    priorityClassName?: string;
    replicas?: number;
    resources?: {
      claims?: {
        name: string;
        request?: string;
      }[];
      limits?: {
        [key: string]: unknown;
      };
      requests?: {
        [key: string]: unknown;
      };
    };
    retention?: string;
    routePrefix?: string;
    secrets?: string[];
    securityContext?: {
      appArmorProfile?: {
        localhostProfile?: string;
        type: string;
      };
      fsGroup?: number;
      fsGroupChangePolicy?: string;
      runAsGroup?: number;
      runAsNonRoot?: boolean;
      runAsUser?: number;
      seLinuxChangePolicy?: string;
      seLinuxOptions?: {
        level?: string;
        role?: string;
        type?: string;
        user?: string;
      };
      seccompProfile?: {
        localhostProfile?: string;
        type: string;
      };
      supplementalGroups?: number[];
      supplementalGroupsPolicy?: string;
      sysctls?: {
        name: string;
        value: string;
      }[];
      windowsOptions?: {
        gmsaCredentialSpec?: string;
        gmsaCredentialSpecName?: string;
        hostProcess?: boolean;
        runAsUserName?: string;
      };
    };
    serviceAccountName?: string;
    serviceName?: string;
    sha?: string;
    storage?: {
      disableMountSubPath?: boolean;
      emptyDir?: {
        medium?: string;
        sizeLimit?: any;
      };
      ephemeral?: {
        volumeClaimTemplate?: {
          metadata?: {
            [key: string]: unknown;
          };
          spec: {
            accessModes?: string[];
            dataSource?: {
              apiGroup?: string;
              kind: string;
              name: string;
            };
            dataSourceRef?: {
              apiGroup?: string;
              kind: string;
              name: string;
              namespace?: string;
            };
            resources?: {
              limits?: {
                [key: string]: unknown;
              };
              requests?: {
                [key: string]: unknown;
              };
            };
            selector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            storageClassName?: string;
            volumeAttributesClassName?: string;
            volumeMode?: string;
            volumeName?: string;
          };
        };
      };
      volumeClaimTemplate?: {
        apiVersion?: string;
        kind?: string;
        metadata?: {
          annotations?: {
            [key: string]: unknown;
          };
          labels?: {
            [key: string]: unknown;
          };
          name?: string;
        };
        spec?: {
          accessModes?: string[];
          dataSource?: {
            apiGroup?: string;
            kind: string;
            name: string;
          };
          dataSourceRef?: {
            apiGroup?: string;
            kind: string;
            name: string;
            namespace?: string;
          };
          resources?: {
            limits?: {
              [key: string]: unknown;
            };
            requests?: {
              [key: string]: unknown;
            };
          };
          selector?: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchLabels?: {
              [key: string]: unknown;
            };
          };
          storageClassName?: string;
          volumeAttributesClassName?: string;
          volumeMode?: string;
          volumeName?: string;
        };
        status?: {
          accessModes?: string[];
          allocatedResourceStatuses?: {
            [key: string]: unknown;
          };
          allocatedResources?: {
            [key: string]: unknown;
          };
          capacity?: {
            [key: string]: unknown;
          };
          conditions?: {
            lastProbeTime?: string;
            lastTransitionTime?: string;
            message?: string;
            reason?: string;
            status: string;
            type: string;
          }[];
          currentVolumeAttributesClassName?: string;
          modifyVolumeStatus?: {
            status: string;
            targetVolumeAttributesClassName?: string;
          };
          phase?: string;
        };
      };
    };
    tag?: string;
    terminationGracePeriodSeconds?: number;
    tolerations?: {
      effect?: string;
      key?: string;
      operator?: string;
      tolerationSeconds?: number;
      value?: string;
    }[];
    topologySpreadConstraints?: {
      labelSelector?: {
        matchExpressions?: {
          key: string;
          operator: string;
          values?: string[];
        }[];
        matchLabels?: {
          [key: string]: unknown;
        };
      };
      matchLabelKeys?: string[];
      maxSkew: number;
      minDomains?: number;
      nodeAffinityPolicy?: string;
      nodeTaintsPolicy?: string;
      topologyKey: string;
      whenUnsatisfiable: string;
    }[];
    version?: string;
    volumeMounts?: {
      mountPath: string;
      mountPropagation?: string;
      name: string;
      readOnly?: boolean;
      recursiveReadOnly?: string;
      subPath?: string;
      subPathExpr?: string;
    }[];
    volumes?: {
      awsElasticBlockStore?: {
        fsType?: string;
        partition?: number;
        readOnly?: boolean;
        volumeID: string;
      };
      azureDisk?: {
        cachingMode?: string;
        diskName: string;
        diskURI: string;
        fsType?: string;
        kind?: string;
        readOnly?: boolean;
      };
      azureFile?: {
        readOnly?: boolean;
        secretName: string;
        shareName: string;
      };
      cephfs?: {
        monitors: string[];
        path?: string;
        readOnly?: boolean;
        secretFile?: string;
        secretRef?: {
          name?: string;
        };
        user?: string;
      };
      cinder?: {
        fsType?: string;
        readOnly?: boolean;
        secretRef?: {
          name?: string;
        };
        volumeID: string;
      };
      configMap?: {
        defaultMode?: number;
        items?: {
          key: string;
          mode?: number;
          path: string;
        }[];
        name?: string;
        optional?: boolean;
      };
      csi?: {
        driver: string;
        fsType?: string;
        nodePublishSecretRef?: {
          name?: string;
        };
        readOnly?: boolean;
        volumeAttributes?: {
          [key: string]: unknown;
        };
      };
      downwardAPI?: {
        defaultMode?: number;
        items?: {
          fieldRef?: {
            apiVersion?: string;
            fieldPath: string;
          };
          mode?: number;
          path: string;
          resourceFieldRef?: {
            containerName?: string;
            divisor?: any;
            resource: string;
          };
        }[];
      };
      emptyDir?: {
        medium?: string;
        sizeLimit?: any;
      };
      ephemeral?: {
        volumeClaimTemplate?: {
          metadata?: {
            [key: string]: unknown;
          };
          spec: {
            accessModes?: string[];
            dataSource?: {
              apiGroup?: string;
              kind: string;
              name: string;
            };
            dataSourceRef?: {
              apiGroup?: string;
              kind: string;
              name: string;
              namespace?: string;
            };
            resources?: {
              limits?: {
                [key: string]: unknown;
              };
              requests?: {
                [key: string]: unknown;
              };
            };
            selector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            storageClassName?: string;
            volumeAttributesClassName?: string;
            volumeMode?: string;
            volumeName?: string;
          };
        };
      };
      fc?: {
        fsType?: string;
        lun?: number;
        readOnly?: boolean;
        targetWWNs?: string[];
        wwids?: string[];
      };
      flexVolume?: {
        driver: string;
        fsType?: string;
        options?: {
          [key: string]: unknown;
        };
        readOnly?: boolean;
        secretRef?: {
          name?: string;
        };
      };
      flocker?: {
        datasetName?: string;
        datasetUUID?: string;
      };
      gcePersistentDisk?: {
        fsType?: string;
        partition?: number;
        pdName: string;
        readOnly?: boolean;
      };
      gitRepo?: {
        directory?: string;
        repository: string;
        revision?: string;
      };
      glusterfs?: {
        endpoints: string;
        path: string;
        readOnly?: boolean;
      };
      hostPath?: {
        path: string;
        type?: string;
      };
      image?: {
        pullPolicy?: string;
        reference?: string;
      };
      iscsi?: {
        chapAuthDiscovery?: boolean;
        chapAuthSession?: boolean;
        fsType?: string;
        initiatorName?: string;
        iqn: string;
        iscsiInterface?: string;
        lun: number;
        portals?: string[];
        readOnly?: boolean;
        secretRef?: {
          name?: string;
        };
        targetPortal: string;
      };
      name: string;
      nfs?: {
        path: string;
        readOnly?: boolean;
        server: string;
      };
      persistentVolumeClaim?: {
        claimName: string;
        readOnly?: boolean;
      };
      photonPersistentDisk?: {
        fsType?: string;
        pdID: string;
      };
      portworxVolume?: {
        fsType?: string;
        readOnly?: boolean;
        volumeID: string;
      };
      projected?: {
        defaultMode?: number;
        sources?: {
          clusterTrustBundle?: {
            labelSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            name?: string;
            optional?: boolean;
            path: string;
            signerName?: string;
          };
          configMap?: {
            items?: {
              key: string;
              mode?: number;
              path: string;
            }[];
            name?: string;
            optional?: boolean;
          };
          downwardAPI?: {
            items?: {
              fieldRef?: {
                apiVersion?: string;
                fieldPath: string;
              };
              mode?: number;
              path: string;
              resourceFieldRef?: {
                containerName?: string;
                divisor?: any;
                resource: string;
              };
            }[];
          };
          secret?: {
            items?: {
              key: string;
              mode?: number;
              path: string;
            }[];
            name?: string;
            optional?: boolean;
          };
          serviceAccountToken?: {
            audience?: string;
            expirationSeconds?: number;
            path: string;
          };
        }[];
      };
      quobyte?: {
        group?: string;
        readOnly?: boolean;
        registry: string;
        tenant?: string;
        user?: string;
        volume: string;
      };
      rbd?: {
        fsType?: string;
        image: string;
        keyring?: string;
        monitors: string[];
        pool?: string;
        readOnly?: boolean;
        secretRef?: {
          name?: string;
        };
        user?: string;
      };
      scaleIO?: {
        fsType?: string;
        gateway: string;
        protectionDomain?: string;
        readOnly?: boolean;
        secretRef: {
          name?: string;
        };
        sslEnabled?: boolean;
        storageMode?: string;
        storagePool?: string;
        system: string;
        volumeName?: string;
      };
      secret?: {
        defaultMode?: number;
        items?: {
          key: string;
          mode?: number;
          path: string;
        }[];
        optional?: boolean;
        secretName?: string;
      };
      storageos?: {
        fsType?: string;
        readOnly?: boolean;
        secretRef?: {
          name?: string;
        };
        volumeName?: string;
        volumeNamespace?: string;
      };
      vsphereVolume?: {
        fsType?: string;
        storagePolicyID?: string;
        storagePolicyName?: string;
        volumePath: string;
      };
    }[];
    web?: {
      getConcurrency?: number;
      httpConfig?: {
        headers?: {
          contentSecurityPolicy?: string;
          strictTransportSecurity?: string;
          xContentTypeOptions?: "" | "NoSniff";
          xFrameOptions?: "" | "Deny" | "SameOrigin";
          xXSSProtection?: string;
        };
        http2?: boolean;
      };
      timeout?: number;
      tlsConfig?: {
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        certFile?: string;
        cipherSuites?: string[];
        clientAuthType?: string;
        clientCAFile?: string;
        client_ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        curvePreferences?: string[];
        keyFile?: string;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: string;
        minVersion?: string;
        preferServerCipherSuites?: boolean;
      };
    };
  };
  status?: {
    availableReplicas: number;
    conditions?: {
      lastTransitionTime: string;
      message?: string;
      observedGeneration?: number;
      reason?: string;
      status: string;
      type: string;
    }[];
    paused: boolean;
    replicas: number;
    selector?: string;
    unavailableReplicas: number;
    updatedReplicas: number;
  };
}
/* com.coreos.monitoring.v1.AlertmanagerList */
/* AlertmanagerList is a list of Alertmanager */
export interface MonitoringCoreosComV1AlertmanagerList {
  apiVersion?: string;
  items: MonitoringCoreosComV1Alertmanager[];
  kind?: string;
  metadata?: ListMeta;
}
/* com.coreos.monitoring.v1.PodMonitor */
/* The `PodMonitor` custom resource definition (CRD) defines how `Prometheus` and `PrometheusAgent` can scrape metrics from a group of pods.
Among other things, it allows to specify:
* The pods to scrape via label selectors.
* The container ports to scrape.
* Authentication credentials to use.
* Target and metric relabeling.

`Prometheus` and `PrometheusAgent` objects select `PodMonitor` objects using label and namespace selectors. */
export interface MonitoringCoreosComV1PodMonitor {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec: {
    attachMetadata?: {
      node?: boolean;
    };
    bodySizeLimit?: string;
    convertClassicHistogramsToNHCB?: boolean;
    fallbackScrapeProtocol?: "PrometheusProto" | "OpenMetricsText0.0.1" | "OpenMetricsText1.0.0" | "PrometheusText0.0.4" | "PrometheusText1.0.0";
    jobLabel?: string;
    keepDroppedTargets?: number;
    labelLimit?: number;
    labelNameLengthLimit?: number;
    labelValueLengthLimit?: number;
    namespaceSelector?: {
      any?: boolean;
      matchNames?: string[];
    };
    nativeHistogramBucketLimit?: number;
    nativeHistogramMinBucketFactor?: any;
    podMetricsEndpoints?: {
      authorization?: {
        credentials?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        type?: string;
      };
      basicAuth?: {
        password?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        username?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      bearerTokenSecret?: {
        key: string;
        name?: string;
        optional?: boolean;
      };
      enableHttp2?: boolean;
      filterRunning?: boolean;
      followRedirects?: boolean;
      honorLabels?: boolean;
      honorTimestamps?: boolean;
      interval?: string;
      metricRelabelings?: {
        action?: "replace" | "Replace" | "keep" | "Keep" | "drop" | "Drop" | "hashmod" | "HashMod" | "labelmap" | "LabelMap" | "labeldrop" | "LabelDrop" | "labelkeep" | "LabelKeep" | "lowercase" | "Lowercase" | "uppercase" | "Uppercase" | "keepequal" | "KeepEqual" | "dropequal" | "DropEqual";
        modulus?: number;
        regex?: string;
        replacement?: string;
        separator?: string;
        sourceLabels?: string[];
        targetLabel?: string;
      }[];
      noProxy?: string;
      oauth2?: {
        clientId: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        clientSecret: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        endpointParams?: {
          [key: string]: unknown;
        };
        noProxy?: string;
        proxyConnectHeader?: {
          [key: string]: unknown;
        };
        proxyFromEnvironment?: boolean;
        proxyUrl?: string;
        scopes?: string[];
        tlsConfig?: {
          ca?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          cert?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          insecureSkipVerify?: boolean;
          keySecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          serverName?: string;
        };
        tokenUrl: string;
      };
      params?: {
        [key: string]: unknown;
      };
      path?: string;
      port?: string;
      portNumber?: number;
      proxyConnectHeader?: {
        [key: string]: unknown;
      };
      proxyFromEnvironment?: boolean;
      proxyUrl?: string;
      relabelings?: {
        action?: "replace" | "Replace" | "keep" | "Keep" | "drop" | "Drop" | "hashmod" | "HashMod" | "labelmap" | "LabelMap" | "labeldrop" | "LabelDrop" | "labelkeep" | "LabelKeep" | "lowercase" | "Lowercase" | "uppercase" | "Uppercase" | "keepequal" | "KeepEqual" | "dropequal" | "DropEqual";
        modulus?: number;
        regex?: string;
        replacement?: string;
        separator?: string;
        sourceLabels?: string[];
        targetLabel?: string;
      }[];
      scheme?: "http" | "https";
      scrapeTimeout?: string;
      targetPort?: any;
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        insecureSkipVerify?: boolean;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
      trackTimestampsStaleness?: boolean;
    }[];
    podTargetLabels?: string[];
    sampleLimit?: number;
    scrapeClass?: string;
    scrapeClassicHistograms?: boolean;
    scrapeProtocols?: ("PrometheusProto" | "OpenMetricsText0.0.1" | "OpenMetricsText1.0.0" | "PrometheusText0.0.4" | "PrometheusText1.0.0")[];
    selector: {
      matchExpressions?: {
        key: string;
        operator: string;
        values?: string[];
      }[];
      matchLabels?: {
        [key: string]: unknown;
      };
    };
    selectorMechanism?: "RelabelConfig" | "RoleSelector";
    targetLimit?: number;
  };
}
/* com.coreos.monitoring.v1.PodMonitorList */
/* PodMonitorList is a list of PodMonitor */
export interface MonitoringCoreosComV1PodMonitorList {
  apiVersion?: string;
  items: MonitoringCoreosComV1PodMonitor[];
  kind?: string;
  metadata?: ListMeta;
}
/* com.coreos.monitoring.v1.Probe */
/* The `Probe` custom resource definition (CRD) defines how to scrape metrics from prober exporters such as the [blackbox exporter](https://github.com/prometheus/blackbox_exporter).

The `Probe` resource needs 2 pieces of information:
* The list of probed addresses which can be defined statically or by discovering Kubernetes Ingress objects.
* The prober which exposes the availability of probed endpoints (over various protocols such HTTP, TCP, ICMP, ...) as Prometheus metrics.

`Prometheus` and `PrometheusAgent` objects select `Probe` objects using label and namespace selectors. */
export interface MonitoringCoreosComV1Probe {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec: {
    authorization?: {
      credentials?: {
        key: string;
        name?: string;
        optional?: boolean;
      };
      type?: string;
    };
    basicAuth?: {
      password?: {
        key: string;
        name?: string;
        optional?: boolean;
      };
      username?: {
        key: string;
        name?: string;
        optional?: boolean;
      };
    };
    bearerTokenSecret?: {
      key: string;
      name?: string;
      optional?: boolean;
    };
    convertClassicHistogramsToNHCB?: boolean;
    fallbackScrapeProtocol?: "PrometheusProto" | "OpenMetricsText0.0.1" | "OpenMetricsText1.0.0" | "PrometheusText0.0.4" | "PrometheusText1.0.0";
    interval?: string;
    jobName?: string;
    keepDroppedTargets?: number;
    labelLimit?: number;
    labelNameLengthLimit?: number;
    labelValueLengthLimit?: number;
    metricRelabelings?: {
      action?: "replace" | "Replace" | "keep" | "Keep" | "drop" | "Drop" | "hashmod" | "HashMod" | "labelmap" | "LabelMap" | "labeldrop" | "LabelDrop" | "labelkeep" | "LabelKeep" | "lowercase" | "Lowercase" | "uppercase" | "Uppercase" | "keepequal" | "KeepEqual" | "dropequal" | "DropEqual";
      modulus?: number;
      regex?: string;
      replacement?: string;
      separator?: string;
      sourceLabels?: string[];
      targetLabel?: string;
    }[];
    module?: string;
    nativeHistogramBucketLimit?: number;
    nativeHistogramMinBucketFactor?: any;
    oauth2?: {
      clientId: {
        configMap?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        secret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      clientSecret: {
        key: string;
        name?: string;
        optional?: boolean;
      };
      endpointParams?: {
        [key: string]: unknown;
      };
      noProxy?: string;
      proxyConnectHeader?: {
        [key: string]: unknown;
      };
      proxyFromEnvironment?: boolean;
      proxyUrl?: string;
      scopes?: string[];
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        insecureSkipVerify?: boolean;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
      tokenUrl: string;
    };
    params?: {
      name: string;
      values?: string[];
    }[];
    prober?: {
      noProxy?: string;
      path?: string;
      proxyConnectHeader?: {
        [key: string]: unknown;
      };
      proxyFromEnvironment?: boolean;
      proxyUrl?: string;
      scheme?: "http" | "https";
      url: string;
    };
    sampleLimit?: number;
    scrapeClass?: string;
    scrapeClassicHistograms?: boolean;
    scrapeProtocols?: ("PrometheusProto" | "OpenMetricsText0.0.1" | "OpenMetricsText1.0.0" | "PrometheusText0.0.4" | "PrometheusText1.0.0")[];
    scrapeTimeout?: string;
    targetLimit?: number;
    targets?: {
      ingress?: {
        namespaceSelector?: {
          any?: boolean;
          matchNames?: string[];
        };
        relabelingConfigs?: {
          action?: "replace" | "Replace" | "keep" | "Keep" | "drop" | "Drop" | "hashmod" | "HashMod" | "labelmap" | "LabelMap" | "labeldrop" | "LabelDrop" | "labelkeep" | "LabelKeep" | "lowercase" | "Lowercase" | "uppercase" | "Uppercase" | "keepequal" | "KeepEqual" | "dropequal" | "DropEqual";
          modulus?: number;
          regex?: string;
          replacement?: string;
          separator?: string;
          sourceLabels?: string[];
          targetLabel?: string;
        }[];
        selector?: {
          matchExpressions?: {
            key: string;
            operator: string;
            values?: string[];
          }[];
          matchLabels?: {
            [key: string]: unknown;
          };
        };
      };
      staticConfig?: {
        labels?: {
          [key: string]: unknown;
        };
        relabelingConfigs?: {
          action?: "replace" | "Replace" | "keep" | "Keep" | "drop" | "Drop" | "hashmod" | "HashMod" | "labelmap" | "LabelMap" | "labeldrop" | "LabelDrop" | "labelkeep" | "LabelKeep" | "lowercase" | "Lowercase" | "uppercase" | "Uppercase" | "keepequal" | "KeepEqual" | "dropequal" | "DropEqual";
          modulus?: number;
          regex?: string;
          replacement?: string;
          separator?: string;
          sourceLabels?: string[];
          targetLabel?: string;
        }[];
        static?: string[];
      };
    };
    tlsConfig?: {
      ca?: {
        configMap?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        secret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      cert?: {
        configMap?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        secret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      insecureSkipVerify?: boolean;
      keySecret?: {
        key: string;
        name?: string;
        optional?: boolean;
      };
      maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
      minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
      serverName?: string;
    };
  };
}
/* com.coreos.monitoring.v1.ProbeList */
/* ProbeList is a list of Probe */
export interface MonitoringCoreosComV1ProbeList {
  apiVersion?: string;
  items: MonitoringCoreosComV1Probe[];
  kind?: string;
  metadata?: ListMeta;
}
/* com.coreos.monitoring.v1.Prometheus */
/* The `Prometheus` custom resource definition (CRD) defines a desired [Prometheus](https://prometheus.io/docs/prometheus) setup to run in a Kubernetes cluster. It allows to specify many options such as the number of replicas, persistent storage, and Alertmanagers where firing alerts should be sent and many more.

For each `Prometheus` resource, the Operator deploys one or several `StatefulSet` objects in the same namespace. The number of StatefulSets is equal to the number of shards which is 1 by default.

The resource defines via label and namespace selectors which `ServiceMonitor`, `PodMonitor`, `Probe` and `PrometheusRule` objects should be associated to the deployed Prometheus instances.

The Operator continuously reconciles the scrape and rules configuration and a sidecar container running in the Prometheus pods triggers a reload of the configuration when needed. */
export interface MonitoringCoreosComV1Prometheus {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec: {
    additionalAlertManagerConfigs?: {
      key: string;
      name?: string;
      optional?: boolean;
    };
    additionalAlertRelabelConfigs?: {
      key: string;
      name?: string;
      optional?: boolean;
    };
    additionalArgs?: {
      name: string;
      value?: string;
    }[];
    additionalScrapeConfigs?: {
      key: string;
      name?: string;
      optional?: boolean;
    };
    affinity?: {
      nodeAffinity?: {
        preferredDuringSchedulingIgnoredDuringExecution?: {
          preference: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchFields?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
          };
          weight: number;
        }[];
        requiredDuringSchedulingIgnoredDuringExecution?: {
          nodeSelectorTerms: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchFields?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
          }[];
        };
      };
      podAffinity?: {
        preferredDuringSchedulingIgnoredDuringExecution?: {
          podAffinityTerm: {
            labelSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            matchLabelKeys?: string[];
            mismatchLabelKeys?: string[];
            namespaceSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            namespaces?: string[];
            topologyKey: string;
          };
          weight: number;
        }[];
        requiredDuringSchedulingIgnoredDuringExecution?: {
          labelSelector?: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchLabels?: {
              [key: string]: unknown;
            };
          };
          matchLabelKeys?: string[];
          mismatchLabelKeys?: string[];
          namespaceSelector?: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchLabels?: {
              [key: string]: unknown;
            };
          };
          namespaces?: string[];
          topologyKey: string;
        }[];
      };
      podAntiAffinity?: {
        preferredDuringSchedulingIgnoredDuringExecution?: {
          podAffinityTerm: {
            labelSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            matchLabelKeys?: string[];
            mismatchLabelKeys?: string[];
            namespaceSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            namespaces?: string[];
            topologyKey: string;
          };
          weight: number;
        }[];
        requiredDuringSchedulingIgnoredDuringExecution?: {
          labelSelector?: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchLabels?: {
              [key: string]: unknown;
            };
          };
          matchLabelKeys?: string[];
          mismatchLabelKeys?: string[];
          namespaceSelector?: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchLabels?: {
              [key: string]: unknown;
            };
          };
          namespaces?: string[];
          topologyKey: string;
        }[];
      };
    };
    alerting?: {
      alertmanagers: {
        alertRelabelings?: {
          action?: "replace" | "Replace" | "keep" | "Keep" | "drop" | "Drop" | "hashmod" | "HashMod" | "labelmap" | "LabelMap" | "labeldrop" | "LabelDrop" | "labelkeep" | "LabelKeep" | "lowercase" | "Lowercase" | "uppercase" | "Uppercase" | "keepequal" | "KeepEqual" | "dropequal" | "DropEqual";
          modulus?: number;
          regex?: string;
          replacement?: string;
          separator?: string;
          sourceLabels?: string[];
          targetLabel?: string;
        }[];
        apiVersion?: "v1" | "V1" | "v2" | "V2";
        authorization?: {
          credentials?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          type?: string;
        };
        basicAuth?: {
          password?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          username?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        bearerTokenFile?: string;
        enableHttp2?: boolean;
        name: string;
        namespace?: string;
        noProxy?: string;
        pathPrefix?: string;
        port: any;
        proxyConnectHeader?: {
          [key: string]: unknown;
        };
        proxyFromEnvironment?: boolean;
        proxyUrl?: string;
        relabelings?: {
          action?: "replace" | "Replace" | "keep" | "Keep" | "drop" | "Drop" | "hashmod" | "HashMod" | "labelmap" | "LabelMap" | "labeldrop" | "LabelDrop" | "labelkeep" | "LabelKeep" | "lowercase" | "Lowercase" | "uppercase" | "Uppercase" | "keepequal" | "KeepEqual" | "dropequal" | "DropEqual";
          modulus?: number;
          regex?: string;
          replacement?: string;
          separator?: string;
          sourceLabels?: string[];
          targetLabel?: string;
        }[];
        scheme?: string;
        sigv4?: {
          accessKey?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          profile?: string;
          region?: string;
          roleArn?: string;
          secretKey?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        timeout?: string;
        tlsConfig?: {
          ca?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          caFile?: string;
          cert?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          certFile?: string;
          insecureSkipVerify?: boolean;
          keyFile?: string;
          keySecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          serverName?: string;
        };
      }[];
    };
    allowOverlappingBlocks?: boolean;
    apiserverConfig?: {
      authorization?: {
        credentials?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        credentialsFile?: string;
        type?: string;
      };
      basicAuth?: {
        password?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        username?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      bearerToken?: string;
      bearerTokenFile?: string;
      host: string;
      noProxy?: string;
      proxyConnectHeader?: {
        [key: string]: unknown;
      };
      proxyFromEnvironment?: boolean;
      proxyUrl?: string;
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        caFile?: string;
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        certFile?: string;
        insecureSkipVerify?: boolean;
        keyFile?: string;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
    };
    arbitraryFSAccessThroughSMs?: {
      deny?: boolean;
    };
    automountServiceAccountToken?: boolean;
    baseImage?: string;
    bodySizeLimit?: string;
    configMaps?: string[];
    containers?: {
      args?: string[];
      command?: string[];
      env?: {
        name: string;
        value?: string;
        valueFrom?: {
          configMapKeyRef?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          fieldRef?: {
            apiVersion?: string;
            fieldPath: string;
          };
          resourceFieldRef?: {
            containerName?: string;
            divisor?: any;
            resource: string;
          };
          secretKeyRef?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
      }[];
      envFrom?: {
        configMapRef?: {
          name?: string;
          optional?: boolean;
        };
        prefix?: string;
        secretRef?: {
          name?: string;
          optional?: boolean;
        };
      }[];
      image?: string;
      imagePullPolicy?: string;
      lifecycle?: {
        postStart?: {
          exec?: {
            command?: string[];
          };
          httpGet?: {
            host?: string;
            httpHeaders?: {
              name: string;
              value: string;
            }[];
            path?: string;
            port: any;
            scheme?: string;
          };
          sleep?: {
            seconds: number;
          };
          tcpSocket?: {
            host?: string;
            port: any;
          };
        };
        preStop?: {
          exec?: {
            command?: string[];
          };
          httpGet?: {
            host?: string;
            httpHeaders?: {
              name: string;
              value: string;
            }[];
            path?: string;
            port: any;
            scheme?: string;
          };
          sleep?: {
            seconds: number;
          };
          tcpSocket?: {
            host?: string;
            port: any;
          };
        };
        stopSignal?: string;
      };
      livenessProbe?: {
        exec?: {
          command?: string[];
        };
        failureThreshold?: number;
        grpc?: {
          port: number;
          service?: string;
        };
        httpGet?: {
          host?: string;
          httpHeaders?: {
            name: string;
            value: string;
          }[];
          path?: string;
          port: any;
          scheme?: string;
        };
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        tcpSocket?: {
          host?: string;
          port: any;
        };
        terminationGracePeriodSeconds?: number;
        timeoutSeconds?: number;
      };
      name: string;
      ports?: {
        containerPort: number;
        hostIP?: string;
        hostPort?: number;
        name?: string;
        protocol?: string;
      }[];
      readinessProbe?: {
        exec?: {
          command?: string[];
        };
        failureThreshold?: number;
        grpc?: {
          port: number;
          service?: string;
        };
        httpGet?: {
          host?: string;
          httpHeaders?: {
            name: string;
            value: string;
          }[];
          path?: string;
          port: any;
          scheme?: string;
        };
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        tcpSocket?: {
          host?: string;
          port: any;
        };
        terminationGracePeriodSeconds?: number;
        timeoutSeconds?: number;
      };
      resizePolicy?: {
        resourceName: string;
        restartPolicy: string;
      }[];
      resources?: {
        claims?: {
          name: string;
          request?: string;
        }[];
        limits?: {
          [key: string]: unknown;
        };
        requests?: {
          [key: string]: unknown;
        };
      };
      restartPolicy?: string;
      securityContext?: {
        allowPrivilegeEscalation?: boolean;
        appArmorProfile?: {
          localhostProfile?: string;
          type: string;
        };
        capabilities?: {
          add?: string[];
          drop?: string[];
        };
        privileged?: boolean;
        procMount?: string;
        readOnlyRootFilesystem?: boolean;
        runAsGroup?: number;
        runAsNonRoot?: boolean;
        runAsUser?: number;
        seLinuxOptions?: {
          level?: string;
          role?: string;
          type?: string;
          user?: string;
        };
        seccompProfile?: {
          localhostProfile?: string;
          type: string;
        };
        windowsOptions?: {
          gmsaCredentialSpec?: string;
          gmsaCredentialSpecName?: string;
          hostProcess?: boolean;
          runAsUserName?: string;
        };
      };
      startupProbe?: {
        exec?: {
          command?: string[];
        };
        failureThreshold?: number;
        grpc?: {
          port: number;
          service?: string;
        };
        httpGet?: {
          host?: string;
          httpHeaders?: {
            name: string;
            value: string;
          }[];
          path?: string;
          port: any;
          scheme?: string;
        };
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        tcpSocket?: {
          host?: string;
          port: any;
        };
        terminationGracePeriodSeconds?: number;
        timeoutSeconds?: number;
      };
      stdin?: boolean;
      stdinOnce?: boolean;
      terminationMessagePath?: string;
      terminationMessagePolicy?: string;
      tty?: boolean;
      volumeDevices?: {
        devicePath: string;
        name: string;
      }[];
      volumeMounts?: {
        mountPath: string;
        mountPropagation?: string;
        name: string;
        readOnly?: boolean;
        recursiveReadOnly?: string;
        subPath?: string;
        subPathExpr?: string;
      }[];
      workingDir?: string;
    }[];
    convertClassicHistogramsToNHCB?: boolean;
    disableCompaction?: boolean;
    dnsConfig?: {
      nameservers?: string[];
      options?: {
        name: string;
        value?: string;
      }[];
      searches?: string[];
    };
    dnsPolicy?: "ClusterFirstWithHostNet" | "ClusterFirst" | "Default" | "None";
    enableAdminAPI?: boolean;
    enableFeatures?: string[];
    enableOTLPReceiver?: boolean;
    enableRemoteWriteReceiver?: boolean;
    enableServiceLinks?: boolean;
    enforcedBodySizeLimit?: string;
    enforcedKeepDroppedTargets?: number;
    enforcedLabelLimit?: number;
    enforcedLabelNameLengthLimit?: number;
    enforcedLabelValueLengthLimit?: number;
    enforcedNamespaceLabel?: string;
    enforcedSampleLimit?: number;
    enforcedTargetLimit?: number;
    evaluationInterval?: string;
    excludedFromEnforcement?: {
      group?: "monitoring.coreos.com";
      name?: string;
      namespace: string;
      resource: "prometheusrules" | "servicemonitors" | "podmonitors" | "probes" | "scrapeconfigs";
    }[];
    exemplars?: {
      maxSize?: number;
    };
    externalLabels?: {
      [key: string]: unknown;
    };
    externalUrl?: string;
    hostAliases?: {
      hostnames: string[];
      ip: string;
    }[];
    hostNetwork?: boolean;
    hostUsers?: boolean;
    ignoreNamespaceSelectors?: boolean;
    image?: string;
    imagePullPolicy?: "" | "Always" | "Never" | "IfNotPresent";
    imagePullSecrets?: {
      name?: string;
    }[];
    initContainers?: {
      args?: string[];
      command?: string[];
      env?: {
        name: string;
        value?: string;
        valueFrom?: {
          configMapKeyRef?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          fieldRef?: {
            apiVersion?: string;
            fieldPath: string;
          };
          resourceFieldRef?: {
            containerName?: string;
            divisor?: any;
            resource: string;
          };
          secretKeyRef?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
      }[];
      envFrom?: {
        configMapRef?: {
          name?: string;
          optional?: boolean;
        };
        prefix?: string;
        secretRef?: {
          name?: string;
          optional?: boolean;
        };
      }[];
      image?: string;
      imagePullPolicy?: string;
      lifecycle?: {
        postStart?: {
          exec?: {
            command?: string[];
          };
          httpGet?: {
            host?: string;
            httpHeaders?: {
              name: string;
              value: string;
            }[];
            path?: string;
            port: any;
            scheme?: string;
          };
          sleep?: {
            seconds: number;
          };
          tcpSocket?: {
            host?: string;
            port: any;
          };
        };
        preStop?: {
          exec?: {
            command?: string[];
          };
          httpGet?: {
            host?: string;
            httpHeaders?: {
              name: string;
              value: string;
            }[];
            path?: string;
            port: any;
            scheme?: string;
          };
          sleep?: {
            seconds: number;
          };
          tcpSocket?: {
            host?: string;
            port: any;
          };
        };
        stopSignal?: string;
      };
      livenessProbe?: {
        exec?: {
          command?: string[];
        };
        failureThreshold?: number;
        grpc?: {
          port: number;
          service?: string;
        };
        httpGet?: {
          host?: string;
          httpHeaders?: {
            name: string;
            value: string;
          }[];
          path?: string;
          port: any;
          scheme?: string;
        };
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        tcpSocket?: {
          host?: string;
          port: any;
        };
        terminationGracePeriodSeconds?: number;
        timeoutSeconds?: number;
      };
      name: string;
      ports?: {
        containerPort: number;
        hostIP?: string;
        hostPort?: number;
        name?: string;
        protocol?: string;
      }[];
      readinessProbe?: {
        exec?: {
          command?: string[];
        };
        failureThreshold?: number;
        grpc?: {
          port: number;
          service?: string;
        };
        httpGet?: {
          host?: string;
          httpHeaders?: {
            name: string;
            value: string;
          }[];
          path?: string;
          port: any;
          scheme?: string;
        };
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        tcpSocket?: {
          host?: string;
          port: any;
        };
        terminationGracePeriodSeconds?: number;
        timeoutSeconds?: number;
      };
      resizePolicy?: {
        resourceName: string;
        restartPolicy: string;
      }[];
      resources?: {
        claims?: {
          name: string;
          request?: string;
        }[];
        limits?: {
          [key: string]: unknown;
        };
        requests?: {
          [key: string]: unknown;
        };
      };
      restartPolicy?: string;
      securityContext?: {
        allowPrivilegeEscalation?: boolean;
        appArmorProfile?: {
          localhostProfile?: string;
          type: string;
        };
        capabilities?: {
          add?: string[];
          drop?: string[];
        };
        privileged?: boolean;
        procMount?: string;
        readOnlyRootFilesystem?: boolean;
        runAsGroup?: number;
        runAsNonRoot?: boolean;
        runAsUser?: number;
        seLinuxOptions?: {
          level?: string;
          role?: string;
          type?: string;
          user?: string;
        };
        seccompProfile?: {
          localhostProfile?: string;
          type: string;
        };
        windowsOptions?: {
          gmsaCredentialSpec?: string;
          gmsaCredentialSpecName?: string;
          hostProcess?: boolean;
          runAsUserName?: string;
        };
      };
      startupProbe?: {
        exec?: {
          command?: string[];
        };
        failureThreshold?: number;
        grpc?: {
          port: number;
          service?: string;
        };
        httpGet?: {
          host?: string;
          httpHeaders?: {
            name: string;
            value: string;
          }[];
          path?: string;
          port: any;
          scheme?: string;
        };
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        tcpSocket?: {
          host?: string;
          port: any;
        };
        terminationGracePeriodSeconds?: number;
        timeoutSeconds?: number;
      };
      stdin?: boolean;
      stdinOnce?: boolean;
      terminationMessagePath?: string;
      terminationMessagePolicy?: string;
      tty?: boolean;
      volumeDevices?: {
        devicePath: string;
        name: string;
      }[];
      volumeMounts?: {
        mountPath: string;
        mountPropagation?: string;
        name: string;
        readOnly?: boolean;
        recursiveReadOnly?: string;
        subPath?: string;
        subPathExpr?: string;
      }[];
      workingDir?: string;
    }[];
    keepDroppedTargets?: number;
    labelLimit?: number;
    labelNameLengthLimit?: number;
    labelValueLengthLimit?: number;
    listenLocal?: boolean;
    logFormat?: "" | "logfmt" | "json";
    logLevel?: "" | "debug" | "info" | "warn" | "error";
    maximumStartupDurationSeconds?: number;
    minReadySeconds?: number;
    nameEscapingScheme?: "AllowUTF8" | "Underscores" | "Dots" | "Values";
    nameValidationScheme?: "UTF8" | "Legacy";
    nodeSelector?: {
      [key: string]: unknown;
    };
    otlp?: {
      convertHistogramsToNHCB?: boolean;
      ignoreResourceAttributes?: string[];
      keepIdentifyingResourceAttributes?: boolean;
      promoteAllResourceAttributes?: boolean;
      promoteResourceAttributes?: string[];
      translationStrategy?: "NoUTF8EscapingWithSuffixes" | "UnderscoreEscapingWithSuffixes" | "NoTranslation";
    };
    overrideHonorLabels?: boolean;
    overrideHonorTimestamps?: boolean;
    paused?: boolean;
    persistentVolumeClaimRetentionPolicy?: {
      whenDeleted?: string;
      whenScaled?: string;
    };
    podMetadata?: {
      annotations?: {
        [key: string]: unknown;
      };
      labels?: {
        [key: string]: unknown;
      };
      name?: string;
    };
    podMonitorNamespaceSelector?: {
      matchExpressions?: {
        key: string;
        operator: string;
        values?: string[];
      }[];
      matchLabels?: {
        [key: string]: unknown;
      };
    };
    podMonitorSelector?: {
      matchExpressions?: {
        key: string;
        operator: string;
        values?: string[];
      }[];
      matchLabels?: {
        [key: string]: unknown;
      };
    };
    podTargetLabels?: string[];
    portName?: string;
    priorityClassName?: string;
    probeNamespaceSelector?: {
      matchExpressions?: {
        key: string;
        operator: string;
        values?: string[];
      }[];
      matchLabels?: {
        [key: string]: unknown;
      };
    };
    probeSelector?: {
      matchExpressions?: {
        key: string;
        operator: string;
        values?: string[];
      }[];
      matchLabels?: {
        [key: string]: unknown;
      };
    };
    prometheusExternalLabelName?: string;
    prometheusRulesExcludedFromEnforce?: {
      ruleName: string;
      ruleNamespace: string;
    }[];
    query?: {
      lookbackDelta?: string;
      maxConcurrency?: number;
      maxSamples?: number;
      timeout?: string;
    };
    queryLogFile?: string;
    reloadStrategy?: "HTTP" | "ProcessSignal";
    remoteRead?: {
      authorization?: {
        credentials?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        credentialsFile?: string;
        type?: string;
      };
      basicAuth?: {
        password?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        username?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      bearerToken?: string;
      bearerTokenFile?: string;
      filterExternalLabels?: boolean;
      followRedirects?: boolean;
      headers?: {
        [key: string]: unknown;
      };
      name?: string;
      noProxy?: string;
      oauth2?: {
        clientId: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        clientSecret: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        endpointParams?: {
          [key: string]: unknown;
        };
        noProxy?: string;
        proxyConnectHeader?: {
          [key: string]: unknown;
        };
        proxyFromEnvironment?: boolean;
        proxyUrl?: string;
        scopes?: string[];
        tlsConfig?: {
          ca?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          cert?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          insecureSkipVerify?: boolean;
          keySecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          serverName?: string;
        };
        tokenUrl: string;
      };
      proxyConnectHeader?: {
        [key: string]: unknown;
      };
      proxyFromEnvironment?: boolean;
      proxyUrl?: string;
      readRecent?: boolean;
      remoteTimeout?: string;
      requiredMatchers?: {
        [key: string]: unknown;
      };
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        caFile?: string;
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        certFile?: string;
        insecureSkipVerify?: boolean;
        keyFile?: string;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
      url: string;
    }[];
    remoteWrite?: {
      authorization?: {
        credentials?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        credentialsFile?: string;
        type?: string;
      };
      azureAd?: {
        cloud?: "AzureChina" | "AzureGovernment" | "AzurePublic";
        managedIdentity?: {
          clientId: string;
        };
        oauth?: {
          clientId: string;
          clientSecret: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          tenantId: string;
        };
        sdk?: {
          tenantId?: string;
        };
      };
      basicAuth?: {
        password?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        username?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      bearerToken?: string;
      bearerTokenFile?: string;
      enableHTTP2?: boolean;
      followRedirects?: boolean;
      headers?: {
        [key: string]: unknown;
      };
      messageVersion?: "V1.0" | "V2.0";
      metadataConfig?: {
        maxSamplesPerSend?: number;
        send?: boolean;
        sendInterval?: string;
      };
      name?: string;
      noProxy?: string;
      oauth2?: {
        clientId: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        clientSecret: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        endpointParams?: {
          [key: string]: unknown;
        };
        noProxy?: string;
        proxyConnectHeader?: {
          [key: string]: unknown;
        };
        proxyFromEnvironment?: boolean;
        proxyUrl?: string;
        scopes?: string[];
        tlsConfig?: {
          ca?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          cert?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          insecureSkipVerify?: boolean;
          keySecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          serverName?: string;
        };
        tokenUrl: string;
      };
      proxyConnectHeader?: {
        [key: string]: unknown;
      };
      proxyFromEnvironment?: boolean;
      proxyUrl?: string;
      queueConfig?: {
        batchSendDeadline?: string;
        capacity?: number;
        maxBackoff?: string;
        maxRetries?: number;
        maxSamplesPerSend?: number;
        maxShards?: number;
        minBackoff?: string;
        minShards?: number;
        retryOnRateLimit?: boolean;
        sampleAgeLimit?: string;
      };
      remoteTimeout?: string;
      roundRobinDNS?: boolean;
      sendExemplars?: boolean;
      sendNativeHistograms?: boolean;
      sigv4?: {
        accessKey?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        profile?: string;
        region?: string;
        roleArn?: string;
        secretKey?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        caFile?: string;
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        certFile?: string;
        insecureSkipVerify?: boolean;
        keyFile?: string;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
      url: string;
      writeRelabelConfigs?: {
        action?: "replace" | "Replace" | "keep" | "Keep" | "drop" | "Drop" | "hashmod" | "HashMod" | "labelmap" | "LabelMap" | "labeldrop" | "LabelDrop" | "labelkeep" | "LabelKeep" | "lowercase" | "Lowercase" | "uppercase" | "Uppercase" | "keepequal" | "KeepEqual" | "dropequal" | "DropEqual";
        modulus?: number;
        regex?: string;
        replacement?: string;
        separator?: string;
        sourceLabels?: string[];
        targetLabel?: string;
      }[];
    }[];
    remoteWriteReceiverMessageVersions?: ("V1.0" | "V2.0")[];
    replicaExternalLabelName?: string;
    replicas?: number;
    resources?: {
      claims?: {
        name: string;
        request?: string;
      }[];
      limits?: {
        [key: string]: unknown;
      };
      requests?: {
        [key: string]: unknown;
      };
    };
    retention?: string;
    retentionSize?: string;
    routePrefix?: string;
    ruleNamespaceSelector?: {
      matchExpressions?: {
        key: string;
        operator: string;
        values?: string[];
      }[];
      matchLabels?: {
        [key: string]: unknown;
      };
    };
    ruleQueryOffset?: string;
    ruleSelector?: {
      matchExpressions?: {
        key: string;
        operator: string;
        values?: string[];
      }[];
      matchLabels?: {
        [key: string]: unknown;
      };
    };
    rules?: {
      alert?: {
        forGracePeriod?: string;
        forOutageTolerance?: string;
        resendDelay?: string;
      };
    };
    runtime?: {
      goGC?: number;
    };
    sampleLimit?: number;
    scrapeClasses?: {
      attachMetadata?: {
        node?: boolean;
      };
      authorization?: {
        credentials?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        credentialsFile?: string;
        type?: string;
      };
      default?: boolean;
      fallbackScrapeProtocol?: "PrometheusProto" | "OpenMetricsText0.0.1" | "OpenMetricsText1.0.0" | "PrometheusText0.0.4" | "PrometheusText1.0.0";
      metricRelabelings?: {
        action?: "replace" | "Replace" | "keep" | "Keep" | "drop" | "Drop" | "hashmod" | "HashMod" | "labelmap" | "LabelMap" | "labeldrop" | "LabelDrop" | "labelkeep" | "LabelKeep" | "lowercase" | "Lowercase" | "uppercase" | "Uppercase" | "keepequal" | "KeepEqual" | "dropequal" | "DropEqual";
        modulus?: number;
        regex?: string;
        replacement?: string;
        separator?: string;
        sourceLabels?: string[];
        targetLabel?: string;
      }[];
      name: string;
      relabelings?: {
        action?: "replace" | "Replace" | "keep" | "Keep" | "drop" | "Drop" | "hashmod" | "HashMod" | "labelmap" | "LabelMap" | "labeldrop" | "LabelDrop" | "labelkeep" | "LabelKeep" | "lowercase" | "Lowercase" | "uppercase" | "Uppercase" | "keepequal" | "KeepEqual" | "dropequal" | "DropEqual";
        modulus?: number;
        regex?: string;
        replacement?: string;
        separator?: string;
        sourceLabels?: string[];
        targetLabel?: string;
      }[];
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        caFile?: string;
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        certFile?: string;
        insecureSkipVerify?: boolean;
        keyFile?: string;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
    }[];
    scrapeClassicHistograms?: boolean;
    scrapeConfigNamespaceSelector?: {
      matchExpressions?: {
        key: string;
        operator: string;
        values?: string[];
      }[];
      matchLabels?: {
        [key: string]: unknown;
      };
    };
    scrapeConfigSelector?: {
      matchExpressions?: {
        key: string;
        operator: string;
        values?: string[];
      }[];
      matchLabels?: {
        [key: string]: unknown;
      };
    };
    scrapeFailureLogFile?: string;
    scrapeInterval?: string;
    scrapeProtocols?: ("PrometheusProto" | "OpenMetricsText0.0.1" | "OpenMetricsText1.0.0" | "PrometheusText0.0.4" | "PrometheusText1.0.0")[];
    scrapeTimeout?: string;
    secrets?: string[];
    securityContext?: {
      appArmorProfile?: {
        localhostProfile?: string;
        type: string;
      };
      fsGroup?: number;
      fsGroupChangePolicy?: string;
      runAsGroup?: number;
      runAsNonRoot?: boolean;
      runAsUser?: number;
      seLinuxChangePolicy?: string;
      seLinuxOptions?: {
        level?: string;
        role?: string;
        type?: string;
        user?: string;
      };
      seccompProfile?: {
        localhostProfile?: string;
        type: string;
      };
      supplementalGroups?: number[];
      supplementalGroupsPolicy?: string;
      sysctls?: {
        name: string;
        value: string;
      }[];
      windowsOptions?: {
        gmsaCredentialSpec?: string;
        gmsaCredentialSpecName?: string;
        hostProcess?: boolean;
        runAsUserName?: string;
      };
    };
    serviceAccountName?: string;
    serviceDiscoveryRole?: "Endpoints" | "EndpointSlice";
    serviceMonitorNamespaceSelector?: {
      matchExpressions?: {
        key: string;
        operator: string;
        values?: string[];
      }[];
      matchLabels?: {
        [key: string]: unknown;
      };
    };
    serviceMonitorSelector?: {
      matchExpressions?: {
        key: string;
        operator: string;
        values?: string[];
      }[];
      matchLabels?: {
        [key: string]: unknown;
      };
    };
    serviceName?: string;
    sha?: string;
    shardRetentionPolicy?: {
      retain?: {
        retentionPeriod: string;
      };
      whenScaled?: "Retain" | "Delete";
    };
    shards?: number;
    storage?: {
      disableMountSubPath?: boolean;
      emptyDir?: {
        medium?: string;
        sizeLimit?: any;
      };
      ephemeral?: {
        volumeClaimTemplate?: {
          metadata?: {
            [key: string]: unknown;
          };
          spec: {
            accessModes?: string[];
            dataSource?: {
              apiGroup?: string;
              kind: string;
              name: string;
            };
            dataSourceRef?: {
              apiGroup?: string;
              kind: string;
              name: string;
              namespace?: string;
            };
            resources?: {
              limits?: {
                [key: string]: unknown;
              };
              requests?: {
                [key: string]: unknown;
              };
            };
            selector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            storageClassName?: string;
            volumeAttributesClassName?: string;
            volumeMode?: string;
            volumeName?: string;
          };
        };
      };
      volumeClaimTemplate?: {
        apiVersion?: string;
        kind?: string;
        metadata?: {
          annotations?: {
            [key: string]: unknown;
          };
          labels?: {
            [key: string]: unknown;
          };
          name?: string;
        };
        spec?: {
          accessModes?: string[];
          dataSource?: {
            apiGroup?: string;
            kind: string;
            name: string;
          };
          dataSourceRef?: {
            apiGroup?: string;
            kind: string;
            name: string;
            namespace?: string;
          };
          resources?: {
            limits?: {
              [key: string]: unknown;
            };
            requests?: {
              [key: string]: unknown;
            };
          };
          selector?: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchLabels?: {
              [key: string]: unknown;
            };
          };
          storageClassName?: string;
          volumeAttributesClassName?: string;
          volumeMode?: string;
          volumeName?: string;
        };
        status?: {
          accessModes?: string[];
          allocatedResourceStatuses?: {
            [key: string]: unknown;
          };
          allocatedResources?: {
            [key: string]: unknown;
          };
          capacity?: {
            [key: string]: unknown;
          };
          conditions?: {
            lastProbeTime?: string;
            lastTransitionTime?: string;
            message?: string;
            reason?: string;
            status: string;
            type: string;
          }[];
          currentVolumeAttributesClassName?: string;
          modifyVolumeStatus?: {
            status: string;
            targetVolumeAttributesClassName?: string;
          };
          phase?: string;
        };
      };
    };
    tag?: string;
    targetLimit?: number;
    terminationGracePeriodSeconds?: number;
    thanos?: {
      additionalArgs?: {
        name: string;
        value?: string;
      }[];
      baseImage?: string;
      blockSize?: string;
      getConfigInterval?: string;
      getConfigTimeout?: string;
      grpcListenLocal?: boolean;
      grpcServerTlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        caFile?: string;
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        certFile?: string;
        insecureSkipVerify?: boolean;
        keyFile?: string;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
      httpListenLocal?: boolean;
      image?: string;
      listenLocal?: boolean;
      logFormat?: "" | "logfmt" | "json";
      logLevel?: "" | "debug" | "info" | "warn" | "error";
      minTime?: string;
      objectStorageConfig?: {
        key: string;
        name?: string;
        optional?: boolean;
      };
      objectStorageConfigFile?: string;
      readyTimeout?: string;
      resources?: {
        claims?: {
          name: string;
          request?: string;
        }[];
        limits?: {
          [key: string]: unknown;
        };
        requests?: {
          [key: string]: unknown;
        };
      };
      sha?: string;
      tag?: string;
      tracingConfig?: {
        key: string;
        name?: string;
        optional?: boolean;
      };
      tracingConfigFile?: string;
      version?: string;
      volumeMounts?: {
        mountPath: string;
        mountPropagation?: string;
        name: string;
        readOnly?: boolean;
        recursiveReadOnly?: string;
        subPath?: string;
        subPathExpr?: string;
      }[];
    };
    tolerations?: {
      effect?: string;
      key?: string;
      operator?: string;
      tolerationSeconds?: number;
      value?: string;
    }[];
    topologySpreadConstraints?: {
      additionalLabelSelectors?: "OnResource" | "OnShard";
      labelSelector?: {
        matchExpressions?: {
          key: string;
          operator: string;
          values?: string[];
        }[];
        matchLabels?: {
          [key: string]: unknown;
        };
      };
      matchLabelKeys?: string[];
      maxSkew: number;
      minDomains?: number;
      nodeAffinityPolicy?: string;
      nodeTaintsPolicy?: string;
      topologyKey: string;
      whenUnsatisfiable: string;
    }[];
    tracingConfig?: {
      clientType?: "http" | "grpc";
      compression?: "gzip";
      endpoint: string;
      headers?: {
        [key: string]: unknown;
      };
      insecure?: boolean;
      samplingFraction?: any;
      timeout?: string;
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        caFile?: string;
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        certFile?: string;
        insecureSkipVerify?: boolean;
        keyFile?: string;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
    };
    tsdb?: {
      outOfOrderTimeWindow?: string;
    };
    version?: string;
    volumeMounts?: {
      mountPath: string;
      mountPropagation?: string;
      name: string;
      readOnly?: boolean;
      recursiveReadOnly?: string;
      subPath?: string;
      subPathExpr?: string;
    }[];
    volumes?: {
      awsElasticBlockStore?: {
        fsType?: string;
        partition?: number;
        readOnly?: boolean;
        volumeID: string;
      };
      azureDisk?: {
        cachingMode?: string;
        diskName: string;
        diskURI: string;
        fsType?: string;
        kind?: string;
        readOnly?: boolean;
      };
      azureFile?: {
        readOnly?: boolean;
        secretName: string;
        shareName: string;
      };
      cephfs?: {
        monitors: string[];
        path?: string;
        readOnly?: boolean;
        secretFile?: string;
        secretRef?: {
          name?: string;
        };
        user?: string;
      };
      cinder?: {
        fsType?: string;
        readOnly?: boolean;
        secretRef?: {
          name?: string;
        };
        volumeID: string;
      };
      configMap?: {
        defaultMode?: number;
        items?: {
          key: string;
          mode?: number;
          path: string;
        }[];
        name?: string;
        optional?: boolean;
      };
      csi?: {
        driver: string;
        fsType?: string;
        nodePublishSecretRef?: {
          name?: string;
        };
        readOnly?: boolean;
        volumeAttributes?: {
          [key: string]: unknown;
        };
      };
      downwardAPI?: {
        defaultMode?: number;
        items?: {
          fieldRef?: {
            apiVersion?: string;
            fieldPath: string;
          };
          mode?: number;
          path: string;
          resourceFieldRef?: {
            containerName?: string;
            divisor?: any;
            resource: string;
          };
        }[];
      };
      emptyDir?: {
        medium?: string;
        sizeLimit?: any;
      };
      ephemeral?: {
        volumeClaimTemplate?: {
          metadata?: {
            [key: string]: unknown;
          };
          spec: {
            accessModes?: string[];
            dataSource?: {
              apiGroup?: string;
              kind: string;
              name: string;
            };
            dataSourceRef?: {
              apiGroup?: string;
              kind: string;
              name: string;
              namespace?: string;
            };
            resources?: {
              limits?: {
                [key: string]: unknown;
              };
              requests?: {
                [key: string]: unknown;
              };
            };
            selector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            storageClassName?: string;
            volumeAttributesClassName?: string;
            volumeMode?: string;
            volumeName?: string;
          };
        };
      };
      fc?: {
        fsType?: string;
        lun?: number;
        readOnly?: boolean;
        targetWWNs?: string[];
        wwids?: string[];
      };
      flexVolume?: {
        driver: string;
        fsType?: string;
        options?: {
          [key: string]: unknown;
        };
        readOnly?: boolean;
        secretRef?: {
          name?: string;
        };
      };
      flocker?: {
        datasetName?: string;
        datasetUUID?: string;
      };
      gcePersistentDisk?: {
        fsType?: string;
        partition?: number;
        pdName: string;
        readOnly?: boolean;
      };
      gitRepo?: {
        directory?: string;
        repository: string;
        revision?: string;
      };
      glusterfs?: {
        endpoints: string;
        path: string;
        readOnly?: boolean;
      };
      hostPath?: {
        path: string;
        type?: string;
      };
      image?: {
        pullPolicy?: string;
        reference?: string;
      };
      iscsi?: {
        chapAuthDiscovery?: boolean;
        chapAuthSession?: boolean;
        fsType?: string;
        initiatorName?: string;
        iqn: string;
        iscsiInterface?: string;
        lun: number;
        portals?: string[];
        readOnly?: boolean;
        secretRef?: {
          name?: string;
        };
        targetPortal: string;
      };
      name: string;
      nfs?: {
        path: string;
        readOnly?: boolean;
        server: string;
      };
      persistentVolumeClaim?: {
        claimName: string;
        readOnly?: boolean;
      };
      photonPersistentDisk?: {
        fsType?: string;
        pdID: string;
      };
      portworxVolume?: {
        fsType?: string;
        readOnly?: boolean;
        volumeID: string;
      };
      projected?: {
        defaultMode?: number;
        sources?: {
          clusterTrustBundle?: {
            labelSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            name?: string;
            optional?: boolean;
            path: string;
            signerName?: string;
          };
          configMap?: {
            items?: {
              key: string;
              mode?: number;
              path: string;
            }[];
            name?: string;
            optional?: boolean;
          };
          downwardAPI?: {
            items?: {
              fieldRef?: {
                apiVersion?: string;
                fieldPath: string;
              };
              mode?: number;
              path: string;
              resourceFieldRef?: {
                containerName?: string;
                divisor?: any;
                resource: string;
              };
            }[];
          };
          secret?: {
            items?: {
              key: string;
              mode?: number;
              path: string;
            }[];
            name?: string;
            optional?: boolean;
          };
          serviceAccountToken?: {
            audience?: string;
            expirationSeconds?: number;
            path: string;
          };
        }[];
      };
      quobyte?: {
        group?: string;
        readOnly?: boolean;
        registry: string;
        tenant?: string;
        user?: string;
        volume: string;
      };
      rbd?: {
        fsType?: string;
        image: string;
        keyring?: string;
        monitors: string[];
        pool?: string;
        readOnly?: boolean;
        secretRef?: {
          name?: string;
        };
        user?: string;
      };
      scaleIO?: {
        fsType?: string;
        gateway: string;
        protectionDomain?: string;
        readOnly?: boolean;
        secretRef: {
          name?: string;
        };
        sslEnabled?: boolean;
        storageMode?: string;
        storagePool?: string;
        system: string;
        volumeName?: string;
      };
      secret?: {
        defaultMode?: number;
        items?: {
          key: string;
          mode?: number;
          path: string;
        }[];
        optional?: boolean;
        secretName?: string;
      };
      storageos?: {
        fsType?: string;
        readOnly?: boolean;
        secretRef?: {
          name?: string;
        };
        volumeName?: string;
        volumeNamespace?: string;
      };
      vsphereVolume?: {
        fsType?: string;
        storagePolicyID?: string;
        storagePolicyName?: string;
        volumePath: string;
      };
    }[];
    walCompression?: boolean;
    web?: {
      httpConfig?: {
        headers?: {
          contentSecurityPolicy?: string;
          strictTransportSecurity?: string;
          xContentTypeOptions?: "" | "NoSniff";
          xFrameOptions?: "" | "Deny" | "SameOrigin";
          xXSSProtection?: string;
        };
        http2?: boolean;
      };
      maxConnections?: number;
      pageTitle?: string;
      tlsConfig?: {
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        certFile?: string;
        cipherSuites?: string[];
        clientAuthType?: string;
        clientCAFile?: string;
        client_ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        curvePreferences?: string[];
        keyFile?: string;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: string;
        minVersion?: string;
        preferServerCipherSuites?: boolean;
      };
    };
  };
  status?: {
    availableReplicas: number;
    conditions?: {
      lastTransitionTime: string;
      message?: string;
      observedGeneration?: number;
      reason?: string;
      status: string;
      type: string;
    }[];
    paused: boolean;
    replicas: number;
    selector?: string;
    shardStatuses?: {
      availableReplicas: number;
      replicas: number;
      shardID: string;
      unavailableReplicas: number;
      updatedReplicas: number;
    }[];
    shards?: number;
    unavailableReplicas: number;
    updatedReplicas: number;
  };
}
/* com.coreos.monitoring.v1.PrometheusList */
/* PrometheusList is a list of Prometheus */
export interface MonitoringCoreosComV1PrometheusList {
  apiVersion?: string;
  items: MonitoringCoreosComV1Prometheus[];
  kind?: string;
  metadata?: ListMeta;
}
/* com.coreos.monitoring.v1.PrometheusRule */
/* The `PrometheusRule` custom resource definition (CRD) defines [alerting](https://prometheus.io/docs/prometheus/latest/configuration/alerting_rules/) and [recording](https://prometheus.io/docs/prometheus/latest/configuration/recording_rules/) rules to be evaluated by `Prometheus` or `ThanosRuler` objects.

`Prometheus` and `ThanosRuler` objects select `PrometheusRule` objects using label and namespace selectors. */
export interface MonitoringCoreosComV1PrometheusRule {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec: {
    groups?: {
      interval?: string;
      labels?: {
        [key: string]: unknown;
      };
      limit?: number;
      name: string;
      partial_response_strategy?: string;
      query_offset?: string;
      rules?: {
        alert?: string;
        annotations?: {
          [key: string]: unknown;
        };
        expr: any;
        for?: string;
        keep_firing_for?: string;
        labels?: {
          [key: string]: unknown;
        };
        record?: string;
      }[];
    }[];
  };
}
/* com.coreos.monitoring.v1.PrometheusRuleList */
/* PrometheusRuleList is a list of PrometheusRule */
export interface MonitoringCoreosComV1PrometheusRuleList {
  apiVersion?: string;
  items: MonitoringCoreosComV1PrometheusRule[];
  kind?: string;
  metadata?: ListMeta;
}
/* com.coreos.monitoring.v1.ServiceMonitor */
/* The `ServiceMonitor` custom resource definition (CRD) defines how `Prometheus` and `PrometheusAgent` can scrape metrics from a group of services.
Among other things, it allows to specify:
* The services to scrape via label selectors.
* The container ports to scrape.
* Authentication credentials to use.
* Target and metric relabeling.

`Prometheus` and `PrometheusAgent` objects select `ServiceMonitor` objects using label and namespace selectors. */
export interface MonitoringCoreosComV1ServiceMonitor {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec: {
    attachMetadata?: {
      node?: boolean;
    };
    bodySizeLimit?: string;
    convertClassicHistogramsToNHCB?: boolean;
    endpoints: {
      authorization?: {
        credentials?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        type?: string;
      };
      basicAuth?: {
        password?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        username?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      bearerTokenFile?: string;
      bearerTokenSecret?: {
        key: string;
        name?: string;
        optional?: boolean;
      };
      enableHttp2?: boolean;
      filterRunning?: boolean;
      followRedirects?: boolean;
      honorLabels?: boolean;
      honorTimestamps?: boolean;
      interval?: string;
      metricRelabelings?: {
        action?: "replace" | "Replace" | "keep" | "Keep" | "drop" | "Drop" | "hashmod" | "HashMod" | "labelmap" | "LabelMap" | "labeldrop" | "LabelDrop" | "labelkeep" | "LabelKeep" | "lowercase" | "Lowercase" | "uppercase" | "Uppercase" | "keepequal" | "KeepEqual" | "dropequal" | "DropEqual";
        modulus?: number;
        regex?: string;
        replacement?: string;
        separator?: string;
        sourceLabels?: string[];
        targetLabel?: string;
      }[];
      noProxy?: string;
      oauth2?: {
        clientId: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        clientSecret: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        endpointParams?: {
          [key: string]: unknown;
        };
        noProxy?: string;
        proxyConnectHeader?: {
          [key: string]: unknown;
        };
        proxyFromEnvironment?: boolean;
        proxyUrl?: string;
        scopes?: string[];
        tlsConfig?: {
          ca?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          cert?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          insecureSkipVerify?: boolean;
          keySecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          serverName?: string;
        };
        tokenUrl: string;
      };
      params?: {
        [key: string]: unknown;
      };
      path?: string;
      port?: string;
      proxyConnectHeader?: {
        [key: string]: unknown;
      };
      proxyFromEnvironment?: boolean;
      proxyUrl?: string;
      relabelings?: {
        action?: "replace" | "Replace" | "keep" | "Keep" | "drop" | "Drop" | "hashmod" | "HashMod" | "labelmap" | "LabelMap" | "labeldrop" | "LabelDrop" | "labelkeep" | "LabelKeep" | "lowercase" | "Lowercase" | "uppercase" | "Uppercase" | "keepequal" | "KeepEqual" | "dropequal" | "DropEqual";
        modulus?: number;
        regex?: string;
        replacement?: string;
        separator?: string;
        sourceLabels?: string[];
        targetLabel?: string;
      }[];
      scheme?: "http" | "https";
      scrapeTimeout?: string;
      targetPort?: any;
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        caFile?: string;
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        certFile?: string;
        insecureSkipVerify?: boolean;
        keyFile?: string;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
      trackTimestampsStaleness?: boolean;
    }[];
    fallbackScrapeProtocol?: "PrometheusProto" | "OpenMetricsText0.0.1" | "OpenMetricsText1.0.0" | "PrometheusText0.0.4" | "PrometheusText1.0.0";
    jobLabel?: string;
    keepDroppedTargets?: number;
    labelLimit?: number;
    labelNameLengthLimit?: number;
    labelValueLengthLimit?: number;
    namespaceSelector?: {
      any?: boolean;
      matchNames?: string[];
    };
    nativeHistogramBucketLimit?: number;
    nativeHistogramMinBucketFactor?: any;
    podTargetLabels?: string[];
    sampleLimit?: number;
    scrapeClass?: string;
    scrapeClassicHistograms?: boolean;
    scrapeProtocols?: ("PrometheusProto" | "OpenMetricsText0.0.1" | "OpenMetricsText1.0.0" | "PrometheusText0.0.4" | "PrometheusText1.0.0")[];
    selector: {
      matchExpressions?: {
        key: string;
        operator: string;
        values?: string[];
      }[];
      matchLabels?: {
        [key: string]: unknown;
      };
    };
    selectorMechanism?: "RelabelConfig" | "RoleSelector";
    targetLabels?: string[];
    targetLimit?: number;
  };
  status?: {
    bindings?: {
      conditions?: {
        lastTransitionTime: string;
        message?: string;
        observedGeneration?: number;
        reason?: string;
        status: string;
        type: "Accepted";
      }[];
      group: "monitoring.coreos.com";
      name: string;
      namespace: string;
      resource: "prometheuses" | "prometheusagents";
    }[];
  };
}
/* com.coreos.monitoring.v1.ServiceMonitorList */
/* ServiceMonitorList is a list of ServiceMonitor */
export interface MonitoringCoreosComV1ServiceMonitorList {
  apiVersion?: string;
  items: MonitoringCoreosComV1ServiceMonitor[];
  kind?: string;
  metadata?: ListMeta;
}
/* com.coreos.monitoring.v1.ThanosRuler */
/* The `ThanosRuler` custom resource definition (CRD) defines a desired [Thanos Ruler](https://github.com/thanos-io/thanos/blob/main/docs/components/rule.md) setup to run in a Kubernetes cluster.

A `ThanosRuler` instance requires at least one compatible Prometheus API endpoint (either Thanos Querier or Prometheus services).

The resource defines via label and namespace selectors which `PrometheusRule` objects should be associated to the deployed Thanos Ruler instances. */
export interface MonitoringCoreosComV1ThanosRuler {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec: {
    additionalArgs?: {
      name: string;
      value?: string;
    }[];
    affinity?: {
      nodeAffinity?: {
        preferredDuringSchedulingIgnoredDuringExecution?: {
          preference: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchFields?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
          };
          weight: number;
        }[];
        requiredDuringSchedulingIgnoredDuringExecution?: {
          nodeSelectorTerms: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchFields?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
          }[];
        };
      };
      podAffinity?: {
        preferredDuringSchedulingIgnoredDuringExecution?: {
          podAffinityTerm: {
            labelSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            matchLabelKeys?: string[];
            mismatchLabelKeys?: string[];
            namespaceSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            namespaces?: string[];
            topologyKey: string;
          };
          weight: number;
        }[];
        requiredDuringSchedulingIgnoredDuringExecution?: {
          labelSelector?: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchLabels?: {
              [key: string]: unknown;
            };
          };
          matchLabelKeys?: string[];
          mismatchLabelKeys?: string[];
          namespaceSelector?: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchLabels?: {
              [key: string]: unknown;
            };
          };
          namespaces?: string[];
          topologyKey: string;
        }[];
      };
      podAntiAffinity?: {
        preferredDuringSchedulingIgnoredDuringExecution?: {
          podAffinityTerm: {
            labelSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            matchLabelKeys?: string[];
            mismatchLabelKeys?: string[];
            namespaceSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            namespaces?: string[];
            topologyKey: string;
          };
          weight: number;
        }[];
        requiredDuringSchedulingIgnoredDuringExecution?: {
          labelSelector?: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchLabels?: {
              [key: string]: unknown;
            };
          };
          matchLabelKeys?: string[];
          mismatchLabelKeys?: string[];
          namespaceSelector?: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchLabels?: {
              [key: string]: unknown;
            };
          };
          namespaces?: string[];
          topologyKey: string;
        }[];
      };
    };
    alertDropLabels?: string[];
    alertQueryUrl?: string;
    alertRelabelConfigFile?: string;
    alertRelabelConfigs?: {
      key: string;
      name?: string;
      optional?: boolean;
    };
    alertmanagersConfig?: {
      key: string;
      name?: string;
      optional?: boolean;
    };
    alertmanagersUrl?: string[];
    containers?: {
      args?: string[];
      command?: string[];
      env?: {
        name: string;
        value?: string;
        valueFrom?: {
          configMapKeyRef?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          fieldRef?: {
            apiVersion?: string;
            fieldPath: string;
          };
          resourceFieldRef?: {
            containerName?: string;
            divisor?: any;
            resource: string;
          };
          secretKeyRef?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
      }[];
      envFrom?: {
        configMapRef?: {
          name?: string;
          optional?: boolean;
        };
        prefix?: string;
        secretRef?: {
          name?: string;
          optional?: boolean;
        };
      }[];
      image?: string;
      imagePullPolicy?: string;
      lifecycle?: {
        postStart?: {
          exec?: {
            command?: string[];
          };
          httpGet?: {
            host?: string;
            httpHeaders?: {
              name: string;
              value: string;
            }[];
            path?: string;
            port: any;
            scheme?: string;
          };
          sleep?: {
            seconds: number;
          };
          tcpSocket?: {
            host?: string;
            port: any;
          };
        };
        preStop?: {
          exec?: {
            command?: string[];
          };
          httpGet?: {
            host?: string;
            httpHeaders?: {
              name: string;
              value: string;
            }[];
            path?: string;
            port: any;
            scheme?: string;
          };
          sleep?: {
            seconds: number;
          };
          tcpSocket?: {
            host?: string;
            port: any;
          };
        };
        stopSignal?: string;
      };
      livenessProbe?: {
        exec?: {
          command?: string[];
        };
        failureThreshold?: number;
        grpc?: {
          port: number;
          service?: string;
        };
        httpGet?: {
          host?: string;
          httpHeaders?: {
            name: string;
            value: string;
          }[];
          path?: string;
          port: any;
          scheme?: string;
        };
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        tcpSocket?: {
          host?: string;
          port: any;
        };
        terminationGracePeriodSeconds?: number;
        timeoutSeconds?: number;
      };
      name: string;
      ports?: {
        containerPort: number;
        hostIP?: string;
        hostPort?: number;
        name?: string;
        protocol?: string;
      }[];
      readinessProbe?: {
        exec?: {
          command?: string[];
        };
        failureThreshold?: number;
        grpc?: {
          port: number;
          service?: string;
        };
        httpGet?: {
          host?: string;
          httpHeaders?: {
            name: string;
            value: string;
          }[];
          path?: string;
          port: any;
          scheme?: string;
        };
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        tcpSocket?: {
          host?: string;
          port: any;
        };
        terminationGracePeriodSeconds?: number;
        timeoutSeconds?: number;
      };
      resizePolicy?: {
        resourceName: string;
        restartPolicy: string;
      }[];
      resources?: {
        claims?: {
          name: string;
          request?: string;
        }[];
        limits?: {
          [key: string]: unknown;
        };
        requests?: {
          [key: string]: unknown;
        };
      };
      restartPolicy?: string;
      securityContext?: {
        allowPrivilegeEscalation?: boolean;
        appArmorProfile?: {
          localhostProfile?: string;
          type: string;
        };
        capabilities?: {
          add?: string[];
          drop?: string[];
        };
        privileged?: boolean;
        procMount?: string;
        readOnlyRootFilesystem?: boolean;
        runAsGroup?: number;
        runAsNonRoot?: boolean;
        runAsUser?: number;
        seLinuxOptions?: {
          level?: string;
          role?: string;
          type?: string;
          user?: string;
        };
        seccompProfile?: {
          localhostProfile?: string;
          type: string;
        };
        windowsOptions?: {
          gmsaCredentialSpec?: string;
          gmsaCredentialSpecName?: string;
          hostProcess?: boolean;
          runAsUserName?: string;
        };
      };
      startupProbe?: {
        exec?: {
          command?: string[];
        };
        failureThreshold?: number;
        grpc?: {
          port: number;
          service?: string;
        };
        httpGet?: {
          host?: string;
          httpHeaders?: {
            name: string;
            value: string;
          }[];
          path?: string;
          port: any;
          scheme?: string;
        };
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        tcpSocket?: {
          host?: string;
          port: any;
        };
        terminationGracePeriodSeconds?: number;
        timeoutSeconds?: number;
      };
      stdin?: boolean;
      stdinOnce?: boolean;
      terminationMessagePath?: string;
      terminationMessagePolicy?: string;
      tty?: boolean;
      volumeDevices?: {
        devicePath: string;
        name: string;
      }[];
      volumeMounts?: {
        mountPath: string;
        mountPropagation?: string;
        name: string;
        readOnly?: boolean;
        recursiveReadOnly?: string;
        subPath?: string;
        subPathExpr?: string;
      }[];
      workingDir?: string;
    }[];
    dnsConfig?: {
      nameservers?: string[];
      options?: {
        name: string;
        value?: string;
      }[];
      searches?: string[];
    };
    dnsPolicy?: "ClusterFirstWithHostNet" | "ClusterFirst" | "Default" | "None";
    enableFeatures?: string[];
    enableServiceLinks?: boolean;
    enforcedNamespaceLabel?: string;
    evaluationInterval?: string;
    excludedFromEnforcement?: {
      group?: "monitoring.coreos.com";
      name?: string;
      namespace: string;
      resource: "prometheusrules" | "servicemonitors" | "podmonitors" | "probes" | "scrapeconfigs";
    }[];
    externalPrefix?: string;
    grpcServerTlsConfig?: {
      ca?: {
        configMap?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        secret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      caFile?: string;
      cert?: {
        configMap?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        secret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      certFile?: string;
      insecureSkipVerify?: boolean;
      keyFile?: string;
      keySecret?: {
        key: string;
        name?: string;
        optional?: boolean;
      };
      maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
      minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
      serverName?: string;
    };
    hostAliases?: {
      hostnames: string[];
      ip: string;
    }[];
    hostUsers?: boolean;
    image?: string;
    imagePullPolicy?: "" | "Always" | "Never" | "IfNotPresent";
    imagePullSecrets?: {
      name?: string;
    }[];
    initContainers?: {
      args?: string[];
      command?: string[];
      env?: {
        name: string;
        value?: string;
        valueFrom?: {
          configMapKeyRef?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          fieldRef?: {
            apiVersion?: string;
            fieldPath: string;
          };
          resourceFieldRef?: {
            containerName?: string;
            divisor?: any;
            resource: string;
          };
          secretKeyRef?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
      }[];
      envFrom?: {
        configMapRef?: {
          name?: string;
          optional?: boolean;
        };
        prefix?: string;
        secretRef?: {
          name?: string;
          optional?: boolean;
        };
      }[];
      image?: string;
      imagePullPolicy?: string;
      lifecycle?: {
        postStart?: {
          exec?: {
            command?: string[];
          };
          httpGet?: {
            host?: string;
            httpHeaders?: {
              name: string;
              value: string;
            }[];
            path?: string;
            port: any;
            scheme?: string;
          };
          sleep?: {
            seconds: number;
          };
          tcpSocket?: {
            host?: string;
            port: any;
          };
        };
        preStop?: {
          exec?: {
            command?: string[];
          };
          httpGet?: {
            host?: string;
            httpHeaders?: {
              name: string;
              value: string;
            }[];
            path?: string;
            port: any;
            scheme?: string;
          };
          sleep?: {
            seconds: number;
          };
          tcpSocket?: {
            host?: string;
            port: any;
          };
        };
        stopSignal?: string;
      };
      livenessProbe?: {
        exec?: {
          command?: string[];
        };
        failureThreshold?: number;
        grpc?: {
          port: number;
          service?: string;
        };
        httpGet?: {
          host?: string;
          httpHeaders?: {
            name: string;
            value: string;
          }[];
          path?: string;
          port: any;
          scheme?: string;
        };
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        tcpSocket?: {
          host?: string;
          port: any;
        };
        terminationGracePeriodSeconds?: number;
        timeoutSeconds?: number;
      };
      name: string;
      ports?: {
        containerPort: number;
        hostIP?: string;
        hostPort?: number;
        name?: string;
        protocol?: string;
      }[];
      readinessProbe?: {
        exec?: {
          command?: string[];
        };
        failureThreshold?: number;
        grpc?: {
          port: number;
          service?: string;
        };
        httpGet?: {
          host?: string;
          httpHeaders?: {
            name: string;
            value: string;
          }[];
          path?: string;
          port: any;
          scheme?: string;
        };
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        tcpSocket?: {
          host?: string;
          port: any;
        };
        terminationGracePeriodSeconds?: number;
        timeoutSeconds?: number;
      };
      resizePolicy?: {
        resourceName: string;
        restartPolicy: string;
      }[];
      resources?: {
        claims?: {
          name: string;
          request?: string;
        }[];
        limits?: {
          [key: string]: unknown;
        };
        requests?: {
          [key: string]: unknown;
        };
      };
      restartPolicy?: string;
      securityContext?: {
        allowPrivilegeEscalation?: boolean;
        appArmorProfile?: {
          localhostProfile?: string;
          type: string;
        };
        capabilities?: {
          add?: string[];
          drop?: string[];
        };
        privileged?: boolean;
        procMount?: string;
        readOnlyRootFilesystem?: boolean;
        runAsGroup?: number;
        runAsNonRoot?: boolean;
        runAsUser?: number;
        seLinuxOptions?: {
          level?: string;
          role?: string;
          type?: string;
          user?: string;
        };
        seccompProfile?: {
          localhostProfile?: string;
          type: string;
        };
        windowsOptions?: {
          gmsaCredentialSpec?: string;
          gmsaCredentialSpecName?: string;
          hostProcess?: boolean;
          runAsUserName?: string;
        };
      };
      startupProbe?: {
        exec?: {
          command?: string[];
        };
        failureThreshold?: number;
        grpc?: {
          port: number;
          service?: string;
        };
        httpGet?: {
          host?: string;
          httpHeaders?: {
            name: string;
            value: string;
          }[];
          path?: string;
          port: any;
          scheme?: string;
        };
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        tcpSocket?: {
          host?: string;
          port: any;
        };
        terminationGracePeriodSeconds?: number;
        timeoutSeconds?: number;
      };
      stdin?: boolean;
      stdinOnce?: boolean;
      terminationMessagePath?: string;
      terminationMessagePolicy?: string;
      tty?: boolean;
      volumeDevices?: {
        devicePath: string;
        name: string;
      }[];
      volumeMounts?: {
        mountPath: string;
        mountPropagation?: string;
        name: string;
        readOnly?: boolean;
        recursiveReadOnly?: string;
        subPath?: string;
        subPathExpr?: string;
      }[];
      workingDir?: string;
    }[];
    labels?: {
      [key: string]: unknown;
    };
    listenLocal?: boolean;
    logFormat?: "" | "logfmt" | "json";
    logLevel?: "" | "debug" | "info" | "warn" | "error";
    minReadySeconds?: number;
    nodeSelector?: {
      [key: string]: unknown;
    };
    objectStorageConfig?: {
      key: string;
      name?: string;
      optional?: boolean;
    };
    objectStorageConfigFile?: string;
    paused?: boolean;
    podMetadata?: {
      annotations?: {
        [key: string]: unknown;
      };
      labels?: {
        [key: string]: unknown;
      };
      name?: string;
    };
    portName?: string;
    priorityClassName?: string;
    prometheusRulesExcludedFromEnforce?: {
      ruleName: string;
      ruleNamespace: string;
    }[];
    queryConfig?: {
      key: string;
      name?: string;
      optional?: boolean;
    };
    queryEndpoints?: string[];
    remoteWrite?: {
      authorization?: {
        credentials?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        credentialsFile?: string;
        type?: string;
      };
      azureAd?: {
        cloud?: "AzureChina" | "AzureGovernment" | "AzurePublic";
        managedIdentity?: {
          clientId: string;
        };
        oauth?: {
          clientId: string;
          clientSecret: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          tenantId: string;
        };
        sdk?: {
          tenantId?: string;
        };
      };
      basicAuth?: {
        password?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        username?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      bearerToken?: string;
      bearerTokenFile?: string;
      enableHTTP2?: boolean;
      followRedirects?: boolean;
      headers?: {
        [key: string]: unknown;
      };
      messageVersion?: "V1.0" | "V2.0";
      metadataConfig?: {
        maxSamplesPerSend?: number;
        send?: boolean;
        sendInterval?: string;
      };
      name?: string;
      noProxy?: string;
      oauth2?: {
        clientId: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        clientSecret: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        endpointParams?: {
          [key: string]: unknown;
        };
        noProxy?: string;
        proxyConnectHeader?: {
          [key: string]: unknown;
        };
        proxyFromEnvironment?: boolean;
        proxyUrl?: string;
        scopes?: string[];
        tlsConfig?: {
          ca?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          cert?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          insecureSkipVerify?: boolean;
          keySecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          serverName?: string;
        };
        tokenUrl: string;
      };
      proxyConnectHeader?: {
        [key: string]: unknown;
      };
      proxyFromEnvironment?: boolean;
      proxyUrl?: string;
      queueConfig?: {
        batchSendDeadline?: string;
        capacity?: number;
        maxBackoff?: string;
        maxRetries?: number;
        maxSamplesPerSend?: number;
        maxShards?: number;
        minBackoff?: string;
        minShards?: number;
        retryOnRateLimit?: boolean;
        sampleAgeLimit?: string;
      };
      remoteTimeout?: string;
      roundRobinDNS?: boolean;
      sendExemplars?: boolean;
      sendNativeHistograms?: boolean;
      sigv4?: {
        accessKey?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        profile?: string;
        region?: string;
        roleArn?: string;
        secretKey?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        caFile?: string;
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        certFile?: string;
        insecureSkipVerify?: boolean;
        keyFile?: string;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
      url: string;
      writeRelabelConfigs?: {
        action?: "replace" | "Replace" | "keep" | "Keep" | "drop" | "Drop" | "hashmod" | "HashMod" | "labelmap" | "LabelMap" | "labeldrop" | "LabelDrop" | "labelkeep" | "LabelKeep" | "lowercase" | "Lowercase" | "uppercase" | "Uppercase" | "keepequal" | "KeepEqual" | "dropequal" | "DropEqual";
        modulus?: number;
        regex?: string;
        replacement?: string;
        separator?: string;
        sourceLabels?: string[];
        targetLabel?: string;
      }[];
    }[];
    replicas?: number;
    resendDelay?: string;
    resources?: {
      claims?: {
        name: string;
        request?: string;
      }[];
      limits?: {
        [key: string]: unknown;
      };
      requests?: {
        [key: string]: unknown;
      };
    };
    retention?: string;
    routePrefix?: string;
    ruleConcurrentEval?: number;
    ruleGracePeriod?: string;
    ruleNamespaceSelector?: {
      matchExpressions?: {
        key: string;
        operator: string;
        values?: string[];
      }[];
      matchLabels?: {
        [key: string]: unknown;
      };
    };
    ruleOutageTolerance?: string;
    ruleQueryOffset?: string;
    ruleSelector?: {
      matchExpressions?: {
        key: string;
        operator: string;
        values?: string[];
      }[];
      matchLabels?: {
        [key: string]: unknown;
      };
    };
    securityContext?: {
      appArmorProfile?: {
        localhostProfile?: string;
        type: string;
      };
      fsGroup?: number;
      fsGroupChangePolicy?: string;
      runAsGroup?: number;
      runAsNonRoot?: boolean;
      runAsUser?: number;
      seLinuxChangePolicy?: string;
      seLinuxOptions?: {
        level?: string;
        role?: string;
        type?: string;
        user?: string;
      };
      seccompProfile?: {
        localhostProfile?: string;
        type: string;
      };
      supplementalGroups?: number[];
      supplementalGroupsPolicy?: string;
      sysctls?: {
        name: string;
        value: string;
      }[];
      windowsOptions?: {
        gmsaCredentialSpec?: string;
        gmsaCredentialSpecName?: string;
        hostProcess?: boolean;
        runAsUserName?: string;
      };
    };
    serviceAccountName?: string;
    serviceName?: string;
    storage?: {
      disableMountSubPath?: boolean;
      emptyDir?: {
        medium?: string;
        sizeLimit?: any;
      };
      ephemeral?: {
        volumeClaimTemplate?: {
          metadata?: {
            [key: string]: unknown;
          };
          spec: {
            accessModes?: string[];
            dataSource?: {
              apiGroup?: string;
              kind: string;
              name: string;
            };
            dataSourceRef?: {
              apiGroup?: string;
              kind: string;
              name: string;
              namespace?: string;
            };
            resources?: {
              limits?: {
                [key: string]: unknown;
              };
              requests?: {
                [key: string]: unknown;
              };
            };
            selector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            storageClassName?: string;
            volumeAttributesClassName?: string;
            volumeMode?: string;
            volumeName?: string;
          };
        };
      };
      volumeClaimTemplate?: {
        apiVersion?: string;
        kind?: string;
        metadata?: {
          annotations?: {
            [key: string]: unknown;
          };
          labels?: {
            [key: string]: unknown;
          };
          name?: string;
        };
        spec?: {
          accessModes?: string[];
          dataSource?: {
            apiGroup?: string;
            kind: string;
            name: string;
          };
          dataSourceRef?: {
            apiGroup?: string;
            kind: string;
            name: string;
            namespace?: string;
          };
          resources?: {
            limits?: {
              [key: string]: unknown;
            };
            requests?: {
              [key: string]: unknown;
            };
          };
          selector?: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchLabels?: {
              [key: string]: unknown;
            };
          };
          storageClassName?: string;
          volumeAttributesClassName?: string;
          volumeMode?: string;
          volumeName?: string;
        };
        status?: {
          accessModes?: string[];
          allocatedResourceStatuses?: {
            [key: string]: unknown;
          };
          allocatedResources?: {
            [key: string]: unknown;
          };
          capacity?: {
            [key: string]: unknown;
          };
          conditions?: {
            lastProbeTime?: string;
            lastTransitionTime?: string;
            message?: string;
            reason?: string;
            status: string;
            type: string;
          }[];
          currentVolumeAttributesClassName?: string;
          modifyVolumeStatus?: {
            status: string;
            targetVolumeAttributesClassName?: string;
          };
          phase?: string;
        };
      };
    };
    terminationGracePeriodSeconds?: number;
    tolerations?: {
      effect?: string;
      key?: string;
      operator?: string;
      tolerationSeconds?: number;
      value?: string;
    }[];
    topologySpreadConstraints?: {
      labelSelector?: {
        matchExpressions?: {
          key: string;
          operator: string;
          values?: string[];
        }[];
        matchLabels?: {
          [key: string]: unknown;
        };
      };
      matchLabelKeys?: string[];
      maxSkew: number;
      minDomains?: number;
      nodeAffinityPolicy?: string;
      nodeTaintsPolicy?: string;
      topologyKey: string;
      whenUnsatisfiable: string;
    }[];
    tracingConfig?: {
      key: string;
      name?: string;
      optional?: boolean;
    };
    tracingConfigFile?: string;
    version?: string;
    volumeMounts?: {
      mountPath: string;
      mountPropagation?: string;
      name: string;
      readOnly?: boolean;
      recursiveReadOnly?: string;
      subPath?: string;
      subPathExpr?: string;
    }[];
    volumes?: {
      awsElasticBlockStore?: {
        fsType?: string;
        partition?: number;
        readOnly?: boolean;
        volumeID: string;
      };
      azureDisk?: {
        cachingMode?: string;
        diskName: string;
        diskURI: string;
        fsType?: string;
        kind?: string;
        readOnly?: boolean;
      };
      azureFile?: {
        readOnly?: boolean;
        secretName: string;
        shareName: string;
      };
      cephfs?: {
        monitors: string[];
        path?: string;
        readOnly?: boolean;
        secretFile?: string;
        secretRef?: {
          name?: string;
        };
        user?: string;
      };
      cinder?: {
        fsType?: string;
        readOnly?: boolean;
        secretRef?: {
          name?: string;
        };
        volumeID: string;
      };
      configMap?: {
        defaultMode?: number;
        items?: {
          key: string;
          mode?: number;
          path: string;
        }[];
        name?: string;
        optional?: boolean;
      };
      csi?: {
        driver: string;
        fsType?: string;
        nodePublishSecretRef?: {
          name?: string;
        };
        readOnly?: boolean;
        volumeAttributes?: {
          [key: string]: unknown;
        };
      };
      downwardAPI?: {
        defaultMode?: number;
        items?: {
          fieldRef?: {
            apiVersion?: string;
            fieldPath: string;
          };
          mode?: number;
          path: string;
          resourceFieldRef?: {
            containerName?: string;
            divisor?: any;
            resource: string;
          };
        }[];
      };
      emptyDir?: {
        medium?: string;
        sizeLimit?: any;
      };
      ephemeral?: {
        volumeClaimTemplate?: {
          metadata?: {
            [key: string]: unknown;
          };
          spec: {
            accessModes?: string[];
            dataSource?: {
              apiGroup?: string;
              kind: string;
              name: string;
            };
            dataSourceRef?: {
              apiGroup?: string;
              kind: string;
              name: string;
              namespace?: string;
            };
            resources?: {
              limits?: {
                [key: string]: unknown;
              };
              requests?: {
                [key: string]: unknown;
              };
            };
            selector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            storageClassName?: string;
            volumeAttributesClassName?: string;
            volumeMode?: string;
            volumeName?: string;
          };
        };
      };
      fc?: {
        fsType?: string;
        lun?: number;
        readOnly?: boolean;
        targetWWNs?: string[];
        wwids?: string[];
      };
      flexVolume?: {
        driver: string;
        fsType?: string;
        options?: {
          [key: string]: unknown;
        };
        readOnly?: boolean;
        secretRef?: {
          name?: string;
        };
      };
      flocker?: {
        datasetName?: string;
        datasetUUID?: string;
      };
      gcePersistentDisk?: {
        fsType?: string;
        partition?: number;
        pdName: string;
        readOnly?: boolean;
      };
      gitRepo?: {
        directory?: string;
        repository: string;
        revision?: string;
      };
      glusterfs?: {
        endpoints: string;
        path: string;
        readOnly?: boolean;
      };
      hostPath?: {
        path: string;
        type?: string;
      };
      image?: {
        pullPolicy?: string;
        reference?: string;
      };
      iscsi?: {
        chapAuthDiscovery?: boolean;
        chapAuthSession?: boolean;
        fsType?: string;
        initiatorName?: string;
        iqn: string;
        iscsiInterface?: string;
        lun: number;
        portals?: string[];
        readOnly?: boolean;
        secretRef?: {
          name?: string;
        };
        targetPortal: string;
      };
      name: string;
      nfs?: {
        path: string;
        readOnly?: boolean;
        server: string;
      };
      persistentVolumeClaim?: {
        claimName: string;
        readOnly?: boolean;
      };
      photonPersistentDisk?: {
        fsType?: string;
        pdID: string;
      };
      portworxVolume?: {
        fsType?: string;
        readOnly?: boolean;
        volumeID: string;
      };
      projected?: {
        defaultMode?: number;
        sources?: {
          clusterTrustBundle?: {
            labelSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            name?: string;
            optional?: boolean;
            path: string;
            signerName?: string;
          };
          configMap?: {
            items?: {
              key: string;
              mode?: number;
              path: string;
            }[];
            name?: string;
            optional?: boolean;
          };
          downwardAPI?: {
            items?: {
              fieldRef?: {
                apiVersion?: string;
                fieldPath: string;
              };
              mode?: number;
              path: string;
              resourceFieldRef?: {
                containerName?: string;
                divisor?: any;
                resource: string;
              };
            }[];
          };
          secret?: {
            items?: {
              key: string;
              mode?: number;
              path: string;
            }[];
            name?: string;
            optional?: boolean;
          };
          serviceAccountToken?: {
            audience?: string;
            expirationSeconds?: number;
            path: string;
          };
        }[];
      };
      quobyte?: {
        group?: string;
        readOnly?: boolean;
        registry: string;
        tenant?: string;
        user?: string;
        volume: string;
      };
      rbd?: {
        fsType?: string;
        image: string;
        keyring?: string;
        monitors: string[];
        pool?: string;
        readOnly?: boolean;
        secretRef?: {
          name?: string;
        };
        user?: string;
      };
      scaleIO?: {
        fsType?: string;
        gateway: string;
        protectionDomain?: string;
        readOnly?: boolean;
        secretRef: {
          name?: string;
        };
        sslEnabled?: boolean;
        storageMode?: string;
        storagePool?: string;
        system: string;
        volumeName?: string;
      };
      secret?: {
        defaultMode?: number;
        items?: {
          key: string;
          mode?: number;
          path: string;
        }[];
        optional?: boolean;
        secretName?: string;
      };
      storageos?: {
        fsType?: string;
        readOnly?: boolean;
        secretRef?: {
          name?: string;
        };
        volumeName?: string;
        volumeNamespace?: string;
      };
      vsphereVolume?: {
        fsType?: string;
        storagePolicyID?: string;
        storagePolicyName?: string;
        volumePath: string;
      };
    }[];
    web?: {
      httpConfig?: {
        headers?: {
          contentSecurityPolicy?: string;
          strictTransportSecurity?: string;
          xContentTypeOptions?: "" | "NoSniff";
          xFrameOptions?: "" | "Deny" | "SameOrigin";
          xXSSProtection?: string;
        };
        http2?: boolean;
      };
      tlsConfig?: {
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        certFile?: string;
        cipherSuites?: string[];
        clientAuthType?: string;
        clientCAFile?: string;
        client_ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        curvePreferences?: string[];
        keyFile?: string;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: string;
        minVersion?: string;
        preferServerCipherSuites?: boolean;
      };
    };
  };
  status?: {
    availableReplicas: number;
    conditions?: {
      lastTransitionTime: string;
      message?: string;
      observedGeneration?: number;
      reason?: string;
      status: string;
      type: string;
    }[];
    paused: boolean;
    replicas: number;
    unavailableReplicas: number;
    updatedReplicas: number;
  };
}
/* com.coreos.monitoring.v1.ThanosRulerList */
/* ThanosRulerList is a list of ThanosRuler */
export interface MonitoringCoreosComV1ThanosRulerList {
  apiVersion?: string;
  items: MonitoringCoreosComV1ThanosRuler[];
  kind?: string;
  metadata?: ListMeta;
}
/* com.coreos.monitoring.v1alpha1.AlertmanagerConfig */
/* AlertmanagerConfig configures the Prometheus Alertmanager,
specifying how alerts should be grouped, inhibited and notified to external systems. */
export interface MonitoringCoreosComV1alpha1AlertmanagerConfig {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec: {
    inhibitRules?: {
      equal?: string[];
      sourceMatch?: {
        matchType?: "!=" | "=" | "=~" | "!~";
        name: string;
        regex?: boolean;
        value?: string;
      }[];
      targetMatch?: {
        matchType?: "!=" | "=" | "=~" | "!~";
        name: string;
        regex?: boolean;
        value?: string;
      }[];
    }[];
    muteTimeIntervals?: {
      name: string;
      timeIntervals?: {
        daysOfMonth?: {
          end?: number;
          start?: number;
        }[];
        months?: string[];
        times?: {
          endTime?: string;
          startTime?: string;
        }[];
        weekdays?: string[];
        years?: string[];
      }[];
    }[];
    receivers?: {
      discordConfigs?: {
        apiURL: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        avatarURL?: string;
        content?: string;
        httpConfig?: {
          authorization?: {
            credentials?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            type?: string;
          };
          basicAuth?: {
            password?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            username?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          bearerTokenSecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          followRedirects?: boolean;
          noProxy?: string;
          oauth2?: {
            clientId: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            clientSecret: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            endpointParams?: {
              [key: string]: unknown;
            };
            noProxy?: string;
            proxyConnectHeader?: {
              [key: string]: unknown;
            };
            proxyFromEnvironment?: boolean;
            proxyUrl?: string;
            scopes?: string[];
            tlsConfig?: {
              ca?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              cert?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              insecureSkipVerify?: boolean;
              keySecret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              serverName?: string;
            };
            tokenUrl: string;
          };
          proxyConnectHeader?: {
            [key: string]: unknown;
          };
          proxyFromEnvironment?: boolean;
          proxyURL?: string;
          proxyUrl?: string;
          tlsConfig?: {
            ca?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            cert?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            insecureSkipVerify?: boolean;
            keySecret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            serverName?: string;
          };
        };
        message?: string;
        sendResolved?: boolean;
        title?: string;
        username?: string;
      }[];
      emailConfigs?: {
        authIdentity?: string;
        authPassword?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        authSecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        authUsername?: string;
        from?: string;
        headers?: {
          key: string;
          value: string;
        }[];
        hello?: string;
        html?: string;
        requireTLS?: boolean;
        sendResolved?: boolean;
        smarthost?: string;
        text?: string;
        tlsConfig?: {
          ca?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          cert?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          insecureSkipVerify?: boolean;
          keySecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          serverName?: string;
        };
        to?: string;
      }[];
      msteamsConfigs?: {
        httpConfig?: {
          authorization?: {
            credentials?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            type?: string;
          };
          basicAuth?: {
            password?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            username?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          bearerTokenSecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          followRedirects?: boolean;
          noProxy?: string;
          oauth2?: {
            clientId: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            clientSecret: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            endpointParams?: {
              [key: string]: unknown;
            };
            noProxy?: string;
            proxyConnectHeader?: {
              [key: string]: unknown;
            };
            proxyFromEnvironment?: boolean;
            proxyUrl?: string;
            scopes?: string[];
            tlsConfig?: {
              ca?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              cert?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              insecureSkipVerify?: boolean;
              keySecret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              serverName?: string;
            };
            tokenUrl: string;
          };
          proxyConnectHeader?: {
            [key: string]: unknown;
          };
          proxyFromEnvironment?: boolean;
          proxyURL?: string;
          proxyUrl?: string;
          tlsConfig?: {
            ca?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            cert?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            insecureSkipVerify?: boolean;
            keySecret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            serverName?: string;
          };
        };
        sendResolved?: boolean;
        summary?: string;
        text?: string;
        title?: string;
        webhookUrl: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      }[];
      msteamsv2Configs?: {
        httpConfig?: {
          authorization?: {
            credentials?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            type?: string;
          };
          basicAuth?: {
            password?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            username?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          bearerTokenSecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          followRedirects?: boolean;
          noProxy?: string;
          oauth2?: {
            clientId: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            clientSecret: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            endpointParams?: {
              [key: string]: unknown;
            };
            noProxy?: string;
            proxyConnectHeader?: {
              [key: string]: unknown;
            };
            proxyFromEnvironment?: boolean;
            proxyUrl?: string;
            scopes?: string[];
            tlsConfig?: {
              ca?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              cert?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              insecureSkipVerify?: boolean;
              keySecret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              serverName?: string;
            };
            tokenUrl: string;
          };
          proxyConnectHeader?: {
            [key: string]: unknown;
          };
          proxyFromEnvironment?: boolean;
          proxyURL?: string;
          proxyUrl?: string;
          tlsConfig?: {
            ca?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            cert?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            insecureSkipVerify?: boolean;
            keySecret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            serverName?: string;
          };
        };
        sendResolved?: boolean;
        text?: string;
        title?: string;
        webhookURL?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      }[];
      name: string;
      opsgenieConfigs?: {
        actions?: string;
        apiKey?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        apiURL?: string;
        description?: string;
        details?: {
          key: string;
          value: string;
        }[];
        entity?: string;
        httpConfig?: {
          authorization?: {
            credentials?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            type?: string;
          };
          basicAuth?: {
            password?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            username?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          bearerTokenSecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          followRedirects?: boolean;
          noProxy?: string;
          oauth2?: {
            clientId: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            clientSecret: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            endpointParams?: {
              [key: string]: unknown;
            };
            noProxy?: string;
            proxyConnectHeader?: {
              [key: string]: unknown;
            };
            proxyFromEnvironment?: boolean;
            proxyUrl?: string;
            scopes?: string[];
            tlsConfig?: {
              ca?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              cert?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              insecureSkipVerify?: boolean;
              keySecret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              serverName?: string;
            };
            tokenUrl: string;
          };
          proxyConnectHeader?: {
            [key: string]: unknown;
          };
          proxyFromEnvironment?: boolean;
          proxyURL?: string;
          proxyUrl?: string;
          tlsConfig?: {
            ca?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            cert?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            insecureSkipVerify?: boolean;
            keySecret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            serverName?: string;
          };
        };
        message?: string;
        note?: string;
        priority?: string;
        responders?: {
          id?: string;
          name?: string;
          type: string;
          username?: string;
        }[];
        sendResolved?: boolean;
        source?: string;
        tags?: string;
        updateAlerts?: boolean;
      }[];
      pagerdutyConfigs?: {
        class?: string;
        client?: string;
        clientURL?: string;
        component?: string;
        description?: string;
        details?: {
          key: string;
          value: string;
        }[];
        group?: string;
        httpConfig?: {
          authorization?: {
            credentials?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            type?: string;
          };
          basicAuth?: {
            password?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            username?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          bearerTokenSecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          followRedirects?: boolean;
          noProxy?: string;
          oauth2?: {
            clientId: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            clientSecret: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            endpointParams?: {
              [key: string]: unknown;
            };
            noProxy?: string;
            proxyConnectHeader?: {
              [key: string]: unknown;
            };
            proxyFromEnvironment?: boolean;
            proxyUrl?: string;
            scopes?: string[];
            tlsConfig?: {
              ca?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              cert?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              insecureSkipVerify?: boolean;
              keySecret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              serverName?: string;
            };
            tokenUrl: string;
          };
          proxyConnectHeader?: {
            [key: string]: unknown;
          };
          proxyFromEnvironment?: boolean;
          proxyURL?: string;
          proxyUrl?: string;
          tlsConfig?: {
            ca?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            cert?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            insecureSkipVerify?: boolean;
            keySecret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            serverName?: string;
          };
        };
        pagerDutyImageConfigs?: {
          alt?: string;
          href?: string;
          src?: string;
        }[];
        pagerDutyLinkConfigs?: {
          alt?: string;
          href?: string;
        }[];
        routingKey?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        sendResolved?: boolean;
        serviceKey?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        severity?: string;
        source?: string;
        url?: string;
      }[];
      pushoverConfigs?: {
        device?: string;
        expire?: string;
        html?: boolean;
        httpConfig?: {
          authorization?: {
            credentials?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            type?: string;
          };
          basicAuth?: {
            password?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            username?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          bearerTokenSecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          followRedirects?: boolean;
          noProxy?: string;
          oauth2?: {
            clientId: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            clientSecret: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            endpointParams?: {
              [key: string]: unknown;
            };
            noProxy?: string;
            proxyConnectHeader?: {
              [key: string]: unknown;
            };
            proxyFromEnvironment?: boolean;
            proxyUrl?: string;
            scopes?: string[];
            tlsConfig?: {
              ca?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              cert?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              insecureSkipVerify?: boolean;
              keySecret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              serverName?: string;
            };
            tokenUrl: string;
          };
          proxyConnectHeader?: {
            [key: string]: unknown;
          };
          proxyFromEnvironment?: boolean;
          proxyURL?: string;
          proxyUrl?: string;
          tlsConfig?: {
            ca?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            cert?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            insecureSkipVerify?: boolean;
            keySecret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            serverName?: string;
          };
        };
        message?: string;
        priority?: string;
        retry?: string;
        sendResolved?: boolean;
        sound?: string;
        title?: string;
        token?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        tokenFile?: string;
        ttl?: string;
        url?: string;
        urlTitle?: string;
        userKey?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        userKeyFile?: string;
      }[];
      rocketchatConfigs?: {
        actions?: {
          msg?: string;
          text?: string;
          url?: string;
        }[];
        apiURL?: string;
        channel?: string;
        color?: string;
        emoji?: string;
        fields?: {
          short?: boolean;
          title?: string;
          value?: string;
        }[];
        httpConfig?: {
          authorization?: {
            credentials?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            type?: string;
          };
          basicAuth?: {
            password?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            username?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          bearerTokenSecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          followRedirects?: boolean;
          noProxy?: string;
          oauth2?: {
            clientId: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            clientSecret: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            endpointParams?: {
              [key: string]: unknown;
            };
            noProxy?: string;
            proxyConnectHeader?: {
              [key: string]: unknown;
            };
            proxyFromEnvironment?: boolean;
            proxyUrl?: string;
            scopes?: string[];
            tlsConfig?: {
              ca?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              cert?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              insecureSkipVerify?: boolean;
              keySecret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              serverName?: string;
            };
            tokenUrl: string;
          };
          proxyConnectHeader?: {
            [key: string]: unknown;
          };
          proxyFromEnvironment?: boolean;
          proxyURL?: string;
          proxyUrl?: string;
          tlsConfig?: {
            ca?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            cert?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            insecureSkipVerify?: boolean;
            keySecret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            serverName?: string;
          };
        };
        iconURL?: string;
        imageURL?: string;
        linkNames?: boolean;
        sendResolved?: boolean;
        shortFields?: boolean;
        text?: string;
        thumbURL?: string;
        title?: string;
        titleLink?: string;
        token: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        tokenID: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      }[];
      slackConfigs?: {
        actions?: {
          confirm?: {
            dismissText?: string;
            okText?: string;
            text: string;
            title?: string;
          };
          name?: string;
          style?: string;
          text: string;
          type: string;
          url?: string;
          value?: string;
        }[];
        apiURL?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        callbackId?: string;
        channel?: string;
        color?: string;
        fallback?: string;
        fields?: {
          short?: boolean;
          title: string;
          value: string;
        }[];
        footer?: string;
        httpConfig?: {
          authorization?: {
            credentials?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            type?: string;
          };
          basicAuth?: {
            password?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            username?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          bearerTokenSecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          followRedirects?: boolean;
          noProxy?: string;
          oauth2?: {
            clientId: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            clientSecret: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            endpointParams?: {
              [key: string]: unknown;
            };
            noProxy?: string;
            proxyConnectHeader?: {
              [key: string]: unknown;
            };
            proxyFromEnvironment?: boolean;
            proxyUrl?: string;
            scopes?: string[];
            tlsConfig?: {
              ca?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              cert?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              insecureSkipVerify?: boolean;
              keySecret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              serverName?: string;
            };
            tokenUrl: string;
          };
          proxyConnectHeader?: {
            [key: string]: unknown;
          };
          proxyFromEnvironment?: boolean;
          proxyURL?: string;
          proxyUrl?: string;
          tlsConfig?: {
            ca?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            cert?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            insecureSkipVerify?: boolean;
            keySecret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            serverName?: string;
          };
        };
        iconEmoji?: string;
        iconURL?: string;
        imageURL?: string;
        linkNames?: boolean;
        mrkdwnIn?: string[];
        pretext?: string;
        sendResolved?: boolean;
        shortFields?: boolean;
        text?: string;
        thumbURL?: string;
        title?: string;
        titleLink?: string;
        username?: string;
      }[];
      snsConfigs?: {
        apiURL?: string;
        attributes?: {
          [key: string]: unknown;
        };
        httpConfig?: {
          authorization?: {
            credentials?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            type?: string;
          };
          basicAuth?: {
            password?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            username?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          bearerTokenSecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          followRedirects?: boolean;
          noProxy?: string;
          oauth2?: {
            clientId: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            clientSecret: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            endpointParams?: {
              [key: string]: unknown;
            };
            noProxy?: string;
            proxyConnectHeader?: {
              [key: string]: unknown;
            };
            proxyFromEnvironment?: boolean;
            proxyUrl?: string;
            scopes?: string[];
            tlsConfig?: {
              ca?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              cert?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              insecureSkipVerify?: boolean;
              keySecret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              serverName?: string;
            };
            tokenUrl: string;
          };
          proxyConnectHeader?: {
            [key: string]: unknown;
          };
          proxyFromEnvironment?: boolean;
          proxyURL?: string;
          proxyUrl?: string;
          tlsConfig?: {
            ca?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            cert?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            insecureSkipVerify?: boolean;
            keySecret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            serverName?: string;
          };
        };
        message?: string;
        phoneNumber?: string;
        sendResolved?: boolean;
        sigv4?: {
          accessKey?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          profile?: string;
          region?: string;
          roleArn?: string;
          secretKey?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        subject?: string;
        targetARN?: string;
        topicARN?: string;
      }[];
      telegramConfigs?: {
        apiURL?: string;
        botToken?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        botTokenFile?: string;
        chatID: number;
        disableNotifications?: boolean;
        httpConfig?: {
          authorization?: {
            credentials?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            type?: string;
          };
          basicAuth?: {
            password?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            username?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          bearerTokenSecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          followRedirects?: boolean;
          noProxy?: string;
          oauth2?: {
            clientId: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            clientSecret: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            endpointParams?: {
              [key: string]: unknown;
            };
            noProxy?: string;
            proxyConnectHeader?: {
              [key: string]: unknown;
            };
            proxyFromEnvironment?: boolean;
            proxyUrl?: string;
            scopes?: string[];
            tlsConfig?: {
              ca?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              cert?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              insecureSkipVerify?: boolean;
              keySecret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              serverName?: string;
            };
            tokenUrl: string;
          };
          proxyConnectHeader?: {
            [key: string]: unknown;
          };
          proxyFromEnvironment?: boolean;
          proxyURL?: string;
          proxyUrl?: string;
          tlsConfig?: {
            ca?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            cert?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            insecureSkipVerify?: boolean;
            keySecret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            serverName?: string;
          };
        };
        message?: string;
        messageThreadID?: number;
        parseMode?: "MarkdownV2" | "Markdown" | "HTML";
        sendResolved?: boolean;
      }[];
      victoropsConfigs?: {
        apiKey?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        apiUrl?: string;
        customFields?: {
          key: string;
          value: string;
        }[];
        entityDisplayName?: string;
        httpConfig?: {
          authorization?: {
            credentials?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            type?: string;
          };
          basicAuth?: {
            password?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            username?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          bearerTokenSecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          followRedirects?: boolean;
          noProxy?: string;
          oauth2?: {
            clientId: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            clientSecret: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            endpointParams?: {
              [key: string]: unknown;
            };
            noProxy?: string;
            proxyConnectHeader?: {
              [key: string]: unknown;
            };
            proxyFromEnvironment?: boolean;
            proxyUrl?: string;
            scopes?: string[];
            tlsConfig?: {
              ca?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              cert?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              insecureSkipVerify?: boolean;
              keySecret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              serverName?: string;
            };
            tokenUrl: string;
          };
          proxyConnectHeader?: {
            [key: string]: unknown;
          };
          proxyFromEnvironment?: boolean;
          proxyURL?: string;
          proxyUrl?: string;
          tlsConfig?: {
            ca?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            cert?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            insecureSkipVerify?: boolean;
            keySecret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            serverName?: string;
          };
        };
        messageType?: string;
        monitoringTool?: string;
        routingKey?: string;
        sendResolved?: boolean;
        stateMessage?: string;
      }[];
      webexConfigs?: {
        apiURL?: string;
        httpConfig?: {
          authorization?: {
            credentials?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            type?: string;
          };
          basicAuth?: {
            password?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            username?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          bearerTokenSecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          followRedirects?: boolean;
          noProxy?: string;
          oauth2?: {
            clientId: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            clientSecret: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            endpointParams?: {
              [key: string]: unknown;
            };
            noProxy?: string;
            proxyConnectHeader?: {
              [key: string]: unknown;
            };
            proxyFromEnvironment?: boolean;
            proxyUrl?: string;
            scopes?: string[];
            tlsConfig?: {
              ca?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              cert?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              insecureSkipVerify?: boolean;
              keySecret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              serverName?: string;
            };
            tokenUrl: string;
          };
          proxyConnectHeader?: {
            [key: string]: unknown;
          };
          proxyFromEnvironment?: boolean;
          proxyURL?: string;
          proxyUrl?: string;
          tlsConfig?: {
            ca?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            cert?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            insecureSkipVerify?: boolean;
            keySecret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            serverName?: string;
          };
        };
        message?: string;
        roomID: string;
        sendResolved?: boolean;
      }[];
      webhookConfigs?: {
        httpConfig?: {
          authorization?: {
            credentials?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            type?: string;
          };
          basicAuth?: {
            password?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            username?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          bearerTokenSecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          followRedirects?: boolean;
          noProxy?: string;
          oauth2?: {
            clientId: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            clientSecret: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            endpointParams?: {
              [key: string]: unknown;
            };
            noProxy?: string;
            proxyConnectHeader?: {
              [key: string]: unknown;
            };
            proxyFromEnvironment?: boolean;
            proxyUrl?: string;
            scopes?: string[];
            tlsConfig?: {
              ca?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              cert?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              insecureSkipVerify?: boolean;
              keySecret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              serverName?: string;
            };
            tokenUrl: string;
          };
          proxyConnectHeader?: {
            [key: string]: unknown;
          };
          proxyFromEnvironment?: boolean;
          proxyURL?: string;
          proxyUrl?: string;
          tlsConfig?: {
            ca?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            cert?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            insecureSkipVerify?: boolean;
            keySecret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            serverName?: string;
          };
        };
        maxAlerts?: number;
        sendResolved?: boolean;
        timeout?: string;
        url?: string;
        urlSecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      }[];
      wechatConfigs?: {
        agentID?: string;
        apiSecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        apiURL?: string;
        corpID?: string;
        httpConfig?: {
          authorization?: {
            credentials?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            type?: string;
          };
          basicAuth?: {
            password?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            username?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          bearerTokenSecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          followRedirects?: boolean;
          noProxy?: string;
          oauth2?: {
            clientId: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            clientSecret: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            endpointParams?: {
              [key: string]: unknown;
            };
            noProxy?: string;
            proxyConnectHeader?: {
              [key: string]: unknown;
            };
            proxyFromEnvironment?: boolean;
            proxyUrl?: string;
            scopes?: string[];
            tlsConfig?: {
              ca?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              cert?: {
                configMap?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
                secret?: {
                  key: string;
                  name?: string;
                  optional?: boolean;
                };
              };
              insecureSkipVerify?: boolean;
              keySecret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
              serverName?: string;
            };
            tokenUrl: string;
          };
          proxyConnectHeader?: {
            [key: string]: unknown;
          };
          proxyFromEnvironment?: boolean;
          proxyURL?: string;
          proxyUrl?: string;
          tlsConfig?: {
            ca?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            cert?: {
              configMap?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              secret?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
            insecureSkipVerify?: boolean;
            keySecret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
            serverName?: string;
          };
        };
        message?: string;
        messageType?: string;
        sendResolved?: boolean;
        toParty?: string;
        toTag?: string;
        toUser?: string;
      }[];
    }[];
    route?: {
      activeTimeIntervals?: string[];
      continue?: boolean;
      groupBy?: string[];
      groupInterval?: string;
      groupWait?: string;
      matchers?: {
        matchType?: "!=" | "=" | "=~" | "!~";
        name: string;
        regex?: boolean;
        value?: string;
      }[];
      muteTimeIntervals?: string[];
      receiver?: string;
      repeatInterval?: string;
      routes?: any[];
    };
  };
}
/* com.coreos.monitoring.v1alpha1.AlertmanagerConfigList */
/* AlertmanagerConfigList is a list of AlertmanagerConfig */
export interface MonitoringCoreosComV1alpha1AlertmanagerConfigList {
  apiVersion?: string;
  items: MonitoringCoreosComV1alpha1AlertmanagerConfig[];
  kind?: string;
  metadata?: ListMeta;
}
/* com.coreos.monitoring.v1alpha1.PrometheusAgent */
/* The `PrometheusAgent` custom resource definition (CRD) defines a desired [Prometheus Agent](https://prometheus.io/blog/2021/11/16/agent/) setup to run in a Kubernetes cluster.

The CRD is very similar to the `Prometheus` CRD except for features which aren't available in agent mode like rule evaluation, persistent storage and Thanos sidecar. */
export interface MonitoringCoreosComV1alpha1PrometheusAgent {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec: {
    additionalArgs?: {
      name: string;
      value?: string;
    }[];
    additionalScrapeConfigs?: {
      key: string;
      name?: string;
      optional?: boolean;
    };
    affinity?: {
      nodeAffinity?: {
        preferredDuringSchedulingIgnoredDuringExecution?: {
          preference: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchFields?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
          };
          weight: number;
        }[];
        requiredDuringSchedulingIgnoredDuringExecution?: {
          nodeSelectorTerms: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchFields?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
          }[];
        };
      };
      podAffinity?: {
        preferredDuringSchedulingIgnoredDuringExecution?: {
          podAffinityTerm: {
            labelSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            matchLabelKeys?: string[];
            mismatchLabelKeys?: string[];
            namespaceSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            namespaces?: string[];
            topologyKey: string;
          };
          weight: number;
        }[];
        requiredDuringSchedulingIgnoredDuringExecution?: {
          labelSelector?: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchLabels?: {
              [key: string]: unknown;
            };
          };
          matchLabelKeys?: string[];
          mismatchLabelKeys?: string[];
          namespaceSelector?: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchLabels?: {
              [key: string]: unknown;
            };
          };
          namespaces?: string[];
          topologyKey: string;
        }[];
      };
      podAntiAffinity?: {
        preferredDuringSchedulingIgnoredDuringExecution?: {
          podAffinityTerm: {
            labelSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            matchLabelKeys?: string[];
            mismatchLabelKeys?: string[];
            namespaceSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            namespaces?: string[];
            topologyKey: string;
          };
          weight: number;
        }[];
        requiredDuringSchedulingIgnoredDuringExecution?: {
          labelSelector?: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchLabels?: {
              [key: string]: unknown;
            };
          };
          matchLabelKeys?: string[];
          mismatchLabelKeys?: string[];
          namespaceSelector?: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchLabels?: {
              [key: string]: unknown;
            };
          };
          namespaces?: string[];
          topologyKey: string;
        }[];
      };
    };
    apiserverConfig?: {
      authorization?: {
        credentials?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        credentialsFile?: string;
        type?: string;
      };
      basicAuth?: {
        password?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        username?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      bearerToken?: string;
      bearerTokenFile?: string;
      host: string;
      noProxy?: string;
      proxyConnectHeader?: {
        [key: string]: unknown;
      };
      proxyFromEnvironment?: boolean;
      proxyUrl?: string;
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        caFile?: string;
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        certFile?: string;
        insecureSkipVerify?: boolean;
        keyFile?: string;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
    };
    arbitraryFSAccessThroughSMs?: {
      deny?: boolean;
    };
    automountServiceAccountToken?: boolean;
    bodySizeLimit?: string;
    configMaps?: string[];
    containers?: {
      args?: string[];
      command?: string[];
      env?: {
        name: string;
        value?: string;
        valueFrom?: {
          configMapKeyRef?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          fieldRef?: {
            apiVersion?: string;
            fieldPath: string;
          };
          resourceFieldRef?: {
            containerName?: string;
            divisor?: any;
            resource: string;
          };
          secretKeyRef?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
      }[];
      envFrom?: {
        configMapRef?: {
          name?: string;
          optional?: boolean;
        };
        prefix?: string;
        secretRef?: {
          name?: string;
          optional?: boolean;
        };
      }[];
      image?: string;
      imagePullPolicy?: string;
      lifecycle?: {
        postStart?: {
          exec?: {
            command?: string[];
          };
          httpGet?: {
            host?: string;
            httpHeaders?: {
              name: string;
              value: string;
            }[];
            path?: string;
            port: any;
            scheme?: string;
          };
          sleep?: {
            seconds: number;
          };
          tcpSocket?: {
            host?: string;
            port: any;
          };
        };
        preStop?: {
          exec?: {
            command?: string[];
          };
          httpGet?: {
            host?: string;
            httpHeaders?: {
              name: string;
              value: string;
            }[];
            path?: string;
            port: any;
            scheme?: string;
          };
          sleep?: {
            seconds: number;
          };
          tcpSocket?: {
            host?: string;
            port: any;
          };
        };
        stopSignal?: string;
      };
      livenessProbe?: {
        exec?: {
          command?: string[];
        };
        failureThreshold?: number;
        grpc?: {
          port: number;
          service?: string;
        };
        httpGet?: {
          host?: string;
          httpHeaders?: {
            name: string;
            value: string;
          }[];
          path?: string;
          port: any;
          scheme?: string;
        };
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        tcpSocket?: {
          host?: string;
          port: any;
        };
        terminationGracePeriodSeconds?: number;
        timeoutSeconds?: number;
      };
      name: string;
      ports?: {
        containerPort: number;
        hostIP?: string;
        hostPort?: number;
        name?: string;
        protocol?: string;
      }[];
      readinessProbe?: {
        exec?: {
          command?: string[];
        };
        failureThreshold?: number;
        grpc?: {
          port: number;
          service?: string;
        };
        httpGet?: {
          host?: string;
          httpHeaders?: {
            name: string;
            value: string;
          }[];
          path?: string;
          port: any;
          scheme?: string;
        };
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        tcpSocket?: {
          host?: string;
          port: any;
        };
        terminationGracePeriodSeconds?: number;
        timeoutSeconds?: number;
      };
      resizePolicy?: {
        resourceName: string;
        restartPolicy: string;
      }[];
      resources?: {
        claims?: {
          name: string;
          request?: string;
        }[];
        limits?: {
          [key: string]: unknown;
        };
        requests?: {
          [key: string]: unknown;
        };
      };
      restartPolicy?: string;
      securityContext?: {
        allowPrivilegeEscalation?: boolean;
        appArmorProfile?: {
          localhostProfile?: string;
          type: string;
        };
        capabilities?: {
          add?: string[];
          drop?: string[];
        };
        privileged?: boolean;
        procMount?: string;
        readOnlyRootFilesystem?: boolean;
        runAsGroup?: number;
        runAsNonRoot?: boolean;
        runAsUser?: number;
        seLinuxOptions?: {
          level?: string;
          role?: string;
          type?: string;
          user?: string;
        };
        seccompProfile?: {
          localhostProfile?: string;
          type: string;
        };
        windowsOptions?: {
          gmsaCredentialSpec?: string;
          gmsaCredentialSpecName?: string;
          hostProcess?: boolean;
          runAsUserName?: string;
        };
      };
      startupProbe?: {
        exec?: {
          command?: string[];
        };
        failureThreshold?: number;
        grpc?: {
          port: number;
          service?: string;
        };
        httpGet?: {
          host?: string;
          httpHeaders?: {
            name: string;
            value: string;
          }[];
          path?: string;
          port: any;
          scheme?: string;
        };
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        tcpSocket?: {
          host?: string;
          port: any;
        };
        terminationGracePeriodSeconds?: number;
        timeoutSeconds?: number;
      };
      stdin?: boolean;
      stdinOnce?: boolean;
      terminationMessagePath?: string;
      terminationMessagePolicy?: string;
      tty?: boolean;
      volumeDevices?: {
        devicePath: string;
        name: string;
      }[];
      volumeMounts?: {
        mountPath: string;
        mountPropagation?: string;
        name: string;
        readOnly?: boolean;
        recursiveReadOnly?: string;
        subPath?: string;
        subPathExpr?: string;
      }[];
      workingDir?: string;
    }[];
    convertClassicHistogramsToNHCB?: boolean;
    dnsConfig?: {
      nameservers?: string[];
      options?: {
        name: string;
        value?: string;
      }[];
      searches?: string[];
    };
    dnsPolicy?: "ClusterFirstWithHostNet" | "ClusterFirst" | "Default" | "None";
    enableFeatures?: string[];
    enableOTLPReceiver?: boolean;
    enableRemoteWriteReceiver?: boolean;
    enableServiceLinks?: boolean;
    enforcedBodySizeLimit?: string;
    enforcedKeepDroppedTargets?: number;
    enforcedLabelLimit?: number;
    enforcedLabelNameLengthLimit?: number;
    enforcedLabelValueLengthLimit?: number;
    enforcedNamespaceLabel?: string;
    enforcedSampleLimit?: number;
    enforcedTargetLimit?: number;
    excludedFromEnforcement?: {
      group?: "monitoring.coreos.com";
      name?: string;
      namespace: string;
      resource: "prometheusrules" | "servicemonitors" | "podmonitors" | "probes" | "scrapeconfigs";
    }[];
    externalLabels?: {
      [key: string]: unknown;
    };
    externalUrl?: string;
    hostAliases?: {
      hostnames: string[];
      ip: string;
    }[];
    hostNetwork?: boolean;
    hostUsers?: boolean;
    ignoreNamespaceSelectors?: boolean;
    image?: string;
    imagePullPolicy?: "" | "Always" | "Never" | "IfNotPresent";
    imagePullSecrets?: {
      name?: string;
    }[];
    initContainers?: {
      args?: string[];
      command?: string[];
      env?: {
        name: string;
        value?: string;
        valueFrom?: {
          configMapKeyRef?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          fieldRef?: {
            apiVersion?: string;
            fieldPath: string;
          };
          resourceFieldRef?: {
            containerName?: string;
            divisor?: any;
            resource: string;
          };
          secretKeyRef?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
      }[];
      envFrom?: {
        configMapRef?: {
          name?: string;
          optional?: boolean;
        };
        prefix?: string;
        secretRef?: {
          name?: string;
          optional?: boolean;
        };
      }[];
      image?: string;
      imagePullPolicy?: string;
      lifecycle?: {
        postStart?: {
          exec?: {
            command?: string[];
          };
          httpGet?: {
            host?: string;
            httpHeaders?: {
              name: string;
              value: string;
            }[];
            path?: string;
            port: any;
            scheme?: string;
          };
          sleep?: {
            seconds: number;
          };
          tcpSocket?: {
            host?: string;
            port: any;
          };
        };
        preStop?: {
          exec?: {
            command?: string[];
          };
          httpGet?: {
            host?: string;
            httpHeaders?: {
              name: string;
              value: string;
            }[];
            path?: string;
            port: any;
            scheme?: string;
          };
          sleep?: {
            seconds: number;
          };
          tcpSocket?: {
            host?: string;
            port: any;
          };
        };
        stopSignal?: string;
      };
      livenessProbe?: {
        exec?: {
          command?: string[];
        };
        failureThreshold?: number;
        grpc?: {
          port: number;
          service?: string;
        };
        httpGet?: {
          host?: string;
          httpHeaders?: {
            name: string;
            value: string;
          }[];
          path?: string;
          port: any;
          scheme?: string;
        };
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        tcpSocket?: {
          host?: string;
          port: any;
        };
        terminationGracePeriodSeconds?: number;
        timeoutSeconds?: number;
      };
      name: string;
      ports?: {
        containerPort: number;
        hostIP?: string;
        hostPort?: number;
        name?: string;
        protocol?: string;
      }[];
      readinessProbe?: {
        exec?: {
          command?: string[];
        };
        failureThreshold?: number;
        grpc?: {
          port: number;
          service?: string;
        };
        httpGet?: {
          host?: string;
          httpHeaders?: {
            name: string;
            value: string;
          }[];
          path?: string;
          port: any;
          scheme?: string;
        };
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        tcpSocket?: {
          host?: string;
          port: any;
        };
        terminationGracePeriodSeconds?: number;
        timeoutSeconds?: number;
      };
      resizePolicy?: {
        resourceName: string;
        restartPolicy: string;
      }[];
      resources?: {
        claims?: {
          name: string;
          request?: string;
        }[];
        limits?: {
          [key: string]: unknown;
        };
        requests?: {
          [key: string]: unknown;
        };
      };
      restartPolicy?: string;
      securityContext?: {
        allowPrivilegeEscalation?: boolean;
        appArmorProfile?: {
          localhostProfile?: string;
          type: string;
        };
        capabilities?: {
          add?: string[];
          drop?: string[];
        };
        privileged?: boolean;
        procMount?: string;
        readOnlyRootFilesystem?: boolean;
        runAsGroup?: number;
        runAsNonRoot?: boolean;
        runAsUser?: number;
        seLinuxOptions?: {
          level?: string;
          role?: string;
          type?: string;
          user?: string;
        };
        seccompProfile?: {
          localhostProfile?: string;
          type: string;
        };
        windowsOptions?: {
          gmsaCredentialSpec?: string;
          gmsaCredentialSpecName?: string;
          hostProcess?: boolean;
          runAsUserName?: string;
        };
      };
      startupProbe?: {
        exec?: {
          command?: string[];
        };
        failureThreshold?: number;
        grpc?: {
          port: number;
          service?: string;
        };
        httpGet?: {
          host?: string;
          httpHeaders?: {
            name: string;
            value: string;
          }[];
          path?: string;
          port: any;
          scheme?: string;
        };
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        tcpSocket?: {
          host?: string;
          port: any;
        };
        terminationGracePeriodSeconds?: number;
        timeoutSeconds?: number;
      };
      stdin?: boolean;
      stdinOnce?: boolean;
      terminationMessagePath?: string;
      terminationMessagePolicy?: string;
      tty?: boolean;
      volumeDevices?: {
        devicePath: string;
        name: string;
      }[];
      volumeMounts?: {
        mountPath: string;
        mountPropagation?: string;
        name: string;
        readOnly?: boolean;
        recursiveReadOnly?: string;
        subPath?: string;
        subPathExpr?: string;
      }[];
      workingDir?: string;
    }[];
    keepDroppedTargets?: number;
    labelLimit?: number;
    labelNameLengthLimit?: number;
    labelValueLengthLimit?: number;
    listenLocal?: boolean;
    logFormat?: "" | "logfmt" | "json";
    logLevel?: "" | "debug" | "info" | "warn" | "error";
    maximumStartupDurationSeconds?: number;
    minReadySeconds?: number;
    mode?: "StatefulSet" | "DaemonSet";
    nameEscapingScheme?: "AllowUTF8" | "Underscores" | "Dots" | "Values";
    nameValidationScheme?: "UTF8" | "Legacy";
    nodeSelector?: {
      [key: string]: unknown;
    };
    otlp?: {
      convertHistogramsToNHCB?: boolean;
      ignoreResourceAttributes?: string[];
      keepIdentifyingResourceAttributes?: boolean;
      promoteAllResourceAttributes?: boolean;
      promoteResourceAttributes?: string[];
      translationStrategy?: "NoUTF8EscapingWithSuffixes" | "UnderscoreEscapingWithSuffixes" | "NoTranslation";
    };
    overrideHonorLabels?: boolean;
    overrideHonorTimestamps?: boolean;
    paused?: boolean;
    persistentVolumeClaimRetentionPolicy?: {
      whenDeleted?: string;
      whenScaled?: string;
    };
    podMetadata?: {
      annotations?: {
        [key: string]: unknown;
      };
      labels?: {
        [key: string]: unknown;
      };
      name?: string;
    };
    podMonitorNamespaceSelector?: {
      matchExpressions?: {
        key: string;
        operator: string;
        values?: string[];
      }[];
      matchLabels?: {
        [key: string]: unknown;
      };
    };
    podMonitorSelector?: {
      matchExpressions?: {
        key: string;
        operator: string;
        values?: string[];
      }[];
      matchLabels?: {
        [key: string]: unknown;
      };
    };
    podTargetLabels?: string[];
    portName?: string;
    priorityClassName?: string;
    probeNamespaceSelector?: {
      matchExpressions?: {
        key: string;
        operator: string;
        values?: string[];
      }[];
      matchLabels?: {
        [key: string]: unknown;
      };
    };
    probeSelector?: {
      matchExpressions?: {
        key: string;
        operator: string;
        values?: string[];
      }[];
      matchLabels?: {
        [key: string]: unknown;
      };
    };
    prometheusExternalLabelName?: string;
    reloadStrategy?: "HTTP" | "ProcessSignal";
    remoteWrite?: {
      authorization?: {
        credentials?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        credentialsFile?: string;
        type?: string;
      };
      azureAd?: {
        cloud?: "AzureChina" | "AzureGovernment" | "AzurePublic";
        managedIdentity?: {
          clientId: string;
        };
        oauth?: {
          clientId: string;
          clientSecret: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          tenantId: string;
        };
        sdk?: {
          tenantId?: string;
        };
      };
      basicAuth?: {
        password?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        username?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      bearerToken?: string;
      bearerTokenFile?: string;
      enableHTTP2?: boolean;
      followRedirects?: boolean;
      headers?: {
        [key: string]: unknown;
      };
      messageVersion?: "V1.0" | "V2.0";
      metadataConfig?: {
        maxSamplesPerSend?: number;
        send?: boolean;
        sendInterval?: string;
      };
      name?: string;
      noProxy?: string;
      oauth2?: {
        clientId: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        clientSecret: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        endpointParams?: {
          [key: string]: unknown;
        };
        noProxy?: string;
        proxyConnectHeader?: {
          [key: string]: unknown;
        };
        proxyFromEnvironment?: boolean;
        proxyUrl?: string;
        scopes?: string[];
        tlsConfig?: {
          ca?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          cert?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          insecureSkipVerify?: boolean;
          keySecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          serverName?: string;
        };
        tokenUrl: string;
      };
      proxyConnectHeader?: {
        [key: string]: unknown;
      };
      proxyFromEnvironment?: boolean;
      proxyUrl?: string;
      queueConfig?: {
        batchSendDeadline?: string;
        capacity?: number;
        maxBackoff?: string;
        maxRetries?: number;
        maxSamplesPerSend?: number;
        maxShards?: number;
        minBackoff?: string;
        minShards?: number;
        retryOnRateLimit?: boolean;
        sampleAgeLimit?: string;
      };
      remoteTimeout?: string;
      roundRobinDNS?: boolean;
      sendExemplars?: boolean;
      sendNativeHistograms?: boolean;
      sigv4?: {
        accessKey?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        profile?: string;
        region?: string;
        roleArn?: string;
        secretKey?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        caFile?: string;
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        certFile?: string;
        insecureSkipVerify?: boolean;
        keyFile?: string;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
      url: string;
      writeRelabelConfigs?: {
        action?: "replace" | "Replace" | "keep" | "Keep" | "drop" | "Drop" | "hashmod" | "HashMod" | "labelmap" | "LabelMap" | "labeldrop" | "LabelDrop" | "labelkeep" | "LabelKeep" | "lowercase" | "Lowercase" | "uppercase" | "Uppercase" | "keepequal" | "KeepEqual" | "dropequal" | "DropEqual";
        modulus?: number;
        regex?: string;
        replacement?: string;
        separator?: string;
        sourceLabels?: string[];
        targetLabel?: string;
      }[];
    }[];
    remoteWriteReceiverMessageVersions?: ("V1.0" | "V2.0")[];
    replicaExternalLabelName?: string;
    replicas?: number;
    resources?: {
      claims?: {
        name: string;
        request?: string;
      }[];
      limits?: {
        [key: string]: unknown;
      };
      requests?: {
        [key: string]: unknown;
      };
    };
    routePrefix?: string;
    runtime?: {
      goGC?: number;
    };
    sampleLimit?: number;
    scrapeClasses?: {
      attachMetadata?: {
        node?: boolean;
      };
      authorization?: {
        credentials?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        credentialsFile?: string;
        type?: string;
      };
      default?: boolean;
      fallbackScrapeProtocol?: "PrometheusProto" | "OpenMetricsText0.0.1" | "OpenMetricsText1.0.0" | "PrometheusText0.0.4" | "PrometheusText1.0.0";
      metricRelabelings?: {
        action?: "replace" | "Replace" | "keep" | "Keep" | "drop" | "Drop" | "hashmod" | "HashMod" | "labelmap" | "LabelMap" | "labeldrop" | "LabelDrop" | "labelkeep" | "LabelKeep" | "lowercase" | "Lowercase" | "uppercase" | "Uppercase" | "keepequal" | "KeepEqual" | "dropequal" | "DropEqual";
        modulus?: number;
        regex?: string;
        replacement?: string;
        separator?: string;
        sourceLabels?: string[];
        targetLabel?: string;
      }[];
      name: string;
      relabelings?: {
        action?: "replace" | "Replace" | "keep" | "Keep" | "drop" | "Drop" | "hashmod" | "HashMod" | "labelmap" | "LabelMap" | "labeldrop" | "LabelDrop" | "labelkeep" | "LabelKeep" | "lowercase" | "Lowercase" | "uppercase" | "Uppercase" | "keepequal" | "KeepEqual" | "dropequal" | "DropEqual";
        modulus?: number;
        regex?: string;
        replacement?: string;
        separator?: string;
        sourceLabels?: string[];
        targetLabel?: string;
      }[];
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        caFile?: string;
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        certFile?: string;
        insecureSkipVerify?: boolean;
        keyFile?: string;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
    }[];
    scrapeClassicHistograms?: boolean;
    scrapeConfigNamespaceSelector?: {
      matchExpressions?: {
        key: string;
        operator: string;
        values?: string[];
      }[];
      matchLabels?: {
        [key: string]: unknown;
      };
    };
    scrapeConfigSelector?: {
      matchExpressions?: {
        key: string;
        operator: string;
        values?: string[];
      }[];
      matchLabels?: {
        [key: string]: unknown;
      };
    };
    scrapeFailureLogFile?: string;
    scrapeInterval?: string;
    scrapeProtocols?: ("PrometheusProto" | "OpenMetricsText0.0.1" | "OpenMetricsText1.0.0" | "PrometheusText0.0.4" | "PrometheusText1.0.0")[];
    scrapeTimeout?: string;
    secrets?: string[];
    securityContext?: {
      appArmorProfile?: {
        localhostProfile?: string;
        type: string;
      };
      fsGroup?: number;
      fsGroupChangePolicy?: string;
      runAsGroup?: number;
      runAsNonRoot?: boolean;
      runAsUser?: number;
      seLinuxChangePolicy?: string;
      seLinuxOptions?: {
        level?: string;
        role?: string;
        type?: string;
        user?: string;
      };
      seccompProfile?: {
        localhostProfile?: string;
        type: string;
      };
      supplementalGroups?: number[];
      supplementalGroupsPolicy?: string;
      sysctls?: {
        name: string;
        value: string;
      }[];
      windowsOptions?: {
        gmsaCredentialSpec?: string;
        gmsaCredentialSpecName?: string;
        hostProcess?: boolean;
        runAsUserName?: string;
      };
    };
    serviceAccountName?: string;
    serviceDiscoveryRole?: "Endpoints" | "EndpointSlice";
    serviceMonitorNamespaceSelector?: {
      matchExpressions?: {
        key: string;
        operator: string;
        values?: string[];
      }[];
      matchLabels?: {
        [key: string]: unknown;
      };
    };
    serviceMonitorSelector?: {
      matchExpressions?: {
        key: string;
        operator: string;
        values?: string[];
      }[];
      matchLabels?: {
        [key: string]: unknown;
      };
    };
    serviceName?: string;
    shards?: number;
    storage?: {
      disableMountSubPath?: boolean;
      emptyDir?: {
        medium?: string;
        sizeLimit?: any;
      };
      ephemeral?: {
        volumeClaimTemplate?: {
          metadata?: {
            [key: string]: unknown;
          };
          spec: {
            accessModes?: string[];
            dataSource?: {
              apiGroup?: string;
              kind: string;
              name: string;
            };
            dataSourceRef?: {
              apiGroup?: string;
              kind: string;
              name: string;
              namespace?: string;
            };
            resources?: {
              limits?: {
                [key: string]: unknown;
              };
              requests?: {
                [key: string]: unknown;
              };
            };
            selector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            storageClassName?: string;
            volumeAttributesClassName?: string;
            volumeMode?: string;
            volumeName?: string;
          };
        };
      };
      volumeClaimTemplate?: {
        apiVersion?: string;
        kind?: string;
        metadata?: {
          annotations?: {
            [key: string]: unknown;
          };
          labels?: {
            [key: string]: unknown;
          };
          name?: string;
        };
        spec?: {
          accessModes?: string[];
          dataSource?: {
            apiGroup?: string;
            kind: string;
            name: string;
          };
          dataSourceRef?: {
            apiGroup?: string;
            kind: string;
            name: string;
            namespace?: string;
          };
          resources?: {
            limits?: {
              [key: string]: unknown;
            };
            requests?: {
              [key: string]: unknown;
            };
          };
          selector?: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchLabels?: {
              [key: string]: unknown;
            };
          };
          storageClassName?: string;
          volumeAttributesClassName?: string;
          volumeMode?: string;
          volumeName?: string;
        };
        status?: {
          accessModes?: string[];
          allocatedResourceStatuses?: {
            [key: string]: unknown;
          };
          allocatedResources?: {
            [key: string]: unknown;
          };
          capacity?: {
            [key: string]: unknown;
          };
          conditions?: {
            lastProbeTime?: string;
            lastTransitionTime?: string;
            message?: string;
            reason?: string;
            status: string;
            type: string;
          }[];
          currentVolumeAttributesClassName?: string;
          modifyVolumeStatus?: {
            status: string;
            targetVolumeAttributesClassName?: string;
          };
          phase?: string;
        };
      };
    };
    targetLimit?: number;
    terminationGracePeriodSeconds?: number;
    tolerations?: {
      effect?: string;
      key?: string;
      operator?: string;
      tolerationSeconds?: number;
      value?: string;
    }[];
    topologySpreadConstraints?: {
      additionalLabelSelectors?: "OnResource" | "OnShard";
      labelSelector?: {
        matchExpressions?: {
          key: string;
          operator: string;
          values?: string[];
        }[];
        matchLabels?: {
          [key: string]: unknown;
        };
      };
      matchLabelKeys?: string[];
      maxSkew: number;
      minDomains?: number;
      nodeAffinityPolicy?: string;
      nodeTaintsPolicy?: string;
      topologyKey: string;
      whenUnsatisfiable: string;
    }[];
    tracingConfig?: {
      clientType?: "http" | "grpc";
      compression?: "gzip";
      endpoint: string;
      headers?: {
        [key: string]: unknown;
      };
      insecure?: boolean;
      samplingFraction?: any;
      timeout?: string;
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        caFile?: string;
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        certFile?: string;
        insecureSkipVerify?: boolean;
        keyFile?: string;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
    };
    tsdb?: {
      outOfOrderTimeWindow?: string;
    };
    version?: string;
    volumeMounts?: {
      mountPath: string;
      mountPropagation?: string;
      name: string;
      readOnly?: boolean;
      recursiveReadOnly?: string;
      subPath?: string;
      subPathExpr?: string;
    }[];
    volumes?: {
      awsElasticBlockStore?: {
        fsType?: string;
        partition?: number;
        readOnly?: boolean;
        volumeID: string;
      };
      azureDisk?: {
        cachingMode?: string;
        diskName: string;
        diskURI: string;
        fsType?: string;
        kind?: string;
        readOnly?: boolean;
      };
      azureFile?: {
        readOnly?: boolean;
        secretName: string;
        shareName: string;
      };
      cephfs?: {
        monitors: string[];
        path?: string;
        readOnly?: boolean;
        secretFile?: string;
        secretRef?: {
          name?: string;
        };
        user?: string;
      };
      cinder?: {
        fsType?: string;
        readOnly?: boolean;
        secretRef?: {
          name?: string;
        };
        volumeID: string;
      };
      configMap?: {
        defaultMode?: number;
        items?: {
          key: string;
          mode?: number;
          path: string;
        }[];
        name?: string;
        optional?: boolean;
      };
      csi?: {
        driver: string;
        fsType?: string;
        nodePublishSecretRef?: {
          name?: string;
        };
        readOnly?: boolean;
        volumeAttributes?: {
          [key: string]: unknown;
        };
      };
      downwardAPI?: {
        defaultMode?: number;
        items?: {
          fieldRef?: {
            apiVersion?: string;
            fieldPath: string;
          };
          mode?: number;
          path: string;
          resourceFieldRef?: {
            containerName?: string;
            divisor?: any;
            resource: string;
          };
        }[];
      };
      emptyDir?: {
        medium?: string;
        sizeLimit?: any;
      };
      ephemeral?: {
        volumeClaimTemplate?: {
          metadata?: {
            [key: string]: unknown;
          };
          spec: {
            accessModes?: string[];
            dataSource?: {
              apiGroup?: string;
              kind: string;
              name: string;
            };
            dataSourceRef?: {
              apiGroup?: string;
              kind: string;
              name: string;
              namespace?: string;
            };
            resources?: {
              limits?: {
                [key: string]: unknown;
              };
              requests?: {
                [key: string]: unknown;
              };
            };
            selector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            storageClassName?: string;
            volumeAttributesClassName?: string;
            volumeMode?: string;
            volumeName?: string;
          };
        };
      };
      fc?: {
        fsType?: string;
        lun?: number;
        readOnly?: boolean;
        targetWWNs?: string[];
        wwids?: string[];
      };
      flexVolume?: {
        driver: string;
        fsType?: string;
        options?: {
          [key: string]: unknown;
        };
        readOnly?: boolean;
        secretRef?: {
          name?: string;
        };
      };
      flocker?: {
        datasetName?: string;
        datasetUUID?: string;
      };
      gcePersistentDisk?: {
        fsType?: string;
        partition?: number;
        pdName: string;
        readOnly?: boolean;
      };
      gitRepo?: {
        directory?: string;
        repository: string;
        revision?: string;
      };
      glusterfs?: {
        endpoints: string;
        path: string;
        readOnly?: boolean;
      };
      hostPath?: {
        path: string;
        type?: string;
      };
      image?: {
        pullPolicy?: string;
        reference?: string;
      };
      iscsi?: {
        chapAuthDiscovery?: boolean;
        chapAuthSession?: boolean;
        fsType?: string;
        initiatorName?: string;
        iqn: string;
        iscsiInterface?: string;
        lun: number;
        portals?: string[];
        readOnly?: boolean;
        secretRef?: {
          name?: string;
        };
        targetPortal: string;
      };
      name: string;
      nfs?: {
        path: string;
        readOnly?: boolean;
        server: string;
      };
      persistentVolumeClaim?: {
        claimName: string;
        readOnly?: boolean;
      };
      photonPersistentDisk?: {
        fsType?: string;
        pdID: string;
      };
      portworxVolume?: {
        fsType?: string;
        readOnly?: boolean;
        volumeID: string;
      };
      projected?: {
        defaultMode?: number;
        sources?: {
          clusterTrustBundle?: {
            labelSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            name?: string;
            optional?: boolean;
            path: string;
            signerName?: string;
          };
          configMap?: {
            items?: {
              key: string;
              mode?: number;
              path: string;
            }[];
            name?: string;
            optional?: boolean;
          };
          downwardAPI?: {
            items?: {
              fieldRef?: {
                apiVersion?: string;
                fieldPath: string;
              };
              mode?: number;
              path: string;
              resourceFieldRef?: {
                containerName?: string;
                divisor?: any;
                resource: string;
              };
            }[];
          };
          secret?: {
            items?: {
              key: string;
              mode?: number;
              path: string;
            }[];
            name?: string;
            optional?: boolean;
          };
          serviceAccountToken?: {
            audience?: string;
            expirationSeconds?: number;
            path: string;
          };
        }[];
      };
      quobyte?: {
        group?: string;
        readOnly?: boolean;
        registry: string;
        tenant?: string;
        user?: string;
        volume: string;
      };
      rbd?: {
        fsType?: string;
        image: string;
        keyring?: string;
        monitors: string[];
        pool?: string;
        readOnly?: boolean;
        secretRef?: {
          name?: string;
        };
        user?: string;
      };
      scaleIO?: {
        fsType?: string;
        gateway: string;
        protectionDomain?: string;
        readOnly?: boolean;
        secretRef: {
          name?: string;
        };
        sslEnabled?: boolean;
        storageMode?: string;
        storagePool?: string;
        system: string;
        volumeName?: string;
      };
      secret?: {
        defaultMode?: number;
        items?: {
          key: string;
          mode?: number;
          path: string;
        }[];
        optional?: boolean;
        secretName?: string;
      };
      storageos?: {
        fsType?: string;
        readOnly?: boolean;
        secretRef?: {
          name?: string;
        };
        volumeName?: string;
        volumeNamespace?: string;
      };
      vsphereVolume?: {
        fsType?: string;
        storagePolicyID?: string;
        storagePolicyName?: string;
        volumePath: string;
      };
    }[];
    walCompression?: boolean;
    web?: {
      httpConfig?: {
        headers?: {
          contentSecurityPolicy?: string;
          strictTransportSecurity?: string;
          xContentTypeOptions?: "" | "NoSniff";
          xFrameOptions?: "" | "Deny" | "SameOrigin";
          xXSSProtection?: string;
        };
        http2?: boolean;
      };
      maxConnections?: number;
      pageTitle?: string;
      tlsConfig?: {
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        certFile?: string;
        cipherSuites?: string[];
        clientAuthType?: string;
        clientCAFile?: string;
        client_ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        curvePreferences?: string[];
        keyFile?: string;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: string;
        minVersion?: string;
        preferServerCipherSuites?: boolean;
      };
    };
  };
  status?: {
    availableReplicas: number;
    conditions?: {
      lastTransitionTime: string;
      message?: string;
      observedGeneration?: number;
      reason?: string;
      status: string;
      type: string;
    }[];
    paused: boolean;
    replicas: number;
    selector?: string;
    shardStatuses?: {
      availableReplicas: number;
      replicas: number;
      shardID: string;
      unavailableReplicas: number;
      updatedReplicas: number;
    }[];
    shards?: number;
    unavailableReplicas: number;
    updatedReplicas: number;
  };
}
/* com.coreos.monitoring.v1alpha1.PrometheusAgentList */
/* PrometheusAgentList is a list of PrometheusAgent */
export interface MonitoringCoreosComV1alpha1PrometheusAgentList {
  apiVersion?: string;
  items: MonitoringCoreosComV1alpha1PrometheusAgent[];
  kind?: string;
  metadata?: ListMeta;
}
/* com.coreos.monitoring.v1alpha1.ScrapeConfig */
/* ScrapeConfig defines a namespaced Prometheus scrape_config to be aggregated across
multiple namespaces into the Prometheus configuration. */
export interface MonitoringCoreosComV1alpha1ScrapeConfig {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec: {
    authorization?: {
      credentials?: {
        key: string;
        name?: string;
        optional?: boolean;
      };
      type?: string;
    };
    azureSDConfigs?: {
      authenticationMethod?: "OAuth" | "ManagedIdentity" | "SDK";
      authorization?: {
        credentials?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        type?: string;
      };
      basicAuth?: {
        password?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        username?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      clientID?: string;
      clientSecret?: {
        key: string;
        name?: string;
        optional?: boolean;
      };
      enableHTTP2?: boolean;
      environment?: string;
      followRedirects?: boolean;
      noProxy?: string;
      oauth2?: {
        clientId: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        clientSecret: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        endpointParams?: {
          [key: string]: unknown;
        };
        noProxy?: string;
        proxyConnectHeader?: {
          [key: string]: unknown;
        };
        proxyFromEnvironment?: boolean;
        proxyUrl?: string;
        scopes?: string[];
        tlsConfig?: {
          ca?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          cert?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          insecureSkipVerify?: boolean;
          keySecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          serverName?: string;
        };
        tokenUrl: string;
      };
      port?: number;
      proxyConnectHeader?: {
        [key: string]: unknown;
      };
      proxyFromEnvironment?: boolean;
      proxyUrl?: string;
      refreshInterval?: string;
      resourceGroup?: string;
      subscriptionID: string;
      tenantID?: string;
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        insecureSkipVerify?: boolean;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
    }[];
    basicAuth?: {
      password?: {
        key: string;
        name?: string;
        optional?: boolean;
      };
      username?: {
        key: string;
        name?: string;
        optional?: boolean;
      };
    };
    consulSDConfigs?: {
      allowStale?: boolean;
      authorization?: {
        credentials?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        type?: string;
      };
      basicAuth?: {
        password?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        username?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      datacenter?: string;
      enableHTTP2?: boolean;
      filter?: string;
      followRedirects?: boolean;
      namespace?: string;
      noProxy?: string;
      nodeMeta?: {
        [key: string]: unknown;
      };
      oauth2?: {
        clientId: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        clientSecret: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        endpointParams?: {
          [key: string]: unknown;
        };
        noProxy?: string;
        proxyConnectHeader?: {
          [key: string]: unknown;
        };
        proxyFromEnvironment?: boolean;
        proxyUrl?: string;
        scopes?: string[];
        tlsConfig?: {
          ca?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          cert?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          insecureSkipVerify?: boolean;
          keySecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          serverName?: string;
        };
        tokenUrl: string;
      };
      partition?: string;
      pathPrefix?: string;
      proxyConnectHeader?: {
        [key: string]: unknown;
      };
      proxyFromEnvironment?: boolean;
      proxyUrl?: string;
      refreshInterval?: string;
      scheme?: "HTTP" | "HTTPS";
      server: string;
      services?: string[];
      tagSeparator?: string;
      tags?: string[];
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        insecureSkipVerify?: boolean;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
      tokenRef?: {
        key: string;
        name?: string;
        optional?: boolean;
      };
    }[];
    convertClassicHistogramsToNHCB?: boolean;
    digitalOceanSDConfigs?: {
      authorization?: {
        credentials?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        type?: string;
      };
      enableHTTP2?: boolean;
      followRedirects?: boolean;
      noProxy?: string;
      oauth2?: {
        clientId: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        clientSecret: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        endpointParams?: {
          [key: string]: unknown;
        };
        noProxy?: string;
        proxyConnectHeader?: {
          [key: string]: unknown;
        };
        proxyFromEnvironment?: boolean;
        proxyUrl?: string;
        scopes?: string[];
        tlsConfig?: {
          ca?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          cert?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          insecureSkipVerify?: boolean;
          keySecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          serverName?: string;
        };
        tokenUrl: string;
      };
      port?: number;
      proxyConnectHeader?: {
        [key: string]: unknown;
      };
      proxyFromEnvironment?: boolean;
      proxyUrl?: string;
      refreshInterval?: string;
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        insecureSkipVerify?: boolean;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
    }[];
    dnsSDConfigs?: {
      names: string[];
      port?: number;
      refreshInterval?: string;
      type?: "A" | "AAAA" | "MX" | "NS" | "SRV";
    }[];
    dockerSDConfigs?: {
      authorization?: {
        credentials?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        type?: string;
      };
      basicAuth?: {
        password?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        username?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      enableHTTP2?: boolean;
      filters?: {
        name: string;
        values: string[];
      }[];
      followRedirects?: boolean;
      host: string;
      hostNetworkingHost?: string;
      matchFirstNetwork?: boolean;
      noProxy?: string;
      oauth2?: {
        clientId: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        clientSecret: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        endpointParams?: {
          [key: string]: unknown;
        };
        noProxy?: string;
        proxyConnectHeader?: {
          [key: string]: unknown;
        };
        proxyFromEnvironment?: boolean;
        proxyUrl?: string;
        scopes?: string[];
        tlsConfig?: {
          ca?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          cert?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          insecureSkipVerify?: boolean;
          keySecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          serverName?: string;
        };
        tokenUrl: string;
      };
      port?: number;
      proxyConnectHeader?: {
        [key: string]: unknown;
      };
      proxyFromEnvironment?: boolean;
      proxyUrl?: string;
      refreshInterval?: string;
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        insecureSkipVerify?: boolean;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
    }[];
    dockerSwarmSDConfigs?: {
      authorization?: {
        credentials?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        type?: string;
      };
      basicAuth?: {
        password?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        username?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      enableHTTP2?: boolean;
      filters?: {
        name: string;
        values: string[];
      }[];
      followRedirects?: boolean;
      host: string;
      noProxy?: string;
      oauth2?: {
        clientId: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        clientSecret: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        endpointParams?: {
          [key: string]: unknown;
        };
        noProxy?: string;
        proxyConnectHeader?: {
          [key: string]: unknown;
        };
        proxyFromEnvironment?: boolean;
        proxyUrl?: string;
        scopes?: string[];
        tlsConfig?: {
          ca?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          cert?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          insecureSkipVerify?: boolean;
          keySecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          serverName?: string;
        };
        tokenUrl: string;
      };
      port?: number;
      proxyConnectHeader?: {
        [key: string]: unknown;
      };
      proxyFromEnvironment?: boolean;
      proxyUrl?: string;
      refreshInterval?: string;
      role: "Services" | "Tasks" | "Nodes";
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        insecureSkipVerify?: boolean;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
    }[];
    ec2SDConfigs?: {
      accessKey?: {
        key: string;
        name?: string;
        optional?: boolean;
      };
      enableHTTP2?: boolean;
      filters?: {
        name: string;
        values: string[];
      }[];
      followRedirects?: boolean;
      noProxy?: string;
      port?: number;
      proxyConnectHeader?: {
        [key: string]: unknown;
      };
      proxyFromEnvironment?: boolean;
      proxyUrl?: string;
      refreshInterval?: string;
      region?: string;
      roleARN?: string;
      secretKey?: {
        key: string;
        name?: string;
        optional?: boolean;
      };
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        insecureSkipVerify?: boolean;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
    }[];
    enableCompression?: boolean;
    enableHTTP2?: boolean;
    eurekaSDConfigs?: {
      authorization?: {
        credentials?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        type?: string;
      };
      basicAuth?: {
        password?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        username?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      enableHTTP2?: boolean;
      followRedirects?: boolean;
      noProxy?: string;
      oauth2?: {
        clientId: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        clientSecret: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        endpointParams?: {
          [key: string]: unknown;
        };
        noProxy?: string;
        proxyConnectHeader?: {
          [key: string]: unknown;
        };
        proxyFromEnvironment?: boolean;
        proxyUrl?: string;
        scopes?: string[];
        tlsConfig?: {
          ca?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          cert?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          insecureSkipVerify?: boolean;
          keySecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          serverName?: string;
        };
        tokenUrl: string;
      };
      proxyConnectHeader?: {
        [key: string]: unknown;
      };
      proxyFromEnvironment?: boolean;
      proxyUrl?: string;
      refreshInterval?: string;
      server: string;
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        insecureSkipVerify?: boolean;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
    }[];
    fallbackScrapeProtocol?: "PrometheusProto" | "OpenMetricsText0.0.1" | "OpenMetricsText1.0.0" | "PrometheusText0.0.4" | "PrometheusText1.0.0";
    fileSDConfigs?: {
      files: string[];
      refreshInterval?: string;
    }[];
    gceSDConfigs?: {
      filter?: string;
      port?: number;
      project: string;
      refreshInterval?: string;
      tagSeparator?: string;
      zone: string;
    }[];
    hetznerSDConfigs?: {
      authorization?: {
        credentials?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        type?: string;
      };
      basicAuth?: {
        password?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        username?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      enableHTTP2?: boolean;
      followRedirects?: boolean;
      labelSelector?: string;
      noProxy?: string;
      oauth2?: {
        clientId: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        clientSecret: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        endpointParams?: {
          [key: string]: unknown;
        };
        noProxy?: string;
        proxyConnectHeader?: {
          [key: string]: unknown;
        };
        proxyFromEnvironment?: boolean;
        proxyUrl?: string;
        scopes?: string[];
        tlsConfig?: {
          ca?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          cert?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          insecureSkipVerify?: boolean;
          keySecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          serverName?: string;
        };
        tokenUrl: string;
      };
      port?: number;
      proxyConnectHeader?: {
        [key: string]: unknown;
      };
      proxyFromEnvironment?: boolean;
      proxyUrl?: string;
      refreshInterval?: string;
      role: "hcloud" | "Hcloud" | "robot" | "Robot";
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        insecureSkipVerify?: boolean;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
    }[];
    honorLabels?: boolean;
    honorTimestamps?: boolean;
    httpSDConfigs?: {
      authorization?: {
        credentials?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        type?: string;
      };
      basicAuth?: {
        password?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        username?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      enableHTTP2?: boolean;
      followRedirects?: boolean;
      noProxy?: string;
      oauth2?: {
        clientId: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        clientSecret: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        endpointParams?: {
          [key: string]: unknown;
        };
        noProxy?: string;
        proxyConnectHeader?: {
          [key: string]: unknown;
        };
        proxyFromEnvironment?: boolean;
        proxyUrl?: string;
        scopes?: string[];
        tlsConfig?: {
          ca?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          cert?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          insecureSkipVerify?: boolean;
          keySecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          serverName?: string;
        };
        tokenUrl: string;
      };
      proxyConnectHeader?: {
        [key: string]: unknown;
      };
      proxyFromEnvironment?: boolean;
      proxyUrl?: string;
      refreshInterval?: string;
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        insecureSkipVerify?: boolean;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
      url: string;
    }[];
    ionosSDConfigs?: {
      authorization: {
        credentials?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        type?: string;
      };
      datacenterID: string;
      enableHTTP2?: boolean;
      followRedirects?: boolean;
      noProxy?: string;
      oauth2?: {
        clientId: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        clientSecret: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        endpointParams?: {
          [key: string]: unknown;
        };
        noProxy?: string;
        proxyConnectHeader?: {
          [key: string]: unknown;
        };
        proxyFromEnvironment?: boolean;
        proxyUrl?: string;
        scopes?: string[];
        tlsConfig?: {
          ca?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          cert?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          insecureSkipVerify?: boolean;
          keySecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          serverName?: string;
        };
        tokenUrl: string;
      };
      port?: number;
      proxyConnectHeader?: {
        [key: string]: unknown;
      };
      proxyFromEnvironment?: boolean;
      proxyUrl?: string;
      refreshInterval?: string;
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        insecureSkipVerify?: boolean;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
    }[];
    jobName?: string;
    keepDroppedTargets?: number;
    kubernetesSDConfigs?: {
      apiServer?: string;
      attachMetadata?: {
        node?: boolean;
      };
      authorization?: {
        credentials?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        type?: string;
      };
      basicAuth?: {
        password?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        username?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      enableHTTP2?: boolean;
      followRedirects?: boolean;
      namespaces?: {
        names?: string[];
        ownNamespace?: boolean;
      };
      noProxy?: string;
      oauth2?: {
        clientId: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        clientSecret: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        endpointParams?: {
          [key: string]: unknown;
        };
        noProxy?: string;
        proxyConnectHeader?: {
          [key: string]: unknown;
        };
        proxyFromEnvironment?: boolean;
        proxyUrl?: string;
        scopes?: string[];
        tlsConfig?: {
          ca?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          cert?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          insecureSkipVerify?: boolean;
          keySecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          serverName?: string;
        };
        tokenUrl: string;
      };
      proxyConnectHeader?: {
        [key: string]: unknown;
      };
      proxyFromEnvironment?: boolean;
      proxyUrl?: string;
      role: "Pod" | "Endpoints" | "Ingress" | "Service" | "Node" | "EndpointSlice";
      selectors?: {
        field?: string;
        label?: string;
        role: "Pod" | "Endpoints" | "Ingress" | "Service" | "Node" | "EndpointSlice";
      }[];
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        insecureSkipVerify?: boolean;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
    }[];
    kumaSDConfigs?: {
      authorization?: {
        credentials?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        type?: string;
      };
      basicAuth?: {
        password?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        username?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      clientID?: string;
      enableHTTP2?: boolean;
      fetchTimeout?: string;
      followRedirects?: boolean;
      noProxy?: string;
      oauth2?: {
        clientId: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        clientSecret: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        endpointParams?: {
          [key: string]: unknown;
        };
        noProxy?: string;
        proxyConnectHeader?: {
          [key: string]: unknown;
        };
        proxyFromEnvironment?: boolean;
        proxyUrl?: string;
        scopes?: string[];
        tlsConfig?: {
          ca?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          cert?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          insecureSkipVerify?: boolean;
          keySecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          serverName?: string;
        };
        tokenUrl: string;
      };
      proxyConnectHeader?: {
        [key: string]: unknown;
      };
      proxyFromEnvironment?: boolean;
      proxyUrl?: string;
      refreshInterval?: string;
      server: string;
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        insecureSkipVerify?: boolean;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
    }[];
    labelLimit?: number;
    labelNameLengthLimit?: number;
    labelValueLengthLimit?: number;
    lightSailSDConfigs?: {
      accessKey?: {
        key: string;
        name?: string;
        optional?: boolean;
      };
      authorization?: {
        credentials?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        type?: string;
      };
      basicAuth?: {
        password?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        username?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      enableHTTP2?: boolean;
      endpoint?: string;
      followRedirects?: boolean;
      noProxy?: string;
      oauth2?: {
        clientId: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        clientSecret: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        endpointParams?: {
          [key: string]: unknown;
        };
        noProxy?: string;
        proxyConnectHeader?: {
          [key: string]: unknown;
        };
        proxyFromEnvironment?: boolean;
        proxyUrl?: string;
        scopes?: string[];
        tlsConfig?: {
          ca?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          cert?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          insecureSkipVerify?: boolean;
          keySecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          serverName?: string;
        };
        tokenUrl: string;
      };
      port?: number;
      proxyConnectHeader?: {
        [key: string]: unknown;
      };
      proxyFromEnvironment?: boolean;
      proxyUrl?: string;
      refreshInterval?: string;
      region?: string;
      roleARN?: string;
      secretKey?: {
        key: string;
        name?: string;
        optional?: boolean;
      };
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        insecureSkipVerify?: boolean;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
    }[];
    linodeSDConfigs?: {
      authorization?: {
        credentials?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        type?: string;
      };
      enableHTTP2?: boolean;
      followRedirects?: boolean;
      noProxy?: string;
      oauth2?: {
        clientId: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        clientSecret: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        endpointParams?: {
          [key: string]: unknown;
        };
        noProxy?: string;
        proxyConnectHeader?: {
          [key: string]: unknown;
        };
        proxyFromEnvironment?: boolean;
        proxyUrl?: string;
        scopes?: string[];
        tlsConfig?: {
          ca?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          cert?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          insecureSkipVerify?: boolean;
          keySecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          serverName?: string;
        };
        tokenUrl: string;
      };
      port?: number;
      proxyConnectHeader?: {
        [key: string]: unknown;
      };
      proxyFromEnvironment?: boolean;
      proxyUrl?: string;
      refreshInterval?: string;
      region?: string;
      tagSeparator?: string;
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        insecureSkipVerify?: boolean;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
    }[];
    metricRelabelings?: {
      action?: "replace" | "Replace" | "keep" | "Keep" | "drop" | "Drop" | "hashmod" | "HashMod" | "labelmap" | "LabelMap" | "labeldrop" | "LabelDrop" | "labelkeep" | "LabelKeep" | "lowercase" | "Lowercase" | "uppercase" | "Uppercase" | "keepequal" | "KeepEqual" | "dropequal" | "DropEqual";
      modulus?: number;
      regex?: string;
      replacement?: string;
      separator?: string;
      sourceLabels?: string[];
      targetLabel?: string;
    }[];
    metricsPath?: string;
    nameEscapingScheme?: "AllowUTF8" | "Underscores" | "Dots" | "Values";
    nameValidationScheme?: "UTF8" | "Legacy";
    nativeHistogramBucketLimit?: number;
    nativeHistogramMinBucketFactor?: any;
    noProxy?: string;
    nomadSDConfigs?: {
      allowStale?: boolean;
      authorization?: {
        credentials?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        type?: string;
      };
      basicAuth?: {
        password?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        username?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      enableHTTP2?: boolean;
      followRedirects?: boolean;
      namespace?: string;
      noProxy?: string;
      oauth2?: {
        clientId: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        clientSecret: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        endpointParams?: {
          [key: string]: unknown;
        };
        noProxy?: string;
        proxyConnectHeader?: {
          [key: string]: unknown;
        };
        proxyFromEnvironment?: boolean;
        proxyUrl?: string;
        scopes?: string[];
        tlsConfig?: {
          ca?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          cert?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          insecureSkipVerify?: boolean;
          keySecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          serverName?: string;
        };
        tokenUrl: string;
      };
      proxyConnectHeader?: {
        [key: string]: unknown;
      };
      proxyFromEnvironment?: boolean;
      proxyUrl?: string;
      refreshInterval?: string;
      region?: string;
      server: string;
      tagSeparator?: string;
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        insecureSkipVerify?: boolean;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
    }[];
    oauth2?: {
      clientId: {
        configMap?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        secret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      clientSecret: {
        key: string;
        name?: string;
        optional?: boolean;
      };
      endpointParams?: {
        [key: string]: unknown;
      };
      noProxy?: string;
      proxyConnectHeader?: {
        [key: string]: unknown;
      };
      proxyFromEnvironment?: boolean;
      proxyUrl?: string;
      scopes?: string[];
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        insecureSkipVerify?: boolean;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
      tokenUrl: string;
    };
    openstackSDConfigs?: {
      allTenants?: boolean;
      applicationCredentialId?: string;
      applicationCredentialName?: string;
      applicationCredentialSecret?: {
        key: string;
        name?: string;
        optional?: boolean;
      };
      availability?: "Public" | "public" | "Admin" | "admin" | "Internal" | "internal";
      domainID?: string;
      domainName?: string;
      identityEndpoint?: string;
      password?: {
        key: string;
        name?: string;
        optional?: boolean;
      };
      port?: number;
      projectID?: string;
      projectName?: string;
      refreshInterval?: string;
      region: string;
      role: "Instance" | "Hypervisor" | "LoadBalancer";
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        insecureSkipVerify?: boolean;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
      userid?: string;
      username?: string;
    }[];
    ovhcloudSDConfigs?: {
      applicationKey: string;
      applicationSecret: {
        key: string;
        name?: string;
        optional?: boolean;
      };
      consumerKey: {
        key: string;
        name?: string;
        optional?: boolean;
      };
      endpoint?: string;
      refreshInterval?: string;
      service: string;
    }[];
    params?: {
      [key: string]: unknown;
    };
    proxyConnectHeader?: {
      [key: string]: unknown;
    };
    proxyFromEnvironment?: boolean;
    proxyUrl?: string;
    puppetDBSDConfigs?: {
      authorization?: {
        credentials?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        type?: string;
      };
      basicAuth?: {
        password?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        username?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      enableHTTP2?: boolean;
      followRedirects?: boolean;
      includeParameters?: boolean;
      noProxy?: string;
      oauth2?: {
        clientId: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        clientSecret: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        endpointParams?: {
          [key: string]: unknown;
        };
        noProxy?: string;
        proxyConnectHeader?: {
          [key: string]: unknown;
        };
        proxyFromEnvironment?: boolean;
        proxyUrl?: string;
        scopes?: string[];
        tlsConfig?: {
          ca?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          cert?: {
            configMap?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
            secret?: {
              key: string;
              name?: string;
              optional?: boolean;
            };
          };
          insecureSkipVerify?: boolean;
          keySecret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
          serverName?: string;
        };
        tokenUrl: string;
      };
      port?: number;
      proxyConnectHeader?: {
        [key: string]: unknown;
      };
      proxyFromEnvironment?: boolean;
      proxyUrl?: string;
      query: string;
      refreshInterval?: string;
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        insecureSkipVerify?: boolean;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
      url: string;
    }[];
    relabelings?: {
      action?: "replace" | "Replace" | "keep" | "Keep" | "drop" | "Drop" | "hashmod" | "HashMod" | "labelmap" | "LabelMap" | "labeldrop" | "LabelDrop" | "labelkeep" | "LabelKeep" | "lowercase" | "Lowercase" | "uppercase" | "Uppercase" | "keepequal" | "KeepEqual" | "dropequal" | "DropEqual";
      modulus?: number;
      regex?: string;
      replacement?: string;
      separator?: string;
      sourceLabels?: string[];
      targetLabel?: string;
    }[];
    sampleLimit?: number;
    scalewaySDConfigs?: {
      accessKey: string;
      apiURL?: string;
      enableHTTP2?: boolean;
      followRedirects?: boolean;
      nameFilter?: string;
      noProxy?: string;
      port?: number;
      projectID: string;
      proxyConnectHeader?: {
        [key: string]: unknown;
      };
      proxyFromEnvironment?: boolean;
      proxyUrl?: string;
      refreshInterval?: string;
      role: "Instance" | "Baremetal";
      secretKey: {
        key: string;
        name?: string;
        optional?: boolean;
      };
      tagsFilter?: string[];
      tlsConfig?: {
        ca?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        cert?: {
          configMap?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          secret?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
        insecureSkipVerify?: boolean;
        keySecret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
        serverName?: string;
      };
      zone?: string;
    }[];
    scheme?: "HTTP" | "HTTPS";
    scrapeClass?: string;
    scrapeClassicHistograms?: boolean;
    scrapeInterval?: string;
    scrapeProtocols?: ("PrometheusProto" | "OpenMetricsText0.0.1" | "OpenMetricsText1.0.0" | "PrometheusText0.0.4" | "PrometheusText1.0.0")[];
    scrapeTimeout?: string;
    staticConfigs?: {
      labels?: {
        [key: string]: unknown;
      };
      targets: string[];
    }[];
    targetLimit?: number;
    tlsConfig?: {
      ca?: {
        configMap?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        secret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      cert?: {
        configMap?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        secret?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
      insecureSkipVerify?: boolean;
      keySecret?: {
        key: string;
        name?: string;
        optional?: boolean;
      };
      maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
      minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13";
      serverName?: string;
    };
    trackTimestampsStaleness?: boolean;
  };
}
/* com.coreos.monitoring.v1alpha1.ScrapeConfigList */
/* ScrapeConfigList is a list of ScrapeConfig */
export interface MonitoringCoreosComV1alpha1ScrapeConfigList {
  apiVersion?: string;
  items: MonitoringCoreosComV1alpha1ScrapeConfig[];
  kind?: string;
  metadata?: ListMeta;
}
/* dev.knative.internal.autoscaling.v1alpha1.Metric */
/* Metric represents a resource to configure the metric collector with. */
export interface AutoscalingInternalKnativeDevV1alpha1Metric {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: {
    panicWindow: number;
    scrapeTarget: string;
    stableWindow: number;
  };
  status?: {
    annotations?: {
      [key: string]: unknown;
    };
    conditions?: {
      lastTransitionTime?: string;
      message?: string;
      reason?: string;
      severity?: string;
      status: string;
      type: string;
    }[];
    observedGeneration?: number;
  };
}
/* dev.knative.internal.autoscaling.v1alpha1.MetricList */
/* MetricList is a list of Metric */
export interface AutoscalingInternalKnativeDevV1alpha1MetricList {
  apiVersion?: string;
  items: AutoscalingInternalKnativeDevV1alpha1Metric[];
  kind?: string;
  metadata?: ListMeta;
}
/* dev.knative.internal.autoscaling.v1alpha1.PodAutoscaler */
/* PodAutoscaler is a Knative abstraction that encapsulates the interface by which Knative
components instantiate autoscalers.  This definition is an abstraction that may be backed
by multiple definitions.  For more information, see the Knative Pluggability presentation:
https://docs.google.com/presentation/d/19vW9HFZ6Puxt31biNZF3uLRejDmu82rxJIk1cWmxF7w/edit */
export interface AutoscalingInternalKnativeDevV1alpha1PodAutoscaler {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: {
    containerConcurrency?: number;
    protocolType: string;
    reachability?: string;
    scaleTargetRef: {
      apiVersion?: string;
      kind?: string;
      name?: string;
    };
  };
  status?: {
    actualScale?: number;
    annotations?: {
      [key: string]: unknown;
    };
    conditions?: {
      lastTransitionTime?: string;
      message?: string;
      reason?: string;
      severity?: string;
      status: string;
      type: string;
    }[];
    desiredScale?: number;
    metricsServiceName: string;
    observedGeneration?: number;
    serviceName: string;
  };
}
/* dev.knative.internal.autoscaling.v1alpha1.PodAutoscalerList */
/* PodAutoscalerList is a list of PodAutoscaler */
export interface AutoscalingInternalKnativeDevV1alpha1PodAutoscalerList {
  apiVersion?: string;
  items: AutoscalingInternalKnativeDevV1alpha1PodAutoscaler[];
  kind?: string;
  metadata?: ListMeta;
}
/* dev.knative.internal.caching.v1alpha1.Image */
/* Image is a Knative abstraction that encapsulates the interface by which Knative
components express a desire to have a particular image cached. */
export interface CachingInternalKnativeDevV1alpha1Image {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: {
    image: string;
    imagePullSecrets?: {
      name?: string;
    }[];
    serviceAccountName?: string;
  };
  status?: {
    annotations?: {
      [key: string]: unknown;
    };
    conditions?: {
      lastTransitionTime?: string;
      message?: string;
      reason?: string;
      severity?: string;
      status: string;
      type: string;
    }[];
    observedGeneration?: number;
  };
}
/* dev.knative.internal.caching.v1alpha1.ImageList */
/* ImageList is a list of Image */
export interface CachingInternalKnativeDevV1alpha1ImageList {
  apiVersion?: string;
  items: CachingInternalKnativeDevV1alpha1Image[];
  kind?: string;
  metadata?: ListMeta;
}
/* dev.knative.internal.networking.v1alpha1.Certificate */
/* Certificate is responsible for provisioning a SSL certificate for the
given hosts. It is a Knative abstraction for various SSL certificate
provisioning solutions (such as cert-manager or self-signed SSL certificate). */
export interface NetworkingInternalKnativeDevV1alpha1Certificate {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: {
    dnsNames: string[];
    domain?: string;
    secretName: string;
  };
  status?: {
    annotations?: {
      [key: string]: unknown;
    };
    conditions?: {
      lastTransitionTime?: string;
      message?: string;
      reason?: string;
      severity?: string;
      status: string;
      type: string;
    }[];
    http01Challenges?: {
      serviceName?: string;
      serviceNamespace?: string;
      servicePort?: any;
      url?: string;
    }[];
    notAfter?: string;
    observedGeneration?: number;
  };
}
/* dev.knative.internal.networking.v1alpha1.CertificateList */
/* CertificateList is a list of Certificate */
export interface NetworkingInternalKnativeDevV1alpha1CertificateList {
  apiVersion?: string;
  items: NetworkingInternalKnativeDevV1alpha1Certificate[];
  kind?: string;
  metadata?: ListMeta;
}
/* dev.knative.internal.networking.v1alpha1.ClusterDomainClaim */
/* ClusterDomainClaim is a cluster-wide reservation for a particular domain name. */
export interface NetworkingInternalKnativeDevV1alpha1ClusterDomainClaim {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: {
    namespace: string;
  };
}
/* dev.knative.internal.networking.v1alpha1.ClusterDomainClaimList */
/* ClusterDomainClaimList is a list of ClusterDomainClaim */
export interface NetworkingInternalKnativeDevV1alpha1ClusterDomainClaimList {
  apiVersion?: string;
  items: NetworkingInternalKnativeDevV1alpha1ClusterDomainClaim[];
  kind?: string;
  metadata?: ListMeta;
}
/* dev.knative.internal.networking.v1alpha1.Ingress */
/* Ingress is a collection of rules that allow inbound connections to reach the endpoints defined
by a backend. An Ingress can be configured to give services externally-reachable URLs, load
balance traffic, offer name based virtual hosting, etc.


This is heavily based on K8s Ingress https://godoc.org/k8s.io/api/networking/v1beta1#Ingress
which some highlighted modifications. */
export interface NetworkingInternalKnativeDevV1alpha1Ingress {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: {
    httpOption?: string;
    rules?: {
      hosts?: string[];
      http?: {
        paths: {
          appendHeaders?: {
            [key: string]: unknown;
          };
          headers?: {
            [key: string]: unknown;
          };
          path?: string;
          rewriteHost?: string;
          splits: {
            appendHeaders?: {
              [key: string]: unknown;
            };
            percent?: number;
            serviceName: string;
            serviceNamespace: string;
            servicePort: any;
          }[];
        }[];
      };
      visibility?: string;
    }[];
    tls?: {
      hosts?: string[];
      secretName?: string;
      secretNamespace?: string;
    }[];
  };
  status?: {
    annotations?: {
      [key: string]: unknown;
    };
    conditions?: {
      lastTransitionTime?: string;
      message?: string;
      reason?: string;
      severity?: string;
      status: string;
      type: string;
    }[];
    observedGeneration?: number;
    privateLoadBalancer?: {
      ingress?: {
        domain?: string;
        domainInternal?: string;
        ip?: string;
        meshOnly?: boolean;
      }[];
    };
    publicLoadBalancer?: {
      ingress?: {
        domain?: string;
        domainInternal?: string;
        ip?: string;
        meshOnly?: boolean;
      }[];
    };
  };
}
/* dev.knative.internal.networking.v1alpha1.IngressList */
/* IngressList is a list of Ingress */
export interface NetworkingInternalKnativeDevV1alpha1IngressList {
  apiVersion?: string;
  items: NetworkingInternalKnativeDevV1alpha1Ingress[];
  kind?: string;
  metadata?: ListMeta;
}
/* dev.knative.internal.networking.v1alpha1.ServerlessService */
/* ServerlessService is a proxy for the K8s service objects containing the
endpoints for the revision, whether those are endpoints of the activator or
revision pods.
See: https://knative.page.link/naxz for details. */
export interface NetworkingInternalKnativeDevV1alpha1ServerlessService {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: {
    mode?: string;
    numActivators?: number;
    objectRef: {
      apiVersion?: string;
      fieldPath?: string;
      kind?: string;
      name?: string;
      namespace?: string;
      resourceVersion?: string;
      uid?: string;
    };
    protocolType: string;
  };
  status?: {
    annotations?: {
      [key: string]: unknown;
    };
    conditions?: {
      lastTransitionTime?: string;
      message?: string;
      reason?: string;
      severity?: string;
      status: string;
      type: string;
    }[];
    observedGeneration?: number;
    privateServiceName?: string;
    serviceName?: string;
  };
}
/* dev.knative.internal.networking.v1alpha1.ServerlessServiceList */
/* ServerlessServiceList is a list of ServerlessService */
export interface NetworkingInternalKnativeDevV1alpha1ServerlessServiceList {
  apiVersion?: string;
  items: NetworkingInternalKnativeDevV1alpha1ServerlessService[];
  kind?: string;
  metadata?: ListMeta;
}
/* dev.knative.serving.v1.Configuration */
/* Configuration represents the "floating HEAD" of a linear history of Revisions.
Users create new Revisions by updating the Configuration's spec.
The "latest created" revision's name is available under status, as is the
"latest ready" revision's name.
See also: https://github.com/knative/serving/blob/main/docs/spec/overview.md#configuration */
export interface ServingKnativeDevV1Configuration {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: {
    template?: {
      metadata?: any;
      spec?: {
        affinity?: any;
        automountServiceAccountToken?: boolean;
        containerConcurrency?: number;
        containers: {
          args?: string[];
          command?: string[];
          env?: {
            name: string;
            value?: string;
            valueFrom?: {
              configMapKeyRef?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              fieldRef?: any;
              resourceFieldRef?: any;
              secretKeyRef?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
          }[];
          envFrom?: {
            configMapRef?: {
              name?: string;
              optional?: boolean;
            };
            prefix?: string;
            secretRef?: {
              name?: string;
              optional?: boolean;
            };
          }[];
          image?: string;
          imagePullPolicy?: string;
          livenessProbe?: {
            exec?: {
              command?: string[];
            };
            failureThreshold?: number;
            grpc?: {
              port: number;
              service?: string;
            };
            httpGet?: {
              host?: string;
              httpHeaders?: {
                name: string;
                value: string;
              }[];
              path?: string;
              port?: any;
              scheme?: string;
            };
            initialDelaySeconds?: number;
            periodSeconds?: number;
            successThreshold?: number;
            tcpSocket?: {
              host?: string;
              port?: any;
            };
            timeoutSeconds?: number;
          };
          name?: string;
          ports?: {
            containerPort: number;
            name?: string;
            protocol?: string;
          }[];
          readinessProbe?: {
            exec?: {
              command?: string[];
            };
            failureThreshold?: number;
            grpc?: {
              port: number;
              service?: string;
            };
            httpGet?: {
              host?: string;
              httpHeaders?: {
                name: string;
                value: string;
              }[];
              path?: string;
              port?: any;
              scheme?: string;
            };
            initialDelaySeconds?: number;
            periodSeconds?: number;
            successThreshold?: number;
            tcpSocket?: {
              host?: string;
              port?: any;
            };
            timeoutSeconds?: number;
          };
          resources?: {
            claims?: {
              name: string;
            }[];
            limits?: {
              [key: string]: unknown;
            };
            requests?: {
              [key: string]: unknown;
            };
          };
          securityContext?: {
            allowPrivilegeEscalation?: boolean;
            capabilities?: {
              add?: string[];
              drop?: string[];
            };
            readOnlyRootFilesystem?: boolean;
            runAsGroup?: number;
            runAsNonRoot?: boolean;
            runAsUser?: number;
            seccompProfile?: {
              localhostProfile?: string;
              type: string;
            };
          };
          startupProbe?: {
            exec?: {
              command?: string[];
            };
            failureThreshold?: number;
            grpc?: {
              port: number;
              service?: string;
            };
            httpGet?: {
              host?: string;
              httpHeaders?: {
                name: string;
                value: string;
              }[];
              path?: string;
              port?: any;
              scheme?: string;
            };
            initialDelaySeconds?: number;
            periodSeconds?: number;
            successThreshold?: number;
            tcpSocket?: {
              host?: string;
              port?: any;
            };
            timeoutSeconds?: number;
          };
          terminationMessagePath?: string;
          terminationMessagePolicy?: string;
          volumeMounts?: {
            mountPath: string;
            name: string;
            readOnly?: boolean;
            subPath?: string;
          }[];
          workingDir?: string;
        }[];
        dnsConfig?: any;
        dnsPolicy?: string;
        enableServiceLinks?: boolean;
        hostAliases?: any[];
        idleTimeoutSeconds?: number;
        imagePullSecrets?: {
          name?: string;
        }[];
        initContainers?: any[];
        nodeSelector?: any;
        priorityClassName?: string;
        responseStartTimeoutSeconds?: number;
        runtimeClassName?: string;
        schedulerName?: string;
        securityContext?: any;
        serviceAccountName?: string;
        shareProcessNamespace?: boolean;
        timeoutSeconds?: number;
        tolerations?: any[];
        topologySpreadConstraints?: any[];
        volumes?: {
          configMap?: {
            defaultMode?: number;
            items?: {
              key: string;
              mode?: number;
              path: string;
            }[];
            name?: string;
            optional?: boolean;
          };
          emptyDir?: any;
          name: string;
          persistentVolumeClaim?: any;
          projected?: {
            defaultMode?: number;
            sources?: {
              configMap?: {
                items?: {
                  key: string;
                  mode?: number;
                  path: string;
                }[];
                name?: string;
                optional?: boolean;
              };
              downwardAPI?: {
                items?: {
                  fieldRef?: {
                    apiVersion?: string;
                    fieldPath: string;
                  };
                  mode?: number;
                  path: string;
                  resourceFieldRef?: {
                    containerName?: string;
                    divisor?: any;
                    resource: string;
                  };
                }[];
              };
              secret?: {
                items?: {
                  key: string;
                  mode?: number;
                  path: string;
                }[];
                name?: string;
                optional?: boolean;
              };
              serviceAccountToken?: {
                audience?: string;
                expirationSeconds?: number;
                path: string;
              };
            }[];
          };
          secret?: {
            defaultMode?: number;
            items?: {
              key: string;
              mode?: number;
              path: string;
            }[];
            optional?: boolean;
            secretName?: string;
          };
        }[];
      };
    };
  };
  status?: {
    annotations?: {
      [key: string]: unknown;
    };
    conditions?: {
      lastTransitionTime?: string;
      message?: string;
      reason?: string;
      severity?: string;
      status: string;
      type: string;
    }[];
    latestCreatedRevisionName?: string;
    latestReadyRevisionName?: string;
    observedGeneration?: number;
  };
}
/* dev.knative.serving.v1.ConfigurationList */
/* ConfigurationList is a list of Configuration */
export interface ServingKnativeDevV1ConfigurationList {
  apiVersion?: string;
  items: ServingKnativeDevV1Configuration[];
  kind?: string;
  metadata?: ListMeta;
}
/* dev.knative.serving.v1.Revision */
/* Revision is an immutable snapshot of code and configuration.  A revision
references a container image. Revisions are created by updates to a
Configuration.


See also: https://github.com/knative/serving/blob/main/docs/spec/overview.md#revision */
export interface ServingKnativeDevV1Revision {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: {
    affinity?: any;
    automountServiceAccountToken?: boolean;
    containerConcurrency?: number;
    containers: {
      args?: string[];
      command?: string[];
      env?: {
        name: string;
        value?: string;
        valueFrom?: {
          configMapKeyRef?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          fieldRef?: any;
          resourceFieldRef?: any;
          secretKeyRef?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
        };
      }[];
      envFrom?: {
        configMapRef?: {
          name?: string;
          optional?: boolean;
        };
        prefix?: string;
        secretRef?: {
          name?: string;
          optional?: boolean;
        };
      }[];
      image?: string;
      imagePullPolicy?: string;
      livenessProbe?: {
        exec?: {
          command?: string[];
        };
        failureThreshold?: number;
        grpc?: {
          port: number;
          service?: string;
        };
        httpGet?: {
          host?: string;
          httpHeaders?: {
            name: string;
            value: string;
          }[];
          path?: string;
          port?: any;
          scheme?: string;
        };
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        tcpSocket?: {
          host?: string;
          port?: any;
        };
        timeoutSeconds?: number;
      };
      name?: string;
      ports?: {
        containerPort: number;
        name?: string;
        protocol?: string;
      }[];
      readinessProbe?: {
        exec?: {
          command?: string[];
        };
        failureThreshold?: number;
        grpc?: {
          port: number;
          service?: string;
        };
        httpGet?: {
          host?: string;
          httpHeaders?: {
            name: string;
            value: string;
          }[];
          path?: string;
          port?: any;
          scheme?: string;
        };
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        tcpSocket?: {
          host?: string;
          port?: any;
        };
        timeoutSeconds?: number;
      };
      resources?: {
        claims?: {
          name: string;
        }[];
        limits?: {
          [key: string]: unknown;
        };
        requests?: {
          [key: string]: unknown;
        };
      };
      securityContext?: {
        allowPrivilegeEscalation?: boolean;
        capabilities?: {
          add?: string[];
          drop?: string[];
        };
        readOnlyRootFilesystem?: boolean;
        runAsGroup?: number;
        runAsNonRoot?: boolean;
        runAsUser?: number;
        seccompProfile?: {
          localhostProfile?: string;
          type: string;
        };
      };
      startupProbe?: {
        exec?: {
          command?: string[];
        };
        failureThreshold?: number;
        grpc?: {
          port: number;
          service?: string;
        };
        httpGet?: {
          host?: string;
          httpHeaders?: {
            name: string;
            value: string;
          }[];
          path?: string;
          port?: any;
          scheme?: string;
        };
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        tcpSocket?: {
          host?: string;
          port?: any;
        };
        timeoutSeconds?: number;
      };
      terminationMessagePath?: string;
      terminationMessagePolicy?: string;
      volumeMounts?: {
        mountPath: string;
        name: string;
        readOnly?: boolean;
        subPath?: string;
      }[];
      workingDir?: string;
    }[];
    dnsConfig?: any;
    dnsPolicy?: string;
    enableServiceLinks?: boolean;
    hostAliases?: any[];
    idleTimeoutSeconds?: number;
    imagePullSecrets?: {
      name?: string;
    }[];
    initContainers?: any[];
    nodeSelector?: any;
    priorityClassName?: string;
    responseStartTimeoutSeconds?: number;
    runtimeClassName?: string;
    schedulerName?: string;
    securityContext?: any;
    serviceAccountName?: string;
    shareProcessNamespace?: boolean;
    timeoutSeconds?: number;
    tolerations?: any[];
    topologySpreadConstraints?: any[];
    volumes?: {
      configMap?: {
        defaultMode?: number;
        items?: {
          key: string;
          mode?: number;
          path: string;
        }[];
        name?: string;
        optional?: boolean;
      };
      emptyDir?: any;
      name: string;
      persistentVolumeClaim?: any;
      projected?: {
        defaultMode?: number;
        sources?: {
          configMap?: {
            items?: {
              key: string;
              mode?: number;
              path: string;
            }[];
            name?: string;
            optional?: boolean;
          };
          downwardAPI?: {
            items?: {
              fieldRef?: {
                apiVersion?: string;
                fieldPath: string;
              };
              mode?: number;
              path: string;
              resourceFieldRef?: {
                containerName?: string;
                divisor?: any;
                resource: string;
              };
            }[];
          };
          secret?: {
            items?: {
              key: string;
              mode?: number;
              path: string;
            }[];
            name?: string;
            optional?: boolean;
          };
          serviceAccountToken?: {
            audience?: string;
            expirationSeconds?: number;
            path: string;
          };
        }[];
      };
      secret?: {
        defaultMode?: number;
        items?: {
          key: string;
          mode?: number;
          path: string;
        }[];
        optional?: boolean;
        secretName?: string;
      };
    }[];
  };
  status?: {
    actualReplicas?: number;
    annotations?: {
      [key: string]: unknown;
    };
    conditions?: {
      lastTransitionTime?: string;
      message?: string;
      reason?: string;
      severity?: string;
      status: string;
      type: string;
    }[];
    containerStatuses?: {
      imageDigest?: string;
      name?: string;
    }[];
    desiredReplicas?: number;
    initContainerStatuses?: {
      imageDigest?: string;
      name?: string;
    }[];
    logUrl?: string;
    observedGeneration?: number;
  };
}
/* dev.knative.serving.v1.RevisionList */
/* RevisionList is a list of Revision */
export interface ServingKnativeDevV1RevisionList {
  apiVersion?: string;
  items: ServingKnativeDevV1Revision[];
  kind?: string;
  metadata?: ListMeta;
}
/* dev.knative.serving.v1.Route */
/* Route is responsible for configuring ingress over a collection of Revisions.
Some of the Revisions a Route distributes traffic over may be specified by
referencing the Configuration responsible for creating them; in these cases
the Route is additionally responsible for monitoring the Configuration for
"latest ready revision" changes, and smoothly rolling out latest revisions.
See also: https://github.com/knative/serving/blob/main/docs/spec/overview.md#route */
export interface ServingKnativeDevV1Route {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: {
    traffic?: {
      configurationName?: string;
      latestRevision?: boolean;
      percent?: number;
      revisionName?: string;
      tag?: string;
      url?: string;
    }[];
  };
  status?: {
    address?: {
      CACerts?: string;
      audience?: string;
      name?: string;
      url?: string;
    };
    annotations?: {
      [key: string]: unknown;
    };
    conditions?: {
      lastTransitionTime?: string;
      message?: string;
      reason?: string;
      severity?: string;
      status: string;
      type: string;
    }[];
    observedGeneration?: number;
    traffic?: {
      configurationName?: string;
      latestRevision?: boolean;
      percent?: number;
      revisionName?: string;
      tag?: string;
      url?: string;
    }[];
    url?: string;
  };
}
/* dev.knative.serving.v1.RouteList */
/* RouteList is a list of Route */
export interface ServingKnativeDevV1RouteList {
  apiVersion?: string;
  items: ServingKnativeDevV1Route[];
  kind?: string;
  metadata?: ListMeta;
}
/* dev.knative.serving.v1.Service */
/* Service acts as a top-level container that manages a Route and Configuration
which implement a network service. Service exists to provide a singular
abstraction which can be access controlled, reasoned about, and which
encapsulates software lifecycle decisions such as rollout policy and
team resource ownership. Service acts only as an orchestrator of the
underlying Routes and Configurations (much as a kubernetes Deployment
orchestrates ReplicaSets), and its usage is optional but recommended.


The Service's controller will track the statuses of its owned Configuration
and Route, reflecting their statuses and conditions as its own.


See also: https://github.com/knative/serving/blob/main/docs/spec/overview.md#service */
export interface ServingKnativeDevV1Service {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: {
    template?: {
      metadata?: any;
      spec?: {
        affinity?: any;
        automountServiceAccountToken?: boolean;
        containerConcurrency?: number;
        containers: {
          args?: string[];
          command?: string[];
          env?: {
            name: string;
            value?: string;
            valueFrom?: {
              configMapKeyRef?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              fieldRef?: any;
              resourceFieldRef?: any;
              secretKeyRef?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
          }[];
          envFrom?: {
            configMapRef?: {
              name?: string;
              optional?: boolean;
            };
            prefix?: string;
            secretRef?: {
              name?: string;
              optional?: boolean;
            };
          }[];
          image?: string;
          imagePullPolicy?: string;
          livenessProbe?: {
            exec?: {
              command?: string[];
            };
            failureThreshold?: number;
            grpc?: {
              port: number;
              service?: string;
            };
            httpGet?: {
              host?: string;
              httpHeaders?: {
                name: string;
                value: string;
              }[];
              path?: string;
              port?: any;
              scheme?: string;
            };
            initialDelaySeconds?: number;
            periodSeconds?: number;
            successThreshold?: number;
            tcpSocket?: {
              host?: string;
              port?: any;
            };
            timeoutSeconds?: number;
          };
          name?: string;
          ports?: {
            containerPort: number;
            name?: string;
            protocol?: string;
          }[];
          readinessProbe?: {
            exec?: {
              command?: string[];
            };
            failureThreshold?: number;
            grpc?: {
              port: number;
              service?: string;
            };
            httpGet?: {
              host?: string;
              httpHeaders?: {
                name: string;
                value: string;
              }[];
              path?: string;
              port?: any;
              scheme?: string;
            };
            initialDelaySeconds?: number;
            periodSeconds?: number;
            successThreshold?: number;
            tcpSocket?: {
              host?: string;
              port?: any;
            };
            timeoutSeconds?: number;
          };
          resources?: {
            claims?: {
              name: string;
            }[];
            limits?: {
              [key: string]: unknown;
            };
            requests?: {
              [key: string]: unknown;
            };
          };
          securityContext?: {
            allowPrivilegeEscalation?: boolean;
            capabilities?: {
              add?: string[];
              drop?: string[];
            };
            readOnlyRootFilesystem?: boolean;
            runAsGroup?: number;
            runAsNonRoot?: boolean;
            runAsUser?: number;
            seccompProfile?: {
              localhostProfile?: string;
              type: string;
            };
          };
          startupProbe?: {
            exec?: {
              command?: string[];
            };
            failureThreshold?: number;
            grpc?: {
              port: number;
              service?: string;
            };
            httpGet?: {
              host?: string;
              httpHeaders?: {
                name: string;
                value: string;
              }[];
              path?: string;
              port?: any;
              scheme?: string;
            };
            initialDelaySeconds?: number;
            periodSeconds?: number;
            successThreshold?: number;
            tcpSocket?: {
              host?: string;
              port?: any;
            };
            timeoutSeconds?: number;
          };
          terminationMessagePath?: string;
          terminationMessagePolicy?: string;
          volumeMounts?: {
            mountPath: string;
            name: string;
            readOnly?: boolean;
            subPath?: string;
          }[];
          workingDir?: string;
        }[];
        dnsConfig?: any;
        dnsPolicy?: string;
        enableServiceLinks?: boolean;
        hostAliases?: any[];
        idleTimeoutSeconds?: number;
        imagePullSecrets?: {
          name?: string;
        }[];
        initContainers?: any[];
        nodeSelector?: any;
        priorityClassName?: string;
        responseStartTimeoutSeconds?: number;
        runtimeClassName?: string;
        schedulerName?: string;
        securityContext?: any;
        serviceAccountName?: string;
        shareProcessNamespace?: boolean;
        timeoutSeconds?: number;
        tolerations?: any[];
        topologySpreadConstraints?: any[];
        volumes?: {
          configMap?: {
            defaultMode?: number;
            items?: {
              key: string;
              mode?: number;
              path: string;
            }[];
            name?: string;
            optional?: boolean;
          };
          emptyDir?: any;
          name: string;
          persistentVolumeClaim?: any;
          projected?: {
            defaultMode?: number;
            sources?: {
              configMap?: {
                items?: {
                  key: string;
                  mode?: number;
                  path: string;
                }[];
                name?: string;
                optional?: boolean;
              };
              downwardAPI?: {
                items?: {
                  fieldRef?: {
                    apiVersion?: string;
                    fieldPath: string;
                  };
                  mode?: number;
                  path: string;
                  resourceFieldRef?: {
                    containerName?: string;
                    divisor?: any;
                    resource: string;
                  };
                }[];
              };
              secret?: {
                items?: {
                  key: string;
                  mode?: number;
                  path: string;
                }[];
                name?: string;
                optional?: boolean;
              };
              serviceAccountToken?: {
                audience?: string;
                expirationSeconds?: number;
                path: string;
              };
            }[];
          };
          secret?: {
            defaultMode?: number;
            items?: {
              key: string;
              mode?: number;
              path: string;
            }[];
            optional?: boolean;
            secretName?: string;
          };
        }[];
      };
    };
    traffic?: {
      configurationName?: string;
      latestRevision?: boolean;
      percent?: number;
      revisionName?: string;
      tag?: string;
      url?: string;
    }[];
  };
  status?: {
    address?: {
      CACerts?: string;
      audience?: string;
      name?: string;
      url?: string;
    };
    annotations?: {
      [key: string]: unknown;
    };
    conditions?: {
      lastTransitionTime?: string;
      message?: string;
      reason?: string;
      severity?: string;
      status: string;
      type: string;
    }[];
    latestCreatedRevisionName?: string;
    latestReadyRevisionName?: string;
    observedGeneration?: number;
    traffic?: {
      configurationName?: string;
      latestRevision?: boolean;
      percent?: number;
      revisionName?: string;
      tag?: string;
      url?: string;
    }[];
    url?: string;
  };
}
/* dev.knative.serving.v1.ServiceList */
/* ServiceList is a list of Service */
export interface ServingKnativeDevV1ServiceList {
  apiVersion?: string;
  items: ServingKnativeDevV1Service[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.cert-manager.acme.v1.Challenge */
/* Challenge is a type to represent a Challenge request with an ACME server */
export interface AcmeCertManagerIoV1Challenge {
  apiVersion?: string;
  kind?: string;
  metadata: ObjectMeta;
  spec: {
    authorizationURL: string;
    dnsName: string;
    issuerRef: {
      group?: string;
      kind?: string;
      name: string;
    };
    key: string;
    solver: {
      dns01?: {
        acmeDNS?: {
          accountSecretRef: {
            key?: string;
            name: string;
          };
          host: string;
        };
        akamai?: {
          accessTokenSecretRef: {
            key?: string;
            name: string;
          };
          clientSecretSecretRef: {
            key?: string;
            name: string;
          };
          clientTokenSecretRef: {
            key?: string;
            name: string;
          };
          serviceConsumerDomain: string;
        };
        azureDNS?: {
          clientID?: string;
          clientSecretSecretRef?: {
            key?: string;
            name: string;
          };
          environment?: "AzurePublicCloud" | "AzureChinaCloud" | "AzureGermanCloud" | "AzureUSGovernmentCloud";
          hostedZoneName?: string;
          managedIdentity?: {
            clientID?: string;
            resourceID?: string;
            tenantID?: string;
          };
          resourceGroupName: string;
          subscriptionID: string;
          tenantID?: string;
        };
        cloudDNS?: {
          hostedZoneName?: string;
          project: string;
          serviceAccountSecretRef?: {
            key?: string;
            name: string;
          };
        };
        cloudflare?: {
          apiKeySecretRef?: {
            key?: string;
            name: string;
          };
          apiTokenSecretRef?: {
            key?: string;
            name: string;
          };
          email?: string;
        };
        cnameStrategy?: "None" | "Follow";
        digitalocean?: {
          tokenSecretRef: {
            key?: string;
            name: string;
          };
        };
        rfc2136?: {
          nameserver: string;
          tsigAlgorithm?: string;
          tsigKeyName?: string;
          tsigSecretSecretRef?: {
            key?: string;
            name: string;
          };
        };
        route53?: {
          accessKeyID?: string;
          accessKeyIDSecretRef?: {
            key?: string;
            name: string;
          };
          auth?: {
            kubernetes: {
              serviceAccountRef: {
                audiences?: string[];
                name: string;
              };
            };
          };
          hostedZoneID?: string;
          region?: string;
          role?: string;
          secretAccessKeySecretRef?: {
            key?: string;
            name: string;
          };
        };
        webhook?: {
          config?: any;
          groupName: string;
          solverName: string;
        };
      };
      http01?: {
        gatewayHTTPRoute?: {
          labels?: {
            [key: string]: unknown;
          };
          parentRefs?: {
            group?: string;
            kind?: string;
            name: string;
            namespace?: string;
            port?: number;
            sectionName?: string;
          }[];
          podTemplate?: {
            metadata?: {
              annotations?: {
                [key: string]: unknown;
              };
              labels?: {
                [key: string]: unknown;
              };
            };
            spec?: {
              affinity?: {
                nodeAffinity?: {
                  preferredDuringSchedulingIgnoredDuringExecution?: {
                    preference: {
                      matchExpressions?: {
                        key: string;
                        operator: string;
                        values?: string[];
                      }[];
                      matchFields?: {
                        key: string;
                        operator: string;
                        values?: string[];
                      }[];
                    };
                    weight: number;
                  }[];
                  requiredDuringSchedulingIgnoredDuringExecution?: {
                    nodeSelectorTerms: {
                      matchExpressions?: {
                        key: string;
                        operator: string;
                        values?: string[];
                      }[];
                      matchFields?: {
                        key: string;
                        operator: string;
                        values?: string[];
                      }[];
                    }[];
                  };
                };
                podAffinity?: {
                  preferredDuringSchedulingIgnoredDuringExecution?: {
                    podAffinityTerm: {
                      labelSelector?: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchLabels?: {
                          [key: string]: unknown;
                        };
                      };
                      matchLabelKeys?: string[];
                      mismatchLabelKeys?: string[];
                      namespaceSelector?: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchLabels?: {
                          [key: string]: unknown;
                        };
                      };
                      namespaces?: string[];
                      topologyKey: string;
                    };
                    weight: number;
                  }[];
                  requiredDuringSchedulingIgnoredDuringExecution?: {
                    labelSelector?: {
                      matchExpressions?: {
                        key: string;
                        operator: string;
                        values?: string[];
                      }[];
                      matchLabels?: {
                        [key: string]: unknown;
                      };
                    };
                    matchLabelKeys?: string[];
                    mismatchLabelKeys?: string[];
                    namespaceSelector?: {
                      matchExpressions?: {
                        key: string;
                        operator: string;
                        values?: string[];
                      }[];
                      matchLabels?: {
                        [key: string]: unknown;
                      };
                    };
                    namespaces?: string[];
                    topologyKey: string;
                  }[];
                };
                podAntiAffinity?: {
                  preferredDuringSchedulingIgnoredDuringExecution?: {
                    podAffinityTerm: {
                      labelSelector?: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchLabels?: {
                          [key: string]: unknown;
                        };
                      };
                      matchLabelKeys?: string[];
                      mismatchLabelKeys?: string[];
                      namespaceSelector?: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchLabels?: {
                          [key: string]: unknown;
                        };
                      };
                      namespaces?: string[];
                      topologyKey: string;
                    };
                    weight: number;
                  }[];
                  requiredDuringSchedulingIgnoredDuringExecution?: {
                    labelSelector?: {
                      matchExpressions?: {
                        key: string;
                        operator: string;
                        values?: string[];
                      }[];
                      matchLabels?: {
                        [key: string]: unknown;
                      };
                    };
                    matchLabelKeys?: string[];
                    mismatchLabelKeys?: string[];
                    namespaceSelector?: {
                      matchExpressions?: {
                        key: string;
                        operator: string;
                        values?: string[];
                      }[];
                      matchLabels?: {
                        [key: string]: unknown;
                      };
                    };
                    namespaces?: string[];
                    topologyKey: string;
                  }[];
                };
              };
              imagePullSecrets?: {
                name?: string;
              }[];
              nodeSelector?: {
                [key: string]: unknown;
              };
              priorityClassName?: string;
              securityContext?: {
                fsGroup?: number;
                fsGroupChangePolicy?: string;
                runAsGroup?: number;
                runAsNonRoot?: boolean;
                runAsUser?: number;
                seLinuxOptions?: {
                  level?: string;
                  role?: string;
                  type?: string;
                  user?: string;
                };
                seccompProfile?: {
                  localhostProfile?: string;
                  type: string;
                };
                supplementalGroups?: number[];
                sysctls?: {
                  name: string;
                  value: string;
                }[];
              };
              serviceAccountName?: string;
              tolerations?: {
                effect?: string;
                key?: string;
                operator?: string;
                tolerationSeconds?: number;
                value?: string;
              }[];
            };
          };
          serviceType?: string;
        };
        ingress?: {
          class?: string;
          ingressClassName?: string;
          ingressTemplate?: {
            metadata?: {
              annotations?: {
                [key: string]: unknown;
              };
              labels?: {
                [key: string]: unknown;
              };
            };
          };
          name?: string;
          podTemplate?: {
            metadata?: {
              annotations?: {
                [key: string]: unknown;
              };
              labels?: {
                [key: string]: unknown;
              };
            };
            spec?: {
              affinity?: {
                nodeAffinity?: {
                  preferredDuringSchedulingIgnoredDuringExecution?: {
                    preference: {
                      matchExpressions?: {
                        key: string;
                        operator: string;
                        values?: string[];
                      }[];
                      matchFields?: {
                        key: string;
                        operator: string;
                        values?: string[];
                      }[];
                    };
                    weight: number;
                  }[];
                  requiredDuringSchedulingIgnoredDuringExecution?: {
                    nodeSelectorTerms: {
                      matchExpressions?: {
                        key: string;
                        operator: string;
                        values?: string[];
                      }[];
                      matchFields?: {
                        key: string;
                        operator: string;
                        values?: string[];
                      }[];
                    }[];
                  };
                };
                podAffinity?: {
                  preferredDuringSchedulingIgnoredDuringExecution?: {
                    podAffinityTerm: {
                      labelSelector?: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchLabels?: {
                          [key: string]: unknown;
                        };
                      };
                      matchLabelKeys?: string[];
                      mismatchLabelKeys?: string[];
                      namespaceSelector?: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchLabels?: {
                          [key: string]: unknown;
                        };
                      };
                      namespaces?: string[];
                      topologyKey: string;
                    };
                    weight: number;
                  }[];
                  requiredDuringSchedulingIgnoredDuringExecution?: {
                    labelSelector?: {
                      matchExpressions?: {
                        key: string;
                        operator: string;
                        values?: string[];
                      }[];
                      matchLabels?: {
                        [key: string]: unknown;
                      };
                    };
                    matchLabelKeys?: string[];
                    mismatchLabelKeys?: string[];
                    namespaceSelector?: {
                      matchExpressions?: {
                        key: string;
                        operator: string;
                        values?: string[];
                      }[];
                      matchLabels?: {
                        [key: string]: unknown;
                      };
                    };
                    namespaces?: string[];
                    topologyKey: string;
                  }[];
                };
                podAntiAffinity?: {
                  preferredDuringSchedulingIgnoredDuringExecution?: {
                    podAffinityTerm: {
                      labelSelector?: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchLabels?: {
                          [key: string]: unknown;
                        };
                      };
                      matchLabelKeys?: string[];
                      mismatchLabelKeys?: string[];
                      namespaceSelector?: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchLabels?: {
                          [key: string]: unknown;
                        };
                      };
                      namespaces?: string[];
                      topologyKey: string;
                    };
                    weight: number;
                  }[];
                  requiredDuringSchedulingIgnoredDuringExecution?: {
                    labelSelector?: {
                      matchExpressions?: {
                        key: string;
                        operator: string;
                        values?: string[];
                      }[];
                      matchLabels?: {
                        [key: string]: unknown;
                      };
                    };
                    matchLabelKeys?: string[];
                    mismatchLabelKeys?: string[];
                    namespaceSelector?: {
                      matchExpressions?: {
                        key: string;
                        operator: string;
                        values?: string[];
                      }[];
                      matchLabels?: {
                        [key: string]: unknown;
                      };
                    };
                    namespaces?: string[];
                    topologyKey: string;
                  }[];
                };
              };
              imagePullSecrets?: {
                name?: string;
              }[];
              nodeSelector?: {
                [key: string]: unknown;
              };
              priorityClassName?: string;
              securityContext?: {
                fsGroup?: number;
                fsGroupChangePolicy?: string;
                runAsGroup?: number;
                runAsNonRoot?: boolean;
                runAsUser?: number;
                seLinuxOptions?: {
                  level?: string;
                  role?: string;
                  type?: string;
                  user?: string;
                };
                seccompProfile?: {
                  localhostProfile?: string;
                  type: string;
                };
                supplementalGroups?: number[];
                sysctls?: {
                  name: string;
                  value: string;
                }[];
              };
              serviceAccountName?: string;
              tolerations?: {
                effect?: string;
                key?: string;
                operator?: string;
                tolerationSeconds?: number;
                value?: string;
              }[];
            };
          };
          serviceType?: string;
        };
      };
      selector?: {
        dnsNames?: string[];
        dnsZones?: string[];
        matchLabels?: {
          [key: string]: unknown;
        };
      };
    };
    token: string;
    type: "HTTP-01" | "DNS-01";
    url: string;
    wildcard?: boolean;
  };
  status?: {
    presented?: boolean;
    processing?: boolean;
    reason?: string;
    state?: "valid" | "ready" | "pending" | "processing" | "invalid" | "expired" | "errored";
  };
}
/* io.cert-manager.acme.v1.ChallengeList */
/* ChallengeList is a list of Challenge */
export interface AcmeCertManagerIoV1ChallengeList {
  apiVersion?: string;
  items: AcmeCertManagerIoV1Challenge[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.cert-manager.acme.v1.Order */
/* Order is a type to represent an Order with an ACME server */
export interface AcmeCertManagerIoV1Order {
  apiVersion?: string;
  kind?: string;
  metadata: ObjectMeta;
  spec: {
    commonName?: string;
    dnsNames?: string[];
    duration?: string;
    ipAddresses?: string[];
    issuerRef: {
      group?: string;
      kind?: string;
      name: string;
    };
    request: string;
  };
  status?: {
    authorizations?: {
      challenges?: {
        token: string;
        type: string;
        url: string;
      }[];
      identifier?: string;
      initialState?: "valid" | "ready" | "pending" | "processing" | "invalid" | "expired" | "errored";
      url: string;
      wildcard?: boolean;
    }[];
    certificate?: string;
    failureTime?: string;
    finalizeURL?: string;
    reason?: string;
    state?: "valid" | "ready" | "pending" | "processing" | "invalid" | "expired" | "errored";
    url?: string;
  };
}
/* io.cert-manager.acme.v1.OrderList */
/* OrderList is a list of Order */
export interface AcmeCertManagerIoV1OrderList {
  apiVersion?: string;
  items: AcmeCertManagerIoV1Order[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.cert-manager.v1.Certificate */
/* A Certificate resource should be created to ensure an up to date and signed
X.509 certificate is stored in the Kubernetes Secret resource named in `spec.secretName`.

The stored certificate will be renewed before it expires (as configured by `spec.renewBefore`). */
export interface CertManagerIoV1Certificate {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: {
    additionalOutputFormats?: {
      type: "DER" | "CombinedPEM";
    }[];
    commonName?: string;
    dnsNames?: string[];
    duration?: string;
    emailAddresses?: string[];
    encodeUsagesInRequest?: boolean;
    ipAddresses?: string[];
    isCA?: boolean;
    issuerRef: {
      group?: string;
      kind?: string;
      name: string;
    };
    keystores?: {
      jks?: {
        alias?: string;
        create: boolean;
        password?: string;
        passwordSecretRef?: {
          key?: string;
          name: string;
        };
      };
      pkcs12?: {
        create: boolean;
        password?: string;
        passwordSecretRef?: {
          key?: string;
          name: string;
        };
        profile?: "LegacyRC2" | "LegacyDES" | "Modern2023";
      };
    };
    literalSubject?: string;
    nameConstraints?: {
      critical?: boolean;
      excluded?: {
        dnsDomains?: string[];
        emailAddresses?: string[];
        ipRanges?: string[];
        uriDomains?: string[];
      };
      permitted?: {
        dnsDomains?: string[];
        emailAddresses?: string[];
        ipRanges?: string[];
        uriDomains?: string[];
      };
    };
    otherNames?: {
      oid?: string;
      utf8Value?: string;
    }[];
    privateKey?: {
      algorithm?: "RSA" | "ECDSA" | "Ed25519";
      encoding?: "PKCS1" | "PKCS8";
      rotationPolicy?: "Never" | "Always";
      size?: number;
    };
    renewBefore?: string;
    renewBeforePercentage?: number;
    revisionHistoryLimit?: number;
    secretName: string;
    secretTemplate?: {
      annotations?: {
        [key: string]: unknown;
      };
      labels?: {
        [key: string]: unknown;
      };
    };
    subject?: {
      countries?: string[];
      localities?: string[];
      organizationalUnits?: string[];
      organizations?: string[];
      postalCodes?: string[];
      provinces?: string[];
      serialNumber?: string;
      streetAddresses?: string[];
    };
    uris?: string[];
    usages?: ("signing" | "digital signature" | "content commitment" | "key encipherment" | "key agreement" | "data encipherment" | "cert sign" | "crl sign" | "encipher only" | "decipher only" | "any" | "server auth" | "client auth" | "code signing" | "email protection" | "s/mime" | "ipsec end system" | "ipsec tunnel" | "ipsec user" | "timestamping" | "ocsp signing" | "microsoft sgc" | "netscape sgc")[];
  };
  status?: {
    conditions?: {
      lastTransitionTime?: string;
      message?: string;
      observedGeneration?: number;
      reason?: string;
      status: "True" | "False" | "Unknown";
      type: string;
    }[];
    failedIssuanceAttempts?: number;
    lastFailureTime?: string;
    nextPrivateKeySecretName?: string;
    notAfter?: string;
    notBefore?: string;
    renewalTime?: string;
    revision?: number;
  };
}
/* io.cert-manager.v1.CertificateList */
/* CertificateList is a list of Certificate */
export interface CertManagerIoV1CertificateList {
  apiVersion?: string;
  items: CertManagerIoV1Certificate[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.cert-manager.v1.CertificateRequest */
/* A CertificateRequest is used to request a signed certificate from one of the
configured issuers.

All fields within the CertificateRequest's `spec` are immutable after creation.
A CertificateRequest will either succeed or fail, as denoted by its `Ready` status
condition and its `status.failureTime` field.

A CertificateRequest is a one-shot resource, meaning it represents a single
point in time request for a certificate and cannot be re-used. */
export interface CertManagerIoV1CertificateRequest {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: {
    duration?: string;
    extra?: {
      [key: string]: unknown;
    };
    groups?: string[];
    isCA?: boolean;
    issuerRef: {
      group?: string;
      kind?: string;
      name: string;
    };
    request: string;
    uid?: string;
    usages?: ("signing" | "digital signature" | "content commitment" | "key encipherment" | "key agreement" | "data encipherment" | "cert sign" | "crl sign" | "encipher only" | "decipher only" | "any" | "server auth" | "client auth" | "code signing" | "email protection" | "s/mime" | "ipsec end system" | "ipsec tunnel" | "ipsec user" | "timestamping" | "ocsp signing" | "microsoft sgc" | "netscape sgc")[];
    username?: string;
  };
  status?: {
    ca?: string;
    certificate?: string;
    conditions?: {
      lastTransitionTime?: string;
      message?: string;
      reason?: string;
      status: "True" | "False" | "Unknown";
      type: string;
    }[];
    failureTime?: string;
  };
}
/* io.cert-manager.v1.CertificateRequestList */
/* CertificateRequestList is a list of CertificateRequest */
export interface CertManagerIoV1CertificateRequestList {
  apiVersion?: string;
  items: CertManagerIoV1CertificateRequest[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.cert-manager.v1.ClusterIssuer */
/* A ClusterIssuer represents a certificate issuing authority which can be
referenced as part of `issuerRef` fields.
It is similar to an Issuer, however it is cluster-scoped and therefore can
be referenced by resources that exist in *any* namespace, not just the same
namespace as the referent. */
export interface CertManagerIoV1ClusterIssuer {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec: {
    acme?: {
      caBundle?: string;
      disableAccountKeyGeneration?: boolean;
      email?: string;
      enableDurationFeature?: boolean;
      externalAccountBinding?: {
        keyAlgorithm?: "HS256" | "HS384" | "HS512";
        keyID: string;
        keySecretRef: {
          key?: string;
          name: string;
        };
      };
      preferredChain?: string;
      privateKeySecretRef: {
        key?: string;
        name: string;
      };
      server: string;
      skipTLSVerify?: boolean;
      solvers?: {
        dns01?: {
          acmeDNS?: {
            accountSecretRef: {
              key?: string;
              name: string;
            };
            host: string;
          };
          akamai?: {
            accessTokenSecretRef: {
              key?: string;
              name: string;
            };
            clientSecretSecretRef: {
              key?: string;
              name: string;
            };
            clientTokenSecretRef: {
              key?: string;
              name: string;
            };
            serviceConsumerDomain: string;
          };
          azureDNS?: {
            clientID?: string;
            clientSecretSecretRef?: {
              key?: string;
              name: string;
            };
            environment?: "AzurePublicCloud" | "AzureChinaCloud" | "AzureGermanCloud" | "AzureUSGovernmentCloud";
            hostedZoneName?: string;
            managedIdentity?: {
              clientID?: string;
              resourceID?: string;
              tenantID?: string;
            };
            resourceGroupName: string;
            subscriptionID: string;
            tenantID?: string;
          };
          cloudDNS?: {
            hostedZoneName?: string;
            project: string;
            serviceAccountSecretRef?: {
              key?: string;
              name: string;
            };
          };
          cloudflare?: {
            apiKeySecretRef?: {
              key?: string;
              name: string;
            };
            apiTokenSecretRef?: {
              key?: string;
              name: string;
            };
            email?: string;
          };
          cnameStrategy?: "None" | "Follow";
          digitalocean?: {
            tokenSecretRef: {
              key?: string;
              name: string;
            };
          };
          rfc2136?: {
            nameserver: string;
            tsigAlgorithm?: string;
            tsigKeyName?: string;
            tsigSecretSecretRef?: {
              key?: string;
              name: string;
            };
          };
          route53?: {
            accessKeyID?: string;
            accessKeyIDSecretRef?: {
              key?: string;
              name: string;
            };
            auth?: {
              kubernetes: {
                serviceAccountRef: {
                  audiences?: string[];
                  name: string;
                };
              };
            };
            hostedZoneID?: string;
            region?: string;
            role?: string;
            secretAccessKeySecretRef?: {
              key?: string;
              name: string;
            };
          };
          webhook?: {
            config?: any;
            groupName: string;
            solverName: string;
          };
        };
        http01?: {
          gatewayHTTPRoute?: {
            labels?: {
              [key: string]: unknown;
            };
            parentRefs?: {
              group?: string;
              kind?: string;
              name: string;
              namespace?: string;
              port?: number;
              sectionName?: string;
            }[];
            podTemplate?: {
              metadata?: {
                annotations?: {
                  [key: string]: unknown;
                };
                labels?: {
                  [key: string]: unknown;
                };
              };
              spec?: {
                affinity?: {
                  nodeAffinity?: {
                    preferredDuringSchedulingIgnoredDuringExecution?: {
                      preference: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchFields?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                      };
                      weight: number;
                    }[];
                    requiredDuringSchedulingIgnoredDuringExecution?: {
                      nodeSelectorTerms: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchFields?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                      }[];
                    };
                  };
                  podAffinity?: {
                    preferredDuringSchedulingIgnoredDuringExecution?: {
                      podAffinityTerm: {
                        labelSelector?: {
                          matchExpressions?: {
                            key: string;
                            operator: string;
                            values?: string[];
                          }[];
                          matchLabels?: {
                            [key: string]: unknown;
                          };
                        };
                        matchLabelKeys?: string[];
                        mismatchLabelKeys?: string[];
                        namespaceSelector?: {
                          matchExpressions?: {
                            key: string;
                            operator: string;
                            values?: string[];
                          }[];
                          matchLabels?: {
                            [key: string]: unknown;
                          };
                        };
                        namespaces?: string[];
                        topologyKey: string;
                      };
                      weight: number;
                    }[];
                    requiredDuringSchedulingIgnoredDuringExecution?: {
                      labelSelector?: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchLabels?: {
                          [key: string]: unknown;
                        };
                      };
                      matchLabelKeys?: string[];
                      mismatchLabelKeys?: string[];
                      namespaceSelector?: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchLabels?: {
                          [key: string]: unknown;
                        };
                      };
                      namespaces?: string[];
                      topologyKey: string;
                    }[];
                  };
                  podAntiAffinity?: {
                    preferredDuringSchedulingIgnoredDuringExecution?: {
                      podAffinityTerm: {
                        labelSelector?: {
                          matchExpressions?: {
                            key: string;
                            operator: string;
                            values?: string[];
                          }[];
                          matchLabels?: {
                            [key: string]: unknown;
                          };
                        };
                        matchLabelKeys?: string[];
                        mismatchLabelKeys?: string[];
                        namespaceSelector?: {
                          matchExpressions?: {
                            key: string;
                            operator: string;
                            values?: string[];
                          }[];
                          matchLabels?: {
                            [key: string]: unknown;
                          };
                        };
                        namespaces?: string[];
                        topologyKey: string;
                      };
                      weight: number;
                    }[];
                    requiredDuringSchedulingIgnoredDuringExecution?: {
                      labelSelector?: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchLabels?: {
                          [key: string]: unknown;
                        };
                      };
                      matchLabelKeys?: string[];
                      mismatchLabelKeys?: string[];
                      namespaceSelector?: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchLabels?: {
                          [key: string]: unknown;
                        };
                      };
                      namespaces?: string[];
                      topologyKey: string;
                    }[];
                  };
                };
                imagePullSecrets?: {
                  name?: string;
                }[];
                nodeSelector?: {
                  [key: string]: unknown;
                };
                priorityClassName?: string;
                securityContext?: {
                  fsGroup?: number;
                  fsGroupChangePolicy?: string;
                  runAsGroup?: number;
                  runAsNonRoot?: boolean;
                  runAsUser?: number;
                  seLinuxOptions?: {
                    level?: string;
                    role?: string;
                    type?: string;
                    user?: string;
                  };
                  seccompProfile?: {
                    localhostProfile?: string;
                    type: string;
                  };
                  supplementalGroups?: number[];
                  sysctls?: {
                    name: string;
                    value: string;
                  }[];
                };
                serviceAccountName?: string;
                tolerations?: {
                  effect?: string;
                  key?: string;
                  operator?: string;
                  tolerationSeconds?: number;
                  value?: string;
                }[];
              };
            };
            serviceType?: string;
          };
          ingress?: {
            class?: string;
            ingressClassName?: string;
            ingressTemplate?: {
              metadata?: {
                annotations?: {
                  [key: string]: unknown;
                };
                labels?: {
                  [key: string]: unknown;
                };
              };
            };
            name?: string;
            podTemplate?: {
              metadata?: {
                annotations?: {
                  [key: string]: unknown;
                };
                labels?: {
                  [key: string]: unknown;
                };
              };
              spec?: {
                affinity?: {
                  nodeAffinity?: {
                    preferredDuringSchedulingIgnoredDuringExecution?: {
                      preference: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchFields?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                      };
                      weight: number;
                    }[];
                    requiredDuringSchedulingIgnoredDuringExecution?: {
                      nodeSelectorTerms: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchFields?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                      }[];
                    };
                  };
                  podAffinity?: {
                    preferredDuringSchedulingIgnoredDuringExecution?: {
                      podAffinityTerm: {
                        labelSelector?: {
                          matchExpressions?: {
                            key: string;
                            operator: string;
                            values?: string[];
                          }[];
                          matchLabels?: {
                            [key: string]: unknown;
                          };
                        };
                        matchLabelKeys?: string[];
                        mismatchLabelKeys?: string[];
                        namespaceSelector?: {
                          matchExpressions?: {
                            key: string;
                            operator: string;
                            values?: string[];
                          }[];
                          matchLabels?: {
                            [key: string]: unknown;
                          };
                        };
                        namespaces?: string[];
                        topologyKey: string;
                      };
                      weight: number;
                    }[];
                    requiredDuringSchedulingIgnoredDuringExecution?: {
                      labelSelector?: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchLabels?: {
                          [key: string]: unknown;
                        };
                      };
                      matchLabelKeys?: string[];
                      mismatchLabelKeys?: string[];
                      namespaceSelector?: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchLabels?: {
                          [key: string]: unknown;
                        };
                      };
                      namespaces?: string[];
                      topologyKey: string;
                    }[];
                  };
                  podAntiAffinity?: {
                    preferredDuringSchedulingIgnoredDuringExecution?: {
                      podAffinityTerm: {
                        labelSelector?: {
                          matchExpressions?: {
                            key: string;
                            operator: string;
                            values?: string[];
                          }[];
                          matchLabels?: {
                            [key: string]: unknown;
                          };
                        };
                        matchLabelKeys?: string[];
                        mismatchLabelKeys?: string[];
                        namespaceSelector?: {
                          matchExpressions?: {
                            key: string;
                            operator: string;
                            values?: string[];
                          }[];
                          matchLabels?: {
                            [key: string]: unknown;
                          };
                        };
                        namespaces?: string[];
                        topologyKey: string;
                      };
                      weight: number;
                    }[];
                    requiredDuringSchedulingIgnoredDuringExecution?: {
                      labelSelector?: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchLabels?: {
                          [key: string]: unknown;
                        };
                      };
                      matchLabelKeys?: string[];
                      mismatchLabelKeys?: string[];
                      namespaceSelector?: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchLabels?: {
                          [key: string]: unknown;
                        };
                      };
                      namespaces?: string[];
                      topologyKey: string;
                    }[];
                  };
                };
                imagePullSecrets?: {
                  name?: string;
                }[];
                nodeSelector?: {
                  [key: string]: unknown;
                };
                priorityClassName?: string;
                securityContext?: {
                  fsGroup?: number;
                  fsGroupChangePolicy?: string;
                  runAsGroup?: number;
                  runAsNonRoot?: boolean;
                  runAsUser?: number;
                  seLinuxOptions?: {
                    level?: string;
                    role?: string;
                    type?: string;
                    user?: string;
                  };
                  seccompProfile?: {
                    localhostProfile?: string;
                    type: string;
                  };
                  supplementalGroups?: number[];
                  sysctls?: {
                    name: string;
                    value: string;
                  }[];
                };
                serviceAccountName?: string;
                tolerations?: {
                  effect?: string;
                  key?: string;
                  operator?: string;
                  tolerationSeconds?: number;
                  value?: string;
                }[];
              };
            };
            serviceType?: string;
          };
        };
        selector?: {
          dnsNames?: string[];
          dnsZones?: string[];
          matchLabels?: {
            [key: string]: unknown;
          };
        };
      }[];
    };
    ca?: {
      crlDistributionPoints?: string[];
      issuingCertificateURLs?: string[];
      ocspServers?: string[];
      secretName: string;
    };
    selfSigned?: {
      crlDistributionPoints?: string[];
    };
    vault?: {
      auth: {
        appRole?: {
          path: string;
          roleId: string;
          secretRef: {
            key?: string;
            name: string;
          };
        };
        clientCertificate?: {
          mountPath?: string;
          name?: string;
          secretName?: string;
        };
        kubernetes?: {
          mountPath?: string;
          role: string;
          secretRef?: {
            key?: string;
            name: string;
          };
          serviceAccountRef?: {
            audiences?: string[];
            name: string;
          };
        };
        tokenSecretRef?: {
          key?: string;
          name: string;
        };
      };
      caBundle?: string;
      caBundleSecretRef?: {
        key?: string;
        name: string;
      };
      clientCertSecretRef?: {
        key?: string;
        name: string;
      };
      clientKeySecretRef?: {
        key?: string;
        name: string;
      };
      namespace?: string;
      path: string;
      server: string;
    };
    venafi?: {
      cloud?: {
        apiTokenSecretRef: {
          key?: string;
          name: string;
        };
        url?: string;
      };
      tpp?: {
        caBundle?: string;
        caBundleSecretRef?: {
          key?: string;
          name: string;
        };
        credentialsRef: {
          name: string;
        };
        url: string;
      };
      zone: string;
    };
  };
  status?: {
    acme?: {
      lastPrivateKeyHash?: string;
      lastRegisteredEmail?: string;
      uri?: string;
    };
    conditions?: {
      lastTransitionTime?: string;
      message?: string;
      observedGeneration?: number;
      reason?: string;
      status: "True" | "False" | "Unknown";
      type: string;
    }[];
  };
}
/* io.cert-manager.v1.ClusterIssuerList */
/* ClusterIssuerList is a list of ClusterIssuer */
export interface CertManagerIoV1ClusterIssuerList {
  apiVersion?: string;
  items: CertManagerIoV1ClusterIssuer[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.cert-manager.v1.Issuer */
/* An Issuer represents a certificate issuing authority which can be
referenced as part of `issuerRef` fields.
It is scoped to a single namespace and can therefore only be referenced by
resources within the same namespace. */
export interface CertManagerIoV1Issuer {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec: {
    acme?: {
      caBundle?: string;
      disableAccountKeyGeneration?: boolean;
      email?: string;
      enableDurationFeature?: boolean;
      externalAccountBinding?: {
        keyAlgorithm?: "HS256" | "HS384" | "HS512";
        keyID: string;
        keySecretRef: {
          key?: string;
          name: string;
        };
      };
      preferredChain?: string;
      privateKeySecretRef: {
        key?: string;
        name: string;
      };
      server: string;
      skipTLSVerify?: boolean;
      solvers?: {
        dns01?: {
          acmeDNS?: {
            accountSecretRef: {
              key?: string;
              name: string;
            };
            host: string;
          };
          akamai?: {
            accessTokenSecretRef: {
              key?: string;
              name: string;
            };
            clientSecretSecretRef: {
              key?: string;
              name: string;
            };
            clientTokenSecretRef: {
              key?: string;
              name: string;
            };
            serviceConsumerDomain: string;
          };
          azureDNS?: {
            clientID?: string;
            clientSecretSecretRef?: {
              key?: string;
              name: string;
            };
            environment?: "AzurePublicCloud" | "AzureChinaCloud" | "AzureGermanCloud" | "AzureUSGovernmentCloud";
            hostedZoneName?: string;
            managedIdentity?: {
              clientID?: string;
              resourceID?: string;
              tenantID?: string;
            };
            resourceGroupName: string;
            subscriptionID: string;
            tenantID?: string;
          };
          cloudDNS?: {
            hostedZoneName?: string;
            project: string;
            serviceAccountSecretRef?: {
              key?: string;
              name: string;
            };
          };
          cloudflare?: {
            apiKeySecretRef?: {
              key?: string;
              name: string;
            };
            apiTokenSecretRef?: {
              key?: string;
              name: string;
            };
            email?: string;
          };
          cnameStrategy?: "None" | "Follow";
          digitalocean?: {
            tokenSecretRef: {
              key?: string;
              name: string;
            };
          };
          rfc2136?: {
            nameserver: string;
            tsigAlgorithm?: string;
            tsigKeyName?: string;
            tsigSecretSecretRef?: {
              key?: string;
              name: string;
            };
          };
          route53?: {
            accessKeyID?: string;
            accessKeyIDSecretRef?: {
              key?: string;
              name: string;
            };
            auth?: {
              kubernetes: {
                serviceAccountRef: {
                  audiences?: string[];
                  name: string;
                };
              };
            };
            hostedZoneID?: string;
            region?: string;
            role?: string;
            secretAccessKeySecretRef?: {
              key?: string;
              name: string;
            };
          };
          webhook?: {
            config?: any;
            groupName: string;
            solverName: string;
          };
        };
        http01?: {
          gatewayHTTPRoute?: {
            labels?: {
              [key: string]: unknown;
            };
            parentRefs?: {
              group?: string;
              kind?: string;
              name: string;
              namespace?: string;
              port?: number;
              sectionName?: string;
            }[];
            podTemplate?: {
              metadata?: {
                annotations?: {
                  [key: string]: unknown;
                };
                labels?: {
                  [key: string]: unknown;
                };
              };
              spec?: {
                affinity?: {
                  nodeAffinity?: {
                    preferredDuringSchedulingIgnoredDuringExecution?: {
                      preference: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchFields?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                      };
                      weight: number;
                    }[];
                    requiredDuringSchedulingIgnoredDuringExecution?: {
                      nodeSelectorTerms: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchFields?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                      }[];
                    };
                  };
                  podAffinity?: {
                    preferredDuringSchedulingIgnoredDuringExecution?: {
                      podAffinityTerm: {
                        labelSelector?: {
                          matchExpressions?: {
                            key: string;
                            operator: string;
                            values?: string[];
                          }[];
                          matchLabels?: {
                            [key: string]: unknown;
                          };
                        };
                        matchLabelKeys?: string[];
                        mismatchLabelKeys?: string[];
                        namespaceSelector?: {
                          matchExpressions?: {
                            key: string;
                            operator: string;
                            values?: string[];
                          }[];
                          matchLabels?: {
                            [key: string]: unknown;
                          };
                        };
                        namespaces?: string[];
                        topologyKey: string;
                      };
                      weight: number;
                    }[];
                    requiredDuringSchedulingIgnoredDuringExecution?: {
                      labelSelector?: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchLabels?: {
                          [key: string]: unknown;
                        };
                      };
                      matchLabelKeys?: string[];
                      mismatchLabelKeys?: string[];
                      namespaceSelector?: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchLabels?: {
                          [key: string]: unknown;
                        };
                      };
                      namespaces?: string[];
                      topologyKey: string;
                    }[];
                  };
                  podAntiAffinity?: {
                    preferredDuringSchedulingIgnoredDuringExecution?: {
                      podAffinityTerm: {
                        labelSelector?: {
                          matchExpressions?: {
                            key: string;
                            operator: string;
                            values?: string[];
                          }[];
                          matchLabels?: {
                            [key: string]: unknown;
                          };
                        };
                        matchLabelKeys?: string[];
                        mismatchLabelKeys?: string[];
                        namespaceSelector?: {
                          matchExpressions?: {
                            key: string;
                            operator: string;
                            values?: string[];
                          }[];
                          matchLabels?: {
                            [key: string]: unknown;
                          };
                        };
                        namespaces?: string[];
                        topologyKey: string;
                      };
                      weight: number;
                    }[];
                    requiredDuringSchedulingIgnoredDuringExecution?: {
                      labelSelector?: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchLabels?: {
                          [key: string]: unknown;
                        };
                      };
                      matchLabelKeys?: string[];
                      mismatchLabelKeys?: string[];
                      namespaceSelector?: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchLabels?: {
                          [key: string]: unknown;
                        };
                      };
                      namespaces?: string[];
                      topologyKey: string;
                    }[];
                  };
                };
                imagePullSecrets?: {
                  name?: string;
                }[];
                nodeSelector?: {
                  [key: string]: unknown;
                };
                priorityClassName?: string;
                securityContext?: {
                  fsGroup?: number;
                  fsGroupChangePolicy?: string;
                  runAsGroup?: number;
                  runAsNonRoot?: boolean;
                  runAsUser?: number;
                  seLinuxOptions?: {
                    level?: string;
                    role?: string;
                    type?: string;
                    user?: string;
                  };
                  seccompProfile?: {
                    localhostProfile?: string;
                    type: string;
                  };
                  supplementalGroups?: number[];
                  sysctls?: {
                    name: string;
                    value: string;
                  }[];
                };
                serviceAccountName?: string;
                tolerations?: {
                  effect?: string;
                  key?: string;
                  operator?: string;
                  tolerationSeconds?: number;
                  value?: string;
                }[];
              };
            };
            serviceType?: string;
          };
          ingress?: {
            class?: string;
            ingressClassName?: string;
            ingressTemplate?: {
              metadata?: {
                annotations?: {
                  [key: string]: unknown;
                };
                labels?: {
                  [key: string]: unknown;
                };
              };
            };
            name?: string;
            podTemplate?: {
              metadata?: {
                annotations?: {
                  [key: string]: unknown;
                };
                labels?: {
                  [key: string]: unknown;
                };
              };
              spec?: {
                affinity?: {
                  nodeAffinity?: {
                    preferredDuringSchedulingIgnoredDuringExecution?: {
                      preference: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchFields?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                      };
                      weight: number;
                    }[];
                    requiredDuringSchedulingIgnoredDuringExecution?: {
                      nodeSelectorTerms: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchFields?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                      }[];
                    };
                  };
                  podAffinity?: {
                    preferredDuringSchedulingIgnoredDuringExecution?: {
                      podAffinityTerm: {
                        labelSelector?: {
                          matchExpressions?: {
                            key: string;
                            operator: string;
                            values?: string[];
                          }[];
                          matchLabels?: {
                            [key: string]: unknown;
                          };
                        };
                        matchLabelKeys?: string[];
                        mismatchLabelKeys?: string[];
                        namespaceSelector?: {
                          matchExpressions?: {
                            key: string;
                            operator: string;
                            values?: string[];
                          }[];
                          matchLabels?: {
                            [key: string]: unknown;
                          };
                        };
                        namespaces?: string[];
                        topologyKey: string;
                      };
                      weight: number;
                    }[];
                    requiredDuringSchedulingIgnoredDuringExecution?: {
                      labelSelector?: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchLabels?: {
                          [key: string]: unknown;
                        };
                      };
                      matchLabelKeys?: string[];
                      mismatchLabelKeys?: string[];
                      namespaceSelector?: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchLabels?: {
                          [key: string]: unknown;
                        };
                      };
                      namespaces?: string[];
                      topologyKey: string;
                    }[];
                  };
                  podAntiAffinity?: {
                    preferredDuringSchedulingIgnoredDuringExecution?: {
                      podAffinityTerm: {
                        labelSelector?: {
                          matchExpressions?: {
                            key: string;
                            operator: string;
                            values?: string[];
                          }[];
                          matchLabels?: {
                            [key: string]: unknown;
                          };
                        };
                        matchLabelKeys?: string[];
                        mismatchLabelKeys?: string[];
                        namespaceSelector?: {
                          matchExpressions?: {
                            key: string;
                            operator: string;
                            values?: string[];
                          }[];
                          matchLabels?: {
                            [key: string]: unknown;
                          };
                        };
                        namespaces?: string[];
                        topologyKey: string;
                      };
                      weight: number;
                    }[];
                    requiredDuringSchedulingIgnoredDuringExecution?: {
                      labelSelector?: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchLabels?: {
                          [key: string]: unknown;
                        };
                      };
                      matchLabelKeys?: string[];
                      mismatchLabelKeys?: string[];
                      namespaceSelector?: {
                        matchExpressions?: {
                          key: string;
                          operator: string;
                          values?: string[];
                        }[];
                        matchLabels?: {
                          [key: string]: unknown;
                        };
                      };
                      namespaces?: string[];
                      topologyKey: string;
                    }[];
                  };
                };
                imagePullSecrets?: {
                  name?: string;
                }[];
                nodeSelector?: {
                  [key: string]: unknown;
                };
                priorityClassName?: string;
                securityContext?: {
                  fsGroup?: number;
                  fsGroupChangePolicy?: string;
                  runAsGroup?: number;
                  runAsNonRoot?: boolean;
                  runAsUser?: number;
                  seLinuxOptions?: {
                    level?: string;
                    role?: string;
                    type?: string;
                    user?: string;
                  };
                  seccompProfile?: {
                    localhostProfile?: string;
                    type: string;
                  };
                  supplementalGroups?: number[];
                  sysctls?: {
                    name: string;
                    value: string;
                  }[];
                };
                serviceAccountName?: string;
                tolerations?: {
                  effect?: string;
                  key?: string;
                  operator?: string;
                  tolerationSeconds?: number;
                  value?: string;
                }[];
              };
            };
            serviceType?: string;
          };
        };
        selector?: {
          dnsNames?: string[];
          dnsZones?: string[];
          matchLabels?: {
            [key: string]: unknown;
          };
        };
      }[];
    };
    ca?: {
      crlDistributionPoints?: string[];
      issuingCertificateURLs?: string[];
      ocspServers?: string[];
      secretName: string;
    };
    selfSigned?: {
      crlDistributionPoints?: string[];
    };
    vault?: {
      auth: {
        appRole?: {
          path: string;
          roleId: string;
          secretRef: {
            key?: string;
            name: string;
          };
        };
        clientCertificate?: {
          mountPath?: string;
          name?: string;
          secretName?: string;
        };
        kubernetes?: {
          mountPath?: string;
          role: string;
          secretRef?: {
            key?: string;
            name: string;
          };
          serviceAccountRef?: {
            audiences?: string[];
            name: string;
          };
        };
        tokenSecretRef?: {
          key?: string;
          name: string;
        };
      };
      caBundle?: string;
      caBundleSecretRef?: {
        key?: string;
        name: string;
      };
      clientCertSecretRef?: {
        key?: string;
        name: string;
      };
      clientKeySecretRef?: {
        key?: string;
        name: string;
      };
      namespace?: string;
      path: string;
      server: string;
    };
    venafi?: {
      cloud?: {
        apiTokenSecretRef: {
          key?: string;
          name: string;
        };
        url?: string;
      };
      tpp?: {
        caBundle?: string;
        caBundleSecretRef?: {
          key?: string;
          name: string;
        };
        credentialsRef: {
          name: string;
        };
        url: string;
      };
      zone: string;
    };
  };
  status?: {
    acme?: {
      lastPrivateKeyHash?: string;
      lastRegisteredEmail?: string;
      uri?: string;
    };
    conditions?: {
      lastTransitionTime?: string;
      message?: string;
      observedGeneration?: number;
      reason?: string;
      status: "True" | "False" | "Unknown";
      type: string;
    }[];
  };
}
/* io.cert-manager.v1.IssuerList */
/* IssuerList is a list of Issuer */
export interface CertManagerIoV1IssuerList {
  apiVersion?: string;
  items: CertManagerIoV1Issuer[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.cnpg.postgresql.v1.Backup */
/* A Backup resource is a request for a PostgreSQL backup by the user. */
export interface PostgresqlCnpgIoV1Backup {
  apiVersion?: string;
  kind?: string;
  metadata: ObjectMeta;
  spec: {
    cluster: {
      name: string;
    };
    method?: "barmanObjectStore" | "volumeSnapshot" | "plugin";
    online?: boolean;
    onlineConfiguration?: {
      immediateCheckpoint?: boolean;
      waitForArchive?: boolean;
    };
    pluginConfiguration?: {
      name: string;
      parameters?: {
        [key: string]: unknown;
      };
    };
    target?: "primary" | "prefer-standby";
  };
  status?: {
    azureCredentials?: {
      connectionString?: {
        key: string;
        name: string;
      };
      inheritFromAzureAD?: boolean;
      storageAccount?: {
        key: string;
        name: string;
      };
      storageKey?: {
        key: string;
        name: string;
      };
      storageSasToken?: {
        key: string;
        name: string;
      };
    };
    backupId?: string;
    backupLabelFile?: string;
    backupName?: string;
    beginLSN?: string;
    beginWal?: string;
    commandError?: string;
    commandOutput?: string;
    destinationPath?: string;
    encryption?: string;
    endLSN?: string;
    endWal?: string;
    endpointCA?: {
      key: string;
      name: string;
    };
    endpointURL?: string;
    error?: string;
    googleCredentials?: {
      applicationCredentials?: {
        key: string;
        name: string;
      };
      gkeEnvironment?: boolean;
    };
    instanceID?: {
      ContainerID?: string;
      podName?: string;
    };
    method?: string;
    online?: boolean;
    phase?: string;
    pluginMetadata?: {
      [key: string]: unknown;
    };
    s3Credentials?: {
      accessKeyId?: {
        key: string;
        name: string;
      };
      inheritFromIAMRole?: boolean;
      region?: {
        key: string;
        name: string;
      };
      secretAccessKey?: {
        key: string;
        name: string;
      };
      sessionToken?: {
        key: string;
        name: string;
      };
    };
    serverName?: string;
    snapshotBackupStatus?: {
      elements?: {
        name: string;
        tablespaceName?: string;
        type: string;
      }[];
    };
    startedAt?: string;
    stoppedAt?: string;
    tablespaceMapFile?: string;
  };
}
/* io.cnpg.postgresql.v1.BackupList */
/* BackupList is a list of Backup */
export interface PostgresqlCnpgIoV1BackupList {
  apiVersion?: string;
  items: PostgresqlCnpgIoV1Backup[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.cnpg.postgresql.v1.Cluster */
/* Cluster is the Schema for the PostgreSQL API */
export interface PostgresqlCnpgIoV1Cluster {
  apiVersion?: string;
  kind?: string;
  metadata: ObjectMeta;
  spec: {
    affinity?: {
      additionalPodAffinity?: {
        preferredDuringSchedulingIgnoredDuringExecution?: {
          podAffinityTerm: {
            labelSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            matchLabelKeys?: string[];
            mismatchLabelKeys?: string[];
            namespaceSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            namespaces?: string[];
            topologyKey: string;
          };
          weight: number;
        }[];
        requiredDuringSchedulingIgnoredDuringExecution?: {
          labelSelector?: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchLabels?: {
              [key: string]: unknown;
            };
          };
          matchLabelKeys?: string[];
          mismatchLabelKeys?: string[];
          namespaceSelector?: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchLabels?: {
              [key: string]: unknown;
            };
          };
          namespaces?: string[];
          topologyKey: string;
        }[];
      };
      additionalPodAntiAffinity?: {
        preferredDuringSchedulingIgnoredDuringExecution?: {
          podAffinityTerm: {
            labelSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            matchLabelKeys?: string[];
            mismatchLabelKeys?: string[];
            namespaceSelector?: {
              matchExpressions?: {
                key: string;
                operator: string;
                values?: string[];
              }[];
              matchLabels?: {
                [key: string]: unknown;
              };
            };
            namespaces?: string[];
            topologyKey: string;
          };
          weight: number;
        }[];
        requiredDuringSchedulingIgnoredDuringExecution?: {
          labelSelector?: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchLabels?: {
              [key: string]: unknown;
            };
          };
          matchLabelKeys?: string[];
          mismatchLabelKeys?: string[];
          namespaceSelector?: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchLabels?: {
              [key: string]: unknown;
            };
          };
          namespaces?: string[];
          topologyKey: string;
        }[];
      };
      enablePodAntiAffinity?: boolean;
      nodeAffinity?: {
        preferredDuringSchedulingIgnoredDuringExecution?: {
          preference: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchFields?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
          };
          weight: number;
        }[];
        requiredDuringSchedulingIgnoredDuringExecution?: {
          nodeSelectorTerms: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchFields?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
          }[];
        };
      };
      nodeSelector?: {
        [key: string]: unknown;
      };
      podAntiAffinityType?: string;
      tolerations?: {
        effect?: string;
        key?: string;
        operator?: string;
        tolerationSeconds?: number;
        value?: string;
      }[];
      topologyKey?: string;
    };
    backup?: {
      barmanObjectStore?: {
        azureCredentials?: {
          connectionString?: {
            key: string;
            name: string;
          };
          inheritFromAzureAD?: boolean;
          storageAccount?: {
            key: string;
            name: string;
          };
          storageKey?: {
            key: string;
            name: string;
          };
          storageSasToken?: {
            key: string;
            name: string;
          };
        };
        data?: {
          additionalCommandArgs?: string[];
          compression?: "bzip2" | "gzip" | "snappy";
          encryption?: "AES256" | "aws:kms";
          immediateCheckpoint?: boolean;
          jobs?: number;
        };
        destinationPath: string;
        endpointCA?: {
          key: string;
          name: string;
        };
        endpointURL?: string;
        googleCredentials?: {
          applicationCredentials?: {
            key: string;
            name: string;
          };
          gkeEnvironment?: boolean;
        };
        historyTags?: {
          [key: string]: unknown;
        };
        s3Credentials?: {
          accessKeyId?: {
            key: string;
            name: string;
          };
          inheritFromIAMRole?: boolean;
          region?: {
            key: string;
            name: string;
          };
          secretAccessKey?: {
            key: string;
            name: string;
          };
          sessionToken?: {
            key: string;
            name: string;
          };
        };
        serverName?: string;
        tags?: {
          [key: string]: unknown;
        };
        wal?: {
          archiveAdditionalCommandArgs?: string[];
          compression?: "bzip2" | "gzip" | "lz4" | "snappy" | "xz" | "zstd";
          encryption?: "AES256" | "aws:kms";
          maxParallel?: number;
          restoreAdditionalCommandArgs?: string[];
        };
      };
      retentionPolicy?: string;
      target?: "primary" | "prefer-standby";
      volumeSnapshot?: {
        annotations?: {
          [key: string]: unknown;
        };
        className?: string;
        labels?: {
          [key: string]: unknown;
        };
        online?: boolean;
        onlineConfiguration?: {
          immediateCheckpoint?: boolean;
          waitForArchive?: boolean;
        };
        snapshotOwnerReference?: "none" | "cluster" | "backup";
        tablespaceClassName?: {
          [key: string]: unknown;
        };
        walClassName?: string;
      };
    };
    bootstrap?: {
      initdb?: {
        builtinLocale?: string;
        dataChecksums?: boolean;
        database?: string;
        encoding?: string;
        icuLocale?: string;
        icuRules?: string;
        import?: {
          databases: string[];
          pgDumpExtraOptions?: string[];
          pgRestoreExtraOptions?: string[];
          postImportApplicationSQL?: string[];
          roles?: string[];
          schemaOnly?: boolean;
          source: {
            externalCluster: string;
          };
          type: "microservice" | "monolith";
        };
        locale?: string;
        localeCType?: string;
        localeCollate?: string;
        localeProvider?: string;
        options?: string[];
        owner?: string;
        postInitApplicationSQL?: string[];
        postInitApplicationSQLRefs?: {
          configMapRefs?: {
            key: string;
            name: string;
          }[];
          secretRefs?: {
            key: string;
            name: string;
          }[];
        };
        postInitSQL?: string[];
        postInitSQLRefs?: {
          configMapRefs?: {
            key: string;
            name: string;
          }[];
          secretRefs?: {
            key: string;
            name: string;
          }[];
        };
        postInitTemplateSQL?: string[];
        postInitTemplateSQLRefs?: {
          configMapRefs?: {
            key: string;
            name: string;
          }[];
          secretRefs?: {
            key: string;
            name: string;
          }[];
        };
        secret?: {
          name: string;
        };
        walSegmentSize?: number;
      };
      pg_basebackup?: {
        database?: string;
        owner?: string;
        secret?: {
          name: string;
        };
        source: string;
      };
      recovery?: {
        backup?: {
          endpointCA?: {
            key: string;
            name: string;
          };
          name: string;
        };
        database?: string;
        owner?: string;
        recoveryTarget?: {
          backupID?: string;
          exclusive?: boolean;
          targetImmediate?: boolean;
          targetLSN?: string;
          targetName?: string;
          targetTLI?: string;
          targetTime?: string;
          targetXID?: string;
        };
        secret?: {
          name: string;
        };
        source?: string;
        volumeSnapshots?: {
          storage: {
            apiGroup?: string;
            kind: string;
            name: string;
          };
          tablespaceStorage?: {
            [key: string]: unknown;
          };
          walStorage?: {
            apiGroup?: string;
            kind: string;
            name: string;
          };
        };
      };
    };
    certificates?: {
      clientCASecret?: string;
      replicationTLSSecret?: string;
      serverAltDNSNames?: string[];
      serverCASecret?: string;
      serverTLSSecret?: string;
    };
    description?: string;
    enablePDB?: boolean;
    enableSuperuserAccess?: boolean;
    env?: {
      name: string;
      value?: string;
      valueFrom?: {
        configMapKeyRef?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
        fieldRef?: {
          apiVersion?: string;
          fieldPath: string;
        };
        resourceFieldRef?: {
          containerName?: string;
          divisor?: any;
          resource: string;
        };
        secretKeyRef?: {
          key: string;
          name?: string;
          optional?: boolean;
        };
      };
    }[];
    envFrom?: {
      configMapRef?: {
        name?: string;
        optional?: boolean;
      };
      prefix?: string;
      secretRef?: {
        name?: string;
        optional?: boolean;
      };
    }[];
    ephemeralVolumeSource?: {
      volumeClaimTemplate?: {
        metadata?: {
          [key: string]: unknown;
        };
        spec: {
          accessModes?: string[];
          dataSource?: {
            apiGroup?: string;
            kind: string;
            name: string;
          };
          dataSourceRef?: {
            apiGroup?: string;
            kind: string;
            name: string;
            namespace?: string;
          };
          resources?: {
            limits?: {
              [key: string]: unknown;
            };
            requests?: {
              [key: string]: unknown;
            };
          };
          selector?: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchLabels?: {
              [key: string]: unknown;
            };
          };
          storageClassName?: string;
          volumeAttributesClassName?: string;
          volumeMode?: string;
          volumeName?: string;
        };
      };
    };
    ephemeralVolumesSizeLimit?: {
      shm?: any;
      temporaryData?: any;
    };
    externalClusters?: {
      barmanObjectStore?: {
        azureCredentials?: {
          connectionString?: {
            key: string;
            name: string;
          };
          inheritFromAzureAD?: boolean;
          storageAccount?: {
            key: string;
            name: string;
          };
          storageKey?: {
            key: string;
            name: string;
          };
          storageSasToken?: {
            key: string;
            name: string;
          };
        };
        data?: {
          additionalCommandArgs?: string[];
          compression?: "bzip2" | "gzip" | "snappy";
          encryption?: "AES256" | "aws:kms";
          immediateCheckpoint?: boolean;
          jobs?: number;
        };
        destinationPath: string;
        endpointCA?: {
          key: string;
          name: string;
        };
        endpointURL?: string;
        googleCredentials?: {
          applicationCredentials?: {
            key: string;
            name: string;
          };
          gkeEnvironment?: boolean;
        };
        historyTags?: {
          [key: string]: unknown;
        };
        s3Credentials?: {
          accessKeyId?: {
            key: string;
            name: string;
          };
          inheritFromIAMRole?: boolean;
          region?: {
            key: string;
            name: string;
          };
          secretAccessKey?: {
            key: string;
            name: string;
          };
          sessionToken?: {
            key: string;
            name: string;
          };
        };
        serverName?: string;
        tags?: {
          [key: string]: unknown;
        };
        wal?: {
          archiveAdditionalCommandArgs?: string[];
          compression?: "bzip2" | "gzip" | "lz4" | "snappy" | "xz" | "zstd";
          encryption?: "AES256" | "aws:kms";
          maxParallel?: number;
          restoreAdditionalCommandArgs?: string[];
        };
      };
      connectionParameters?: {
        [key: string]: unknown;
      };
      name: string;
      password?: {
        key: string;
        name?: string;
        optional?: boolean;
      };
      plugin?: {
        enabled?: boolean;
        isWALArchiver?: boolean;
        name: string;
        parameters?: {
          [key: string]: unknown;
        };
      };
      sslCert?: {
        key: string;
        name?: string;
        optional?: boolean;
      };
      sslKey?: {
        key: string;
        name?: string;
        optional?: boolean;
      };
      sslRootCert?: {
        key: string;
        name?: string;
        optional?: boolean;
      };
    }[];
    failoverDelay?: number;
    imageCatalogRef?: {
      apiGroup?: string;
      kind: string;
      major: number;
      name: string;
    };
    imageName?: string;
    imagePullPolicy?: string;
    imagePullSecrets?: {
      name: string;
    }[];
    inheritedMetadata?: {
      annotations?: {
        [key: string]: unknown;
      };
      labels?: {
        [key: string]: unknown;
      };
    };
    instances: number;
    livenessProbeTimeout?: number;
    logLevel?: "error" | "warning" | "info" | "debug" | "trace";
    managed?: {
      roles?: {
        bypassrls?: boolean;
        comment?: string;
        connectionLimit?: number;
        createdb?: boolean;
        createrole?: boolean;
        disablePassword?: boolean;
        ensure?: "present" | "absent";
        inRoles?: string[];
        inherit?: boolean;
        login?: boolean;
        name: string;
        passwordSecret?: {
          name: string;
        };
        replication?: boolean;
        superuser?: boolean;
        validUntil?: string;
      }[];
      services?: {
        additional?: {
          selectorType: "rw" | "r" | "ro";
          serviceTemplate: {
            metadata?: {
              annotations?: {
                [key: string]: unknown;
              };
              labels?: {
                [key: string]: unknown;
              };
              name?: string;
            };
            spec?: {
              allocateLoadBalancerNodePorts?: boolean;
              clusterIP?: string;
              clusterIPs?: string[];
              externalIPs?: string[];
              externalName?: string;
              externalTrafficPolicy?: string;
              healthCheckNodePort?: number;
              internalTrafficPolicy?: string;
              ipFamilies?: string[];
              ipFamilyPolicy?: string;
              loadBalancerClass?: string;
              loadBalancerIP?: string;
              loadBalancerSourceRanges?: string[];
              ports?: {
                appProtocol?: string;
                name?: string;
                nodePort?: number;
                port: number;
                protocol?: string;
                targetPort?: any;
              }[];
              publishNotReadyAddresses?: boolean;
              selector?: {
                [key: string]: unknown;
              };
              sessionAffinity?: string;
              sessionAffinityConfig?: {
                clientIP?: {
                  timeoutSeconds?: number;
                };
              };
              trafficDistribution?: string;
              type?: string;
            };
          };
          updateStrategy?: "patch" | "replace";
        }[];
        disabledDefaultServices?: ("rw" | "r" | "ro")[];
      };
    };
    maxSyncReplicas?: number;
    minSyncReplicas?: number;
    monitoring?: {
      customQueriesConfigMap?: {
        key: string;
        name: string;
      }[];
      customQueriesSecret?: {
        key: string;
        name: string;
      }[];
      disableDefaultQueries?: boolean;
      enablePodMonitor?: boolean;
      podMonitorMetricRelabelings?: {
        action?: "replace" | "Replace" | "keep" | "Keep" | "drop" | "Drop" | "hashmod" | "HashMod" | "labelmap" | "LabelMap" | "labeldrop" | "LabelDrop" | "labelkeep" | "LabelKeep" | "lowercase" | "Lowercase" | "uppercase" | "Uppercase" | "keepequal" | "KeepEqual" | "dropequal" | "DropEqual";
        modulus?: number;
        regex?: string;
        replacement?: string;
        separator?: string;
        sourceLabels?: string[];
        targetLabel?: string;
      }[];
      podMonitorRelabelings?: {
        action?: "replace" | "Replace" | "keep" | "Keep" | "drop" | "Drop" | "hashmod" | "HashMod" | "labelmap" | "LabelMap" | "labeldrop" | "LabelDrop" | "labelkeep" | "LabelKeep" | "lowercase" | "Lowercase" | "uppercase" | "Uppercase" | "keepequal" | "KeepEqual" | "dropequal" | "DropEqual";
        modulus?: number;
        regex?: string;
        replacement?: string;
        separator?: string;
        sourceLabels?: string[];
        targetLabel?: string;
      }[];
      tls?: {
        enabled?: boolean;
      };
    };
    nodeMaintenanceWindow?: {
      inProgress?: boolean;
      reusePVC?: boolean;
    };
    plugins?: {
      enabled?: boolean;
      isWALArchiver?: boolean;
      name: string;
      parameters?: {
        [key: string]: unknown;
      };
    }[];
    postgresGID?: number;
    postgresUID?: number;
    postgresql?: {
      enableAlterSystem?: boolean;
      ldap?: {
        bindAsAuth?: {
          prefix?: string;
          suffix?: string;
        };
        bindSearchAuth?: {
          baseDN?: string;
          bindDN?: string;
          bindPassword?: {
            key: string;
            name?: string;
            optional?: boolean;
          };
          searchAttribute?: string;
          searchFilter?: string;
        };
        port?: number;
        scheme?: "ldap" | "ldaps";
        server?: string;
        tls?: boolean;
      };
      parameters?: {
        [key: string]: unknown;
      };
      pg_hba?: string[];
      pg_ident?: string[];
      promotionTimeout?: number;
      shared_preload_libraries?: string[];
      syncReplicaElectionConstraint?: {
        enabled: boolean;
        nodeLabelsAntiAffinity?: string[];
      };
      synchronous?: {
        dataDurability?: "required" | "preferred";
        maxStandbyNamesFromCluster?: number;
        method: "any" | "first";
        number: number;
        standbyNamesPost?: string[];
        standbyNamesPre?: string[];
      };
    };
    primaryUpdateMethod?: "switchover" | "restart";
    primaryUpdateStrategy?: "unsupervised" | "supervised";
    priorityClassName?: string;
    probes?: {
      liveness?: {
        failureThreshold?: number;
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        terminationGracePeriodSeconds?: number;
        timeoutSeconds?: number;
      };
      readiness?: {
        failureThreshold?: number;
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        terminationGracePeriodSeconds?: number;
        timeoutSeconds?: number;
      };
      startup?: {
        failureThreshold?: number;
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        terminationGracePeriodSeconds?: number;
        timeoutSeconds?: number;
      };
    };
    projectedVolumeTemplate?: {
      defaultMode?: number;
      sources?: {
        clusterTrustBundle?: {
          labelSelector?: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchLabels?: {
              [key: string]: unknown;
            };
          };
          name?: string;
          optional?: boolean;
          path: string;
          signerName?: string;
        };
        configMap?: {
          items?: {
            key: string;
            mode?: number;
            path: string;
          }[];
          name?: string;
          optional?: boolean;
        };
        downwardAPI?: {
          items?: {
            fieldRef?: {
              apiVersion?: string;
              fieldPath: string;
            };
            mode?: number;
            path: string;
            resourceFieldRef?: {
              containerName?: string;
              divisor?: any;
              resource: string;
            };
          }[];
        };
        secret?: {
          items?: {
            key: string;
            mode?: number;
            path: string;
          }[];
          name?: string;
          optional?: boolean;
        };
        serviceAccountToken?: {
          audience?: string;
          expirationSeconds?: number;
          path: string;
        };
      }[];
    };
    replica?: {
      enabled?: boolean;
      minApplyDelay?: string;
      primary?: string;
      promotionToken?: string;
      self?: string;
      source: string;
    };
    replicationSlots?: {
      highAvailability?: {
        enabled?: boolean;
        slotPrefix?: string;
      };
      synchronizeReplicas?: {
        enabled: boolean;
        excludePatterns?: string[];
      };
      updateInterval?: number;
    };
    resources?: {
      claims?: {
        name: string;
        request?: string;
      }[];
      limits?: {
        [key: string]: unknown;
      };
      requests?: {
        [key: string]: unknown;
      };
    };
    schedulerName?: string;
    seccompProfile?: {
      localhostProfile?: string;
      type: string;
    };
    serviceAccountTemplate?: {
      metadata: {
        annotations?: {
          [key: string]: unknown;
        };
        labels?: {
          [key: string]: unknown;
        };
        name?: string;
      };
    };
    smartShutdownTimeout?: number;
    startDelay?: number;
    stopDelay?: number;
    storage?: {
      pvcTemplate?: {
        accessModes?: string[];
        dataSource?: {
          apiGroup?: string;
          kind: string;
          name: string;
        };
        dataSourceRef?: {
          apiGroup?: string;
          kind: string;
          name: string;
          namespace?: string;
        };
        resources?: {
          limits?: {
            [key: string]: unknown;
          };
          requests?: {
            [key: string]: unknown;
          };
        };
        selector?: {
          matchExpressions?: {
            key: string;
            operator: string;
            values?: string[];
          }[];
          matchLabels?: {
            [key: string]: unknown;
          };
        };
        storageClassName?: string;
        volumeAttributesClassName?: string;
        volumeMode?: string;
        volumeName?: string;
      };
      resizeInUseVolumes?: boolean;
      size?: string;
      storageClass?: string;
    };
    superuserSecret?: {
      name: string;
    };
    switchoverDelay?: number;
    tablespaces?: {
      name: string;
      owner?: {
        name?: string;
      };
      storage: {
        pvcTemplate?: {
          accessModes?: string[];
          dataSource?: {
            apiGroup?: string;
            kind: string;
            name: string;
          };
          dataSourceRef?: {
            apiGroup?: string;
            kind: string;
            name: string;
            namespace?: string;
          };
          resources?: {
            limits?: {
              [key: string]: unknown;
            };
            requests?: {
              [key: string]: unknown;
            };
          };
          selector?: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchLabels?: {
              [key: string]: unknown;
            };
          };
          storageClassName?: string;
          volumeAttributesClassName?: string;
          volumeMode?: string;
          volumeName?: string;
        };
        resizeInUseVolumes?: boolean;
        size?: string;
        storageClass?: string;
      };
      temporary?: boolean;
    }[];
    topologySpreadConstraints?: {
      labelSelector?: {
        matchExpressions?: {
          key: string;
          operator: string;
          values?: string[];
        }[];
        matchLabels?: {
          [key: string]: unknown;
        };
      };
      matchLabelKeys?: string[];
      maxSkew: number;
      minDomains?: number;
      nodeAffinityPolicy?: string;
      nodeTaintsPolicy?: string;
      topologyKey: string;
      whenUnsatisfiable: string;
    }[];
    walStorage?: {
      pvcTemplate?: {
        accessModes?: string[];
        dataSource?: {
          apiGroup?: string;
          kind: string;
          name: string;
        };
        dataSourceRef?: {
          apiGroup?: string;
          kind: string;
          name: string;
          namespace?: string;
        };
        resources?: {
          limits?: {
            [key: string]: unknown;
          };
          requests?: {
            [key: string]: unknown;
          };
        };
        selector?: {
          matchExpressions?: {
            key: string;
            operator: string;
            values?: string[];
          }[];
          matchLabels?: {
            [key: string]: unknown;
          };
        };
        storageClassName?: string;
        volumeAttributesClassName?: string;
        volumeMode?: string;
        volumeName?: string;
      };
      resizeInUseVolumes?: boolean;
      size?: string;
      storageClass?: string;
    };
  };
  status?: {
    availableArchitectures?: {
      goArch: string;
      hash: string;
    }[];
    azurePVCUpdateEnabled?: boolean;
    certificates?: {
      clientCASecret?: string;
      expirations?: {
        [key: string]: unknown;
      };
      replicationTLSSecret?: string;
      serverAltDNSNames?: string[];
      serverCASecret?: string;
      serverTLSSecret?: string;
    };
    cloudNativePGCommitHash?: string;
    cloudNativePGOperatorHash?: string;
    conditions?: {
      lastTransitionTime: string;
      message: string;
      observedGeneration?: number;
      reason: string;
      status: "True" | "False" | "Unknown";
      type: string;
    }[];
    configMapResourceVersion?: {
      metrics?: {
        [key: string]: unknown;
      };
    };
    currentPrimary?: string;
    currentPrimaryFailingSinceTimestamp?: string;
    currentPrimaryTimestamp?: string;
    danglingPVC?: string[];
    demotionToken?: string;
    firstRecoverabilityPoint?: string;
    firstRecoverabilityPointByMethod?: {
      [key: string]: unknown;
    };
    healthyPVC?: string[];
    image?: string;
    initializingPVC?: string[];
    instanceNames?: string[];
    instances?: number;
    instancesReportedState?: {
      [key: string]: unknown;
    };
    instancesStatus?: {
      [key: string]: unknown;
    };
    jobCount?: number;
    lastFailedBackup?: string;
    lastPromotionToken?: string;
    lastSuccessfulBackup?: string;
    lastSuccessfulBackupByMethod?: {
      [key: string]: unknown;
    };
    latestGeneratedNode?: number;
    managedRolesStatus?: {
      byStatus?: {
        [key: string]: unknown;
      };
      cannotReconcile?: {
        [key: string]: unknown;
      };
      passwordStatus?: {
        [key: string]: unknown;
      };
    };
    onlineUpdateEnabled?: boolean;
    phase?: string;
    phaseReason?: string;
    pluginStatus?: {
      backupCapabilities?: string[];
      capabilities?: string[];
      name: string;
      operatorCapabilities?: string[];
      restoreJobHookCapabilities?: string[];
      status?: string;
      version: string;
      walCapabilities?: string[];
    }[];
    poolerIntegrations?: {
      pgBouncerIntegration?: {
        secrets?: string[];
      };
    };
    pvcCount?: number;
    readService?: string;
    readyInstances?: number;
    resizingPVC?: string[];
    secretsResourceVersion?: {
      applicationSecretVersion?: string;
      barmanEndpointCA?: string;
      caSecretVersion?: string;
      clientCaSecretVersion?: string;
      externalClusterSecretVersion?: {
        [key: string]: unknown;
      };
      managedRoleSecretVersion?: {
        [key: string]: unknown;
      };
      metrics?: {
        [key: string]: unknown;
      };
      replicationSecretVersion?: string;
      serverCaSecretVersion?: string;
      serverSecretVersion?: string;
      superuserSecretVersion?: string;
    };
    switchReplicaClusterStatus?: {
      inProgress?: boolean;
    };
    tablespacesStatus?: {
      error?: string;
      name: string;
      owner?: string;
      state: string;
    }[];
    targetPrimary?: string;
    targetPrimaryTimestamp?: string;
    timelineID?: number;
    topology?: {
      instances?: {
        [key: string]: unknown;
      };
      nodesUsed?: number;
      successfullyExtracted?: boolean;
    };
    unusablePVC?: string[];
    writeService?: string;
  };
}
/* io.cnpg.postgresql.v1.ClusterImageCatalog */
/* ClusterImageCatalog is the Schema for the clusterimagecatalogs API */
export interface PostgresqlCnpgIoV1ClusterImageCatalog {
  apiVersion?: string;
  kind?: string;
  metadata: ObjectMeta;
  spec: {
    images: {
      image: string;
      major: number;
    }[];
  };
}
/* io.cnpg.postgresql.v1.ClusterImageCatalogList */
/* ClusterImageCatalogList is a list of ClusterImageCatalog */
export interface PostgresqlCnpgIoV1ClusterImageCatalogList {
  apiVersion?: string;
  items: PostgresqlCnpgIoV1ClusterImageCatalog[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.cnpg.postgresql.v1.ClusterList */
/* ClusterList is a list of Cluster */
export interface PostgresqlCnpgIoV1ClusterList {
  apiVersion?: string;
  items: PostgresqlCnpgIoV1Cluster[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.cnpg.postgresql.v1.Database */
/* Database is the Schema for the databases API */
export interface PostgresqlCnpgIoV1Database {
  apiVersion?: string;
  kind?: string;
  metadata: ObjectMeta;
  spec: {
    allowConnections?: boolean;
    builtinLocale?: string;
    cluster: {
      name?: string;
    };
    collationVersion?: string;
    connectionLimit?: number;
    databaseReclaimPolicy?: "delete" | "retain";
    encoding?: string;
    ensure?: "present" | "absent";
    icuLocale?: string;
    icuRules?: string;
    isTemplate?: boolean;
    locale?: string;
    localeCType?: string;
    localeCollate?: string;
    localeProvider?: string;
    name: string;
    owner: string;
    tablespace?: string;
    template?: string;
  };
  status?: {
    applied?: boolean;
    message?: string;
    observedGeneration?: number;
  };
}
/* io.cnpg.postgresql.v1.DatabaseList */
/* DatabaseList is a list of Database */
export interface PostgresqlCnpgIoV1DatabaseList {
  apiVersion?: string;
  items: PostgresqlCnpgIoV1Database[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.cnpg.postgresql.v1.ImageCatalog */
/* ImageCatalog is the Schema for the imagecatalogs API */
export interface PostgresqlCnpgIoV1ImageCatalog {
  apiVersion?: string;
  kind?: string;
  metadata: ObjectMeta;
  spec: {
    images: {
      image: string;
      major: number;
    }[];
  };
}
/* io.cnpg.postgresql.v1.ImageCatalogList */
/* ImageCatalogList is a list of ImageCatalog */
export interface PostgresqlCnpgIoV1ImageCatalogList {
  apiVersion?: string;
  items: PostgresqlCnpgIoV1ImageCatalog[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.cnpg.postgresql.v1.Pooler */
/* Pooler is the Schema for the poolers API */
export interface PostgresqlCnpgIoV1Pooler {
  apiVersion?: string;
  kind?: string;
  metadata: ObjectMeta;
  spec: {
    cluster: {
      name: string;
    };
    deploymentStrategy?: {
      rollingUpdate?: {
        maxSurge?: any;
        maxUnavailable?: any;
      };
      type?: string;
    };
    instances?: number;
    monitoring?: {
      enablePodMonitor?: boolean;
      podMonitorMetricRelabelings?: {
        action?: "replace" | "Replace" | "keep" | "Keep" | "drop" | "Drop" | "hashmod" | "HashMod" | "labelmap" | "LabelMap" | "labeldrop" | "LabelDrop" | "labelkeep" | "LabelKeep" | "lowercase" | "Lowercase" | "uppercase" | "Uppercase" | "keepequal" | "KeepEqual" | "dropequal" | "DropEqual";
        modulus?: number;
        regex?: string;
        replacement?: string;
        separator?: string;
        sourceLabels?: string[];
        targetLabel?: string;
      }[];
      podMonitorRelabelings?: {
        action?: "replace" | "Replace" | "keep" | "Keep" | "drop" | "Drop" | "hashmod" | "HashMod" | "labelmap" | "LabelMap" | "labeldrop" | "LabelDrop" | "labelkeep" | "LabelKeep" | "lowercase" | "Lowercase" | "uppercase" | "Uppercase" | "keepequal" | "KeepEqual" | "dropequal" | "DropEqual";
        modulus?: number;
        regex?: string;
        replacement?: string;
        separator?: string;
        sourceLabels?: string[];
        targetLabel?: string;
      }[];
    };
    pgbouncer: {
      authQuery?: string;
      authQuerySecret?: {
        name: string;
      };
      parameters?: {
        [key: string]: unknown;
      };
      paused?: boolean;
      pg_hba?: string[];
      poolMode?: "session" | "transaction";
    };
    serviceTemplate?: {
      metadata?: {
        annotations?: {
          [key: string]: unknown;
        };
        labels?: {
          [key: string]: unknown;
        };
        name?: string;
      };
      spec?: {
        allocateLoadBalancerNodePorts?: boolean;
        clusterIP?: string;
        clusterIPs?: string[];
        externalIPs?: string[];
        externalName?: string;
        externalTrafficPolicy?: string;
        healthCheckNodePort?: number;
        internalTrafficPolicy?: string;
        ipFamilies?: string[];
        ipFamilyPolicy?: string;
        loadBalancerClass?: string;
        loadBalancerIP?: string;
        loadBalancerSourceRanges?: string[];
        ports?: {
          appProtocol?: string;
          name?: string;
          nodePort?: number;
          port: number;
          protocol?: string;
          targetPort?: any;
        }[];
        publishNotReadyAddresses?: boolean;
        selector?: {
          [key: string]: unknown;
        };
        sessionAffinity?: string;
        sessionAffinityConfig?: {
          clientIP?: {
            timeoutSeconds?: number;
          };
        };
        trafficDistribution?: string;
        type?: string;
      };
    };
    template?: {
      metadata?: {
        annotations?: {
          [key: string]: unknown;
        };
        labels?: {
          [key: string]: unknown;
        };
        name?: string;
      };
      spec?: {
        activeDeadlineSeconds?: number;
        affinity?: {
          nodeAffinity?: {
            preferredDuringSchedulingIgnoredDuringExecution?: {
              preference: {
                matchExpressions?: {
                  key: string;
                  operator: string;
                  values?: string[];
                }[];
                matchFields?: {
                  key: string;
                  operator: string;
                  values?: string[];
                }[];
              };
              weight: number;
            }[];
            requiredDuringSchedulingIgnoredDuringExecution?: {
              nodeSelectorTerms: {
                matchExpressions?: {
                  key: string;
                  operator: string;
                  values?: string[];
                }[];
                matchFields?: {
                  key: string;
                  operator: string;
                  values?: string[];
                }[];
              }[];
            };
          };
          podAffinity?: {
            preferredDuringSchedulingIgnoredDuringExecution?: {
              podAffinityTerm: {
                labelSelector?: {
                  matchExpressions?: {
                    key: string;
                    operator: string;
                    values?: string[];
                  }[];
                  matchLabels?: {
                    [key: string]: unknown;
                  };
                };
                matchLabelKeys?: string[];
                mismatchLabelKeys?: string[];
                namespaceSelector?: {
                  matchExpressions?: {
                    key: string;
                    operator: string;
                    values?: string[];
                  }[];
                  matchLabels?: {
                    [key: string]: unknown;
                  };
                };
                namespaces?: string[];
                topologyKey: string;
              };
              weight: number;
            }[];
            requiredDuringSchedulingIgnoredDuringExecution?: {
              labelSelector?: {
                matchExpressions?: {
                  key: string;
                  operator: string;
                  values?: string[];
                }[];
                matchLabels?: {
                  [key: string]: unknown;
                };
              };
              matchLabelKeys?: string[];
              mismatchLabelKeys?: string[];
              namespaceSelector?: {
                matchExpressions?: {
                  key: string;
                  operator: string;
                  values?: string[];
                }[];
                matchLabels?: {
                  [key: string]: unknown;
                };
              };
              namespaces?: string[];
              topologyKey: string;
            }[];
          };
          podAntiAffinity?: {
            preferredDuringSchedulingIgnoredDuringExecution?: {
              podAffinityTerm: {
                labelSelector?: {
                  matchExpressions?: {
                    key: string;
                    operator: string;
                    values?: string[];
                  }[];
                  matchLabels?: {
                    [key: string]: unknown;
                  };
                };
                matchLabelKeys?: string[];
                mismatchLabelKeys?: string[];
                namespaceSelector?: {
                  matchExpressions?: {
                    key: string;
                    operator: string;
                    values?: string[];
                  }[];
                  matchLabels?: {
                    [key: string]: unknown;
                  };
                };
                namespaces?: string[];
                topologyKey: string;
              };
              weight: number;
            }[];
            requiredDuringSchedulingIgnoredDuringExecution?: {
              labelSelector?: {
                matchExpressions?: {
                  key: string;
                  operator: string;
                  values?: string[];
                }[];
                matchLabels?: {
                  [key: string]: unknown;
                };
              };
              matchLabelKeys?: string[];
              mismatchLabelKeys?: string[];
              namespaceSelector?: {
                matchExpressions?: {
                  key: string;
                  operator: string;
                  values?: string[];
                }[];
                matchLabels?: {
                  [key: string]: unknown;
                };
              };
              namespaces?: string[];
              topologyKey: string;
            }[];
          };
        };
        automountServiceAccountToken?: boolean;
        containers: {
          args?: string[];
          command?: string[];
          env?: {
            name: string;
            value?: string;
            valueFrom?: {
              configMapKeyRef?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              fieldRef?: {
                apiVersion?: string;
                fieldPath: string;
              };
              resourceFieldRef?: {
                containerName?: string;
                divisor?: any;
                resource: string;
              };
              secretKeyRef?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
          }[];
          envFrom?: {
            configMapRef?: {
              name?: string;
              optional?: boolean;
            };
            prefix?: string;
            secretRef?: {
              name?: string;
              optional?: boolean;
            };
          }[];
          image?: string;
          imagePullPolicy?: string;
          lifecycle?: {
            postStart?: {
              exec?: {
                command?: string[];
              };
              httpGet?: {
                host?: string;
                httpHeaders?: {
                  name: string;
                  value: string;
                }[];
                path?: string;
                port: any;
                scheme?: string;
              };
              sleep?: {
                seconds: number;
              };
              tcpSocket?: {
                host?: string;
                port: any;
              };
            };
            preStop?: {
              exec?: {
                command?: string[];
              };
              httpGet?: {
                host?: string;
                httpHeaders?: {
                  name: string;
                  value: string;
                }[];
                path?: string;
                port: any;
                scheme?: string;
              };
              sleep?: {
                seconds: number;
              };
              tcpSocket?: {
                host?: string;
                port: any;
              };
            };
          };
          livenessProbe?: {
            exec?: {
              command?: string[];
            };
            failureThreshold?: number;
            grpc?: {
              port: number;
              service?: string;
            };
            httpGet?: {
              host?: string;
              httpHeaders?: {
                name: string;
                value: string;
              }[];
              path?: string;
              port: any;
              scheme?: string;
            };
            initialDelaySeconds?: number;
            periodSeconds?: number;
            successThreshold?: number;
            tcpSocket?: {
              host?: string;
              port: any;
            };
            terminationGracePeriodSeconds?: number;
            timeoutSeconds?: number;
          };
          name: string;
          ports?: {
            containerPort: number;
            hostIP?: string;
            hostPort?: number;
            name?: string;
            protocol?: string;
          }[];
          readinessProbe?: {
            exec?: {
              command?: string[];
            };
            failureThreshold?: number;
            grpc?: {
              port: number;
              service?: string;
            };
            httpGet?: {
              host?: string;
              httpHeaders?: {
                name: string;
                value: string;
              }[];
              path?: string;
              port: any;
              scheme?: string;
            };
            initialDelaySeconds?: number;
            periodSeconds?: number;
            successThreshold?: number;
            tcpSocket?: {
              host?: string;
              port: any;
            };
            terminationGracePeriodSeconds?: number;
            timeoutSeconds?: number;
          };
          resizePolicy?: {
            resourceName: string;
            restartPolicy: string;
          }[];
          resources?: {
            claims?: {
              name: string;
              request?: string;
            }[];
            limits?: {
              [key: string]: unknown;
            };
            requests?: {
              [key: string]: unknown;
            };
          };
          restartPolicy?: string;
          securityContext?: {
            allowPrivilegeEscalation?: boolean;
            appArmorProfile?: {
              localhostProfile?: string;
              type: string;
            };
            capabilities?: {
              add?: string[];
              drop?: string[];
            };
            privileged?: boolean;
            procMount?: string;
            readOnlyRootFilesystem?: boolean;
            runAsGroup?: number;
            runAsNonRoot?: boolean;
            runAsUser?: number;
            seLinuxOptions?: {
              level?: string;
              role?: string;
              type?: string;
              user?: string;
            };
            seccompProfile?: {
              localhostProfile?: string;
              type: string;
            };
            windowsOptions?: {
              gmsaCredentialSpec?: string;
              gmsaCredentialSpecName?: string;
              hostProcess?: boolean;
              runAsUserName?: string;
            };
          };
          startupProbe?: {
            exec?: {
              command?: string[];
            };
            failureThreshold?: number;
            grpc?: {
              port: number;
              service?: string;
            };
            httpGet?: {
              host?: string;
              httpHeaders?: {
                name: string;
                value: string;
              }[];
              path?: string;
              port: any;
              scheme?: string;
            };
            initialDelaySeconds?: number;
            periodSeconds?: number;
            successThreshold?: number;
            tcpSocket?: {
              host?: string;
              port: any;
            };
            terminationGracePeriodSeconds?: number;
            timeoutSeconds?: number;
          };
          stdin?: boolean;
          stdinOnce?: boolean;
          terminationMessagePath?: string;
          terminationMessagePolicy?: string;
          tty?: boolean;
          volumeDevices?: {
            devicePath: string;
            name: string;
          }[];
          volumeMounts?: {
            mountPath: string;
            mountPropagation?: string;
            name: string;
            readOnly?: boolean;
            recursiveReadOnly?: string;
            subPath?: string;
            subPathExpr?: string;
          }[];
          workingDir?: string;
        }[];
        dnsConfig?: {
          nameservers?: string[];
          options?: {
            name?: string;
            value?: string;
          }[];
          searches?: string[];
        };
        dnsPolicy?: string;
        enableServiceLinks?: boolean;
        ephemeralContainers?: {
          args?: string[];
          command?: string[];
          env?: {
            name: string;
            value?: string;
            valueFrom?: {
              configMapKeyRef?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              fieldRef?: {
                apiVersion?: string;
                fieldPath: string;
              };
              resourceFieldRef?: {
                containerName?: string;
                divisor?: any;
                resource: string;
              };
              secretKeyRef?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
          }[];
          envFrom?: {
            configMapRef?: {
              name?: string;
              optional?: boolean;
            };
            prefix?: string;
            secretRef?: {
              name?: string;
              optional?: boolean;
            };
          }[];
          image?: string;
          imagePullPolicy?: string;
          lifecycle?: {
            postStart?: {
              exec?: {
                command?: string[];
              };
              httpGet?: {
                host?: string;
                httpHeaders?: {
                  name: string;
                  value: string;
                }[];
                path?: string;
                port: any;
                scheme?: string;
              };
              sleep?: {
                seconds: number;
              };
              tcpSocket?: {
                host?: string;
                port: any;
              };
            };
            preStop?: {
              exec?: {
                command?: string[];
              };
              httpGet?: {
                host?: string;
                httpHeaders?: {
                  name: string;
                  value: string;
                }[];
                path?: string;
                port: any;
                scheme?: string;
              };
              sleep?: {
                seconds: number;
              };
              tcpSocket?: {
                host?: string;
                port: any;
              };
            };
          };
          livenessProbe?: {
            exec?: {
              command?: string[];
            };
            failureThreshold?: number;
            grpc?: {
              port: number;
              service?: string;
            };
            httpGet?: {
              host?: string;
              httpHeaders?: {
                name: string;
                value: string;
              }[];
              path?: string;
              port: any;
              scheme?: string;
            };
            initialDelaySeconds?: number;
            periodSeconds?: number;
            successThreshold?: number;
            tcpSocket?: {
              host?: string;
              port: any;
            };
            terminationGracePeriodSeconds?: number;
            timeoutSeconds?: number;
          };
          name: string;
          ports?: {
            containerPort: number;
            hostIP?: string;
            hostPort?: number;
            name?: string;
            protocol?: string;
          }[];
          readinessProbe?: {
            exec?: {
              command?: string[];
            };
            failureThreshold?: number;
            grpc?: {
              port: number;
              service?: string;
            };
            httpGet?: {
              host?: string;
              httpHeaders?: {
                name: string;
                value: string;
              }[];
              path?: string;
              port: any;
              scheme?: string;
            };
            initialDelaySeconds?: number;
            periodSeconds?: number;
            successThreshold?: number;
            tcpSocket?: {
              host?: string;
              port: any;
            };
            terminationGracePeriodSeconds?: number;
            timeoutSeconds?: number;
          };
          resizePolicy?: {
            resourceName: string;
            restartPolicy: string;
          }[];
          resources?: {
            claims?: {
              name: string;
              request?: string;
            }[];
            limits?: {
              [key: string]: unknown;
            };
            requests?: {
              [key: string]: unknown;
            };
          };
          restartPolicy?: string;
          securityContext?: {
            allowPrivilegeEscalation?: boolean;
            appArmorProfile?: {
              localhostProfile?: string;
              type: string;
            };
            capabilities?: {
              add?: string[];
              drop?: string[];
            };
            privileged?: boolean;
            procMount?: string;
            readOnlyRootFilesystem?: boolean;
            runAsGroup?: number;
            runAsNonRoot?: boolean;
            runAsUser?: number;
            seLinuxOptions?: {
              level?: string;
              role?: string;
              type?: string;
              user?: string;
            };
            seccompProfile?: {
              localhostProfile?: string;
              type: string;
            };
            windowsOptions?: {
              gmsaCredentialSpec?: string;
              gmsaCredentialSpecName?: string;
              hostProcess?: boolean;
              runAsUserName?: string;
            };
          };
          startupProbe?: {
            exec?: {
              command?: string[];
            };
            failureThreshold?: number;
            grpc?: {
              port: number;
              service?: string;
            };
            httpGet?: {
              host?: string;
              httpHeaders?: {
                name: string;
                value: string;
              }[];
              path?: string;
              port: any;
              scheme?: string;
            };
            initialDelaySeconds?: number;
            periodSeconds?: number;
            successThreshold?: number;
            tcpSocket?: {
              host?: string;
              port: any;
            };
            terminationGracePeriodSeconds?: number;
            timeoutSeconds?: number;
          };
          stdin?: boolean;
          stdinOnce?: boolean;
          targetContainerName?: string;
          terminationMessagePath?: string;
          terminationMessagePolicy?: string;
          tty?: boolean;
          volumeDevices?: {
            devicePath: string;
            name: string;
          }[];
          volumeMounts?: {
            mountPath: string;
            mountPropagation?: string;
            name: string;
            readOnly?: boolean;
            recursiveReadOnly?: string;
            subPath?: string;
            subPathExpr?: string;
          }[];
          workingDir?: string;
        }[];
        hostAliases?: {
          hostnames?: string[];
          ip: string;
        }[];
        hostIPC?: boolean;
        hostNetwork?: boolean;
        hostPID?: boolean;
        hostUsers?: boolean;
        hostname?: string;
        imagePullSecrets?: {
          name?: string;
        }[];
        initContainers?: {
          args?: string[];
          command?: string[];
          env?: {
            name: string;
            value?: string;
            valueFrom?: {
              configMapKeyRef?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
              fieldRef?: {
                apiVersion?: string;
                fieldPath: string;
              };
              resourceFieldRef?: {
                containerName?: string;
                divisor?: any;
                resource: string;
              };
              secretKeyRef?: {
                key: string;
                name?: string;
                optional?: boolean;
              };
            };
          }[];
          envFrom?: {
            configMapRef?: {
              name?: string;
              optional?: boolean;
            };
            prefix?: string;
            secretRef?: {
              name?: string;
              optional?: boolean;
            };
          }[];
          image?: string;
          imagePullPolicy?: string;
          lifecycle?: {
            postStart?: {
              exec?: {
                command?: string[];
              };
              httpGet?: {
                host?: string;
                httpHeaders?: {
                  name: string;
                  value: string;
                }[];
                path?: string;
                port: any;
                scheme?: string;
              };
              sleep?: {
                seconds: number;
              };
              tcpSocket?: {
                host?: string;
                port: any;
              };
            };
            preStop?: {
              exec?: {
                command?: string[];
              };
              httpGet?: {
                host?: string;
                httpHeaders?: {
                  name: string;
                  value: string;
                }[];
                path?: string;
                port: any;
                scheme?: string;
              };
              sleep?: {
                seconds: number;
              };
              tcpSocket?: {
                host?: string;
                port: any;
              };
            };
          };
          livenessProbe?: {
            exec?: {
              command?: string[];
            };
            failureThreshold?: number;
            grpc?: {
              port: number;
              service?: string;
            };
            httpGet?: {
              host?: string;
              httpHeaders?: {
                name: string;
                value: string;
              }[];
              path?: string;
              port: any;
              scheme?: string;
            };
            initialDelaySeconds?: number;
            periodSeconds?: number;
            successThreshold?: number;
            tcpSocket?: {
              host?: string;
              port: any;
            };
            terminationGracePeriodSeconds?: number;
            timeoutSeconds?: number;
          };
          name: string;
          ports?: {
            containerPort: number;
            hostIP?: string;
            hostPort?: number;
            name?: string;
            protocol?: string;
          }[];
          readinessProbe?: {
            exec?: {
              command?: string[];
            };
            failureThreshold?: number;
            grpc?: {
              port: number;
              service?: string;
            };
            httpGet?: {
              host?: string;
              httpHeaders?: {
                name: string;
                value: string;
              }[];
              path?: string;
              port: any;
              scheme?: string;
            };
            initialDelaySeconds?: number;
            periodSeconds?: number;
            successThreshold?: number;
            tcpSocket?: {
              host?: string;
              port: any;
            };
            terminationGracePeriodSeconds?: number;
            timeoutSeconds?: number;
          };
          resizePolicy?: {
            resourceName: string;
            restartPolicy: string;
          }[];
          resources?: {
            claims?: {
              name: string;
              request?: string;
            }[];
            limits?: {
              [key: string]: unknown;
            };
            requests?: {
              [key: string]: unknown;
            };
          };
          restartPolicy?: string;
          securityContext?: {
            allowPrivilegeEscalation?: boolean;
            appArmorProfile?: {
              localhostProfile?: string;
              type: string;
            };
            capabilities?: {
              add?: string[];
              drop?: string[];
            };
            privileged?: boolean;
            procMount?: string;
            readOnlyRootFilesystem?: boolean;
            runAsGroup?: number;
            runAsNonRoot?: boolean;
            runAsUser?: number;
            seLinuxOptions?: {
              level?: string;
              role?: string;
              type?: string;
              user?: string;
            };
            seccompProfile?: {
              localhostProfile?: string;
              type: string;
            };
            windowsOptions?: {
              gmsaCredentialSpec?: string;
              gmsaCredentialSpecName?: string;
              hostProcess?: boolean;
              runAsUserName?: string;
            };
          };
          startupProbe?: {
            exec?: {
              command?: string[];
            };
            failureThreshold?: number;
            grpc?: {
              port: number;
              service?: string;
            };
            httpGet?: {
              host?: string;
              httpHeaders?: {
                name: string;
                value: string;
              }[];
              path?: string;
              port: any;
              scheme?: string;
            };
            initialDelaySeconds?: number;
            periodSeconds?: number;
            successThreshold?: number;
            tcpSocket?: {
              host?: string;
              port: any;
            };
            terminationGracePeriodSeconds?: number;
            timeoutSeconds?: number;
          };
          stdin?: boolean;
          stdinOnce?: boolean;
          terminationMessagePath?: string;
          terminationMessagePolicy?: string;
          tty?: boolean;
          volumeDevices?: {
            devicePath: string;
            name: string;
          }[];
          volumeMounts?: {
            mountPath: string;
            mountPropagation?: string;
            name: string;
            readOnly?: boolean;
            recursiveReadOnly?: string;
            subPath?: string;
            subPathExpr?: string;
          }[];
          workingDir?: string;
        }[];
        nodeName?: string;
        nodeSelector?: {
          [key: string]: unknown;
        };
        os?: {
          name: string;
        };
        overhead?: {
          [key: string]: unknown;
        };
        preemptionPolicy?: string;
        priority?: number;
        priorityClassName?: string;
        readinessGates?: {
          conditionType: string;
        }[];
        resourceClaims?: {
          name: string;
          resourceClaimName?: string;
          resourceClaimTemplateName?: string;
        }[];
        resources?: {
          claims?: {
            name: string;
            request?: string;
          }[];
          limits?: {
            [key: string]: unknown;
          };
          requests?: {
            [key: string]: unknown;
          };
        };
        restartPolicy?: string;
        runtimeClassName?: string;
        schedulerName?: string;
        schedulingGates?: {
          name: string;
        }[];
        securityContext?: {
          appArmorProfile?: {
            localhostProfile?: string;
            type: string;
          };
          fsGroup?: number;
          fsGroupChangePolicy?: string;
          runAsGroup?: number;
          runAsNonRoot?: boolean;
          runAsUser?: number;
          seLinuxChangePolicy?: string;
          seLinuxOptions?: {
            level?: string;
            role?: string;
            type?: string;
            user?: string;
          };
          seccompProfile?: {
            localhostProfile?: string;
            type: string;
          };
          supplementalGroups?: number[];
          supplementalGroupsPolicy?: string;
          sysctls?: {
            name: string;
            value: string;
          }[];
          windowsOptions?: {
            gmsaCredentialSpec?: string;
            gmsaCredentialSpecName?: string;
            hostProcess?: boolean;
            runAsUserName?: string;
          };
        };
        serviceAccount?: string;
        serviceAccountName?: string;
        setHostnameAsFQDN?: boolean;
        shareProcessNamespace?: boolean;
        subdomain?: string;
        terminationGracePeriodSeconds?: number;
        tolerations?: {
          effect?: string;
          key?: string;
          operator?: string;
          tolerationSeconds?: number;
          value?: string;
        }[];
        topologySpreadConstraints?: {
          labelSelector?: {
            matchExpressions?: {
              key: string;
              operator: string;
              values?: string[];
            }[];
            matchLabels?: {
              [key: string]: unknown;
            };
          };
          matchLabelKeys?: string[];
          maxSkew: number;
          minDomains?: number;
          nodeAffinityPolicy?: string;
          nodeTaintsPolicy?: string;
          topologyKey: string;
          whenUnsatisfiable: string;
        }[];
        volumes?: {
          awsElasticBlockStore?: {
            fsType?: string;
            partition?: number;
            readOnly?: boolean;
            volumeID: string;
          };
          azureDisk?: {
            cachingMode?: string;
            diskName: string;
            diskURI: string;
            fsType?: string;
            kind?: string;
            readOnly?: boolean;
          };
          azureFile?: {
            readOnly?: boolean;
            secretName: string;
            shareName: string;
          };
          cephfs?: {
            monitors: string[];
            path?: string;
            readOnly?: boolean;
            secretFile?: string;
            secretRef?: {
              name?: string;
            };
            user?: string;
          };
          cinder?: {
            fsType?: string;
            readOnly?: boolean;
            secretRef?: {
              name?: string;
            };
            volumeID: string;
          };
          configMap?: {
            defaultMode?: number;
            items?: {
              key: string;
              mode?: number;
              path: string;
            }[];
            name?: string;
            optional?: boolean;
          };
          csi?: {
            driver: string;
            fsType?: string;
            nodePublishSecretRef?: {
              name?: string;
            };
            readOnly?: boolean;
            volumeAttributes?: {
              [key: string]: unknown;
            };
          };
          downwardAPI?: {
            defaultMode?: number;
            items?: {
              fieldRef?: {
                apiVersion?: string;
                fieldPath: string;
              };
              mode?: number;
              path: string;
              resourceFieldRef?: {
                containerName?: string;
                divisor?: any;
                resource: string;
              };
            }[];
          };
          emptyDir?: {
            medium?: string;
            sizeLimit?: any;
          };
          ephemeral?: {
            volumeClaimTemplate?: {
              metadata?: {
                [key: string]: unknown;
              };
              spec: {
                accessModes?: string[];
                dataSource?: {
                  apiGroup?: string;
                  kind: string;
                  name: string;
                };
                dataSourceRef?: {
                  apiGroup?: string;
                  kind: string;
                  name: string;
                  namespace?: string;
                };
                resources?: {
                  limits?: {
                    [key: string]: unknown;
                  };
                  requests?: {
                    [key: string]: unknown;
                  };
                };
                selector?: {
                  matchExpressions?: {
                    key: string;
                    operator: string;
                    values?: string[];
                  }[];
                  matchLabels?: {
                    [key: string]: unknown;
                  };
                };
                storageClassName?: string;
                volumeAttributesClassName?: string;
                volumeMode?: string;
                volumeName?: string;
              };
            };
          };
          fc?: {
            fsType?: string;
            lun?: number;
            readOnly?: boolean;
            targetWWNs?: string[];
            wwids?: string[];
          };
          flexVolume?: {
            driver: string;
            fsType?: string;
            options?: {
              [key: string]: unknown;
            };
            readOnly?: boolean;
            secretRef?: {
              name?: string;
            };
          };
          flocker?: {
            datasetName?: string;
            datasetUUID?: string;
          };
          gcePersistentDisk?: {
            fsType?: string;
            partition?: number;
            pdName: string;
            readOnly?: boolean;
          };
          gitRepo?: {
            directory?: string;
            repository: string;
            revision?: string;
          };
          glusterfs?: {
            endpoints: string;
            path: string;
            readOnly?: boolean;
          };
          hostPath?: {
            path: string;
            type?: string;
          };
          image?: {
            pullPolicy?: string;
            reference?: string;
          };
          iscsi?: {
            chapAuthDiscovery?: boolean;
            chapAuthSession?: boolean;
            fsType?: string;
            initiatorName?: string;
            iqn: string;
            iscsiInterface?: string;
            lun: number;
            portals?: string[];
            readOnly?: boolean;
            secretRef?: {
              name?: string;
            };
            targetPortal: string;
          };
          name: string;
          nfs?: {
            path: string;
            readOnly?: boolean;
            server: string;
          };
          persistentVolumeClaim?: {
            claimName: string;
            readOnly?: boolean;
          };
          photonPersistentDisk?: {
            fsType?: string;
            pdID: string;
          };
          portworxVolume?: {
            fsType?: string;
            readOnly?: boolean;
            volumeID: string;
          };
          projected?: {
            defaultMode?: number;
            sources?: {
              clusterTrustBundle?: {
                labelSelector?: {
                  matchExpressions?: {
                    key: string;
                    operator: string;
                    values?: string[];
                  }[];
                  matchLabels?: {
                    [key: string]: unknown;
                  };
                };
                name?: string;
                optional?: boolean;
                path: string;
                signerName?: string;
              };
              configMap?: {
                items?: {
                  key: string;
                  mode?: number;
                  path: string;
                }[];
                name?: string;
                optional?: boolean;
              };
              downwardAPI?: {
                items?: {
                  fieldRef?: {
                    apiVersion?: string;
                    fieldPath: string;
                  };
                  mode?: number;
                  path: string;
                  resourceFieldRef?: {
                    containerName?: string;
                    divisor?: any;
                    resource: string;
                  };
                }[];
              };
              secret?: {
                items?: {
                  key: string;
                  mode?: number;
                  path: string;
                }[];
                name?: string;
                optional?: boolean;
              };
              serviceAccountToken?: {
                audience?: string;
                expirationSeconds?: number;
                path: string;
              };
            }[];
          };
          quobyte?: {
            group?: string;
            readOnly?: boolean;
            registry: string;
            tenant?: string;
            user?: string;
            volume: string;
          };
          rbd?: {
            fsType?: string;
            image: string;
            keyring?: string;
            monitors: string[];
            pool?: string;
            readOnly?: boolean;
            secretRef?: {
              name?: string;
            };
            user?: string;
          };
          scaleIO?: {
            fsType?: string;
            gateway: string;
            protectionDomain?: string;
            readOnly?: boolean;
            secretRef: {
              name?: string;
            };
            sslEnabled?: boolean;
            storageMode?: string;
            storagePool?: string;
            system: string;
            volumeName?: string;
          };
          secret?: {
            defaultMode?: number;
            items?: {
              key: string;
              mode?: number;
              path: string;
            }[];
            optional?: boolean;
            secretName?: string;
          };
          storageos?: {
            fsType?: string;
            readOnly?: boolean;
            secretRef?: {
              name?: string;
            };
            volumeName?: string;
            volumeNamespace?: string;
          };
          vsphereVolume?: {
            fsType?: string;
            storagePolicyID?: string;
            storagePolicyName?: string;
            volumePath: string;
          };
        }[];
      };
    };
    type?: "rw" | "ro" | "r";
  };
  status?: {
    instances?: number;
    secrets?: {
      clientCA?: {
        name?: string;
        version?: string;
      };
      pgBouncerSecrets?: {
        authQuery?: {
          name?: string;
          version?: string;
        };
      };
      serverCA?: {
        name?: string;
        version?: string;
      };
      serverTLS?: {
        name?: string;
        version?: string;
      };
    };
  };
}
/* io.cnpg.postgresql.v1.PoolerList */
/* PoolerList is a list of Pooler */
export interface PostgresqlCnpgIoV1PoolerList {
  apiVersion?: string;
  items: PostgresqlCnpgIoV1Pooler[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.cnpg.postgresql.v1.Publication */
/* Publication is the Schema for the publications API */
export interface PostgresqlCnpgIoV1Publication {
  apiVersion?: string;
  kind?: string;
  metadata: ObjectMeta;
  spec: {
    cluster: {
      name?: string;
    };
    dbname: string;
    name: string;
    parameters?: {
      [key: string]: unknown;
    };
    publicationReclaimPolicy?: "delete" | "retain";
    target: {
      allTables?: boolean;
      objects?: {
        table?: {
          columns?: string[];
          name: string;
          only?: boolean;
          schema?: string;
        };
        tablesInSchema?: string;
      }[];
    };
  };
  status?: {
    applied?: boolean;
    message?: string;
    observedGeneration?: number;
  };
}
/* io.cnpg.postgresql.v1.PublicationList */
/* PublicationList is a list of Publication */
export interface PostgresqlCnpgIoV1PublicationList {
  apiVersion?: string;
  items: PostgresqlCnpgIoV1Publication[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.cnpg.postgresql.v1.ScheduledBackup */
/* ScheduledBackup is the Schema for the scheduledbackups API */
export interface PostgresqlCnpgIoV1ScheduledBackup {
  apiVersion?: string;
  kind?: string;
  metadata: ObjectMeta;
  spec: {
    backupOwnerReference?: "none" | "self" | "cluster";
    cluster: {
      name: string;
    };
    immediate?: boolean;
    method?: "barmanObjectStore" | "volumeSnapshot" | "plugin";
    online?: boolean;
    onlineConfiguration?: {
      immediateCheckpoint?: boolean;
      waitForArchive?: boolean;
    };
    pluginConfiguration?: {
      name: string;
      parameters?: {
        [key: string]: unknown;
      };
    };
    schedule: string;
    suspend?: boolean;
    target?: "primary" | "prefer-standby";
  };
  status?: {
    lastCheckTime?: string;
    lastScheduleTime?: string;
    nextScheduleTime?: string;
  };
}
/* io.cnpg.postgresql.v1.ScheduledBackupList */
/* ScheduledBackupList is a list of ScheduledBackup */
export interface PostgresqlCnpgIoV1ScheduledBackupList {
  apiVersion?: string;
  items: PostgresqlCnpgIoV1ScheduledBackup[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.cnpg.postgresql.v1.Subscription */
/* Subscription is the Schema for the subscriptions API */
export interface PostgresqlCnpgIoV1Subscription {
  apiVersion?: string;
  kind?: string;
  metadata: ObjectMeta;
  spec: {
    cluster: {
      name?: string;
    };
    dbname: string;
    externalClusterName: string;
    name: string;
    parameters?: {
      [key: string]: unknown;
    };
    publicationDBName?: string;
    publicationName: string;
    subscriptionReclaimPolicy?: "delete" | "retain";
  };
  status?: {
    applied?: boolean;
    message?: string;
    observedGeneration?: number;
  };
}
/* io.cnpg.postgresql.v1.SubscriptionList */
/* SubscriptionList is a list of Subscription */
export interface PostgresqlCnpgIoV1SubscriptionList {
  apiVersion?: string;
  items: PostgresqlCnpgIoV1Subscription[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.k8s.api.admissionregistration.v1.AuditAnnotation */
/* AuditAnnotation describes how to produce an audit annotation for an API request. */
export interface AuditAnnotation {
  key: string;
  valueExpression: string;
}
/* io.k8s.api.admissionregistration.v1.ExpressionWarning */
/* ExpressionWarning is a warning information that targets a specific expression. */
export interface ExpressionWarning {
  fieldRef: string;
  warning: string;
}
/* io.k8s.api.admissionregistration.v1.MatchCondition */
/* MatchCondition represents a condition which must by fulfilled for a request to be sent to a webhook. */
export interface MatchCondition {
  expression: string;
  name: string;
}
/* io.k8s.api.admissionregistration.v1.MatchResources */
/* MatchResources decides whether to run the admission control policy on an object based on whether it meets the match criteria. The exclude rules take precedence over include rules (if a resource matches both, it is excluded) */
export interface MatchResources {
  excludeResourceRules?: NamedRuleWithOperations[];
  matchPolicy?: "Equivalent" | "Exact";
  namespaceSelector?: LabelSelector;
  objectSelector?: LabelSelector;
  resourceRules?: NamedRuleWithOperations[];
}
/* io.k8s.api.admissionregistration.v1.MutatingWebhook */
/* MutatingWebhook describes an admission webhook and the resources and operations it applies to. */
export interface MutatingWebhook {
  admissionReviewVersions: string[];
  clientConfig: IoK8sApiAdmissionregistrationV1WebhookClientConfig;
  failurePolicy?: "Fail" | "Ignore";
  matchConditions?: MatchCondition[];
  matchPolicy?: "Equivalent" | "Exact";
  name: string;
  namespaceSelector?: LabelSelector;
  objectSelector?: LabelSelector;
  reinvocationPolicy?: "IfNeeded" | "Never";
  rules?: RuleWithOperations[];
  sideEffects: "None" | "NoneOnDryRun" | "Some" | "Unknown";
  timeoutSeconds?: number;
}
/* io.k8s.api.admissionregistration.v1.MutatingWebhookConfiguration */
/* MutatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and may change the object. */
export interface AdmissionregistrationK8sIoV1MutatingWebhookConfiguration {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  webhooks?: MutatingWebhook[];
}
/* io.k8s.api.admissionregistration.v1.MutatingWebhookConfigurationList */
/* MutatingWebhookConfigurationList is a list of MutatingWebhookConfiguration. */
export interface AdmissionregistrationK8sIoV1MutatingWebhookConfigurationList {
  apiVersion?: string;
  items: AdmissionregistrationK8sIoV1MutatingWebhookConfiguration[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.k8s.api.admissionregistration.v1.NamedRuleWithOperations */
/* NamedRuleWithOperations is a tuple of Operations and Resources with ResourceNames. */
export interface NamedRuleWithOperations {
  apiGroups?: string[];
  apiVersions?: string[];
  operations?: ("*" | "CONNECT" | "CREATE" | "DELETE" | "UPDATE")[];
  resourceNames?: string[];
  resources?: string[];
  scope?: string;
}
/* io.k8s.api.admissionregistration.v1.ParamKind */
/* ParamKind is a tuple of Group Kind and Version. */
export interface ParamKind {
  apiVersion?: string;
  kind?: string;
}
/* io.k8s.api.admissionregistration.v1.ParamRef */
/* ParamRef describes how to locate the params to be used as input to expressions of rules applied by a policy binding. */
export interface ParamRef {
  name?: string;
  namespace?: string;
  parameterNotFoundAction?: string;
  selector?: LabelSelector;
}
/* io.k8s.api.admissionregistration.v1.RuleWithOperations */
/* RuleWithOperations is a tuple of Operations and Resources. It is recommended to make sure that all the tuple expansions are valid. */
export interface RuleWithOperations {
  apiGroups?: string[];
  apiVersions?: string[];
  operations?: ("*" | "CONNECT" | "CREATE" | "DELETE" | "UPDATE")[];
  resources?: string[];
  scope?: string;
}
/* io.k8s.api.admissionregistration.v1.ServiceReference */
/* ServiceReference holds a reference to Service.legacy.k8s.io */
export interface IoK8sApiAdmissionregistrationV1ServiceReference {
  name: string;
  namespace: string;
  path?: string;
  port?: number;
}
/* io.k8s.api.admissionregistration.v1.TypeChecking */
/* TypeChecking contains results of type checking the expressions in the ValidatingAdmissionPolicy */
export interface TypeChecking {
  expressionWarnings?: ExpressionWarning[];
}
/* io.k8s.api.admissionregistration.v1.ValidatingAdmissionPolicy */
/* ValidatingAdmissionPolicy describes the definition of an admission validation policy that accepts or rejects an object without changing it. */
export interface AdmissionregistrationK8sIoV1ValidatingAdmissionPolicy {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: ValidatingAdmissionPolicySpec;
  status?: ValidatingAdmissionPolicyStatus;
}
/* io.k8s.api.admissionregistration.v1.ValidatingAdmissionPolicyBinding */
/* ValidatingAdmissionPolicyBinding binds the ValidatingAdmissionPolicy with paramerized resources. ValidatingAdmissionPolicyBinding and parameter CRDs together define how cluster administrators configure policies for clusters.

For a given admission request, each binding will cause its policy to be evaluated N times, where N is 1 for policies/bindings that don't use params, otherwise N is the number of parameters selected by the binding.

The CEL expressions of a policy must have a computed CEL cost below the maximum CEL budget. Each evaluation of the policy is given an independent CEL cost budget. Adding/removing policies, bindings, or params can not affect whether a given (policy, binding, param) combination is within its own CEL budget. */
export interface AdmissionregistrationK8sIoV1ValidatingAdmissionPolicyBinding {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: ValidatingAdmissionPolicyBindingSpec;
}
/* io.k8s.api.admissionregistration.v1.ValidatingAdmissionPolicyBindingList */
/* ValidatingAdmissionPolicyBindingList is a list of ValidatingAdmissionPolicyBinding. */
export interface AdmissionregistrationK8sIoV1ValidatingAdmissionPolicyBindingList {
  apiVersion?: string;
  items: AdmissionregistrationK8sIoV1ValidatingAdmissionPolicyBinding[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.k8s.api.admissionregistration.v1.ValidatingAdmissionPolicyBindingSpec */
/* ValidatingAdmissionPolicyBindingSpec is the specification of the ValidatingAdmissionPolicyBinding. */
export interface ValidatingAdmissionPolicyBindingSpec {
  matchResources?: MatchResources;
  paramRef?: ParamRef;
  policyName?: string;
  validationActions?: ("Audit" | "Deny" | "Warn")[];
}
/* io.k8s.api.admissionregistration.v1.ValidatingAdmissionPolicyList */
/* ValidatingAdmissionPolicyList is a list of ValidatingAdmissionPolicy. */
export interface AdmissionregistrationK8sIoV1ValidatingAdmissionPolicyList {
  apiVersion?: string;
  items: AdmissionregistrationK8sIoV1ValidatingAdmissionPolicy[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.k8s.api.admissionregistration.v1.ValidatingAdmissionPolicySpec */
/* ValidatingAdmissionPolicySpec is the specification of the desired behavior of the AdmissionPolicy. */
export interface ValidatingAdmissionPolicySpec {
  auditAnnotations?: AuditAnnotation[];
  failurePolicy?: "Fail" | "Ignore";
  matchConditions?: MatchCondition[];
  matchConstraints?: MatchResources;
  paramKind?: ParamKind;
  validations?: Validation[];
  variables?: Variable[];
}
/* io.k8s.api.admissionregistration.v1.ValidatingAdmissionPolicyStatus */
/* ValidatingAdmissionPolicyStatus represents the status of an admission validation policy. */
export interface ValidatingAdmissionPolicyStatus {
  conditions?: Condition[];
  observedGeneration?: number;
  typeChecking?: TypeChecking;
}
/* io.k8s.api.admissionregistration.v1.ValidatingWebhook */
/* ValidatingWebhook describes an admission webhook and the resources and operations it applies to. */
export interface ValidatingWebhook {
  admissionReviewVersions: string[];
  clientConfig: IoK8sApiAdmissionregistrationV1WebhookClientConfig;
  failurePolicy?: "Fail" | "Ignore";
  matchConditions?: MatchCondition[];
  matchPolicy?: "Equivalent" | "Exact";
  name: string;
  namespaceSelector?: LabelSelector;
  objectSelector?: LabelSelector;
  rules?: RuleWithOperations[];
  sideEffects: "None" | "NoneOnDryRun" | "Some" | "Unknown";
  timeoutSeconds?: number;
}
/* io.k8s.api.admissionregistration.v1.ValidatingWebhookConfiguration */
/* ValidatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and object without changing it. */
export interface AdmissionregistrationK8sIoV1ValidatingWebhookConfiguration {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  webhooks?: ValidatingWebhook[];
}
/* io.k8s.api.admissionregistration.v1.ValidatingWebhookConfigurationList */
/* ValidatingWebhookConfigurationList is a list of ValidatingWebhookConfiguration. */
export interface AdmissionregistrationK8sIoV1ValidatingWebhookConfigurationList {
  apiVersion?: string;
  items: AdmissionregistrationK8sIoV1ValidatingWebhookConfiguration[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.k8s.api.admissionregistration.v1.Validation */
/* Validation specifies the CEL expression which is used to apply the validation. */
export interface Validation {
  expression: string;
  message?: string;
  messageExpression?: string;
  reason?: string;
}
/* io.k8s.api.admissionregistration.v1.Variable */
/* Variable is the definition of a variable that is used for composition. A variable is defined as a named expression. */
export interface Variable {
  expression: string;
  name: string;
}
/* io.k8s.api.admissionregistration.v1.WebhookClientConfig */
/* WebhookClientConfig contains the information to make a TLS connection with the webhook */
export interface IoK8sApiAdmissionregistrationV1WebhookClientConfig {
  caBundle?: string;
  service?: IoK8sApiAdmissionregistrationV1ServiceReference;
  url?: string;
}
/* io.k8s.api.apps.v1.ControllerRevision */
/* ControllerRevision implements an immutable snapshot of state data. Clients are responsible for serializing and deserializing the objects that contain their internal state. Once a ControllerRevision has been successfully created, it can not be updated. The API Server will fail validation of all requests that attempt to mutate the Data field. ControllerRevisions may, however, be deleted. Note that, due to its use by both the DaemonSet and StatefulSet controllers for update and rollback, this object is beta. However, it may be subject to name and representation changes in future releases, and clients should not depend on its stability. It is primarily for internal use by controllers. */
export interface AppsV1ControllerRevision {
  apiVersion?: string;
  data?: RawExtension;
  kind?: string;
  metadata?: ObjectMeta;
  revision: number;
}
/* io.k8s.api.apps.v1.ControllerRevisionList */
/* ControllerRevisionList is a resource containing a list of ControllerRevision objects. */
export interface AppsV1ControllerRevisionList {
  apiVersion?: string;
  items: AppsV1ControllerRevision[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.k8s.api.apps.v1.DaemonSet */
/* DaemonSet represents the configuration of a daemon set. */
export interface AppsV1DaemonSet {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: DaemonSetSpec;
  status?: DaemonSetStatus;
}
/* io.k8s.api.apps.v1.DaemonSetCondition */
/* DaemonSetCondition describes the state of a DaemonSet at a certain point. */
export interface DaemonSetCondition {
  lastTransitionTime?: Time;
  message?: string;
  reason?: string;
  status: string;
  type: string;
}
/* io.k8s.api.apps.v1.DaemonSetList */
/* DaemonSetList is a collection of daemon sets. */
export interface AppsV1DaemonSetList {
  apiVersion?: string;
  items: AppsV1DaemonSet[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.k8s.api.apps.v1.DaemonSetSpec */
/* DaemonSetSpec is the specification of a daemon set. */
export interface DaemonSetSpec {
  minReadySeconds?: number;
  revisionHistoryLimit?: number;
  selector: LabelSelector;
  template: PodTemplateSpec;
  updateStrategy?: DaemonSetUpdateStrategy;
}
/* io.k8s.api.apps.v1.DaemonSetStatus */
/* DaemonSetStatus represents the current status of a daemon set. */
export interface DaemonSetStatus {
  collisionCount?: number;
  conditions?: DaemonSetCondition[];
  currentNumberScheduled: number;
  desiredNumberScheduled: number;
  numberAvailable?: number;
  numberMisscheduled: number;
  numberReady: number;
  numberUnavailable?: number;
  observedGeneration?: number;
  updatedNumberScheduled?: number;
}
/* io.k8s.api.apps.v1.DaemonSetUpdateStrategy */
/* DaemonSetUpdateStrategy is a struct used to control the update strategy for a DaemonSet. */
export interface DaemonSetUpdateStrategy {
  rollingUpdate?: RollingUpdateDaemonSet;
  type?: "OnDelete" | "RollingUpdate";
}
/* io.k8s.api.apps.v1.Deployment */
/* Deployment enables declarative updates for Pods and ReplicaSets. */
export interface AppsV1Deployment {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: DeploymentSpec;
  status?: DeploymentStatus;
}
/* io.k8s.api.apps.v1.DeploymentCondition */
/* DeploymentCondition describes the state of a deployment at a certain point. */
export interface DeploymentCondition {
  lastTransitionTime?: Time;
  lastUpdateTime?: Time;
  message?: string;
  reason?: string;
  status: string;
  type: string;
}
/* io.k8s.api.apps.v1.DeploymentList */
/* DeploymentList is a list of Deployments. */
export interface AppsV1DeploymentList {
  apiVersion?: string;
  items: AppsV1Deployment[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.k8s.api.apps.v1.DeploymentSpec */
/* DeploymentSpec is the specification of the desired behavior of the Deployment. */
export interface DeploymentSpec {
  minReadySeconds?: number;
  paused?: boolean;
  progressDeadlineSeconds?: number;
  replicas?: number;
  revisionHistoryLimit?: number;
  selector: LabelSelector;
  strategy?: DeploymentStrategy;
  template: PodTemplateSpec;
}
/* io.k8s.api.apps.v1.DeploymentStatus */
/* DeploymentStatus is the most recently observed status of the Deployment. */
export interface DeploymentStatus {
  availableReplicas?: number;
  collisionCount?: number;
  conditions?: DeploymentCondition[];
  observedGeneration?: number;
  readyReplicas?: number;
  replicas?: number;
  unavailableReplicas?: number;
  updatedReplicas?: number;
}
/* io.k8s.api.apps.v1.DeploymentStrategy */
/* DeploymentStrategy describes how to replace existing pods with new ones. */
export interface DeploymentStrategy {
  rollingUpdate?: RollingUpdateDeployment;
  type?: "Recreate" | "RollingUpdate";
}
/* io.k8s.api.apps.v1.ReplicaSet */
/* ReplicaSet ensures that a specified number of pod replicas are running at any given time. */
export interface AppsV1ReplicaSet {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: ReplicaSetSpec;
  status?: ReplicaSetStatus;
}
/* io.k8s.api.apps.v1.ReplicaSetCondition */
/* ReplicaSetCondition describes the state of a replica set at a certain point. */
export interface ReplicaSetCondition {
  lastTransitionTime?: Time;
  message?: string;
  reason?: string;
  status: string;
  type: string;
}
/* io.k8s.api.apps.v1.ReplicaSetList */
/* ReplicaSetList is a collection of ReplicaSets. */
export interface AppsV1ReplicaSetList {
  apiVersion?: string;
  items: AppsV1ReplicaSet[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.k8s.api.apps.v1.ReplicaSetSpec */
/* ReplicaSetSpec is the specification of a ReplicaSet. */
export interface ReplicaSetSpec {
  minReadySeconds?: number;
  replicas?: number;
  selector: LabelSelector;
  template?: PodTemplateSpec;
}
/* io.k8s.api.apps.v1.ReplicaSetStatus */
/* ReplicaSetStatus represents the current status of a ReplicaSet. */
export interface ReplicaSetStatus {
  availableReplicas?: number;
  conditions?: ReplicaSetCondition[];
  fullyLabeledReplicas?: number;
  observedGeneration?: number;
  readyReplicas?: number;
  replicas: number;
}
/* io.k8s.api.apps.v1.RollingUpdateDaemonSet */
/* Spec to control the desired behavior of daemon set rolling update. */
export interface RollingUpdateDaemonSet {
  maxSurge?: IntOrString;
  maxUnavailable?: IntOrString;
}
/* io.k8s.api.apps.v1.RollingUpdateDeployment */
/* Spec to control the desired behavior of rolling update. */
export interface RollingUpdateDeployment {
  maxSurge?: IntOrString;
  maxUnavailable?: IntOrString;
}
/* io.k8s.api.apps.v1.RollingUpdateStatefulSetStrategy */
/* RollingUpdateStatefulSetStrategy is used to communicate parameter for RollingUpdateStatefulSetStrategyType. */
export interface RollingUpdateStatefulSetStrategy {
  maxUnavailable?: IntOrString;
  partition?: number;
}
/* io.k8s.api.apps.v1.StatefulSet */
/* StatefulSet represents a set of pods with consistent identities. Identities are defined as:
  - Network: A single stable DNS and hostname.
  - Storage: As many VolumeClaims as requested.

The StatefulSet guarantees that a given network identity will always map to the same storage identity. */
export interface AppsV1StatefulSet {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: StatefulSetSpec;
  status?: StatefulSetStatus;
}
/* io.k8s.api.apps.v1.StatefulSetCondition */
/* StatefulSetCondition describes the state of a statefulset at a certain point. */
export interface StatefulSetCondition {
  lastTransitionTime?: Time;
  message?: string;
  reason?: string;
  status: string;
  type: string;
}
/* io.k8s.api.apps.v1.StatefulSetList */
/* StatefulSetList is a collection of StatefulSets. */
export interface AppsV1StatefulSetList {
  apiVersion?: string;
  items: AppsV1StatefulSet[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.k8s.api.apps.v1.StatefulSetOrdinals */
/* StatefulSetOrdinals describes the policy used for replica ordinal assignment in this StatefulSet. */
export interface StatefulSetOrdinals {
  start?: number;
}
/* io.k8s.api.apps.v1.StatefulSetPersistentVolumeClaimRetentionPolicy */
/* StatefulSetPersistentVolumeClaimRetentionPolicy describes the policy used for PVCs created from the StatefulSet VolumeClaimTemplates. */
export interface StatefulSetPersistentVolumeClaimRetentionPolicy {
  whenDeleted?: string;
  whenScaled?: string;
}
/* io.k8s.api.apps.v1.StatefulSetSpec */
/* A StatefulSetSpec is the specification of a StatefulSet. */
export interface StatefulSetSpec {
  minReadySeconds?: number;
  ordinals?: StatefulSetOrdinals;
  persistentVolumeClaimRetentionPolicy?: StatefulSetPersistentVolumeClaimRetentionPolicy;
  podManagementPolicy?: "OrderedReady" | "Parallel";
  replicas?: number;
  revisionHistoryLimit?: number;
  selector: LabelSelector;
  serviceName: string;
  template: PodTemplateSpec;
  updateStrategy?: StatefulSetUpdateStrategy;
  volumeClaimTemplates?: PersistentVolumeClaim[];
}
/* io.k8s.api.apps.v1.StatefulSetStatus */
/* StatefulSetStatus represents the current state of a StatefulSet. */
export interface StatefulSetStatus {
  availableReplicas?: number;
  collisionCount?: number;
  conditions?: StatefulSetCondition[];
  currentReplicas?: number;
  currentRevision?: string;
  observedGeneration?: number;
  readyReplicas?: number;
  replicas: number;
  updateRevision?: string;
  updatedReplicas?: number;
}
/* io.k8s.api.apps.v1.StatefulSetUpdateStrategy */
/* StatefulSetUpdateStrategy indicates the strategy that the StatefulSet controller will use to perform updates. It includes any additional parameters necessary to perform the update for the indicated strategy. */
export interface StatefulSetUpdateStrategy {
  rollingUpdate?: RollingUpdateStatefulSetStrategy;
  type?: "OnDelete" | "RollingUpdate";
}
/* io.k8s.api.authentication.v1.BoundObjectReference */
/* BoundObjectReference is a reference to an object that a token is bound to. */
export interface BoundObjectReference {
  apiVersion?: string;
  kind?: string;
  name?: string;
  uid?: string;
}
/* io.k8s.api.authentication.v1.SelfSubjectReview */
/* SelfSubjectReview contains the user information that the kube-apiserver has about the user making this request. When using impersonation, users will receive the user info of the user being impersonated.  If impersonation or request header authentication is used, any extra keys will have their case ignored and returned as lowercase. */
export interface AuthenticationK8sIoV1SelfSubjectReview {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  status?: SelfSubjectReviewStatus;
}
/* io.k8s.api.authentication.v1.SelfSubjectReviewStatus */
/* SelfSubjectReviewStatus is filled by the kube-apiserver and sent back to a user. */
export interface SelfSubjectReviewStatus {
  userInfo?: UserInfo;
}
/* io.k8s.api.authentication.v1.TokenRequest */
/* TokenRequest requests a token for a given service account. */
export interface AuthenticationK8sIoV1TokenRequest {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec: TokenRequestSpec;
  status?: TokenRequestStatus;
}
/* io.k8s.api.authentication.v1.TokenRequestSpec */
/* TokenRequestSpec contains client provided parameters of a token request. */
export interface TokenRequestSpec {
  audiences: string[];
  boundObjectRef?: BoundObjectReference;
  expirationSeconds?: number;
}
/* io.k8s.api.authentication.v1.TokenRequestStatus */
/* TokenRequestStatus is the result of a token request. */
export interface TokenRequestStatus {
  expirationTimestamp: Time;
  token: string;
}
/* io.k8s.api.authentication.v1.TokenReview */
/* TokenReview attempts to authenticate a token to a known user. Note: TokenReview requests may be cached by the webhook token authenticator plugin in the kube-apiserver. */
export interface AuthenticationK8sIoV1TokenReview {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec: TokenReviewSpec;
  status?: TokenReviewStatus;
}
/* io.k8s.api.authentication.v1.TokenReviewSpec */
/* TokenReviewSpec is a description of the token authentication request. */
export interface TokenReviewSpec {
  audiences?: string[];
  token?: string;
}
/* io.k8s.api.authentication.v1.TokenReviewStatus */
/* TokenReviewStatus is the result of the token authentication request. */
export interface TokenReviewStatus {
  audiences?: string[];
  authenticated?: boolean;
  error?: string;
  user?: UserInfo;
}
/* io.k8s.api.authentication.v1.UserInfo */
/* UserInfo holds the information about the user needed to implement the user.Info interface. */
export interface UserInfo {
  extra?: {
    [key: string]: unknown;
  };
  groups?: string[];
  uid?: string;
  username?: string;
}
/* io.k8s.api.authorization.v1.FieldSelectorAttributes */
/* FieldSelectorAttributes indicates a field limited access. Webhook authors are encouraged to * ensure rawSelector and requirements are not both set * consider the requirements field if set * not try to parse or consider the rawSelector field if set. This is to avoid another CVE-2022-2880 (i.e. getting different systems to agree on how exactly to parse a query is not something we want), see https://www.oxeye.io/resources/golang-parameter-smuggling-attack for more details. For the *SubjectAccessReview endpoints of the kube-apiserver: * If rawSelector is empty and requirements are empty, the request is not limited. * If rawSelector is present and requirements are empty, the rawSelector will be parsed and limited if the parsing succeeds. * If rawSelector is empty and requirements are present, the requirements should be honored * If rawSelector is present and requirements are present, the request is invalid. */
export interface FieldSelectorAttributes {
  rawSelector?: string;
  requirements?: FieldSelectorRequirement[];
}
/* io.k8s.api.authorization.v1.LabelSelectorAttributes */
/* LabelSelectorAttributes indicates a label limited access. Webhook authors are encouraged to * ensure rawSelector and requirements are not both set * consider the requirements field if set * not try to parse or consider the rawSelector field if set. This is to avoid another CVE-2022-2880 (i.e. getting different systems to agree on how exactly to parse a query is not something we want), see https://www.oxeye.io/resources/golang-parameter-smuggling-attack for more details. For the *SubjectAccessReview endpoints of the kube-apiserver: * If rawSelector is empty and requirements are empty, the request is not limited. * If rawSelector is present and requirements are empty, the rawSelector will be parsed and limited if the parsing succeeds. * If rawSelector is empty and requirements are present, the requirements should be honored * If rawSelector is present and requirements are present, the request is invalid. */
export interface LabelSelectorAttributes {
  rawSelector?: string;
  requirements?: LabelSelectorRequirement[];
}
/* io.k8s.api.authorization.v1.LocalSubjectAccessReview */
/* LocalSubjectAccessReview checks whether or not a user or group can perform an action in a given namespace. Having a namespace scoped resource makes it much easier to grant namespace scoped policy that includes permissions checking. */
export interface AuthorizationK8sIoV1LocalSubjectAccessReview {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec: SubjectAccessReviewSpec;
  status?: SubjectAccessReviewStatus;
}
/* io.k8s.api.authorization.v1.NonResourceAttributes */
/* NonResourceAttributes includes the authorization attributes available for non-resource requests to the Authorizer interface */
export interface NonResourceAttributes {
  path?: string;
  verb?: string;
}
/* io.k8s.api.authorization.v1.NonResourceRule */
/* NonResourceRule holds information that describes a rule for the non-resource */
export interface NonResourceRule {
  nonResourceURLs?: string[];
  verbs: string[];
}
/* io.k8s.api.authorization.v1.ResourceAttributes */
/* ResourceAttributes includes the authorization attributes available for resource requests to the Authorizer interface */
export interface ResourceAttributes {
  fieldSelector?: FieldSelectorAttributes;
  group?: string;
  labelSelector?: LabelSelectorAttributes;
  name?: string;
  namespace?: string;
  resource?: string;
  subresource?: string;
  verb?: string;
  version?: string;
}
/* io.k8s.api.authorization.v1.ResourceRule */
/* ResourceRule is the list of actions the subject is allowed to perform on resources. The list ordering isn't significant, may contain duplicates, and possibly be incomplete. */
export interface ResourceRule {
  apiGroups?: string[];
  resourceNames?: string[];
  resources?: string[];
  verbs: string[];
}
/* io.k8s.api.authorization.v1.SelfSubjectAccessReview */
/* SelfSubjectAccessReview checks whether or the current user can perform an action.  Not filling in a spec.namespace means "in all namespaces".  Self is a special case, because users should always be able to check whether they can perform an action */
export interface AuthorizationK8sIoV1SelfSubjectAccessReview {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec: SelfSubjectAccessReviewSpec;
  status?: SubjectAccessReviewStatus;
}
/* io.k8s.api.authorization.v1.SelfSubjectAccessReviewSpec */
/* SelfSubjectAccessReviewSpec is a description of the access request.  Exactly one of ResourceAuthorizationAttributes and NonResourceAuthorizationAttributes must be set */
export interface SelfSubjectAccessReviewSpec {
  nonResourceAttributes?: NonResourceAttributes;
  resourceAttributes?: ResourceAttributes;
}
/* io.k8s.api.authorization.v1.SelfSubjectRulesReview */
/* SelfSubjectRulesReview enumerates the set of actions the current user can perform within a namespace. The returned list of actions may be incomplete depending on the server's authorization mode, and any errors experienced during the evaluation. SelfSubjectRulesReview should be used by UIs to show/hide actions, or to quickly let an end user reason about their permissions. It should NOT Be used by external systems to drive authorization decisions as this raises confused deputy, cache lifetime/revocation, and correctness concerns. SubjectAccessReview, and LocalAccessReview are the correct way to defer authorization decisions to the API server. */
export interface AuthorizationK8sIoV1SelfSubjectRulesReview {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec: SelfSubjectRulesReviewSpec;
  status?: SubjectRulesReviewStatus;
}
/* io.k8s.api.authorization.v1.SelfSubjectRulesReviewSpec */
/* SelfSubjectRulesReviewSpec defines the specification for SelfSubjectRulesReview. */
export interface SelfSubjectRulesReviewSpec {
  namespace?: string;
}
/* io.k8s.api.authorization.v1.SubjectAccessReview */
/* SubjectAccessReview checks whether or not a user or group can perform an action. */
export interface AuthorizationK8sIoV1SubjectAccessReview {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec: SubjectAccessReviewSpec;
  status?: SubjectAccessReviewStatus;
}
/* io.k8s.api.authorization.v1.SubjectAccessReviewSpec */
/* SubjectAccessReviewSpec is a description of the access request.  Exactly one of ResourceAuthorizationAttributes and NonResourceAuthorizationAttributes must be set */
export interface SubjectAccessReviewSpec {
  extra?: {
    [key: string]: unknown;
  };
  groups?: string[];
  nonResourceAttributes?: NonResourceAttributes;
  resourceAttributes?: ResourceAttributes;
  uid?: string;
  user?: string;
}
/* io.k8s.api.authorization.v1.SubjectAccessReviewStatus */
/* SubjectAccessReviewStatus */
export interface SubjectAccessReviewStatus {
  allowed: boolean;
  denied?: boolean;
  evaluationError?: string;
  reason?: string;
}
/* io.k8s.api.authorization.v1.SubjectRulesReviewStatus */
/* SubjectRulesReviewStatus contains the result of a rules check. This check can be incomplete depending on the set of authorizers the server is configured with and any errors experienced during evaluation. Because authorization rules are additive, if a rule appears in a list it's safe to assume the subject has that permission, even if that list is incomplete. */
export interface SubjectRulesReviewStatus {
  evaluationError?: string;
  incomplete: boolean;
  nonResourceRules: NonResourceRule[];
  resourceRules: ResourceRule[];
}
/* io.k8s.api.autoscaling.v1.CrossVersionObjectReference */
/* CrossVersionObjectReference contains enough information to let you identify the referred resource. */
export interface IoK8sApiAutoscalingV1CrossVersionObjectReference {
  apiVersion?: string;
  kind: string;
  name: string;
}
/* io.k8s.api.autoscaling.v1.HorizontalPodAutoscaler */
/* configuration of a horizontal pod autoscaler. */
export interface AutoscalingV1HorizontalPodAutoscaler {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: IoK8sApiAutoscalingV1HorizontalPodAutoscalerSpec;
  status?: IoK8sApiAutoscalingV1HorizontalPodAutoscalerStatus;
}
/* io.k8s.api.autoscaling.v1.HorizontalPodAutoscalerList */
/* list of horizontal pod autoscaler objects. */
export interface AutoscalingV1HorizontalPodAutoscalerList {
  apiVersion?: string;
  items: AutoscalingV1HorizontalPodAutoscaler[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.k8s.api.autoscaling.v1.HorizontalPodAutoscalerSpec */
/* specification of a horizontal pod autoscaler. */
export interface IoK8sApiAutoscalingV1HorizontalPodAutoscalerSpec {
  maxReplicas: number;
  minReplicas?: number;
  scaleTargetRef: IoK8sApiAutoscalingV1CrossVersionObjectReference;
  targetCPUUtilizationPercentage?: number;
}
/* io.k8s.api.autoscaling.v1.HorizontalPodAutoscalerStatus */
/* current status of a horizontal pod autoscaler */
export interface IoK8sApiAutoscalingV1HorizontalPodAutoscalerStatus {
  currentCPUUtilizationPercentage?: number;
  currentReplicas: number;
  desiredReplicas: number;
  lastScaleTime?: Time;
  observedGeneration?: number;
}
/* io.k8s.api.autoscaling.v1.Scale */
/* Scale represents a scaling request for a resource. */
export interface AutoscalingV1Scale {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: ScaleSpec;
  status?: ScaleStatus;
}
/* io.k8s.api.autoscaling.v1.ScaleSpec */
/* ScaleSpec describes the attributes of a scale subresource. */
export interface ScaleSpec {
  replicas?: number;
}
/* io.k8s.api.autoscaling.v1.ScaleStatus */
/* ScaleStatus represents the current status of a scale subresource. */
export interface ScaleStatus {
  replicas: number;
  selector?: string;
}
/* io.k8s.api.autoscaling.v2.ContainerResourceMetricSource */
/* ContainerResourceMetricSource indicates how to scale on a resource metric known to Kubernetes, as specified in requests and limits, describing each pod in the current scale target (e.g. CPU or memory).  The values will be averaged together before being compared to the target.  Such metrics are built in to Kubernetes, and have special scaling options on top of those available to normal per-pod metrics using the "pods" source.  Only one "target" type should be set. */
export interface ContainerResourceMetricSource {
  container: string;
  name: string;
  target: MetricTarget;
}
/* io.k8s.api.autoscaling.v2.ContainerResourceMetricStatus */
/* ContainerResourceMetricStatus indicates the current value of a resource metric known to Kubernetes, as specified in requests and limits, describing a single container in each pod in the current scale target (e.g. CPU or memory).  Such metrics are built in to Kubernetes, and have special scaling options on top of those available to normal per-pod metrics using the "pods" source. */
export interface ContainerResourceMetricStatus {
  container: string;
  current: MetricValueStatus;
  name: string;
}
/* io.k8s.api.autoscaling.v2.CrossVersionObjectReference */
/* CrossVersionObjectReference contains enough information to let you identify the referred resource. */
export interface IoK8sApiAutoscalingV2CrossVersionObjectReference {
  apiVersion?: string;
  kind: string;
  name: string;
}
/* io.k8s.api.autoscaling.v2.ExternalMetricSource */
/* ExternalMetricSource indicates how to scale on a metric not associated with any Kubernetes object (for example length of queue in cloud messaging service, or QPS from loadbalancer running outside of cluster). */
export interface ExternalMetricSource {
  metric: MetricIdentifier;
  target: MetricTarget;
}
/* io.k8s.api.autoscaling.v2.ExternalMetricStatus */
/* ExternalMetricStatus indicates the current value of a global metric not associated with any Kubernetes object. */
export interface ExternalMetricStatus {
  current: MetricValueStatus;
  metric: MetricIdentifier;
}
/* io.k8s.api.autoscaling.v2.HPAScalingPolicy */
/* HPAScalingPolicy is a single policy which must hold true for a specified past interval. */
export interface HPAScalingPolicy {
  periodSeconds: number;
  type: string;
  value: number;
}
/* io.k8s.api.autoscaling.v2.HPAScalingRules */
/* HPAScalingRules configures the scaling behavior for one direction. These Rules are applied after calculating DesiredReplicas from metrics for the HPA. They can limit the scaling velocity by specifying scaling policies. They can prevent flapping by specifying the stabilization window, so that the number of replicas is not set instantly, instead, the safest value from the stabilization window is chosen. */
export interface HPAScalingRules {
  policies?: HPAScalingPolicy[];
  selectPolicy?: string;
  stabilizationWindowSeconds?: number;
}
/* io.k8s.api.autoscaling.v2.HorizontalPodAutoscaler */
/* HorizontalPodAutoscaler is the configuration for a horizontal pod autoscaler, which automatically manages the replica count of any resource implementing the scale subresource based on the metrics specified. */
export interface AutoscalingV2HorizontalPodAutoscaler {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: IoK8sApiAutoscalingV2HorizontalPodAutoscalerSpec;
  status?: IoK8sApiAutoscalingV2HorizontalPodAutoscalerStatus;
}
/* io.k8s.api.autoscaling.v2.HorizontalPodAutoscalerBehavior */
/* HorizontalPodAutoscalerBehavior configures the scaling behavior of the target in both Up and Down directions (scaleUp and scaleDown fields respectively). */
export interface HorizontalPodAutoscalerBehavior {
  scaleDown?: HPAScalingRules;
  scaleUp?: HPAScalingRules;
}
/* io.k8s.api.autoscaling.v2.HorizontalPodAutoscalerCondition */
/* HorizontalPodAutoscalerCondition describes the state of a HorizontalPodAutoscaler at a certain point. */
export interface HorizontalPodAutoscalerCondition {
  lastTransitionTime?: Time;
  message?: string;
  reason?: string;
  status: string;
  type: string;
}
/* io.k8s.api.autoscaling.v2.HorizontalPodAutoscalerList */
/* HorizontalPodAutoscalerList is a list of horizontal pod autoscaler objects. */
export interface AutoscalingV2HorizontalPodAutoscalerList {
  apiVersion?: string;
  items: AutoscalingV2HorizontalPodAutoscaler[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.k8s.api.autoscaling.v2.HorizontalPodAutoscalerSpec */
/* HorizontalPodAutoscalerSpec describes the desired functionality of the HorizontalPodAutoscaler. */
export interface IoK8sApiAutoscalingV2HorizontalPodAutoscalerSpec {
  behavior?: HorizontalPodAutoscalerBehavior;
  maxReplicas: number;
  metrics?: MetricSpec[];
  minReplicas?: number;
  scaleTargetRef: IoK8sApiAutoscalingV2CrossVersionObjectReference;
}
/* io.k8s.api.autoscaling.v2.HorizontalPodAutoscalerStatus */
/* HorizontalPodAutoscalerStatus describes the current status of a horizontal pod autoscaler. */
export interface IoK8sApiAutoscalingV2HorizontalPodAutoscalerStatus {
  conditions?: HorizontalPodAutoscalerCondition[];
  currentMetrics?: MetricStatus[];
  currentReplicas?: number;
  desiredReplicas: number;
  lastScaleTime?: Time;
  observedGeneration?: number;
}
/* io.k8s.api.autoscaling.v2.MetricIdentifier */
/* MetricIdentifier defines the name and optionally selector for a metric */
export interface MetricIdentifier {
  name: string;
  selector?: LabelSelector;
}
/* io.k8s.api.autoscaling.v2.MetricSpec */
/* MetricSpec specifies how to scale based on a single metric (only `type` and one other matching field should be set at once). */
export interface MetricSpec {
  containerResource?: ContainerResourceMetricSource;
  external?: ExternalMetricSource;
  object?: ObjectMetricSource;
  pods?: PodsMetricSource;
  resource?: ResourceMetricSource;
  type: string;
}
/* io.k8s.api.autoscaling.v2.MetricStatus */
/* MetricStatus describes the last-read state of a single metric. */
export interface MetricStatus {
  containerResource?: ContainerResourceMetricStatus;
  external?: ExternalMetricStatus;
  object?: ObjectMetricStatus;
  pods?: PodsMetricStatus;
  resource?: ResourceMetricStatus;
  type: string;
}
/* io.k8s.api.autoscaling.v2.MetricTarget */
/* MetricTarget defines the target value, average value, or average utilization of a specific metric */
export interface MetricTarget {
  averageUtilization?: number;
  averageValue?: Quantity;
  type: string;
  value?: Quantity;
}
/* io.k8s.api.autoscaling.v2.MetricValueStatus */
/* MetricValueStatus holds the current value for a metric */
export interface MetricValueStatus {
  averageUtilization?: number;
  averageValue?: Quantity;
  value?: Quantity;
}
/* io.k8s.api.autoscaling.v2.ObjectMetricSource */
/* ObjectMetricSource indicates how to scale on a metric describing a kubernetes object (for example, hits-per-second on an Ingress object). */
export interface ObjectMetricSource {
  describedObject: IoK8sApiAutoscalingV2CrossVersionObjectReference;
  metric: MetricIdentifier;
  target: MetricTarget;
}
/* io.k8s.api.autoscaling.v2.ObjectMetricStatus */
/* ObjectMetricStatus indicates the current value of a metric describing a kubernetes object (for example, hits-per-second on an Ingress object). */
export interface ObjectMetricStatus {
  current: MetricValueStatus;
  describedObject: IoK8sApiAutoscalingV2CrossVersionObjectReference;
  metric: MetricIdentifier;
}
/* io.k8s.api.autoscaling.v2.PodsMetricSource */
/* PodsMetricSource indicates how to scale on a metric describing each pod in the current scale target (for example, transactions-processed-per-second). The values will be averaged together before being compared to the target value. */
export interface PodsMetricSource {
  metric: MetricIdentifier;
  target: MetricTarget;
}
/* io.k8s.api.autoscaling.v2.PodsMetricStatus */
/* PodsMetricStatus indicates the current value of a metric describing each pod in the current scale target (for example, transactions-processed-per-second). */
export interface PodsMetricStatus {
  current: MetricValueStatus;
  metric: MetricIdentifier;
}
/* io.k8s.api.autoscaling.v2.ResourceMetricSource */
/* ResourceMetricSource indicates how to scale on a resource metric known to Kubernetes, as specified in requests and limits, describing each pod in the current scale target (e.g. CPU or memory).  The values will be averaged together before being compared to the target.  Such metrics are built in to Kubernetes, and have special scaling options on top of those available to normal per-pod metrics using the "pods" source.  Only one "target" type should be set. */
export interface ResourceMetricSource {
  name: string;
  target: MetricTarget;
}
/* io.k8s.api.autoscaling.v2.ResourceMetricStatus */
/* ResourceMetricStatus indicates the current value of a resource metric known to Kubernetes, as specified in requests and limits, describing each pod in the current scale target (e.g. CPU or memory).  Such metrics are built in to Kubernetes, and have special scaling options on top of those available to normal per-pod metrics using the "pods" source. */
export interface ResourceMetricStatus {
  current: MetricValueStatus;
  name: string;
}
/* io.k8s.api.batch.v1.CronJob */
/* CronJob represents the configuration of a single cron job. */
export interface BatchV1CronJob {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: CronJobSpec;
  status?: CronJobStatus;
}
/* io.k8s.api.batch.v1.CronJobList */
/* CronJobList is a collection of cron jobs. */
export interface BatchV1CronJobList {
  apiVersion?: string;
  items: BatchV1CronJob[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.k8s.api.batch.v1.CronJobSpec */
/* CronJobSpec describes how the job execution will look like and when it will actually run. */
export interface CronJobSpec {
  concurrencyPolicy?: "Allow" | "Forbid" | "Replace";
  failedJobsHistoryLimit?: number;
  jobTemplate: JobTemplateSpec;
  schedule: string;
  startingDeadlineSeconds?: number;
  successfulJobsHistoryLimit?: number;
  suspend?: boolean;
  timeZone?: string;
}
/* io.k8s.api.batch.v1.CronJobStatus */
/* CronJobStatus represents the current state of a cron job. */
export interface CronJobStatus {
  active?: ObjectReference[];
  lastScheduleTime?: Time;
  lastSuccessfulTime?: Time;
}
/* io.k8s.api.batch.v1.Job */
/* Job represents the configuration of a single job. */
export interface BatchV1Job {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: JobSpec;
  status?: JobStatus;
}
/* io.k8s.api.batch.v1.JobCondition */
/* JobCondition describes current state of a job. */
export interface JobCondition {
  lastProbeTime?: Time;
  lastTransitionTime?: Time;
  message?: string;
  reason?: string;
  status: string;
  type: string;
}
/* io.k8s.api.batch.v1.JobList */
/* JobList is a collection of jobs. */
export interface BatchV1JobList {
  apiVersion?: string;
  items: BatchV1Job[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.k8s.api.batch.v1.JobSpec */
/* JobSpec describes how the job execution will look like. */
export interface JobSpec {
  activeDeadlineSeconds?: number;
  backoffLimit?: number;
  backoffLimitPerIndex?: number;
  completionMode?: "Indexed" | "NonIndexed";
  completions?: number;
  managedBy?: string;
  manualSelector?: boolean;
  maxFailedIndexes?: number;
  parallelism?: number;
  podFailurePolicy?: PodFailurePolicy;
  podReplacementPolicy?: "Failed" | "TerminatingOrFailed";
  selector?: LabelSelector;
  successPolicy?: SuccessPolicy;
  suspend?: boolean;
  template: PodTemplateSpec;
  ttlSecondsAfterFinished?: number;
}
/* io.k8s.api.batch.v1.JobStatus */
/* JobStatus represents the current state of a Job. */
export interface JobStatus {
  active?: number;
  completedIndexes?: string;
  completionTime?: Time;
  conditions?: JobCondition[];
  failed?: number;
  failedIndexes?: string;
  ready?: number;
  startTime?: Time;
  succeeded?: number;
  terminating?: number;
  uncountedTerminatedPods?: UncountedTerminatedPods;
}
/* io.k8s.api.batch.v1.JobTemplateSpec */
/* JobTemplateSpec describes the data a Job should have when created from a template */
export interface JobTemplateSpec {
  metadata?: ObjectMeta;
  spec?: JobSpec;
}
/* io.k8s.api.batch.v1.PodFailurePolicy */
/* PodFailurePolicy describes how failed pods influence the backoffLimit. */
export interface PodFailurePolicy {
  rules: PodFailurePolicyRule[];
}
/* io.k8s.api.batch.v1.PodFailurePolicyOnExitCodesRequirement */
/* PodFailurePolicyOnExitCodesRequirement describes the requirement for handling a failed pod based on its container exit codes. In particular, it lookups the .state.terminated.exitCode for each app container and init container status, represented by the .status.containerStatuses and .status.initContainerStatuses fields in the Pod status, respectively. Containers completed with success (exit code 0) are excluded from the requirement check. */
export interface PodFailurePolicyOnExitCodesRequirement {
  containerName?: string;
  operator: "In" | "NotIn";
  values: number[];
}
/* io.k8s.api.batch.v1.PodFailurePolicyOnPodConditionsPattern */
/* PodFailurePolicyOnPodConditionsPattern describes a pattern for matching an actual pod condition type. */
export interface PodFailurePolicyOnPodConditionsPattern {
  status: string;
  type: string;
}
/* io.k8s.api.batch.v1.PodFailurePolicyRule */
/* PodFailurePolicyRule describes how a pod failure is handled when the requirements are met. One of onExitCodes and onPodConditions, but not both, can be used in each rule. */
export interface PodFailurePolicyRule {
  action: "Count" | "FailIndex" | "FailJob" | "Ignore";
  onExitCodes?: PodFailurePolicyOnExitCodesRequirement;
  onPodConditions?: PodFailurePolicyOnPodConditionsPattern[];
}
/* io.k8s.api.batch.v1.SuccessPolicy */
/* SuccessPolicy describes when a Job can be declared as succeeded based on the success of some indexes. */
export interface SuccessPolicy {
  rules: SuccessPolicyRule[];
}
/* io.k8s.api.batch.v1.SuccessPolicyRule */
/* SuccessPolicyRule describes rule for declaring a Job as succeeded. Each rule must have at least one of the "succeededIndexes" or "succeededCount" specified. */
export interface SuccessPolicyRule {
  succeededCount?: number;
  succeededIndexes?: string;
}
/* io.k8s.api.batch.v1.UncountedTerminatedPods */
/* UncountedTerminatedPods holds UIDs of Pods that have terminated but haven't been accounted in Job status counters. */
export interface UncountedTerminatedPods {
  failed?: string[];
  succeeded?: string[];
}
/* io.k8s.api.certificates.v1.CertificateSigningRequest */
/* CertificateSigningRequest objects provide a mechanism to obtain x509 certificates by submitting a certificate signing request, and having it asynchronously approved and issued.

Kubelets use this API to obtain:
 1. client certificates to authenticate to kube-apiserver (with the "kubernetes.io/kube-apiserver-client-kubelet" signerName).
 2. serving certificates for TLS endpoints kube-apiserver can connect to securely (with the "kubernetes.io/kubelet-serving" signerName).

This API can be used to request client certificates to authenticate to kube-apiserver (with the "kubernetes.io/kube-apiserver-client" signerName), or to obtain certificates from custom non-Kubernetes signers. */
export interface CertificatesK8sIoV1CertificateSigningRequest {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec: CertificateSigningRequestSpec;
  status?: CertificateSigningRequestStatus;
}
/* io.k8s.api.certificates.v1.CertificateSigningRequestCondition */
/* CertificateSigningRequestCondition describes a condition of a CertificateSigningRequest object */
export interface CertificateSigningRequestCondition {
  lastTransitionTime?: Time;
  lastUpdateTime?: Time;
  message?: string;
  reason?: string;
  status: string;
  type: string;
}
/* io.k8s.api.certificates.v1.CertificateSigningRequestList */
/* CertificateSigningRequestList is a collection of CertificateSigningRequest objects */
export interface CertificatesK8sIoV1CertificateSigningRequestList {
  apiVersion?: string;
  items: CertificatesK8sIoV1CertificateSigningRequest[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.k8s.api.certificates.v1.CertificateSigningRequestSpec */
/* CertificateSigningRequestSpec contains the certificate request. */
export interface CertificateSigningRequestSpec {
  expirationSeconds?: number;
  extra?: {
    [key: string]: unknown;
  };
  groups?: string[];
  request: string;
  signerName: string;
  uid?: string;
  usages?: ("any" | "cert sign" | "client auth" | "code signing" | "content commitment" | "crl sign" | "data encipherment" | "decipher only" | "digital signature" | "email protection" | "encipher only" | "ipsec end system" | "ipsec tunnel" | "ipsec user" | "key agreement" | "key encipherment" | "microsoft sgc" | "netscape sgc" | "ocsp signing" | "s/mime" | "server auth" | "signing" | "timestamping")[];
  username?: string;
}
/* io.k8s.api.certificates.v1.CertificateSigningRequestStatus */
/* CertificateSigningRequestStatus contains conditions used to indicate approved/denied/failed status of the request, and the issued certificate. */
export interface CertificateSigningRequestStatus {
  certificate?: string;
  conditions?: CertificateSigningRequestCondition[];
}
/* io.k8s.api.coordination.v1.Lease */
/* Lease defines a lease concept. */
export interface CoordinationK8sIoV1Lease {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: LeaseSpec;
}
/* io.k8s.api.coordination.v1.LeaseList */
/* LeaseList is a list of Lease objects. */
export interface CoordinationK8sIoV1LeaseList {
  apiVersion?: string;
  items: CoordinationK8sIoV1Lease[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.k8s.api.coordination.v1.LeaseSpec */
/* LeaseSpec is a specification of a Lease. */
export interface LeaseSpec {
  acquireTime?: MicroTime;
  holderIdentity?: string;
  leaseDurationSeconds?: number;
  leaseTransitions?: number;
  preferredHolder?: string;
  renewTime?: MicroTime;
  strategy?: string;
}
/* io.k8s.api.core.v1.AWSElasticBlockStoreVolumeSource */
/* Represents a Persistent Disk resource in AWS.

An AWS EBS disk must exist before mounting to a container. The disk must also be in the same AWS zone as the kubelet. An AWS EBS disk can only be mounted as read/write once. AWS EBS volumes support ownership management and SELinux relabeling. */
export interface AWSElasticBlockStoreVolumeSource {
  fsType?: string;
  partition?: number;
  readOnly?: boolean;
  volumeID: string;
}
/* io.k8s.api.core.v1.Affinity */
/* Affinity is a group of affinity scheduling rules. */
export interface Affinity {
  nodeAffinity?: NodeAffinity;
  podAffinity?: PodAffinity;
  podAntiAffinity?: PodAntiAffinity;
}
/* io.k8s.api.core.v1.AppArmorProfile */
/* AppArmorProfile defines a pod or container's AppArmor settings. */
export interface AppArmorProfile {
  localhostProfile?: string;
  type: "Localhost" | "RuntimeDefault" | "Unconfined";
}
/* io.k8s.api.core.v1.AttachedVolume */
/* AttachedVolume describes a volume attached to a node */
export interface AttachedVolume {
  devicePath: string;
  name: string;
}
/* io.k8s.api.core.v1.AzureDiskVolumeSource */
/* AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod. */
export interface AzureDiskVolumeSource {
  cachingMode?: "None" | "ReadOnly" | "ReadWrite";
  diskName: string;
  diskURI: string;
  fsType?: string;
  kind?: "Dedicated" | "Managed" | "Shared";
  readOnly?: boolean;
}
/* io.k8s.api.core.v1.AzureFilePersistentVolumeSource */
/* AzureFile represents an Azure File Service mount on the host and bind mount to the pod. */
export interface AzureFilePersistentVolumeSource {
  readOnly?: boolean;
  secretName: string;
  secretNamespace?: string;
  shareName: string;
}
/* io.k8s.api.core.v1.AzureFileVolumeSource */
/* AzureFile represents an Azure File Service mount on the host and bind mount to the pod. */
export interface AzureFileVolumeSource {
  readOnly?: boolean;
  secretName: string;
  shareName: string;
}
/* io.k8s.api.core.v1.Binding */
/* Binding ties one object to another; for example, a pod is bound to a node by a scheduler. */
export interface Binding {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  target: ObjectReference;
}
/* io.k8s.api.core.v1.CSIPersistentVolumeSource */
/* Represents storage that is managed by an external CSI volume driver */
export interface CSIPersistentVolumeSource {
  controllerExpandSecretRef?: SecretReference;
  controllerPublishSecretRef?: SecretReference;
  driver: string;
  fsType?: string;
  nodeExpandSecretRef?: SecretReference;
  nodePublishSecretRef?: SecretReference;
  nodeStageSecretRef?: SecretReference;
  readOnly?: boolean;
  volumeAttributes?: {
    [key: string]: unknown;
  };
  volumeHandle: string;
}
/* io.k8s.api.core.v1.CSIVolumeSource */
/* Represents a source location of a volume to mount, managed by an external CSI driver */
export interface CSIVolumeSource {
  driver: string;
  fsType?: string;
  nodePublishSecretRef?: LocalObjectReference;
  readOnly?: boolean;
  volumeAttributes?: {
    [key: string]: unknown;
  };
}
/* io.k8s.api.core.v1.Capabilities */
/* Adds and removes POSIX capabilities from running containers. */
export interface Capabilities {
  add?: string[];
  drop?: string[];
}
/* io.k8s.api.core.v1.CephFSPersistentVolumeSource */
/* Represents a Ceph Filesystem mount that lasts the lifetime of a pod Cephfs volumes do not support ownership management or SELinux relabeling. */
export interface CephFSPersistentVolumeSource {
  monitors: string[];
  path?: string;
  readOnly?: boolean;
  secretFile?: string;
  secretRef?: SecretReference;
  user?: string;
}
/* io.k8s.api.core.v1.CephFSVolumeSource */
/* Represents a Ceph Filesystem mount that lasts the lifetime of a pod Cephfs volumes do not support ownership management or SELinux relabeling. */
export interface CephFSVolumeSource {
  monitors: string[];
  path?: string;
  readOnly?: boolean;
  secretFile?: string;
  secretRef?: LocalObjectReference;
  user?: string;
}
/* io.k8s.api.core.v1.CinderPersistentVolumeSource */
/* Represents a cinder volume resource in Openstack. A Cinder volume must exist before mounting to a container. The volume must also be in the same region as the kubelet. Cinder volumes support ownership management and SELinux relabeling. */
export interface CinderPersistentVolumeSource {
  fsType?: string;
  readOnly?: boolean;
  secretRef?: SecretReference;
  volumeID: string;
}
/* io.k8s.api.core.v1.CinderVolumeSource */
/* Represents a cinder volume resource in Openstack. A Cinder volume must exist before mounting to a container. The volume must also be in the same region as the kubelet. Cinder volumes support ownership management and SELinux relabeling. */
export interface CinderVolumeSource {
  fsType?: string;
  readOnly?: boolean;
  secretRef?: LocalObjectReference;
  volumeID: string;
}
/* io.k8s.api.core.v1.ClientIPConfig */
/* ClientIPConfig represents the configurations of Client IP based session affinity. */
export interface ClientIPConfig {
  timeoutSeconds?: number;
}
/* io.k8s.api.core.v1.ClusterTrustBundleProjection */
/* ClusterTrustBundleProjection describes how to select a set of ClusterTrustBundle objects and project their contents into the pod filesystem. */
export interface ClusterTrustBundleProjection {
  labelSelector?: LabelSelector;
  name?: string;
  optional?: boolean;
  path: string;
  signerName?: string;
}
/* io.k8s.api.core.v1.ComponentCondition */
/* Information about the condition of a component. */
export interface ComponentCondition {
  error?: string;
  message?: string;
  status: string;
  type: string;
}
/* io.k8s.api.core.v1.ComponentStatus */
/* ComponentStatus (and ComponentStatusList) holds the cluster validation info. Deprecated: This API is deprecated in v1.19+ */
export interface ComponentStatus {
  apiVersion?: string;
  conditions?: ComponentCondition[];
  kind?: string;
  metadata?: ObjectMeta;
}
/* io.k8s.api.core.v1.ComponentStatusList */
/* Status of all the conditions for the component as a list of ComponentStatus objects. Deprecated: This API is deprecated in v1.19+ */
export interface ComponentStatusList {
  apiVersion?: string;
  items: ComponentStatus[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.k8s.api.core.v1.ConfigMap */
/* ConfigMap holds configuration data for pods to consume. */
export interface ConfigMap {
  apiVersion?: string;
  binaryData?: {
    [key: string]: unknown;
  };
  data?: {
    [key: string]: unknown;
  };
  immutable?: boolean;
  kind?: string;
  metadata?: ObjectMeta;
}
/* io.k8s.api.core.v1.ConfigMapEnvSource */
/* ConfigMapEnvSource selects a ConfigMap to populate the environment variables with.

The contents of the target ConfigMap's Data field will represent the key-value pairs as environment variables. */
export interface ConfigMapEnvSource {
  name?: string;
  optional?: boolean;
}
/* io.k8s.api.core.v1.ConfigMapKeySelector */
/* Selects a key from a ConfigMap. */
export interface ConfigMapKeySelector {
  key: string;
  name?: string;
  optional?: boolean;
}
/* io.k8s.api.core.v1.ConfigMapList */
/* ConfigMapList is a resource containing a list of ConfigMap objects. */
export interface ConfigMapList {
  apiVersion?: string;
  items: ConfigMap[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.k8s.api.core.v1.ConfigMapNodeConfigSource */
/* ConfigMapNodeConfigSource contains the information to reference a ConfigMap as a config source for the Node. This API is deprecated since 1.22: https://git.k8s.io/enhancements/keps/sig-node/281-dynamic-kubelet-configuration */
export interface ConfigMapNodeConfigSource {
  kubeletConfigKey: string;
  name: string;
  namespace: string;
  resourceVersion?: string;
  uid?: string;
}
/* io.k8s.api.core.v1.ConfigMapProjection */
/* Adapts a ConfigMap into a projected volume.

The contents of the target ConfigMap's Data field will be presented in a projected volume as files using the keys in the Data field as the file names, unless the items element is populated with specific mappings of keys to paths. Note that this is identical to a configmap volume source without the default mode. */
export interface ConfigMapProjection {
  items?: KeyToPath[];
  name?: string;
  optional?: boolean;
}
/* io.k8s.api.core.v1.ConfigMapVolumeSource */
/* Adapts a ConfigMap into a volume.

The contents of the target ConfigMap's Data field will be presented in a volume as files using the keys in the Data field as the file names, unless the items element is populated with specific mappings of keys to paths. ConfigMap volumes support ownership management and SELinux relabeling. */
export interface ConfigMapVolumeSource {
  defaultMode?: number;
  items?: KeyToPath[];
  name?: string;
  optional?: boolean;
}
/* io.k8s.api.core.v1.Container */
/* A single application container that you want to run within a pod. */
export interface Container {
  args?: string[];
  command?: string[];
  env?: EnvVar[];
  envFrom?: EnvFromSource[];
  image?: string;
  imagePullPolicy?: "Always" | "IfNotPresent" | "Never";
  lifecycle?: Lifecycle;
  livenessProbe?: IoK8sApiCoreV1Probe;
  name: string;
  ports?: ContainerPort[];
  readinessProbe?: IoK8sApiCoreV1Probe;
  resizePolicy?: ContainerResizePolicy[];
  resources?: ResourceRequirements;
  restartPolicy?: string;
  securityContext?: SecurityContext;
  startupProbe?: IoK8sApiCoreV1Probe;
  stdin?: boolean;
  stdinOnce?: boolean;
  terminationMessagePath?: string;
  terminationMessagePolicy?: "FallbackToLogsOnError" | "File";
  tty?: boolean;
  volumeDevices?: VolumeDevice[];
  volumeMounts?: VolumeMount[];
  workingDir?: string;
}
/* io.k8s.api.core.v1.ContainerImage */
/* Describe a container image */
export interface ContainerImage {
  names?: string[];
  sizeBytes?: number;
}
/* io.k8s.api.core.v1.ContainerPort */
/* ContainerPort represents a network port in a single container. */
export interface ContainerPort {
  containerPort: number;
  hostIP?: string;
  hostPort?: number;
  name?: string;
  protocol?: "SCTP" | "TCP" | "UDP";
}
/* io.k8s.api.core.v1.ContainerResizePolicy */
/* ContainerResizePolicy represents resource resize policy for the container. */
export interface ContainerResizePolicy {
  resourceName: string;
  restartPolicy: string;
}
/* io.k8s.api.core.v1.ContainerState */
/* ContainerState holds a possible state of container. Only one of its members may be specified. If none of them is specified, the default one is ContainerStateWaiting. */
export interface ContainerState {
  running?: ContainerStateRunning;
  terminated?: ContainerStateTerminated;
  waiting?: ContainerStateWaiting;
}
/* io.k8s.api.core.v1.ContainerStateRunning */
/* ContainerStateRunning is a running state of a container. */
export interface ContainerStateRunning {
  startedAt?: Time;
}
/* io.k8s.api.core.v1.ContainerStateTerminated */
/* ContainerStateTerminated is a terminated state of a container. */
export interface ContainerStateTerminated {
  containerID?: string;
  exitCode: number;
  finishedAt?: Time;
  message?: string;
  reason?: string;
  signal?: number;
  startedAt?: Time;
}
/* io.k8s.api.core.v1.ContainerStateWaiting */
/* ContainerStateWaiting is a waiting state of a container. */
export interface ContainerStateWaiting {
  message?: string;
  reason?: string;
}
/* io.k8s.api.core.v1.ContainerStatus */
/* ContainerStatus contains details for the current status of this container. */
export interface ContainerStatus {
  allocatedResources?: {
    [key: string]: unknown;
  };
  allocatedResourcesStatus?: ResourceStatus[];
  containerID?: string;
  image: string;
  imageID: string;
  lastState?: ContainerState;
  name: string;
  ready: boolean;
  resources?: ResourceRequirements;
  restartCount: number;
  started?: boolean;
  state?: ContainerState;
  user?: ContainerUser;
  volumeMounts?: VolumeMountStatus[];
}
/* io.k8s.api.core.v1.ContainerUser */
/* ContainerUser represents user identity information */
export interface ContainerUser {
  linux?: LinuxContainerUser;
}
/* io.k8s.api.core.v1.DaemonEndpoint */
/* DaemonEndpoint contains information about a single Daemon endpoint. */
export interface DaemonEndpoint {
  Port: number;
}
/* io.k8s.api.core.v1.DownwardAPIProjection */
/* Represents downward API info for projecting into a projected volume. Note that this is identical to a downwardAPI volume source without the default mode. */
export interface DownwardAPIProjection {
  items?: DownwardAPIVolumeFile[];
}
/* io.k8s.api.core.v1.DownwardAPIVolumeFile */
/* DownwardAPIVolumeFile represents information to create the file containing the pod field */
export interface DownwardAPIVolumeFile {
  fieldRef?: ObjectFieldSelector;
  mode?: number;
  path: string;
  resourceFieldRef?: ResourceFieldSelector;
}
/* io.k8s.api.core.v1.DownwardAPIVolumeSource */
/* DownwardAPIVolumeSource represents a volume containing downward API info. Downward API volumes support ownership management and SELinux relabeling. */
export interface DownwardAPIVolumeSource {
  defaultMode?: number;
  items?: DownwardAPIVolumeFile[];
}
/* io.k8s.api.core.v1.EmptyDirVolumeSource */
/* Represents an empty directory for a pod. Empty directory volumes support ownership management and SELinux relabeling. */
export interface EmptyDirVolumeSource {
  medium?: string;
  sizeLimit?: Quantity;
}
/* io.k8s.api.core.v1.EndpointAddress */
/* EndpointAddress is a tuple that describes single IP address. */
export interface EndpointAddress {
  hostname?: string;
  ip: string;
  nodeName?: string;
  targetRef?: ObjectReference;
}
/* io.k8s.api.core.v1.EndpointPort */
/* EndpointPort is a tuple that describes a single port. */
export interface IoK8sApiCoreV1EndpointPort {
  appProtocol?: string;
  name?: string;
  port: number;
  protocol?: "SCTP" | "TCP" | "UDP";
}
/* io.k8s.api.core.v1.EndpointSubset */
/* EndpointSubset is a group of addresses with a common set of ports. The expanded set of endpoints is the Cartesian product of Addresses x Ports. For example, given:

	{
	  Addresses: [{"ip": "10.10.1.1"}, {"ip": "10.10.2.2"}],
	  Ports:     [{"name": "a", "port": 8675}, {"name": "b", "port": 309}]
	}

The resulting set of endpoints can be viewed as:

	a: [ 10.10.1.1:8675, 10.10.2.2:8675 ],
	b: [ 10.10.1.1:309, 10.10.2.2:309 ] */
export interface EndpointSubset {
  addresses?: EndpointAddress[];
  notReadyAddresses?: EndpointAddress[];
  ports?: IoK8sApiCoreV1EndpointPort[];
}
/* io.k8s.api.core.v1.Endpoints */
/* Endpoints is a collection of endpoints that implement the actual service. Example:

	 Name: "mysvc",
	 Subsets: [
	   {
	     Addresses: [{"ip": "10.10.1.1"}, {"ip": "10.10.2.2"}],
	     Ports: [{"name": "a", "port": 8675}, {"name": "b", "port": 309}]
	   },
	   {
	     Addresses: [{"ip": "10.10.3.3"}],
	     Ports: [{"name": "a", "port": 93}, {"name": "b", "port": 76}]
	   },
	] */
export interface Endpoints {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  subsets?: EndpointSubset[];
}
/* io.k8s.api.core.v1.EndpointsList */
/* EndpointsList is a list of endpoints. */
export interface EndpointsList {
  apiVersion?: string;
  items: Endpoints[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.k8s.api.core.v1.EnvFromSource */
/* EnvFromSource represents the source of a set of ConfigMaps */
export interface EnvFromSource {
  configMapRef?: ConfigMapEnvSource;
  prefix?: string;
  secretRef?: SecretEnvSource;
}
/* io.k8s.api.core.v1.EnvVar */
/* EnvVar represents an environment variable present in a Container. */
export interface EnvVar {
  name: string;
  value?: string;
  valueFrom?: EnvVarSource;
}
/* io.k8s.api.core.v1.EnvVarSource */
/* EnvVarSource represents a source for the value of an EnvVar. */
export interface EnvVarSource {
  configMapKeyRef?: ConfigMapKeySelector;
  fieldRef?: ObjectFieldSelector;
  resourceFieldRef?: ResourceFieldSelector;
  secretKeyRef?: SecretKeySelector;
}
/* io.k8s.api.core.v1.EphemeralContainer */
/* An EphemeralContainer is a temporary container that you may add to an existing Pod for user-initiated activities such as debugging. Ephemeral containers have no resource or scheduling guarantees, and they will not be restarted when they exit or when a Pod is removed or restarted. The kubelet may evict a Pod if an ephemeral container causes the Pod to exceed its resource allocation.

To add an ephemeral container, use the ephemeralcontainers subresource of an existing Pod. Ephemeral containers may not be removed or restarted. */
export interface EphemeralContainer {
  args?: string[];
  command?: string[];
  env?: EnvVar[];
  envFrom?: EnvFromSource[];
  image?: string;
  imagePullPolicy?: "Always" | "IfNotPresent" | "Never";
  lifecycle?: Lifecycle;
  livenessProbe?: IoK8sApiCoreV1Probe;
  name: string;
  ports?: ContainerPort[];
  readinessProbe?: IoK8sApiCoreV1Probe;
  resizePolicy?: ContainerResizePolicy[];
  resources?: ResourceRequirements;
  restartPolicy?: string;
  securityContext?: SecurityContext;
  startupProbe?: IoK8sApiCoreV1Probe;
  stdin?: boolean;
  stdinOnce?: boolean;
  targetContainerName?: string;
  terminationMessagePath?: string;
  terminationMessagePolicy?: "FallbackToLogsOnError" | "File";
  tty?: boolean;
  volumeDevices?: VolumeDevice[];
  volumeMounts?: VolumeMount[];
  workingDir?: string;
}
/* io.k8s.api.core.v1.EphemeralVolumeSource */
/* Represents an ephemeral volume that is handled by a normal storage driver. */
export interface EphemeralVolumeSource {
  volumeClaimTemplate?: PersistentVolumeClaimTemplate;
}
/* io.k8s.api.core.v1.Event */
/* Event is a report of an event somewhere in the cluster.  Events have a limited retention time and triggers and messages may evolve with time.  Event consumers should not rely on the timing of an event with a given Reason reflecting a consistent underlying trigger, or the continued existence of events with that Reason.  Events should be treated as informative, best-effort, supplemental data. */
export interface Event {
  action?: string;
  apiVersion?: string;
  count?: number;
  eventTime?: MicroTime;
  firstTimestamp?: Time;
  involvedObject: ObjectReference;
  kind?: string;
  lastTimestamp?: Time;
  message?: string;
  metadata: ObjectMeta;
  reason?: string;
  related?: ObjectReference;
  reportingComponent?: string;
  reportingInstance?: string;
  series?: IoK8sApiCoreV1EventSeries;
  source?: EventSource;
  type?: string;
}
/* io.k8s.api.core.v1.EventList */
/* EventList is a list of events. */
export interface EventList {
  apiVersion?: string;
  items: Event[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.k8s.api.core.v1.EventSeries */
/* EventSeries contain information on series of events, i.e. thing that was/is happening continuously for some time. */
export interface IoK8sApiCoreV1EventSeries {
  count?: number;
  lastObservedTime?: MicroTime;
}
/* io.k8s.api.core.v1.EventSource */
/* EventSource contains information for an event. */
export interface EventSource {
  component?: string;
  host?: string;
}
/* io.k8s.api.core.v1.ExecAction */
/* ExecAction describes a "run in container" action. */
export interface ExecAction {
  command?: string[];
}
/* io.k8s.api.core.v1.FCVolumeSource */
/* Represents a Fibre Channel volume. Fibre Channel volumes can only be mounted as read/write once. Fibre Channel volumes support ownership management and SELinux relabeling. */
export interface FCVolumeSource {
  fsType?: string;
  lun?: number;
  readOnly?: boolean;
  targetWWNs?: string[];
  wwids?: string[];
}
/* io.k8s.api.core.v1.FlexPersistentVolumeSource */
/* FlexPersistentVolumeSource represents a generic persistent volume resource that is provisioned/attached using an exec based plugin. */
export interface FlexPersistentVolumeSource {
  driver: string;
  fsType?: string;
  options?: {
    [key: string]: unknown;
  };
  readOnly?: boolean;
  secretRef?: SecretReference;
}
/* io.k8s.api.core.v1.FlexVolumeSource */
/* FlexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin. */
export interface FlexVolumeSource {
  driver: string;
  fsType?: string;
  options?: {
    [key: string]: unknown;
  };
  readOnly?: boolean;
  secretRef?: LocalObjectReference;
}
/* io.k8s.api.core.v1.FlockerVolumeSource */
/* Represents a Flocker volume mounted by the Flocker agent. One and only one of datasetName and datasetUUID should be set. Flocker volumes do not support ownership management or SELinux relabeling. */
export interface FlockerVolumeSource {
  datasetName?: string;
  datasetUUID?: string;
}
/* io.k8s.api.core.v1.GCEPersistentDiskVolumeSource */
/* Represents a Persistent Disk resource in Google Compute Engine.

A GCE PD must exist before mounting to a container. The disk must also be in the same GCE project and zone as the kubelet. A GCE PD can only be mounted as read/write once or read-only many times. GCE PDs support ownership management and SELinux relabeling. */
export interface GCEPersistentDiskVolumeSource {
  fsType?: string;
  partition?: number;
  pdName: string;
  readOnly?: boolean;
}
/* io.k8s.api.core.v1.GRPCAction */
/* GRPCAction specifies an action involving a GRPC service. */
export interface GRPCAction {
  port: number;
  service?: string;
}
/* io.k8s.api.core.v1.GitRepoVolumeSource */
/* Represents a volume that is populated with the contents of a git repository. Git repo volumes do not support ownership management. Git repo volumes support SELinux relabeling.

DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container. */
export interface GitRepoVolumeSource {
  directory?: string;
  repository: string;
  revision?: string;
}
/* io.k8s.api.core.v1.GlusterfsPersistentVolumeSource */
/* Represents a Glusterfs mount that lasts the lifetime of a pod. Glusterfs volumes do not support ownership management or SELinux relabeling. */
export interface GlusterfsPersistentVolumeSource {
  endpoints: string;
  endpointsNamespace?: string;
  path: string;
  readOnly?: boolean;
}
/* io.k8s.api.core.v1.GlusterfsVolumeSource */
/* Represents a Glusterfs mount that lasts the lifetime of a pod. Glusterfs volumes do not support ownership management or SELinux relabeling. */
export interface GlusterfsVolumeSource {
  endpoints: string;
  path: string;
  readOnly?: boolean;
}
/* io.k8s.api.core.v1.HTTPGetAction */
/* HTTPGetAction describes an action based on HTTP Get requests. */
export interface HTTPGetAction {
  host?: string;
  httpHeaders?: HTTPHeader[];
  path?: string;
  port: IntOrString;
  scheme?: "HTTP" | "HTTPS";
}
/* io.k8s.api.core.v1.HTTPHeader */
/* HTTPHeader describes a custom header to be used in HTTP probes */
export interface HTTPHeader {
  name: string;
  value: string;
}
/* io.k8s.api.core.v1.HostAlias */
/* HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod's hosts file. */
export interface HostAlias {
  hostnames?: string[];
  ip: string;
}
/* io.k8s.api.core.v1.HostIP */
/* HostIP represents a single IP address allocated to the host. */
export interface HostIP {
  ip: string;
}
/* io.k8s.api.core.v1.HostPathVolumeSource */
/* Represents a host path mapped into a pod. Host path volumes do not support ownership management or SELinux relabeling. */
export interface HostPathVolumeSource {
  path: string;
  type?: "" | "BlockDevice" | "CharDevice" | "Directory" | "DirectoryOrCreate" | "File" | "FileOrCreate" | "Socket";
}
/* io.k8s.api.core.v1.ISCSIPersistentVolumeSource */
/* ISCSIPersistentVolumeSource represents an ISCSI disk. ISCSI volumes can only be mounted as read/write once. ISCSI volumes support ownership management and SELinux relabeling. */
export interface ISCSIPersistentVolumeSource {
  chapAuthDiscovery?: boolean;
  chapAuthSession?: boolean;
  fsType?: string;
  initiatorName?: string;
  iqn: string;
  iscsiInterface?: string;
  lun: number;
  portals?: string[];
  readOnly?: boolean;
  secretRef?: SecretReference;
  targetPortal: string;
}
/* io.k8s.api.core.v1.ISCSIVolumeSource */
/* Represents an ISCSI disk. ISCSI volumes can only be mounted as read/write once. ISCSI volumes support ownership management and SELinux relabeling. */
export interface ISCSIVolumeSource {
  chapAuthDiscovery?: boolean;
  chapAuthSession?: boolean;
  fsType?: string;
  initiatorName?: string;
  iqn: string;
  iscsiInterface?: string;
  lun: number;
  portals?: string[];
  readOnly?: boolean;
  secretRef?: LocalObjectReference;
  targetPortal: string;
}
/* io.k8s.api.core.v1.ImageVolumeSource */
/* ImageVolumeSource represents a image volume resource. */
export interface ImageVolumeSource {
  pullPolicy?: "Always" | "IfNotPresent" | "Never";
  reference?: string;
}
/* io.k8s.api.core.v1.KeyToPath */
/* Maps a string key to a path within a volume. */
export interface KeyToPath {
  key: string;
  mode?: number;
  path: string;
}
/* io.k8s.api.core.v1.Lifecycle */
/* Lifecycle describes actions that the management system should take in response to container lifecycle events. For the PostStart and PreStop lifecycle handlers, management of the container blocks until the action is complete, unless the container process fails, in which case the handler is aborted. */
export interface Lifecycle {
  postStart?: LifecycleHandler;
  preStop?: LifecycleHandler;
}
/* io.k8s.api.core.v1.LifecycleHandler */
/* LifecycleHandler defines a specific action that should be taken in a lifecycle hook. One and only one of the fields, except TCPSocket must be specified. */
export interface LifecycleHandler {
  exec?: ExecAction;
  httpGet?: HTTPGetAction;
  sleep?: SleepAction;
  tcpSocket?: TCPSocketAction;
}
/* io.k8s.api.core.v1.LimitRange */
/* LimitRange sets resource usage limits for each kind of resource in a Namespace. */
export interface LimitRange {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: LimitRangeSpec;
}
/* io.k8s.api.core.v1.LimitRangeItem */
/* LimitRangeItem defines a min/max usage limit for any resource that matches on kind. */
export interface LimitRangeItem {
  default?: {
    [key: string]: unknown;
  };
  defaultRequest?: {
    [key: string]: unknown;
  };
  max?: {
    [key: string]: unknown;
  };
  maxLimitRequestRatio?: {
    [key: string]: unknown;
  };
  min?: {
    [key: string]: unknown;
  };
  type: string;
}
/* io.k8s.api.core.v1.LimitRangeList */
/* LimitRangeList is a list of LimitRange items. */
export interface LimitRangeList {
  apiVersion?: string;
  items: LimitRange[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.k8s.api.core.v1.LimitRangeSpec */
/* LimitRangeSpec defines a min/max usage limit for resources that match on kind. */
export interface LimitRangeSpec {
  limits: LimitRangeItem[];
}
/* io.k8s.api.core.v1.LinuxContainerUser */
/* LinuxContainerUser represents user identity information in Linux containers */
export interface LinuxContainerUser {
  gid: number;
  supplementalGroups?: number[];
  uid: number;
}
/* io.k8s.api.core.v1.LoadBalancerIngress */
/* LoadBalancerIngress represents the status of a load-balancer ingress point: traffic intended for the service should be sent to an ingress point. */
export interface LoadBalancerIngress {
  hostname?: string;
  ip?: string;
  ipMode?: string;
  ports?: PortStatus[];
}
/* io.k8s.api.core.v1.LoadBalancerStatus */
/* LoadBalancerStatus represents the status of a load-balancer. */
export interface LoadBalancerStatus {
  ingress?: LoadBalancerIngress[];
}
/* io.k8s.api.core.v1.LocalObjectReference */
/* LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace. */
export interface LocalObjectReference {
  name?: string;
}
/* io.k8s.api.core.v1.LocalVolumeSource */
/* Local represents directly-attached storage with node affinity */
export interface LocalVolumeSource {
  fsType?: string;
  path: string;
}
/* io.k8s.api.core.v1.ModifyVolumeStatus */
/* ModifyVolumeStatus represents the status object of ControllerModifyVolume operation */
export interface ModifyVolumeStatus {
  status: "InProgress" | "Infeasible" | "Pending";
  targetVolumeAttributesClassName?: string;
}
/* io.k8s.api.core.v1.NFSVolumeSource */
/* Represents an NFS mount that lasts the lifetime of a pod. NFS volumes do not support ownership management or SELinux relabeling. */
export interface NFSVolumeSource {
  path: string;
  readOnly?: boolean;
  server: string;
}
/* io.k8s.api.core.v1.Namespace */
/* Namespace provides a scope for Names. Use of multiple namespaces is optional. */
export interface Namespace {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: NamespaceSpec;
  status?: NamespaceStatus;
}
/* io.k8s.api.core.v1.NamespaceCondition */
/* NamespaceCondition contains details about state of namespace. */
export interface NamespaceCondition {
  lastTransitionTime?: Time;
  message?: string;
  reason?: string;
  status: string;
  type: string;
}
/* io.k8s.api.core.v1.NamespaceList */
/* NamespaceList is a list of Namespaces. */
export interface NamespaceList {
  apiVersion?: string;
  items: Namespace[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.k8s.api.core.v1.NamespaceSpec */
/* NamespaceSpec describes the attributes on a Namespace. */
export interface NamespaceSpec {
  finalizers?: string[];
}
/* io.k8s.api.core.v1.NamespaceStatus */
/* NamespaceStatus is information about the current status of a Namespace. */
export interface NamespaceStatus {
  conditions?: NamespaceCondition[];
  phase?: "Active" | "Terminating";
}
/* io.k8s.api.core.v1.Node */
/* Node is a worker node in Kubernetes. Each node will have a unique identifier in the cache (i.e. in etcd). */
export interface Node {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: NodeSpec;
  status?: NodeStatus;
}
/* io.k8s.api.core.v1.NodeAddress */
/* NodeAddress contains information for the node's address. */
export interface NodeAddress {
  address: string;
  type: string;
}
/* io.k8s.api.core.v1.NodeAffinity */
/* Node affinity is a group of node affinity scheduling rules. */
export interface NodeAffinity {
  preferredDuringSchedulingIgnoredDuringExecution?: PreferredSchedulingTerm[];
  requiredDuringSchedulingIgnoredDuringExecution?: NodeSelector;
}
/* io.k8s.api.core.v1.NodeCondition */
/* NodeCondition contains condition information for a node. */
export interface NodeCondition {
  lastHeartbeatTime?: Time;
  lastTransitionTime?: Time;
  message?: string;
  reason?: string;
  status: string;
  type: string;
}
/* io.k8s.api.core.v1.NodeConfigSource */
/* NodeConfigSource specifies a source of node configuration. Exactly one subfield (excluding metadata) must be non-nil. This API is deprecated since 1.22 */
export interface NodeConfigSource {
  configMap?: ConfigMapNodeConfigSource;
}
/* io.k8s.api.core.v1.NodeConfigStatus */
/* NodeConfigStatus describes the status of the config assigned by Node.Spec.ConfigSource. */
export interface NodeConfigStatus {
  active?: NodeConfigSource;
  assigned?: NodeConfigSource;
  error?: string;
  lastKnownGood?: NodeConfigSource;
}
/* io.k8s.api.core.v1.NodeDaemonEndpoints */
/* NodeDaemonEndpoints lists ports opened by daemons running on the Node. */
export interface NodeDaemonEndpoints {
  kubeletEndpoint?: DaemonEndpoint;
}
/* io.k8s.api.core.v1.NodeFeatures */
/* NodeFeatures describes the set of features implemented by the CRI implementation. The features contained in the NodeFeatures should depend only on the cri implementation independent of runtime handlers. */
export interface NodeFeatures {
  supplementalGroupsPolicy?: boolean;
}
/* io.k8s.api.core.v1.NodeList */
/* NodeList is the whole list of all Nodes which have been registered with master. */
export interface NodeList {
  apiVersion?: string;
  items: Node[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.k8s.api.core.v1.NodeRuntimeHandler */
/* NodeRuntimeHandler is a set of runtime handler information. */
export interface NodeRuntimeHandler {
  features?: NodeRuntimeHandlerFeatures;
  name?: string;
}
/* io.k8s.api.core.v1.NodeRuntimeHandlerFeatures */
/* NodeRuntimeHandlerFeatures is a set of features implemented by the runtime handler. */
export interface NodeRuntimeHandlerFeatures {
  recursiveReadOnlyMounts?: boolean;
  userNamespaces?: boolean;
}
/* io.k8s.api.core.v1.NodeSelector */
/* A node selector represents the union of the results of one or more label queries over a set of nodes; that is, it represents the OR of the selectors represented by the node selector terms. */
export interface NodeSelector {
  nodeSelectorTerms: NodeSelectorTerm[];
}
/* io.k8s.api.core.v1.NodeSelectorRequirement */
/* A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values. */
export interface NodeSelectorRequirement {
  key: string;
  operator: "DoesNotExist" | "Exists" | "Gt" | "In" | "Lt" | "NotIn";
  values?: string[];
}
/* io.k8s.api.core.v1.NodeSelectorTerm */
/* A null or empty node selector term matches no objects. The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm. */
export interface NodeSelectorTerm {
  matchExpressions?: NodeSelectorRequirement[];
  matchFields?: NodeSelectorRequirement[];
}
/* io.k8s.api.core.v1.NodeSpec */
/* NodeSpec describes the attributes that a node is created with. */
export interface NodeSpec {
  configSource?: NodeConfigSource;
  externalID?: string;
  podCIDR?: string;
  podCIDRs?: string[];
  providerID?: string;
  taints?: Taint[];
  unschedulable?: boolean;
}
/* io.k8s.api.core.v1.NodeStatus */
/* NodeStatus is information about the current status of a node. */
export interface NodeStatus {
  addresses?: NodeAddress[];
  allocatable?: {
    [key: string]: unknown;
  };
  capacity?: {
    [key: string]: unknown;
  };
  conditions?: NodeCondition[];
  config?: NodeConfigStatus;
  daemonEndpoints?: NodeDaemonEndpoints;
  features?: NodeFeatures;
  images?: ContainerImage[];
  nodeInfo?: NodeSystemInfo;
  phase?: "Pending" | "Running" | "Terminated";
  runtimeHandlers?: NodeRuntimeHandler[];
  volumesAttached?: AttachedVolume[];
  volumesInUse?: string[];
}
/* io.k8s.api.core.v1.NodeSystemInfo */
/* NodeSystemInfo is a set of ids/uuids to uniquely identify the node. */
export interface NodeSystemInfo {
  architecture: string;
  bootID: string;
  containerRuntimeVersion: string;
  kernelVersion: string;
  kubeProxyVersion: string;
  kubeletVersion: string;
  machineID: string;
  operatingSystem: string;
  osImage: string;
  systemUUID: string;
}
/* io.k8s.api.core.v1.ObjectFieldSelector */
/* ObjectFieldSelector selects an APIVersioned field of an object. */
export interface ObjectFieldSelector {
  apiVersion?: string;
  fieldPath: string;
}
/* io.k8s.api.core.v1.ObjectReference */
/* ObjectReference contains enough information to let you inspect or modify the referred object. */
export interface ObjectReference {
  apiVersion?: string;
  fieldPath?: string;
  kind?: string;
  name?: string;
  namespace?: string;
  resourceVersion?: string;
  uid?: string;
}
/* io.k8s.api.core.v1.PersistentVolume */
/* PersistentVolume (PV) is a storage resource provisioned by an administrator. It is analogous to a node. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes */
export interface PersistentVolume {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: PersistentVolumeSpec;
  status?: PersistentVolumeStatus;
}
/* io.k8s.api.core.v1.PersistentVolumeClaim */
/* PersistentVolumeClaim is a user's request for and claim to a persistent volume */
export interface PersistentVolumeClaim {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: PersistentVolumeClaimSpec;
  status?: PersistentVolumeClaimStatus;
}
/* io.k8s.api.core.v1.PersistentVolumeClaimCondition */
/* PersistentVolumeClaimCondition contains details about state of pvc */
export interface PersistentVolumeClaimCondition {
  lastProbeTime?: Time;
  lastTransitionTime?: Time;
  message?: string;
  reason?: string;
  status: string;
  type: string;
}
/* io.k8s.api.core.v1.PersistentVolumeClaimList */
/* PersistentVolumeClaimList is a list of PersistentVolumeClaim items. */
export interface PersistentVolumeClaimList {
  apiVersion?: string;
  items: PersistentVolumeClaim[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.k8s.api.core.v1.PersistentVolumeClaimSpec */
/* PersistentVolumeClaimSpec describes the common attributes of storage devices and allows a Source for provider-specific attributes */
export interface PersistentVolumeClaimSpec {
  accessModes?: ("ReadOnlyMany" | "ReadWriteMany" | "ReadWriteOnce" | "ReadWriteOncePod")[];
  dataSource?: TypedLocalObjectReference;
  dataSourceRef?: TypedObjectReference;
  resources?: VolumeResourceRequirements;
  selector?: LabelSelector;
  storageClassName?: string;
  volumeAttributesClassName?: string;
  volumeMode?: "Block" | "Filesystem";
  volumeName?: string;
}
/* io.k8s.api.core.v1.PersistentVolumeClaimStatus */
/* PersistentVolumeClaimStatus is the current status of a persistent volume claim. */
export interface PersistentVolumeClaimStatus {
  accessModes?: ("ReadOnlyMany" | "ReadWriteMany" | "ReadWriteOnce" | "ReadWriteOncePod")[];
  allocatedResourceStatuses?: {
    [key: string]: unknown;
  };
  allocatedResources?: {
    [key: string]: unknown;
  };
  capacity?: {
    [key: string]: unknown;
  };
  conditions?: PersistentVolumeClaimCondition[];
  currentVolumeAttributesClassName?: string;
  modifyVolumeStatus?: ModifyVolumeStatus;
  phase?: "Bound" | "Lost" | "Pending";
}
/* io.k8s.api.core.v1.PersistentVolumeClaimTemplate */
/* PersistentVolumeClaimTemplate is used to produce PersistentVolumeClaim objects as part of an EphemeralVolumeSource. */
export interface PersistentVolumeClaimTemplate {
  metadata?: ObjectMeta;
  spec: PersistentVolumeClaimSpec;
}
/* io.k8s.api.core.v1.PersistentVolumeClaimVolumeSource */
/* PersistentVolumeClaimVolumeSource references the user's PVC in the same namespace. This volume finds the bound PV and mounts that volume for the pod. A PersistentVolumeClaimVolumeSource is, essentially, a wrapper around another type of volume that is owned by someone else (the system). */
export interface PersistentVolumeClaimVolumeSource {
  claimName: string;
  readOnly?: boolean;
}
/* io.k8s.api.core.v1.PersistentVolumeList */
/* PersistentVolumeList is a list of PersistentVolume items. */
export interface PersistentVolumeList {
  apiVersion?: string;
  items: PersistentVolume[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.k8s.api.core.v1.PersistentVolumeSpec */
/* PersistentVolumeSpec is the specification of a persistent volume. */
export interface PersistentVolumeSpec {
  accessModes?: ("ReadOnlyMany" | "ReadWriteMany" | "ReadWriteOnce" | "ReadWriteOncePod")[];
  awsElasticBlockStore?: AWSElasticBlockStoreVolumeSource;
  azureDisk?: AzureDiskVolumeSource;
  azureFile?: AzureFilePersistentVolumeSource;
  capacity?: {
    [key: string]: unknown;
  };
  cephfs?: CephFSPersistentVolumeSource;
  cinder?: CinderPersistentVolumeSource;
  claimRef?: ObjectReference;
  csi?: CSIPersistentVolumeSource;
  fc?: FCVolumeSource;
  flexVolume?: FlexPersistentVolumeSource;
  flocker?: FlockerVolumeSource;
  gcePersistentDisk?: GCEPersistentDiskVolumeSource;
  glusterfs?: GlusterfsPersistentVolumeSource;
  hostPath?: HostPathVolumeSource;
  iscsi?: ISCSIPersistentVolumeSource;
  local?: LocalVolumeSource;
  mountOptions?: string[];
  nfs?: NFSVolumeSource;
  nodeAffinity?: VolumeNodeAffinity;
  persistentVolumeReclaimPolicy?: "Delete" | "Recycle" | "Retain";
  photonPersistentDisk?: PhotonPersistentDiskVolumeSource;
  portworxVolume?: PortworxVolumeSource;
  quobyte?: QuobyteVolumeSource;
  rbd?: RBDPersistentVolumeSource;
  scaleIO?: ScaleIOPersistentVolumeSource;
  storageClassName?: string;
  storageos?: StorageOSPersistentVolumeSource;
  volumeAttributesClassName?: string;
  volumeMode?: "Block" | "Filesystem";
  vsphereVolume?: VsphereVirtualDiskVolumeSource;
}
/* io.k8s.api.core.v1.PersistentVolumeStatus */
/* PersistentVolumeStatus is the current status of a persistent volume. */
export interface PersistentVolumeStatus {
  lastPhaseTransitionTime?: Time;
  message?: string;
  phase?: "Available" | "Bound" | "Failed" | "Pending" | "Released";
  reason?: string;
}
/* io.k8s.api.core.v1.PhotonPersistentDiskVolumeSource */
/* Represents a Photon Controller persistent disk resource. */
export interface PhotonPersistentDiskVolumeSource {
  fsType?: string;
  pdID: string;
}
/* io.k8s.api.core.v1.Pod */
/* Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts. */
export interface Pod {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: PodSpec;
  status?: PodStatus;
}
/* io.k8s.api.core.v1.PodAffinity */
/* Pod affinity is a group of inter pod affinity scheduling rules. */
export interface PodAffinity {
  preferredDuringSchedulingIgnoredDuringExecution?: WeightedPodAffinityTerm[];
  requiredDuringSchedulingIgnoredDuringExecution?: PodAffinityTerm[];
}
/* io.k8s.api.core.v1.PodAffinityTerm */
/* Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running */
export interface PodAffinityTerm {
  labelSelector?: LabelSelector;
  matchLabelKeys?: string[];
  mismatchLabelKeys?: string[];
  namespaceSelector?: LabelSelector;
  namespaces?: string[];
  topologyKey: string;
}
/* io.k8s.api.core.v1.PodAntiAffinity */
/* Pod anti affinity is a group of inter pod anti affinity scheduling rules. */
export interface PodAntiAffinity {
  preferredDuringSchedulingIgnoredDuringExecution?: WeightedPodAffinityTerm[];
  requiredDuringSchedulingIgnoredDuringExecution?: PodAffinityTerm[];
}
/* io.k8s.api.core.v1.PodCondition */
/* PodCondition contains details for the current condition of this pod. */
export interface PodCondition {
  lastProbeTime?: Time;
  lastTransitionTime?: Time;
  message?: string;
  reason?: string;
  status: string;
  type: string;
}
/* io.k8s.api.core.v1.PodDNSConfig */
/* PodDNSConfig defines the DNS parameters of a pod in addition to those generated from DNSPolicy. */
export interface PodDNSConfig {
  nameservers?: string[];
  options?: PodDNSConfigOption[];
  searches?: string[];
}
/* io.k8s.api.core.v1.PodDNSConfigOption */
/* PodDNSConfigOption defines DNS resolver options of a pod. */
export interface PodDNSConfigOption {
  name?: string;
  value?: string;
}
/* io.k8s.api.core.v1.PodIP */
/* PodIP represents a single IP address allocated to the pod. */
export interface PodIP {
  ip: string;
}
/* io.k8s.api.core.v1.PodList */
/* PodList is a list of Pods. */
export interface PodList {
  apiVersion?: string;
  items: Pod[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.k8s.api.core.v1.PodOS */
/* PodOS defines the OS parameters of a pod. */
export interface PodOS {
  name: string;
}
/* io.k8s.api.core.v1.PodReadinessGate */
/* PodReadinessGate contains the reference to a pod condition */
export interface PodReadinessGate {
  conditionType: string;
}
/* io.k8s.api.core.v1.PodResourceClaim */
/* PodResourceClaim references exactly one ResourceClaim, either directly or by naming a ResourceClaimTemplate which is then turned into a ResourceClaim for the pod.

It adds a name to it that uniquely identifies the ResourceClaim inside the Pod. Containers that need access to the ResourceClaim reference it with this name. */
export interface PodResourceClaim {
  name: string;
  resourceClaimName?: string;
  resourceClaimTemplateName?: string;
}
/* io.k8s.api.core.v1.PodResourceClaimStatus */
/* PodResourceClaimStatus is stored in the PodStatus for each PodResourceClaim which references a ResourceClaimTemplate. It stores the generated name for the corresponding ResourceClaim. */
export interface PodResourceClaimStatus {
  name: string;
  resourceClaimName?: string;
}
/* io.k8s.api.core.v1.PodSchedulingGate */
/* PodSchedulingGate is associated to a Pod to guard its scheduling. */
export interface PodSchedulingGate {
  name: string;
}
/* io.k8s.api.core.v1.PodSecurityContext */
/* PodSecurityContext holds pod-level security attributes and common container settings. Some fields are also present in container.securityContext.  Field values of container.securityContext take precedence over field values of PodSecurityContext. */
export interface PodSecurityContext {
  appArmorProfile?: AppArmorProfile;
  fsGroup?: number;
  fsGroupChangePolicy?: "Always" | "OnRootMismatch";
  runAsGroup?: number;
  runAsNonRoot?: boolean;
  runAsUser?: number;
  seLinuxChangePolicy?: string;
  seLinuxOptions?: SELinuxOptions;
  seccompProfile?: SeccompProfile;
  supplementalGroups?: number[];
  supplementalGroupsPolicy?: "Merge" | "Strict";
  sysctls?: Sysctl[];
  windowsOptions?: WindowsSecurityContextOptions;
}
/* io.k8s.api.core.v1.PodSpec */
/* PodSpec is a description of a pod. */
export interface PodSpec {
  activeDeadlineSeconds?: number;
  affinity?: Affinity;
  automountServiceAccountToken?: boolean;
  containers: Container[];
  dnsConfig?: PodDNSConfig;
  dnsPolicy?: "ClusterFirst" | "ClusterFirstWithHostNet" | "Default" | "None";
  enableServiceLinks?: boolean;
  ephemeralContainers?: EphemeralContainer[];
  hostAliases?: HostAlias[];
  hostIPC?: boolean;
  hostNetwork?: boolean;
  hostPID?: boolean;
  hostUsers?: boolean;
  hostname?: string;
  imagePullSecrets?: LocalObjectReference[];
  initContainers?: Container[];
  nodeName?: string;
  nodeSelector?: {
    [key: string]: unknown;
  };
  os?: PodOS;
  overhead?: {
    [key: string]: unknown;
  };
  preemptionPolicy?: "Never" | "PreemptLowerPriority";
  priority?: number;
  priorityClassName?: string;
  readinessGates?: PodReadinessGate[];
  resourceClaims?: PodResourceClaim[];
  resources?: ResourceRequirements;
  restartPolicy?: "Always" | "Never" | "OnFailure";
  runtimeClassName?: string;
  schedulerName?: string;
  schedulingGates?: PodSchedulingGate[];
  securityContext?: PodSecurityContext;
  serviceAccount?: string;
  serviceAccountName?: string;
  setHostnameAsFQDN?: boolean;
  shareProcessNamespace?: boolean;
  subdomain?: string;
  terminationGracePeriodSeconds?: number;
  tolerations?: Toleration[];
  topologySpreadConstraints?: TopologySpreadConstraint[];
  volumes?: Volume[];
}
/* io.k8s.api.core.v1.PodStatus */
/* PodStatus represents information about the status of a pod. Status may trail the actual state of a system, especially if the node that hosts the pod cannot contact the control plane. */
export interface PodStatus {
  conditions?: PodCondition[];
  containerStatuses?: ContainerStatus[];
  ephemeralContainerStatuses?: ContainerStatus[];
  hostIP?: string;
  hostIPs?: HostIP[];
  initContainerStatuses?: ContainerStatus[];
  message?: string;
  nominatedNodeName?: string;
  phase?: "Failed" | "Pending" | "Running" | "Succeeded" | "Unknown";
  podIP?: string;
  podIPs?: PodIP[];
  qosClass?: "BestEffort" | "Burstable" | "Guaranteed";
  reason?: string;
  resize?: string;
  resourceClaimStatuses?: PodResourceClaimStatus[];
  startTime?: Time;
}
/* io.k8s.api.core.v1.PodTemplate */
/* PodTemplate describes a template for creating copies of a predefined pod. */
export interface PodTemplate {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  template?: PodTemplateSpec;
}
/* io.k8s.api.core.v1.PodTemplateList */
/* PodTemplateList is a list of PodTemplates. */
export interface PodTemplateList {
  apiVersion?: string;
  items: PodTemplate[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.k8s.api.core.v1.PodTemplateSpec */
/* PodTemplateSpec describes the data a pod should have when created from a template */
export interface PodTemplateSpec {
  metadata?: ObjectMeta;
  spec?: PodSpec;
}
/* io.k8s.api.core.v1.PortStatus */
/* PortStatus represents the error condition of a service port */
export interface PortStatus {
  error?: string;
  port: number;
  protocol: "SCTP" | "TCP" | "UDP";
}
/* io.k8s.api.core.v1.PortworxVolumeSource */
/* PortworxVolumeSource represents a Portworx volume resource. */
export interface PortworxVolumeSource {
  fsType?: string;
  readOnly?: boolean;
  volumeID: string;
}
/* io.k8s.api.core.v1.PreferredSchedulingTerm */
/* An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op). */
export interface PreferredSchedulingTerm {
  preference: NodeSelectorTerm;
  weight: number;
}
/* io.k8s.api.core.v1.Probe */
/* Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic. */
export interface IoK8sApiCoreV1Probe {
  exec?: ExecAction;
  failureThreshold?: number;
  grpc?: GRPCAction;
  httpGet?: HTTPGetAction;
  initialDelaySeconds?: number;
  periodSeconds?: number;
  successThreshold?: number;
  tcpSocket?: TCPSocketAction;
  terminationGracePeriodSeconds?: number;
  timeoutSeconds?: number;
}
/* io.k8s.api.core.v1.ProjectedVolumeSource */
/* Represents a projected volume source */
export interface ProjectedVolumeSource {
  defaultMode?: number;
  sources?: VolumeProjection[];
}
/* io.k8s.api.core.v1.QuobyteVolumeSource */
/* Represents a Quobyte mount that lasts the lifetime of a pod. Quobyte volumes do not support ownership management or SELinux relabeling. */
export interface QuobyteVolumeSource {
  group?: string;
  readOnly?: boolean;
  registry: string;
  tenant?: string;
  user?: string;
  volume: string;
}
/* io.k8s.api.core.v1.RBDPersistentVolumeSource */
/* Represents a Rados Block Device mount that lasts the lifetime of a pod. RBD volumes support ownership management and SELinux relabeling. */
export interface RBDPersistentVolumeSource {
  fsType?: string;
  image: string;
  keyring?: string;
  monitors: string[];
  pool?: string;
  readOnly?: boolean;
  secretRef?: SecretReference;
  user?: string;
}
/* io.k8s.api.core.v1.RBDVolumeSource */
/* Represents a Rados Block Device mount that lasts the lifetime of a pod. RBD volumes support ownership management and SELinux relabeling. */
export interface RBDVolumeSource {
  fsType?: string;
  image: string;
  keyring?: string;
  monitors: string[];
  pool?: string;
  readOnly?: boolean;
  secretRef?: LocalObjectReference;
  user?: string;
}
/* io.k8s.api.core.v1.ReplicationController */
/* ReplicationController represents the configuration of a replication controller. */
export interface ReplicationController {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: ReplicationControllerSpec;
  status?: ReplicationControllerStatus;
}
/* io.k8s.api.core.v1.ReplicationControllerCondition */
/* ReplicationControllerCondition describes the state of a replication controller at a certain point. */
export interface ReplicationControllerCondition {
  lastTransitionTime?: Time;
  message?: string;
  reason?: string;
  status: string;
  type: string;
}
/* io.k8s.api.core.v1.ReplicationControllerList */
/* ReplicationControllerList is a collection of replication controllers. */
export interface ReplicationControllerList {
  apiVersion?: string;
  items: ReplicationController[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.k8s.api.core.v1.ReplicationControllerSpec */
/* ReplicationControllerSpec is the specification of a replication controller. */
export interface ReplicationControllerSpec {
  minReadySeconds?: number;
  replicas?: number;
  selector?: {
    [key: string]: unknown;
  };
  template?: PodTemplateSpec;
}
/* io.k8s.api.core.v1.ReplicationControllerStatus */
/* ReplicationControllerStatus represents the current status of a replication controller. */
export interface ReplicationControllerStatus {
  availableReplicas?: number;
  conditions?: ReplicationControllerCondition[];
  fullyLabeledReplicas?: number;
  observedGeneration?: number;
  readyReplicas?: number;
  replicas: number;
}
/* io.k8s.api.core.v1.ResourceClaim */
/* ResourceClaim references one entry in PodSpec.ResourceClaims. */
export interface ResourceClaim {
  name: string;
  request?: string;
}
/* io.k8s.api.core.v1.ResourceFieldSelector */
/* ResourceFieldSelector represents container resources (cpu, memory) and their output format */
export interface ResourceFieldSelector {
  containerName?: string;
  divisor?: Quantity;
  resource: string;
}
/* io.k8s.api.core.v1.ResourceHealth */
/* ResourceHealth represents the health of a resource. It has the latest device health information. This is a part of KEP https://kep.k8s.io/4680. */
export interface ResourceHealth {
  health?: string;
  resourceID: string;
}
/* io.k8s.api.core.v1.ResourceQuota */
/* ResourceQuota sets aggregate quota restrictions enforced per namespace */
export interface ResourceQuota {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: ResourceQuotaSpec;
  status?: ResourceQuotaStatus;
}
/* io.k8s.api.core.v1.ResourceQuotaList */
/* ResourceQuotaList is a list of ResourceQuota items. */
export interface ResourceQuotaList {
  apiVersion?: string;
  items: ResourceQuota[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.k8s.api.core.v1.ResourceQuotaSpec */
/* ResourceQuotaSpec defines the desired hard limits to enforce for Quota. */
export interface ResourceQuotaSpec {
  hard?: {
    [key: string]: unknown;
  };
  scopeSelector?: ScopeSelector;
  scopes?: ("BestEffort" | "CrossNamespacePodAffinity" | "NotBestEffort" | "NotTerminating" | "PriorityClass" | "Terminating")[];
}
/* io.k8s.api.core.v1.ResourceQuotaStatus */
/* ResourceQuotaStatus defines the enforced hard limits and observed use. */
export interface ResourceQuotaStatus {
  hard?: {
    [key: string]: unknown;
  };
  used?: {
    [key: string]: unknown;
  };
}
/* io.k8s.api.core.v1.ResourceRequirements */
/* ResourceRequirements describes the compute resource requirements. */
export interface ResourceRequirements {
  claims?: ResourceClaim[];
  limits?: {
    [key: string]: unknown;
  };
  requests?: {
    [key: string]: unknown;
  };
}
/* io.k8s.api.core.v1.ResourceStatus */
/* ResourceStatus represents the status of a single resource allocated to a Pod. */
export interface ResourceStatus {
  name: string;
  resources?: ResourceHealth[];
}
/* io.k8s.api.core.v1.SELinuxOptions */
/* SELinuxOptions are the labels to be applied to the container */
export interface SELinuxOptions {
  level?: string;
  role?: string;
  type?: string;
  user?: string;
}
/* io.k8s.api.core.v1.ScaleIOPersistentVolumeSource */
/* ScaleIOPersistentVolumeSource represents a persistent ScaleIO volume */
export interface ScaleIOPersistentVolumeSource {
  fsType?: string;
  gateway: string;
  protectionDomain?: string;
  readOnly?: boolean;
  secretRef: SecretReference;
  sslEnabled?: boolean;
  storageMode?: string;
  storagePool?: string;
  system: string;
  volumeName?: string;
}
/* io.k8s.api.core.v1.ScaleIOVolumeSource */
/* ScaleIOVolumeSource represents a persistent ScaleIO volume */
export interface ScaleIOVolumeSource {
  fsType?: string;
  gateway: string;
  protectionDomain?: string;
  readOnly?: boolean;
  secretRef: LocalObjectReference;
  sslEnabled?: boolean;
  storageMode?: string;
  storagePool?: string;
  system: string;
  volumeName?: string;
}
/* io.k8s.api.core.v1.ScopeSelector */
/* A scope selector represents the AND of the selectors represented by the scoped-resource selector requirements. */
export interface ScopeSelector {
  matchExpressions?: ScopedResourceSelectorRequirement[];
}
/* io.k8s.api.core.v1.ScopedResourceSelectorRequirement */
/* A scoped-resource selector requirement is a selector that contains values, a scope name, and an operator that relates the scope name and values. */
export interface ScopedResourceSelectorRequirement {
  operator: "DoesNotExist" | "Exists" | "In" | "NotIn";
  scopeName: "BestEffort" | "CrossNamespacePodAffinity" | "NotBestEffort" | "NotTerminating" | "PriorityClass" | "Terminating";
  values?: string[];
}
/* io.k8s.api.core.v1.SeccompProfile */
/* SeccompProfile defines a pod/container's seccomp profile settings. Only one profile source may be set. */
export interface SeccompProfile {
  localhostProfile?: string;
  type: "Localhost" | "RuntimeDefault" | "Unconfined";
}
/* io.k8s.api.core.v1.Secret */
/* Secret holds secret data of a certain type. The total bytes of the values in the Data field must be less than MaxSecretSize bytes. */
export interface Secret {
  apiVersion?: string;
  data?: {
    [key: string]: unknown;
  };
  immutable?: boolean;
  kind?: string;
  metadata?: ObjectMeta;
  stringData?: {
    [key: string]: unknown;
  };
  type?: string;
}
/* io.k8s.api.core.v1.SecretEnvSource */
/* SecretEnvSource selects a Secret to populate the environment variables with.

The contents of the target Secret's Data field will represent the key-value pairs as environment variables. */
export interface SecretEnvSource {
  name?: string;
  optional?: boolean;
}
/* io.k8s.api.core.v1.SecretKeySelector */
/* SecretKeySelector selects a key of a Secret. */
export interface SecretKeySelector {
  key: string;
  name?: string;
  optional?: boolean;
}
/* io.k8s.api.core.v1.SecretList */
/* SecretList is a list of Secret. */
export interface SecretList {
  apiVersion?: string;
  items: Secret[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.k8s.api.core.v1.SecretProjection */
/* Adapts a secret into a projected volume.

The contents of the target Secret's Data field will be presented in a projected volume as files using the keys in the Data field as the file names. Note that this is identical to a secret volume source without the default mode. */
export interface SecretProjection {
  items?: KeyToPath[];
  name?: string;
  optional?: boolean;
}
/* io.k8s.api.core.v1.SecretReference */
/* SecretReference represents a Secret Reference. It has enough information to retrieve secret in any namespace */
export interface SecretReference {
  name?: string;
  namespace?: string;
}
/* io.k8s.api.core.v1.SecretVolumeSource */
/* Adapts a Secret into a volume.

The contents of the target Secret's Data field will be presented in a volume as files using the keys in the Data field as the file names. Secret volumes support ownership management and SELinux relabeling. */
export interface SecretVolumeSource {
  defaultMode?: number;
  items?: KeyToPath[];
  optional?: boolean;
  secretName?: string;
}
/* io.k8s.api.core.v1.SecurityContext */
/* SecurityContext holds security configuration that will be applied to a container. Some fields are present in both SecurityContext and PodSecurityContext.  When both are set, the values in SecurityContext take precedence. */
export interface SecurityContext {
  allowPrivilegeEscalation?: boolean;
  appArmorProfile?: AppArmorProfile;
  capabilities?: Capabilities;
  privileged?: boolean;
  procMount?: "Default" | "Unmasked";
  readOnlyRootFilesystem?: boolean;
  runAsGroup?: number;
  runAsNonRoot?: boolean;
  runAsUser?: number;
  seLinuxOptions?: SELinuxOptions;
  seccompProfile?: SeccompProfile;
  windowsOptions?: WindowsSecurityContextOptions;
}
/* io.k8s.api.core.v1.Service */
/* Service is a named abstraction of software service (for example, mysql) consisting of local port (for example 3306) that the proxy listens on, and the selector that determines which pods will answer requests sent through the proxy. */
export interface Service {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: ServiceSpec;
  status?: ServiceStatus;
}
/* io.k8s.api.core.v1.ServiceAccount */
/* ServiceAccount binds together: * a name, understood by users, and perhaps by peripheral systems, for an identity * a principal that can be authenticated and authorized * a set of secrets */
export interface ServiceAccount {
  apiVersion?: string;
  automountServiceAccountToken?: boolean;
  imagePullSecrets?: LocalObjectReference[];
  kind?: string;
  metadata?: ObjectMeta;
  secrets?: ObjectReference[];
}
/* io.k8s.api.core.v1.ServiceAccountList */
/* ServiceAccountList is a list of ServiceAccount objects */
export interface ServiceAccountList {
  apiVersion?: string;
  items: ServiceAccount[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.k8s.api.core.v1.ServiceAccountTokenProjection */
/* ServiceAccountTokenProjection represents a projected service account token volume. This projection can be used to insert a service account token into the pods runtime filesystem for use against APIs (Kubernetes API Server or otherwise). */
export interface ServiceAccountTokenProjection {
  audience?: string;
  expirationSeconds?: number;
  path: string;
}
/* io.k8s.api.core.v1.ServiceList */
/* ServiceList holds a list of services. */
export interface ServiceList {
  apiVersion?: string;
  items: Service[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.k8s.api.core.v1.ServicePort */
/* ServicePort contains information on service's port. */
export interface ServicePort {
  appProtocol?: string;
  name?: string;
  nodePort?: number;
  port: number;
  protocol?: "SCTP" | "TCP" | "UDP";
  targetPort?: IntOrString;
}
/* io.k8s.api.core.v1.ServiceSpec */
/* ServiceSpec describes the attributes that a user creates on a service. */
export interface ServiceSpec {
  allocateLoadBalancerNodePorts?: boolean;
  clusterIP?: string;
  clusterIPs?: string[];
  externalIPs?: string[];
  externalName?: string;
  externalTrafficPolicy?: "Cluster" | "Local";
  healthCheckNodePort?: number;
  internalTrafficPolicy?: "Cluster" | "Local";
  ipFamilies?: ("" | "IPv4" | "IPv6")[];
  ipFamilyPolicy?: "PreferDualStack" | "RequireDualStack" | "SingleStack";
  loadBalancerClass?: string;
  loadBalancerIP?: string;
  loadBalancerSourceRanges?: string[];
  ports?: ServicePort[];
  publishNotReadyAddresses?: boolean;
  selector?: {
    [key: string]: unknown;
  };
  sessionAffinity?: "ClientIP" | "None";
  sessionAffinityConfig?: SessionAffinityConfig;
  trafficDistribution?: string;
  type?: "ClusterIP" | "ExternalName" | "LoadBalancer" | "NodePort";
}
/* io.k8s.api.core.v1.ServiceStatus */
/* ServiceStatus represents the current status of a service. */
export interface ServiceStatus {
  conditions?: Condition[];
  loadBalancer?: LoadBalancerStatus;
}
/* io.k8s.api.core.v1.SessionAffinityConfig */
/* SessionAffinityConfig represents the configurations of session affinity. */
export interface SessionAffinityConfig {
  clientIP?: ClientIPConfig;
}
/* io.k8s.api.core.v1.SleepAction */
/* SleepAction describes a "sleep" action. */
export interface SleepAction {
  seconds: number;
}
/* io.k8s.api.core.v1.StorageOSPersistentVolumeSource */
/* Represents a StorageOS persistent volume resource. */
export interface StorageOSPersistentVolumeSource {
  fsType?: string;
  readOnly?: boolean;
  secretRef?: ObjectReference;
  volumeName?: string;
  volumeNamespace?: string;
}
/* io.k8s.api.core.v1.StorageOSVolumeSource */
/* Represents a StorageOS persistent volume resource. */
export interface StorageOSVolumeSource {
  fsType?: string;
  readOnly?: boolean;
  secretRef?: LocalObjectReference;
  volumeName?: string;
  volumeNamespace?: string;
}
/* io.k8s.api.core.v1.Sysctl */
/* Sysctl defines a kernel parameter to be set */
export interface Sysctl {
  name: string;
  value: string;
}
/* io.k8s.api.core.v1.TCPSocketAction */
/* TCPSocketAction describes an action based on opening a socket */
export interface TCPSocketAction {
  host?: string;
  port: IntOrString;
}
/* io.k8s.api.core.v1.Taint */
/* The node this Taint is attached to has the "effect" on any pod that does not tolerate the Taint. */
export interface Taint {
  effect: "NoExecute" | "NoSchedule" | "PreferNoSchedule";
  key: string;
  timeAdded?: Time;
  value?: string;
}
/* io.k8s.api.core.v1.Toleration */
/* The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>. */
export interface Toleration {
  effect?: "NoExecute" | "NoSchedule" | "PreferNoSchedule";
  key?: string;
  operator?: "Equal" | "Exists";
  tolerationSeconds?: number;
  value?: string;
}
/* io.k8s.api.core.v1.TopologySelectorLabelRequirement */
/* A topology selector requirement is a selector that matches given label. This is an alpha feature and may change in the future. */
export interface TopologySelectorLabelRequirement {
  key: string;
  values: string[];
}
/* io.k8s.api.core.v1.TopologySelectorTerm */
/* A topology selector term represents the result of label queries. A null or empty topology selector term matches no objects. The requirements of them are ANDed. It provides a subset of functionality as NodeSelectorTerm. This is an alpha feature and may change in the future. */
export interface TopologySelectorTerm {
  matchLabelExpressions?: TopologySelectorLabelRequirement[];
}
/* io.k8s.api.core.v1.TopologySpreadConstraint */
/* TopologySpreadConstraint specifies how to spread matching pods among the given topology. */
export interface TopologySpreadConstraint {
  labelSelector?: LabelSelector;
  matchLabelKeys?: string[];
  maxSkew: number;
  minDomains?: number;
  nodeAffinityPolicy?: "Honor" | "Ignore";
  nodeTaintsPolicy?: "Honor" | "Ignore";
  topologyKey: string;
  whenUnsatisfiable: "DoNotSchedule" | "ScheduleAnyway";
}
/* io.k8s.api.core.v1.TypedLocalObjectReference */
/* TypedLocalObjectReference contains enough information to let you locate the typed referenced object inside the same namespace. */
export interface TypedLocalObjectReference {
  apiGroup?: string;
  kind: string;
  name: string;
}
/* io.k8s.api.core.v1.TypedObjectReference */
/* TypedObjectReference contains enough information to let you locate the typed referenced object */
export interface TypedObjectReference {
  apiGroup?: string;
  kind: string;
  name: string;
  namespace?: string;
}
/* io.k8s.api.core.v1.Volume */
/* Volume represents a named volume in a pod that may be accessed by any container in the pod. */
export interface Volume {
  awsElasticBlockStore?: AWSElasticBlockStoreVolumeSource;
  azureDisk?: AzureDiskVolumeSource;
  azureFile?: AzureFileVolumeSource;
  cephfs?: CephFSVolumeSource;
  cinder?: CinderVolumeSource;
  configMap?: ConfigMapVolumeSource;
  csi?: CSIVolumeSource;
  downwardAPI?: DownwardAPIVolumeSource;
  emptyDir?: EmptyDirVolumeSource;
  ephemeral?: EphemeralVolumeSource;
  fc?: FCVolumeSource;
  flexVolume?: FlexVolumeSource;
  flocker?: FlockerVolumeSource;
  gcePersistentDisk?: GCEPersistentDiskVolumeSource;
  gitRepo?: GitRepoVolumeSource;
  glusterfs?: GlusterfsVolumeSource;
  hostPath?: HostPathVolumeSource;
  image?: ImageVolumeSource;
  iscsi?: ISCSIVolumeSource;
  name: string;
  nfs?: NFSVolumeSource;
  persistentVolumeClaim?: PersistentVolumeClaimVolumeSource;
  photonPersistentDisk?: PhotonPersistentDiskVolumeSource;
  portworxVolume?: PortworxVolumeSource;
  projected?: ProjectedVolumeSource;
  quobyte?: QuobyteVolumeSource;
  rbd?: RBDVolumeSource;
  scaleIO?: ScaleIOVolumeSource;
  secret?: SecretVolumeSource;
  storageos?: StorageOSVolumeSource;
  vsphereVolume?: VsphereVirtualDiskVolumeSource;
}
/* io.k8s.api.core.v1.VolumeDevice */
/* volumeDevice describes a mapping of a raw block device within a container. */
export interface VolumeDevice {
  devicePath: string;
  name: string;
}
/* io.k8s.api.core.v1.VolumeMount */
/* VolumeMount describes a mounting of a Volume within a container. */
export interface VolumeMount {
  mountPath: string;
  mountPropagation?: "Bidirectional" | "HostToContainer" | "None";
  name: string;
  readOnly?: boolean;
  recursiveReadOnly?: string;
  subPath?: string;
  subPathExpr?: string;
}
/* io.k8s.api.core.v1.VolumeMountStatus */
/* VolumeMountStatus shows status of volume mounts. */
export interface VolumeMountStatus {
  mountPath: string;
  name: string;
  readOnly?: boolean;
  recursiveReadOnly?: string;
}
/* io.k8s.api.core.v1.VolumeNodeAffinity */
/* VolumeNodeAffinity defines constraints that limit what nodes this volume can be accessed from. */
export interface VolumeNodeAffinity {
  required?: NodeSelector;
}
/* io.k8s.api.core.v1.VolumeProjection */
/* Projection that may be projected along with other supported volume types. Exactly one of these fields must be set. */
export interface VolumeProjection {
  clusterTrustBundle?: ClusterTrustBundleProjection;
  configMap?: ConfigMapProjection;
  downwardAPI?: DownwardAPIProjection;
  secret?: SecretProjection;
  serviceAccountToken?: ServiceAccountTokenProjection;
}
/* io.k8s.api.core.v1.VolumeResourceRequirements */
/* VolumeResourceRequirements describes the storage resource requirements for a volume. */
export interface VolumeResourceRequirements {
  limits?: {
    [key: string]: unknown;
  };
  requests?: {
    [key: string]: unknown;
  };
}
/* io.k8s.api.core.v1.VsphereVirtualDiskVolumeSource */
/* Represents a vSphere volume resource. */
export interface VsphereVirtualDiskVolumeSource {
  fsType?: string;
  storagePolicyID?: string;
  storagePolicyName?: string;
  volumePath: string;
}
/* io.k8s.api.core.v1.WeightedPodAffinityTerm */
/* The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s) */
export interface WeightedPodAffinityTerm {
  podAffinityTerm: PodAffinityTerm;
  weight: number;
}
/* io.k8s.api.core.v1.WindowsSecurityContextOptions */
/* WindowsSecurityContextOptions contain Windows-specific options and credentials. */
export interface WindowsSecurityContextOptions {
  gmsaCredentialSpec?: string;
  gmsaCredentialSpecName?: string;
  hostProcess?: boolean;
  runAsUserName?: string;
}
/* io.k8s.api.discovery.v1.Endpoint */
/* Endpoint represents a single logical "backend" implementing a service. */
export interface Endpoint {
  addresses: string[];
  conditions?: EndpointConditions;
  deprecatedTopology?: {
    [key: string]: unknown;
  };
  hints?: EndpointHints;
  hostname?: string;
  nodeName?: string;
  targetRef?: ObjectReference;
  zone?: string;
}
/* io.k8s.api.discovery.v1.EndpointConditions */
/* EndpointConditions represents the current condition of an endpoint. */
export interface EndpointConditions {
  ready?: boolean;
  serving?: boolean;
  terminating?: boolean;
}
/* io.k8s.api.discovery.v1.EndpointHints */
/* EndpointHints provides hints describing how an endpoint should be consumed. */
export interface EndpointHints {
  forZones?: ForZone[];
}
/* io.k8s.api.discovery.v1.EndpointPort */
/* EndpointPort represents a Port used by an EndpointSlice */
export interface IoK8sApiDiscoveryV1EndpointPort {
  appProtocol?: string;
  name?: string;
  port?: number;
  protocol?: "SCTP" | "TCP" | "UDP";
}
/* io.k8s.api.discovery.v1.EndpointSlice */
/* EndpointSlice represents a subset of the endpoints that implement a service. For a given service there may be multiple EndpointSlice objects, selected by labels, which must be joined to produce the full set of endpoints. */
export interface DiscoveryK8sIoV1EndpointSlice {
  addressType: "FQDN" | "IPv4" | "IPv6";
  apiVersion?: string;
  endpoints: Endpoint[];
  kind?: string;
  metadata?: ObjectMeta;
  ports?: IoK8sApiDiscoveryV1EndpointPort[];
}
/* io.k8s.api.discovery.v1.EndpointSliceList */
/* EndpointSliceList represents a list of endpoint slices */
export interface DiscoveryK8sIoV1EndpointSliceList {
  apiVersion?: string;
  items: DiscoveryK8sIoV1EndpointSlice[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.k8s.api.discovery.v1.ForZone */
/* ForZone provides information about which zones should consume this endpoint. */
export interface ForZone {
  name: string;
}
/* io.k8s.api.events.v1.EventList */
/* EventList is a list of Event objects. */
export interface EventsK8sIoV1EventList {
  apiVersion?: string;
  items: EventsK8sIoV1Event[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.k8s.api.networking.v1.HTTPIngressPath */
/* HTTPIngressPath associates a path with a backend. Incoming urls matching the path are forwarded to the backend. */
export interface HTTPIngressPath {
  backend: IngressBackend;
  path?: string;
  pathType: "Exact" | "ImplementationSpecific" | "Prefix";
}
/* io.k8s.api.networking.v1.HTTPIngressRuleValue */
/* HTTPIngressRuleValue is a list of http selectors pointing to backends. In the example: http://<host>/<path>?<searchpart> -> backend where where parts of the url correspond to RFC 3986, this resource will be used to match against everything after the last '/' and before the first '?' or '#'. */
export interface HTTPIngressRuleValue {
  paths: HTTPIngressPath[];
}
/* io.k8s.api.networking.v1.IPBlock */
/* IPBlock describes a particular CIDR (Ex. "192.168.1.0/24","2001:db8::/64") that is allowed to the pods matched by a NetworkPolicySpec's podSelector. The except entry describes CIDRs that should not be included within this rule. */
export interface IPBlock {
  cidr: string;
  except?: string[];
}
/* io.k8s.api.networking.v1.Ingress */
/* Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc. */
export interface NetworkingK8sIoV1Ingress {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: IngressSpec;
  status?: IngressStatus;
}
/* io.k8s.api.networking.v1.IngressBackend */
/* IngressBackend describes all endpoints for a given service and port. */
export interface IngressBackend {
  resource?: TypedLocalObjectReference;
  service?: IngressServiceBackend;
}
/* io.k8s.api.networking.v1.IngressClass */
/* IngressClass represents the class of the Ingress, referenced by the Ingress Spec. The `ingressclass.kubernetes.io/is-default-class` annotation can be used to indicate that an IngressClass should be considered default. When a single IngressClass resource has this annotation set to true, new Ingress resources without a class specified will be assigned this default class. */
export interface NetworkingK8sIoV1IngressClass {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: IngressClassSpec;
}
/* io.k8s.api.networking.v1.IngressClassList */
/* IngressClassList is a collection of IngressClasses. */
export interface NetworkingK8sIoV1IngressClassList {
  apiVersion?: string;
  items: NetworkingK8sIoV1IngressClass[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.k8s.api.networking.v1.IngressClassParametersReference */
/* IngressClassParametersReference identifies an API object. This can be used to specify a cluster or namespace-scoped resource. */
export interface IngressClassParametersReference {
  apiGroup?: string;
  kind: string;
  name: string;
  namespace?: string;
  scope?: string;
}
/* io.k8s.api.networking.v1.IngressClassSpec */
/* IngressClassSpec provides information about the class of an Ingress. */
export interface IngressClassSpec {
  controller?: string;
  parameters?: IngressClassParametersReference;
}
/* io.k8s.api.networking.v1.IngressList */
/* IngressList is a collection of Ingress. */
export interface NetworkingK8sIoV1IngressList {
  apiVersion?: string;
  items: NetworkingK8sIoV1Ingress[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.k8s.api.networking.v1.IngressLoadBalancerIngress */
/* IngressLoadBalancerIngress represents the status of a load-balancer ingress point. */
export interface IngressLoadBalancerIngress {
  hostname?: string;
  ip?: string;
  ports?: IngressPortStatus[];
}
/* io.k8s.api.networking.v1.IngressLoadBalancerStatus */
/* IngressLoadBalancerStatus represents the status of a load-balancer. */
export interface IngressLoadBalancerStatus {
  ingress?: IngressLoadBalancerIngress[];
}
/* io.k8s.api.networking.v1.IngressPortStatus */
/* IngressPortStatus represents the error condition of a service port */
export interface IngressPortStatus {
  error?: string;
  port: number;
  protocol: "SCTP" | "TCP" | "UDP";
}
/* io.k8s.api.networking.v1.IngressRule */
/* IngressRule represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching IngressRuleValue. */
export interface IngressRule {
  host?: string;
  http?: HTTPIngressRuleValue;
}
/* io.k8s.api.networking.v1.IngressServiceBackend */
/* IngressServiceBackend references a Kubernetes Service as a Backend. */
export interface IngressServiceBackend {
  name: string;
  port?: ServiceBackendPort;
}
/* io.k8s.api.networking.v1.IngressSpec */
/* IngressSpec describes the Ingress the user wishes to exist. */
export interface IngressSpec {
  defaultBackend?: IngressBackend;
  ingressClassName?: string;
  rules?: IngressRule[];
  tls?: IngressTLS[];
}
/* io.k8s.api.networking.v1.IngressStatus */
/* IngressStatus describe the current state of the Ingress. */
export interface IngressStatus {
  loadBalancer?: IngressLoadBalancerStatus;
}
/* io.k8s.api.networking.v1.IngressTLS */
/* IngressTLS describes the transport layer security associated with an ingress. */
export interface IngressTLS {
  hosts?: string[];
  secretName?: string;
}
/* io.k8s.api.networking.v1.NetworkPolicy */
/* NetworkPolicy describes what network traffic is allowed for a set of Pods */
export interface NetworkingK8sIoV1NetworkPolicy {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: NetworkPolicySpec;
}
/* io.k8s.api.networking.v1.NetworkPolicyEgressRule */
/* NetworkPolicyEgressRule describes a particular set of traffic that is allowed out of pods matched by a NetworkPolicySpec's podSelector. The traffic must match both ports and to. This type is beta-level in 1.8 */
export interface NetworkPolicyEgressRule {
  ports?: NetworkPolicyPort[];
  to?: NetworkPolicyPeer[];
}
/* io.k8s.api.networking.v1.NetworkPolicyIngressRule */
/* NetworkPolicyIngressRule describes a particular set of traffic that is allowed to the pods matched by a NetworkPolicySpec's podSelector. The traffic must match both ports and from. */
export interface NetworkPolicyIngressRule {
  from?: NetworkPolicyPeer[];
  ports?: NetworkPolicyPort[];
}
/* io.k8s.api.networking.v1.NetworkPolicyList */
/* NetworkPolicyList is a list of NetworkPolicy objects. */
export interface NetworkingK8sIoV1NetworkPolicyList {
  apiVersion?: string;
  items: NetworkingK8sIoV1NetworkPolicy[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.k8s.api.networking.v1.NetworkPolicyPeer */
/* NetworkPolicyPeer describes a peer to allow traffic to/from. Only certain combinations of fields are allowed */
export interface NetworkPolicyPeer {
  ipBlock?: IPBlock;
  namespaceSelector?: LabelSelector;
  podSelector?: LabelSelector;
}
/* io.k8s.api.networking.v1.NetworkPolicyPort */
/* NetworkPolicyPort describes a port to allow traffic on */
export interface NetworkPolicyPort {
  endPort?: number;
  port?: IntOrString;
  protocol?: "SCTP" | "TCP" | "UDP";
}
/* io.k8s.api.networking.v1.NetworkPolicySpec */
/* NetworkPolicySpec provides the specification of a NetworkPolicy */
export interface NetworkPolicySpec {
  egress?: NetworkPolicyEgressRule[];
  ingress?: NetworkPolicyIngressRule[];
  podSelector: LabelSelector;
  policyTypes?: ("Egress" | "Ingress")[];
}
/* io.k8s.api.networking.v1.ServiceBackendPort */
/* ServiceBackendPort is the service port being referenced. */
export interface ServiceBackendPort {
  name?: string;
  number?: number;
}
/* io.k8s.api.node.v1.Overhead */
/* Overhead structure represents the resource overhead associated with running a pod. */
export interface Overhead {
  podFixed?: {
    [key: string]: unknown;
  };
}
/* io.k8s.api.node.v1.RuntimeClass */
/* RuntimeClass defines a class of container runtime supported in the cluster. The RuntimeClass is used to determine which container runtime is used to run all containers in a pod. RuntimeClasses are manually defined by a user or cluster provisioner, and referenced in the PodSpec. The Kubelet is responsible for resolving the RuntimeClassName reference before running the pod.  For more details, see https://kubernetes.io/docs/concepts/containers/runtime-class/ */
export interface NodeK8sIoV1RuntimeClass {
  apiVersion?: string;
  handler: string;
  kind?: string;
  metadata?: ObjectMeta;
  overhead?: Overhead;
  scheduling?: Scheduling;
}
/* io.k8s.api.node.v1.RuntimeClassList */
/* RuntimeClassList is a list of RuntimeClass objects. */
export interface NodeK8sIoV1RuntimeClassList {
  apiVersion?: string;
  items: NodeK8sIoV1RuntimeClass[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.k8s.api.node.v1.Scheduling */
/* Scheduling specifies the scheduling constraints for nodes supporting a RuntimeClass. */
export interface Scheduling {
  nodeSelector?: {
    [key: string]: unknown;
  };
  tolerations?: Toleration[];
}
/* io.k8s.api.policy.v1.Eviction */
/* Eviction evicts a pod from its node subject to certain policies and safety constraints. This is a subresource of Pod.  A request to cause such an eviction is created by POSTing to .../pods/<pod name>/evictions. */
export interface PolicyV1Eviction {
  apiVersion?: string;
  deleteOptions?: DeleteOptions;
  kind?: string;
  metadata?: ObjectMeta;
}
/* io.k8s.api.policy.v1.PodDisruptionBudget */
/* PodDisruptionBudget is an object to define the max disruption that can be caused to a collection of pods */
export interface PolicyV1PodDisruptionBudget {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: PodDisruptionBudgetSpec;
  status?: PodDisruptionBudgetStatus;
}
/* io.k8s.api.policy.v1.PodDisruptionBudgetList */
/* PodDisruptionBudgetList is a collection of PodDisruptionBudgets. */
export interface PolicyV1PodDisruptionBudgetList {
  apiVersion?: string;
  items: PolicyV1PodDisruptionBudget[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.k8s.api.policy.v1.PodDisruptionBudgetSpec */
/* PodDisruptionBudgetSpec is a description of a PodDisruptionBudget. */
export interface PodDisruptionBudgetSpec {
  maxUnavailable?: IntOrString;
  minAvailable?: IntOrString;
  selector?: LabelSelector;
  unhealthyPodEvictionPolicy?: "AlwaysAllow" | "IfHealthyBudget";
}
/* io.k8s.api.policy.v1.PodDisruptionBudgetStatus */
/* PodDisruptionBudgetStatus represents information about the status of a PodDisruptionBudget. Status may trail the actual state of a system. */
export interface PodDisruptionBudgetStatus {
  conditions?: Condition[];
  currentHealthy: number;
  desiredHealthy: number;
  disruptedPods?: {
    [key: string]: unknown;
  };
  disruptionsAllowed: number;
  expectedPods: number;
  observedGeneration?: number;
}
/* io.k8s.api.rbac.v1.AggregationRule */
/* AggregationRule describes how to locate ClusterRoles to aggregate into the ClusterRole */
export interface AggregationRule {
  clusterRoleSelectors?: LabelSelector[];
}
/* io.k8s.api.rbac.v1.ClusterRole */
/* ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding. */
export interface RbacAuthorizationK8sIoV1ClusterRole {
  aggregationRule?: AggregationRule;
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  rules?: PolicyRule[];
}
/* io.k8s.api.rbac.v1.ClusterRoleBinding */
/* ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a ClusterRole in the global namespace, and adds who information via Subject. */
export interface RbacAuthorizationK8sIoV1ClusterRoleBinding {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  roleRef: RoleRef;
  subjects?: IoK8sApiRbacV1Subject[];
}
/* io.k8s.api.rbac.v1.ClusterRoleBindingList */
/* ClusterRoleBindingList is a collection of ClusterRoleBindings */
export interface RbacAuthorizationK8sIoV1ClusterRoleBindingList {
  apiVersion?: string;
  items: RbacAuthorizationK8sIoV1ClusterRoleBinding[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.k8s.api.rbac.v1.ClusterRoleList */
/* ClusterRoleList is a collection of ClusterRoles */
export interface RbacAuthorizationK8sIoV1ClusterRoleList {
  apiVersion?: string;
  items: RbacAuthorizationK8sIoV1ClusterRole[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.k8s.api.rbac.v1.PolicyRule */
/* PolicyRule holds information that describes a policy rule, but does not contain information about who the rule applies to or which namespace the rule applies to. */
export interface PolicyRule {
  apiGroups?: string[];
  nonResourceURLs?: string[];
  resourceNames?: string[];
  resources?: string[];
  verbs: string[];
}
/* io.k8s.api.rbac.v1.Role */
/* Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding. */
export interface RbacAuthorizationK8sIoV1Role {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  rules?: PolicyRule[];
}
/* io.k8s.api.rbac.v1.RoleBinding */
/* RoleBinding references a role, but does not contain it.  It can reference a Role in the same namespace or a ClusterRole in the global namespace. It adds who information via Subjects and namespace information by which namespace it exists in.  RoleBindings in a given namespace only have effect in that namespace. */
export interface RbacAuthorizationK8sIoV1RoleBinding {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  roleRef: RoleRef;
  subjects?: IoK8sApiRbacV1Subject[];
}
/* io.k8s.api.rbac.v1.RoleBindingList */
/* RoleBindingList is a collection of RoleBindings */
export interface RbacAuthorizationK8sIoV1RoleBindingList {
  apiVersion?: string;
  items: RbacAuthorizationK8sIoV1RoleBinding[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.k8s.api.rbac.v1.RoleList */
/* RoleList is a collection of Roles */
export interface RbacAuthorizationK8sIoV1RoleList {
  apiVersion?: string;
  items: RbacAuthorizationK8sIoV1Role[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.k8s.api.rbac.v1.RoleRef */
/* RoleRef contains information that points to the role being used */
export interface RoleRef {
  apiGroup: string;
  kind: string;
  name: string;
}
/* io.k8s.api.rbac.v1.Subject */
/* Subject contains a reference to the object or user identities a role binding applies to.  This can either hold a direct API object reference, or a value for non-objects such as user and group names. */
export interface IoK8sApiRbacV1Subject {
  apiGroup?: string;
  kind: string;
  name: string;
  namespace?: string;
}
/* io.k8s.api.scheduling.v1.PriorityClass */
/* PriorityClass defines mapping from a priority class name to the priority integer value. The value can be any valid integer. */
export interface SchedulingK8sIoV1PriorityClass {
  apiVersion?: string;
  description?: string;
  globalDefault?: boolean;
  kind?: string;
  metadata?: ObjectMeta;
  preemptionPolicy?: "Never" | "PreemptLowerPriority";
  value: number;
}
/* io.k8s.api.scheduling.v1.PriorityClassList */
/* PriorityClassList is a collection of priority classes. */
export interface SchedulingK8sIoV1PriorityClassList {
  apiVersion?: string;
  items: SchedulingK8sIoV1PriorityClass[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.k8s.api.storage.v1.CSIDriver */
/* CSIDriver captures information about a Container Storage Interface (CSI) volume driver deployed on the cluster. Kubernetes attach detach controller uses this object to determine whether attach is required. Kubelet uses this object to determine whether pod information needs to be passed on mount. CSIDriver objects are non-namespaced. */
export interface StorageK8sIoV1CSIDriver {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec: CSIDriverSpec;
}
/* io.k8s.api.storage.v1.CSIDriverList */
/* CSIDriverList is a collection of CSIDriver objects. */
export interface StorageK8sIoV1CSIDriverList {
  apiVersion?: string;
  items: StorageK8sIoV1CSIDriver[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.k8s.api.storage.v1.CSIDriverSpec */
/* CSIDriverSpec is the specification of a CSIDriver. */
export interface CSIDriverSpec {
  attachRequired?: boolean;
  fsGroupPolicy?: string;
  podInfoOnMount?: boolean;
  requiresRepublish?: boolean;
  seLinuxMount?: boolean;
  storageCapacity?: boolean;
  tokenRequests?: IoK8sApiStorageV1TokenRequest[];
  volumeLifecycleModes?: string[];
}
/* io.k8s.api.storage.v1.CSINode */
/* CSINode holds information about all CSI drivers installed on a node. CSI drivers do not need to create the CSINode object directly. As long as they use the node-driver-registrar sidecar container, the kubelet will automatically populate the CSINode object for the CSI driver as part of kubelet plugin registration. CSINode has the same name as a node. If the object is missing, it means either there are no CSI Drivers available on the node, or the Kubelet version is low enough that it doesn't create this object. CSINode has an OwnerReference that points to the corresponding node object. */
export interface StorageK8sIoV1CSINode {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec: CSINodeSpec;
}
/* io.k8s.api.storage.v1.CSINodeDriver */
/* CSINodeDriver holds information about the specification of one CSI driver installed on a node */
export interface CSINodeDriver {
  allocatable?: VolumeNodeResources;
  name: string;
  nodeID: string;
  topologyKeys?: string[];
}
/* io.k8s.api.storage.v1.CSINodeList */
/* CSINodeList is a collection of CSINode objects. */
export interface StorageK8sIoV1CSINodeList {
  apiVersion?: string;
  items: StorageK8sIoV1CSINode[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.k8s.api.storage.v1.CSINodeSpec */
/* CSINodeSpec holds information about the specification of all CSI drivers installed on a node */
export interface CSINodeSpec {
  drivers: CSINodeDriver[];
}
/* io.k8s.api.storage.v1.CSIStorageCapacity */
/* CSIStorageCapacity stores the result of one CSI GetCapacity call. For a given StorageClass, this describes the available capacity in a particular topology segment.  This can be used when considering where to instantiate new PersistentVolumes.

For example this can express things like: - StorageClass "standard" has "1234 GiB" available in "topology.kubernetes.io/zone=us-east1" - StorageClass "localssd" has "10 GiB" available in "kubernetes.io/hostname=knode-abc123"

The following three cases all imply that no capacity is available for a certain combination: - no object exists with suitable topology and storage class name - such an object exists, but the capacity is unset - such an object exists, but the capacity is zero

The producer of these objects can decide which approach is more suitable.

They are consumed by the kube-scheduler when a CSI driver opts into capacity-aware scheduling with CSIDriverSpec.StorageCapacity. The scheduler compares the MaximumVolumeSize against the requested size of pending volumes to filter out unsuitable nodes. If MaximumVolumeSize is unset, it falls back to a comparison against the less precise Capacity. If that is also unset, the scheduler assumes that capacity is insufficient and tries some other node. */
export interface StorageK8sIoV1CSIStorageCapacity {
  apiVersion?: string;
  capacity?: Quantity;
  kind?: string;
  maximumVolumeSize?: Quantity;
  metadata?: ObjectMeta;
  nodeTopology?: LabelSelector;
  storageClassName: string;
}
/* io.k8s.api.storage.v1.CSIStorageCapacityList */
/* CSIStorageCapacityList is a collection of CSIStorageCapacity objects. */
export interface StorageK8sIoV1CSIStorageCapacityList {
  apiVersion?: string;
  items: StorageK8sIoV1CSIStorageCapacity[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.k8s.api.storage.v1.StorageClass */
/* StorageClass describes the parameters for a class of storage for which PersistentVolumes can be dynamically provisioned.

StorageClasses are non-namespaced; the name of the storage class according to etcd is in ObjectMeta.Name. */
export interface StorageK8sIoV1StorageClass {
  allowVolumeExpansion?: boolean;
  allowedTopologies?: TopologySelectorTerm[];
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  mountOptions?: string[];
  parameters?: {
    [key: string]: unknown;
  };
  provisioner: string;
  reclaimPolicy?: "Delete" | "Recycle" | "Retain";
  volumeBindingMode?: "Immediate" | "WaitForFirstConsumer";
}
/* io.k8s.api.storage.v1.StorageClassList */
/* StorageClassList is a collection of storage classes. */
export interface StorageK8sIoV1StorageClassList {
  apiVersion?: string;
  items: StorageK8sIoV1StorageClass[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.k8s.api.storage.v1.TokenRequest */
/* TokenRequest contains parameters of a service account token. */
export interface IoK8sApiStorageV1TokenRequest {
  audience: string;
  expirationSeconds?: number;
}
/* io.k8s.api.storage.v1.VolumeAttachment */
/* VolumeAttachment captures the intent to attach or detach the specified volume to/from the specified node.

VolumeAttachment objects are non-namespaced. */
export interface StorageK8sIoV1VolumeAttachment {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec: VolumeAttachmentSpec;
  status?: VolumeAttachmentStatus;
}
/* io.k8s.api.storage.v1.VolumeAttachmentList */
/* VolumeAttachmentList is a collection of VolumeAttachment objects. */
export interface StorageK8sIoV1VolumeAttachmentList {
  apiVersion?: string;
  items: StorageK8sIoV1VolumeAttachment[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.k8s.api.storage.v1.VolumeAttachmentSource */
/* VolumeAttachmentSource represents a volume that should be attached. Right now only PersistentVolumes can be attached via external attacher, in the future we may allow also inline volumes in pods. Exactly one member can be set. */
export interface VolumeAttachmentSource {
  inlineVolumeSpec?: PersistentVolumeSpec;
  persistentVolumeName?: string;
}
/* io.k8s.api.storage.v1.VolumeAttachmentSpec */
/* VolumeAttachmentSpec is the specification of a VolumeAttachment request. */
export interface VolumeAttachmentSpec {
  attacher: string;
  nodeName: string;
  source: VolumeAttachmentSource;
}
/* io.k8s.api.storage.v1.VolumeAttachmentStatus */
/* VolumeAttachmentStatus is the status of a VolumeAttachment request. */
export interface VolumeAttachmentStatus {
  attachError?: VolumeError;
  attached: boolean;
  attachmentMetadata?: {
    [key: string]: unknown;
  };
  detachError?: VolumeError;
}
/* io.k8s.api.storage.v1.VolumeError */
/* VolumeError captures an error encountered during a volume operation. */
export interface VolumeError {
  message?: string;
  time?: Time;
}
/* io.k8s.api.storage.v1.VolumeNodeResources */
/* VolumeNodeResources is a set of resource limits for scheduling of volumes. */
export interface VolumeNodeResources {
  count?: number;
}
/* io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.CustomResourceColumnDefinition */
/* CustomResourceColumnDefinition specifies a column for server side printing. */
export interface CustomResourceColumnDefinition {
  description?: string;
  format?: string;
  jsonPath: string;
  name: string;
  priority?: number;
  type: string;
}
/* io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.CustomResourceConversion */
/* CustomResourceConversion describes how to convert different versions of a CR. */
export interface CustomResourceConversion {
  strategy: string;
  webhook?: WebhookConversion;
}
/* io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.CustomResourceDefinition */
/* CustomResourceDefinition represents a resource that should be exposed on the API server.  Its name MUST be in the format <.spec.name>.<.spec.group>. */
export interface ApiextensionsK8sIoV1CustomResourceDefinition {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec: CustomResourceDefinitionSpec;
  status?: CustomResourceDefinitionStatus;
}
/* io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.CustomResourceDefinitionCondition */
/* CustomResourceDefinitionCondition contains details for the current condition of this pod. */
export interface CustomResourceDefinitionCondition {
  lastTransitionTime?: Time;
  message?: string;
  reason?: string;
  status: string;
  type: string;
}
/* io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.CustomResourceDefinitionList */
/* CustomResourceDefinitionList is a list of CustomResourceDefinition objects. */
export interface ApiextensionsK8sIoV1CustomResourceDefinitionList {
  apiVersion?: string;
  items: ApiextensionsK8sIoV1CustomResourceDefinition[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.CustomResourceDefinitionNames */
/* CustomResourceDefinitionNames indicates the names to serve this CustomResourceDefinition */
export interface CustomResourceDefinitionNames {
  categories?: string[];
  kind: string;
  listKind?: string;
  plural: string;
  shortNames?: string[];
  singular?: string;
}
/* io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.CustomResourceDefinitionSpec */
/* CustomResourceDefinitionSpec describes how a user wants their resource to appear */
export interface CustomResourceDefinitionSpec {
  conversion?: CustomResourceConversion;
  group: string;
  names: CustomResourceDefinitionNames;
  preserveUnknownFields?: boolean;
  scope: string;
  versions: CustomResourceDefinitionVersion[];
}
/* io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.CustomResourceDefinitionStatus */
/* CustomResourceDefinitionStatus indicates the state of the CustomResourceDefinition */
export interface CustomResourceDefinitionStatus {
  acceptedNames?: CustomResourceDefinitionNames;
  conditions?: CustomResourceDefinitionCondition[];
  storedVersions?: string[];
}
/* io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.CustomResourceDefinitionVersion */
/* CustomResourceDefinitionVersion describes a version for CRD. */
export interface CustomResourceDefinitionVersion {
  additionalPrinterColumns?: CustomResourceColumnDefinition[];
  deprecated?: boolean;
  deprecationWarning?: string;
  name: string;
  schema?: CustomResourceValidation;
  selectableFields?: SelectableField[];
  served: boolean;
  storage: boolean;
  subresources?: CustomResourceSubresources;
}
/* io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.CustomResourceSubresourceScale */
/* CustomResourceSubresourceScale defines how to serve the scale subresource for CustomResources. */
export interface CustomResourceSubresourceScale {
  labelSelectorPath?: string;
  specReplicasPath: string;
  statusReplicasPath: string;
}
/* io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.CustomResourceSubresourceStatus */
/* CustomResourceSubresourceStatus defines how to serve the status subresource for CustomResources. Status is represented by the `.status` JSON path inside of a CustomResource. When set, * exposes a /status subresource for the custom resource * PUT requests to the /status subresource take a custom resource object, and ignore changes to anything except the status stanza * PUT/POST/PATCH requests to the custom resource ignore changes to the status stanza */
export type CustomResourceSubresourceStatus = {
  [key: string]: unknown;
};
/* io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.CustomResourceSubresources */
/* CustomResourceSubresources defines the status and scale subresources for CustomResources. */
export interface CustomResourceSubresources {
  scale?: CustomResourceSubresourceScale;
  status?: CustomResourceSubresourceStatus;
}
/* io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.CustomResourceValidation */
/* CustomResourceValidation is a list of validation methods for CustomResources. */
export interface CustomResourceValidation {
  openAPIV3Schema?: JSONSchemaProps;
}
/* io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.ExternalDocumentation */
/* ExternalDocumentation allows referencing an external resource for extended documentation. */
export interface ExternalDocumentation {
  description?: string;
  url?: string;
}
/* io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.JSON */
/* JSON represents any valid JSON value. These types are supported: bool, int64, float64, string, []interface{}, map[string]interface{} and nil. */
export type JSON = any;
/* io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.JSONSchemaProps */
/* JSONSchemaProps is a JSON-Schema following Specification Draft 4 (http://json-schema.org/). */
export interface JSONSchemaProps {
  $ref?: string;
  $schema?: string;
  additionalItems?: JSONSchemaPropsOrBool;
  additionalProperties?: JSONSchemaPropsOrBool;
  allOf?: JSONSchemaProps[];
  anyOf?: JSONSchemaProps[];
  default?: JSON;
  definitions?: {
    [key: string]: unknown;
  };
  dependencies?: {
    [key: string]: unknown;
  };
  description?: string;
  enum?: JSON[];
  example?: JSON;
  exclusiveMaximum?: boolean;
  exclusiveMinimum?: boolean;
  externalDocs?: ExternalDocumentation;
  format?: string;
  id?: string;
  items?: JSONSchemaPropsOrArray;
  maxItems?: number;
  maxLength?: number;
  maxProperties?: number;
  maximum?: number;
  minItems?: number;
  minLength?: number;
  minProperties?: number;
  minimum?: number;
  multipleOf?: number;
  not?: JSONSchemaProps;
  nullable?: boolean;
  oneOf?: JSONSchemaProps[];
  pattern?: string;
  patternProperties?: {
    [key: string]: unknown;
  };
  properties?: {
    [key: string]: unknown;
  };
  required?: string[];
  title?: string;
  type?: string;
  uniqueItems?: boolean;
  "x-kubernetes-embedded-resource"?: boolean;
  "x-kubernetes-int-or-string"?: boolean;
  "x-kubernetes-list-map-keys"?: string[];
  "x-kubernetes-list-type"?: string;
  "x-kubernetes-map-type"?: string;
  "x-kubernetes-preserve-unknown-fields"?: boolean;
  "x-kubernetes-validations"?: ValidationRule[];
}
/* io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.JSONSchemaPropsOrArray */
/* JSONSchemaPropsOrArray represents a value that can either be a JSONSchemaProps or an array of JSONSchemaProps. Mainly here for serialization purposes. */
export type JSONSchemaPropsOrArray = any;
/* io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.JSONSchemaPropsOrBool */
/* JSONSchemaPropsOrBool represents JSONSchemaProps or a boolean value. Defaults to true for the boolean property. */
export type JSONSchemaPropsOrBool = any;
/* io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.JSONSchemaPropsOrStringArray */
/* JSONSchemaPropsOrStringArray represents a JSONSchemaProps or a string array. */
export type JSONSchemaPropsOrStringArray = any;
/* io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.SelectableField */
/* SelectableField specifies the JSON path of a field that may be used with field selectors. */
export interface SelectableField {
  jsonPath: string;
}
/* io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.ServiceReference */
/* ServiceReference holds a reference to Service.legacy.k8s.io */
export interface IoK8sApiextensionsApiserverPkgApisApiextensionsV1ServiceReference {
  name: string;
  namespace: string;
  path?: string;
  port?: number;
}
/* io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.ValidationRule */
/* ValidationRule describes a validation rule written in the CEL expression language. */
export interface ValidationRule {
  fieldPath?: string;
  message?: string;
  messageExpression?: string;
  optionalOldSelf?: boolean;
  reason?: "FieldValueDuplicate" | "FieldValueForbidden" | "FieldValueInvalid" | "FieldValueRequired";
  rule: string;
}
/* io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.WebhookClientConfig */
/* WebhookClientConfig contains the information to make a TLS connection with the webhook. */
export interface IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookClientConfig {
  caBundle?: string;
  service?: IoK8sApiextensionsApiserverPkgApisApiextensionsV1ServiceReference;
  url?: string;
}
/* io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.WebhookConversion */
/* WebhookConversion describes how to call a conversion webhook */
export interface WebhookConversion {
  clientConfig?: IoK8sApiextensionsApiserverPkgApisApiextensionsV1WebhookClientConfig;
  conversionReviewVersions: string[];
}
/* io.k8s.apimachinery.pkg.api.resource.Quantity */
/* Quantity is a fixed-point representation of a number. It provides convenient marshaling/unmarshaling in JSON and YAML, in addition to String() and AsInt64() accessors.

The serialization format is:

``` <quantity>        ::= <signedNumber><suffix>

	(Note that <suffix> may be empty, from the "" case in <decimalSI>.)

<digit>           ::= 0 | 1 | ... | 9 <digits>          ::= <digit> | <digit><digits> <number>          ::= <digits> | <digits>.<digits> | <digits>. | .<digits> <sign>            ::= "+" | "-" <signedNumber>    ::= <number> | <sign><number> <suffix>          ::= <binarySI> | <decimalExponent> | <decimalSI> <binarySI>        ::= Ki | Mi | Gi | Ti | Pi | Ei

	(International System of units; See: http://physics.nist.gov/cuu/Units/binary.html)

<decimalSI>       ::= m | "" | k | M | G | T | P | E

	(Note that 1024 = 1Ki but 1000 = 1k; I didn't choose the capitalization.)

<decimalExponent> ::= "e" <signedNumber> | "E" <signedNumber> ```

No matter which of the three exponent forms is used, no quantity may represent a number greater than 2^63-1 in magnitude, nor may it have more than 3 decimal places. Numbers larger or more precise will be capped or rounded up. (E.g.: 0.1m will rounded up to 1m.) This may be extended in the future if we require larger or smaller quantities.

When a Quantity is parsed from a string, it will remember the type of suffix it had, and will use the same type again when it is serialized.

Before serializing, Quantity will be put in "canonical form". This means that Exponent/suffix will be adjusted up or down (with a corresponding increase or decrease in Mantissa) such that:

- No precision is lost - No fractional digits will be emitted - The exponent (or suffix) is as large as possible.

The sign will be omitted unless the number is negative.

Examples:

- 1.5 will be serialized as "1500m" - 1.5Gi will be serialized as "1536Mi"

Note that the quantity will NEVER be internally represented by a floating point number. That is the whole point of this exercise.

Non-canonical values will still parse as long as they are well formed, but will be re-emitted in their canonical form. (So always use canonical form, or don't diff.)

This format is intended to make it difficult to use these numbers without writing some sort of special handling code in the hopes that that will cause implementors to also use a fixed point implementation. */
export type Quantity = string;
/* io.k8s.apimachinery.pkg.apis.meta.v1.APIGroup */
/* APIGroup contains the name, the supported versions, and the preferred version of a group. */
export interface APIGroup {
  apiVersion?: string;
  kind?: string;
  name: string;
  preferredVersion?: GroupVersionForDiscovery;
  serverAddressByClientCIDRs?: ServerAddressByClientCIDR[];
  versions: GroupVersionForDiscovery[];
}
/* io.k8s.apimachinery.pkg.apis.meta.v1.APIGroupList */
/* APIGroupList is a list of APIGroup, to allow clients to discover the API at /apis. */
export interface APIGroupList {
  apiVersion?: string;
  groups: APIGroup[];
  kind?: string;
}
/* io.k8s.apimachinery.pkg.apis.meta.v1.APIResource */
/* APIResource specifies the name of a resource and whether it is namespaced. */
export interface APIResource {
  categories?: string[];
  group?: string;
  kind: string;
  name: string;
  namespaced: boolean;
  shortNames?: string[];
  singularName: string;
  storageVersionHash?: string;
  verbs: string[];
  version?: string;
}
/* io.k8s.apimachinery.pkg.apis.meta.v1.APIResourceList */
/* APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced. */
export interface APIResourceList {
  apiVersion?: string;
  groupVersion: string;
  kind?: string;
  resources: APIResource[];
}
/* io.k8s.apimachinery.pkg.apis.meta.v1.APIVersions */
/* APIVersions lists the versions that are available, to allow clients to discover the API at /api, which is the root path of the legacy v1 API. */
export interface APIVersions {
  apiVersion?: string;
  kind?: string;
  serverAddressByClientCIDRs: ServerAddressByClientCIDR[];
  versions: string[];
}
/* io.k8s.apimachinery.pkg.apis.meta.v1.Condition */
/* Condition contains details for one aspect of the current state of this API Resource. */
export interface Condition {
  lastTransitionTime: Time;
  message: string;
  observedGeneration?: number;
  reason: string;
  status: string;
  type: string;
}
/* io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions */
/* DeleteOptions may be provided when deleting an API object. */
export interface DeleteOptions {
  apiVersion?: string;
  dryRun?: string[];
  gracePeriodSeconds?: number;
  ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
  kind?: string;
  orphanDependents?: boolean;
  preconditions?: Preconditions;
  propagationPolicy?: string;
}
/* io.k8s.apimachinery.pkg.apis.meta.v1.FieldSelectorRequirement */
/* FieldSelectorRequirement is a selector that contains values, a key, and an operator that relates the key and values. */
export interface FieldSelectorRequirement {
  key: string;
  operator: string;
  values?: string[];
}
/* io.k8s.apimachinery.pkg.apis.meta.v1.FieldsV1 */
/* FieldsV1 stores a set of fields in a data structure like a Trie, in JSON format.

Each key is either a '.' representing the field itself, and will always map to an empty set, or a string representing a sub-field or item. The string will follow one of these four formats: 'f:<name>', where <name> is the name of a field in a struct, or key in a map 'v:<value>', where <value> is the exact json formatted value of a list item 'i:<index>', where <index> is position of a item in a list 'k:<keys>', where <keys> is a map of  a list item's key fields to their unique values If a key maps to an empty Fields value, the field that key represents is part of the set.

The exact format is defined in sigs.k8s.io/structured-merge-diff */
export type FieldsV1 = {
  [key: string]: unknown;
};
/* io.k8s.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery */
/* GroupVersion contains the "group/version" and "version" string of a version. It is made a struct to keep extensibility. */
export interface GroupVersionForDiscovery {
  groupVersion: string;
  version: string;
}
/* io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector */
/* A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects. */
export interface LabelSelector {
  matchExpressions?: LabelSelectorRequirement[];
  matchLabels?: {
    [key: string]: unknown;
  };
}
/* io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement */
/* A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values. */
export interface LabelSelectorRequirement {
  key: string;
  operator: string;
  values?: string[];
}
/* io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta */
/* ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}. */
export interface ListMeta {
  continue?: string;
  remainingItemCount?: number;
  resourceVersion?: string;
  selfLink?: string;
}
/* io.k8s.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry */
/* ManagedFieldsEntry is a workflow-id, a FieldSet and the group version of the resource that the fieldset applies to. */
export interface ManagedFieldsEntry {
  apiVersion?: string;
  fieldsType?: string;
  fieldsV1?: FieldsV1;
  manager?: string;
  operation?: string;
  subresource?: string;
  time?: Time;
}
/* io.k8s.apimachinery.pkg.apis.meta.v1.MicroTime */
/* MicroTime is version of Time with microsecond level precision. */
export type MicroTime = string;
/* io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta */
/* ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create. */
export interface ObjectMeta {
  annotations?: {
    [key: string]: unknown;
  };
  creationTimestamp?: Time;
  deletionGracePeriodSeconds?: number;
  deletionTimestamp?: Time;
  finalizers?: string[];
  generateName?: string;
  generation?: number;
  labels?: {
    [key: string]: unknown;
  };
  managedFields?: ManagedFieldsEntry[];
  name?: string;
  namespace?: string;
  ownerReferences?: OwnerReference[];
  resourceVersion?: string;
  selfLink?: string;
  uid?: string;
}
/* io.k8s.apimachinery.pkg.apis.meta.v1.OwnerReference */
/* OwnerReference contains enough information to let you identify an owning object. An owning object must be in the same namespace as the dependent, or be cluster-scoped, so there is no namespace field. */
export interface OwnerReference {
  apiVersion: string;
  blockOwnerDeletion?: boolean;
  controller?: boolean;
  kind: string;
  name: string;
  uid: string;
}
/* io.k8s.apimachinery.pkg.apis.meta.v1.Patch */
/* Patch is provided to give a concrete name and type to the Kubernetes PATCH request body. */
export type Patch = {
  [key: string]: unknown;
};
/* io.k8s.apimachinery.pkg.apis.meta.v1.Preconditions */
/* Preconditions must be fulfilled before an operation (update, delete, etc.) is carried out. */
export interface Preconditions {
  resourceVersion?: string;
  uid?: string;
}
/* io.k8s.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR */
/* ServerAddressByClientCIDR helps the client to determine the server address that they should use, depending on the clientCIDR that they match. */
export interface ServerAddressByClientCIDR {
  clientCIDR: string;
  serverAddress: string;
}
/* io.k8s.apimachinery.pkg.apis.meta.v1.Status */
/* Status is a return value for calls that don't return other objects. */
export interface Status {
  apiVersion?: string;
  code?: number;
  details?: StatusDetails;
  kind?: string;
  message?: string;
  metadata?: ListMeta;
  reason?: string;
  status?: string;
}
/* io.k8s.apimachinery.pkg.apis.meta.v1.StatusCause */
/* StatusCause provides more information about an api.Status failure, including cases when multiple errors are encountered. */
export interface StatusCause {
  field?: string;
  message?: string;
  reason?: string;
}
/* io.k8s.apimachinery.pkg.apis.meta.v1.StatusDetails */
/* StatusDetails is a set of additional properties that MAY be set by the server to provide additional information about a response. The Reason field of a Status object defines what attributes will be set. Clients must ignore fields that do not match the defined type of each attribute, and should assume that any attribute may be empty, invalid, or under defined. */
export interface StatusDetails {
  causes?: StatusCause[];
  group?: string;
  kind?: string;
  name?: string;
  retryAfterSeconds?: number;
  uid?: string;
}
/* io.k8s.apimachinery.pkg.apis.meta.v1.Time */
/* Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers. */
export type Time = string;
/* io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent */
/* Event represents a single event to a watched resource. */
export interface WatchEvent {
  object: RawExtension;
  type: string;
}
/* io.k8s.apimachinery.pkg.runtime.RawExtension */
/* RawExtension is used to hold extensions in external versions.

To use this, make a field which has RawExtension as its type in your external, versioned struct, and Object in your internal struct. You also need to register your various plugin types.

// Internal package:

	type MyAPIObject struct {
		runtime.TypeMeta `json:",inline"`
		MyPlugin runtime.Object `json:"myPlugin"`
	}

	type PluginA struct {
		AOption string `json:"aOption"`
	}

// External package:

	type MyAPIObject struct {
		runtime.TypeMeta `json:",inline"`
		MyPlugin runtime.RawExtension `json:"myPlugin"`
	}

	type PluginA struct {
		AOption string `json:"aOption"`
	}

// On the wire, the JSON will look something like this:

	{
		"kind":"MyAPIObject",
		"apiVersion":"v1",
		"myPlugin": {
			"kind":"PluginA",
			"aOption":"foo",
		},
	}

So what happens? Decode first uses json or yaml to unmarshal the serialized data into your external MyAPIObject. That causes the raw JSON to be stored, but not unpacked. The next step is to copy (using pkg/conversion) into the internal struct. The runtime package's DefaultScheme has conversion functions installed which will unpack the JSON stored in RawExtension, turning it into the correct object type, and storing it in the Object. (TODO: In the case where the object is of an unknown type, a runtime.Unknown object will be created and stored.) */
export type RawExtension = {
  [key: string]: unknown;
};
/* io.k8s.apimachinery.pkg.util.intstr.IntOrString */
/* IntOrString is a type that can hold an int32 or a string.  When used in JSON or YAML marshalling and unmarshalling, it produces or consumes the inner type.  This allows you to have, for example, a JSON field that can accept a name or number. */
export type IntOrString = string;
/* io.k8s.apimachinery.pkg.version.Info */
/* Info contains versioning information. how we'll want to distribute that information. */
export interface Info {
  buildDate: string;
  compiler: string;
  gitCommit: string;
  gitTreeState: string;
  gitVersion: string;
  goVersion: string;
  major: string;
  minor: string;
  platform: string;
}
/* io.k8s.kube-aggregator.pkg.apis.apiregistration.v1.APIService */
/* APIService represents a server for a particular GroupVersion. Name must be "version.group". */
export interface ApiregistrationK8sIoV1APIService {
  apiVersion?: string;
  kind?: string;
  metadata?: ObjectMeta;
  spec?: APIServiceSpec;
  status?: APIServiceStatus;
}
/* io.k8s.kube-aggregator.pkg.apis.apiregistration.v1.APIServiceCondition */
/* APIServiceCondition describes the state of an APIService at a particular point */
export interface APIServiceCondition {
  lastTransitionTime?: Time;
  message?: string;
  reason?: string;
  status: string;
  type: string;
}
/* io.k8s.kube-aggregator.pkg.apis.apiregistration.v1.APIServiceList */
/* APIServiceList is a list of APIService objects. */
export interface ApiregistrationK8sIoV1APIServiceList {
  apiVersion?: string;
  items: ApiregistrationK8sIoV1APIService[];
  kind?: string;
  metadata?: ListMeta;
}
/* io.k8s.kube-aggregator.pkg.apis.apiregistration.v1.APIServiceSpec */
/* APIServiceSpec contains information for locating and communicating with a server. Only https is supported, though you are able to disable certificate verification. */
export interface APIServiceSpec {
  caBundle?: string;
  group?: string;
  groupPriorityMinimum: number;
  insecureSkipTLSVerify?: boolean;
  service?: IoK8sKubeAggregatorPkgApisApiregistrationV1ServiceReference;
  version?: string;
  versionPriority: number;
}
/* io.k8s.kube-aggregator.pkg.apis.apiregistration.v1.APIServiceStatus */
/* APIServiceStatus contains derived information about an API server */
export interface APIServiceStatus {
  conditions?: APIServiceCondition[];
}
/* io.k8s.kube-aggregator.pkg.apis.apiregistration.v1.ServiceReference */
/* ServiceReference holds a reference to Service.legacy.k8s.io */
export interface IoK8sKubeAggregatorPkgApisApiregistrationV1ServiceReference {
  name?: string;
  namespace?: string;
  port?: number;
}
export interface GetServiceAccountIssuerOpenIDConfigurationRequest {}
export interface GetCoreAPIVersionsRequest {}
export interface GetCoreV1APIResourcesRequest {}
export interface ListCoreV1ComponentStatusRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ReadCoreV1ComponentStatusRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ListCoreV1ConfigMapForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListCoreV1EndpointsForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListCoreV1EventForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListCoreV1LimitRangeForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListCoreV1NamespaceRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface CreateCoreV1NamespaceRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  body: Namespace;
}
export interface CreateCoreV1NamespacedBindingRequest {
  query: {
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    pretty?: string;
  };
  path: {
    namespace: string;
  };
  body: Binding;
}
export interface ListCoreV1NamespacedConfigMapRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateCoreV1NamespacedConfigMapRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: ConfigMap;
}
export interface DeleteCoreV1CollectionNamespacedConfigMapRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadCoreV1NamespacedConfigMapRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceCoreV1NamespacedConfigMapRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: ConfigMap;
}
export interface DeleteCoreV1NamespacedConfigMapRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchCoreV1NamespacedConfigMapRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListCoreV1NamespacedEndpointsRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateCoreV1NamespacedEndpointsRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: Endpoints;
}
export interface DeleteCoreV1CollectionNamespacedEndpointsRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadCoreV1NamespacedEndpointsRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceCoreV1NamespacedEndpointsRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Endpoints;
}
export interface DeleteCoreV1NamespacedEndpointsRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchCoreV1NamespacedEndpointsRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListCoreV1NamespacedEventRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateCoreV1NamespacedEventRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: Event;
}
export interface DeleteCoreV1CollectionNamespacedEventRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadCoreV1NamespacedEventRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceCoreV1NamespacedEventRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Event;
}
export interface DeleteCoreV1NamespacedEventRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchCoreV1NamespacedEventRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListCoreV1NamespacedLimitRangeRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateCoreV1NamespacedLimitRangeRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: LimitRange;
}
export interface DeleteCoreV1CollectionNamespacedLimitRangeRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadCoreV1NamespacedLimitRangeRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceCoreV1NamespacedLimitRangeRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: LimitRange;
}
export interface DeleteCoreV1NamespacedLimitRangeRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchCoreV1NamespacedLimitRangeRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListCoreV1NamespacedPersistentVolumeClaimRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateCoreV1NamespacedPersistentVolumeClaimRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: PersistentVolumeClaim;
}
export interface DeleteCoreV1CollectionNamespacedPersistentVolumeClaimRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadCoreV1NamespacedPersistentVolumeClaimRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceCoreV1NamespacedPersistentVolumeClaimRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: PersistentVolumeClaim;
}
export interface DeleteCoreV1NamespacedPersistentVolumeClaimRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchCoreV1NamespacedPersistentVolumeClaimRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadCoreV1NamespacedPersistentVolumeClaimStatusRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceCoreV1NamespacedPersistentVolumeClaimStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: PersistentVolumeClaim;
}
export interface PatchCoreV1NamespacedPersistentVolumeClaimStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListCoreV1NamespacedPodRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateCoreV1NamespacedPodRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: Pod;
}
export interface DeleteCoreV1CollectionNamespacedPodRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadCoreV1NamespacedPodRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceCoreV1NamespacedPodRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Pod;
}
export interface DeleteCoreV1NamespacedPodRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchCoreV1NamespacedPodRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ConnectCoreV1GetNamespacedPodAttachRequest {
  query: {
    container?: string;
    stderr?: boolean;
    stdin?: boolean;
    stdout?: boolean;
    tty?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ConnectCoreV1PostNamespacedPodAttachRequest {
  query: {
    container?: string;
    stderr?: boolean;
    stdin?: boolean;
    stdout?: boolean;
    tty?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface CreateCoreV1NamespacedPodBindingRequest {
  query: {
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Binding;
}
export interface ReadCoreV1NamespacedPodEphemeralcontainersRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceCoreV1NamespacedPodEphemeralcontainersRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Pod;
}
export interface PatchCoreV1NamespacedPodEphemeralcontainersRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface CreateCoreV1NamespacedPodEvictionRequest {
  query: {
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: PolicyV1Eviction;
}
export interface ConnectCoreV1GetNamespacedPodExecRequest {
  query: {
    command?: string;
    container?: string;
    stderr?: boolean;
    stdin?: boolean;
    stdout?: boolean;
    tty?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ConnectCoreV1PostNamespacedPodExecRequest {
  query: {
    command?: string;
    container?: string;
    stderr?: boolean;
    stdin?: boolean;
    stdout?: boolean;
    tty?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReadCoreV1NamespacedPodLogRequest {
  query: {
    container?: string;
    follow?: boolean;
    insecureSkipTLSVerifyBackend?: boolean;
    limitBytes?: number;
    pretty?: string;
    previous?: boolean;
    sinceSeconds?: number;
    stream?: string;
    tailLines?: number;
    timestamps?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ConnectCoreV1GetNamespacedPodPortforwardRequest {
  query: {
    ports?: number;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ConnectCoreV1PostNamespacedPodPortforwardRequest {
  query: {
    ports?: number;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ConnectCoreV1GetNamespacedPodProxyRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ConnectCoreV1PostNamespacedPodProxyRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ConnectCoreV1PutNamespacedPodProxyRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ConnectCoreV1DeleteNamespacedPodProxyRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ConnectCoreV1PatchNamespacedPodProxyRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ConnectCoreV1GetNamespacedPodProxyWithPathRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
    namespace: string;
    path: string;
  };
}
export interface ConnectCoreV1PostNamespacedPodProxyWithPathRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
    namespace: string;
    path: string;
  };
}
export interface ConnectCoreV1PutNamespacedPodProxyWithPathRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
    namespace: string;
    path: string;
  };
}
export interface ConnectCoreV1DeleteNamespacedPodProxyWithPathRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
    namespace: string;
    path: string;
  };
}
export interface ConnectCoreV1PatchNamespacedPodProxyWithPathRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
    namespace: string;
    path: string;
  };
}
export interface ReadCoreV1NamespacedPodStatusRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceCoreV1NamespacedPodStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Pod;
}
export interface PatchCoreV1NamespacedPodStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListCoreV1NamespacedPodTemplateRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateCoreV1NamespacedPodTemplateRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: PodTemplate;
}
export interface DeleteCoreV1CollectionNamespacedPodTemplateRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadCoreV1NamespacedPodTemplateRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceCoreV1NamespacedPodTemplateRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: PodTemplate;
}
export interface DeleteCoreV1NamespacedPodTemplateRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchCoreV1NamespacedPodTemplateRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListCoreV1NamespacedReplicationControllerRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateCoreV1NamespacedReplicationControllerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: ReplicationController;
}
export interface DeleteCoreV1CollectionNamespacedReplicationControllerRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadCoreV1NamespacedReplicationControllerRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceCoreV1NamespacedReplicationControllerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: ReplicationController;
}
export interface DeleteCoreV1NamespacedReplicationControllerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchCoreV1NamespacedReplicationControllerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadCoreV1NamespacedReplicationControllerScaleRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceCoreV1NamespacedReplicationControllerScaleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AutoscalingV1Scale;
}
export interface PatchCoreV1NamespacedReplicationControllerScaleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadCoreV1NamespacedReplicationControllerStatusRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceCoreV1NamespacedReplicationControllerStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: ReplicationController;
}
export interface PatchCoreV1NamespacedReplicationControllerStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListCoreV1NamespacedResourceQuotaRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateCoreV1NamespacedResourceQuotaRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: ResourceQuota;
}
export interface DeleteCoreV1CollectionNamespacedResourceQuotaRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadCoreV1NamespacedResourceQuotaRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceCoreV1NamespacedResourceQuotaRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: ResourceQuota;
}
export interface DeleteCoreV1NamespacedResourceQuotaRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchCoreV1NamespacedResourceQuotaRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadCoreV1NamespacedResourceQuotaStatusRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceCoreV1NamespacedResourceQuotaStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: ResourceQuota;
}
export interface PatchCoreV1NamespacedResourceQuotaStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListCoreV1NamespacedSecretRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateCoreV1NamespacedSecretRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: Secret;
}
export interface DeleteCoreV1CollectionNamespacedSecretRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadCoreV1NamespacedSecretRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceCoreV1NamespacedSecretRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Secret;
}
export interface DeleteCoreV1NamespacedSecretRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchCoreV1NamespacedSecretRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListCoreV1NamespacedServiceAccountRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateCoreV1NamespacedServiceAccountRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: ServiceAccount;
}
export interface DeleteCoreV1CollectionNamespacedServiceAccountRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadCoreV1NamespacedServiceAccountRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceCoreV1NamespacedServiceAccountRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: ServiceAccount;
}
export interface DeleteCoreV1NamespacedServiceAccountRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchCoreV1NamespacedServiceAccountRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface CreateCoreV1NamespacedServiceAccountTokenRequest {
  query: {
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AuthenticationK8sIoV1TokenRequest;
}
export interface ListCoreV1NamespacedServiceRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateCoreV1NamespacedServiceRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: Service;
}
export interface DeleteCoreV1CollectionNamespacedServiceRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadCoreV1NamespacedServiceRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceCoreV1NamespacedServiceRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Service;
}
export interface DeleteCoreV1NamespacedServiceRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchCoreV1NamespacedServiceRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ConnectCoreV1GetNamespacedServiceProxyRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ConnectCoreV1PostNamespacedServiceProxyRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ConnectCoreV1PutNamespacedServiceProxyRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ConnectCoreV1DeleteNamespacedServiceProxyRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ConnectCoreV1PatchNamespacedServiceProxyRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ConnectCoreV1GetNamespacedServiceProxyWithPathRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
    namespace: string;
    path: string;
  };
}
export interface ConnectCoreV1PostNamespacedServiceProxyWithPathRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
    namespace: string;
    path: string;
  };
}
export interface ConnectCoreV1PutNamespacedServiceProxyWithPathRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
    namespace: string;
    path: string;
  };
}
export interface ConnectCoreV1DeleteNamespacedServiceProxyWithPathRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
    namespace: string;
    path: string;
  };
}
export interface ConnectCoreV1PatchNamespacedServiceProxyWithPathRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
    namespace: string;
    path: string;
  };
}
export interface ReadCoreV1NamespacedServiceStatusRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceCoreV1NamespacedServiceStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Service;
}
export interface PatchCoreV1NamespacedServiceStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadCoreV1NamespaceRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceCoreV1NamespaceRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: Namespace;
}
export interface DeleteCoreV1NamespaceRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
  };
}
export interface PatchCoreV1NamespaceRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface ReplaceCoreV1NamespaceFinalizeRequest {
  query: {
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    pretty?: string;
  };
  path: {
    name: string;
  };
  body: Namespace;
}
export interface ReadCoreV1NamespaceStatusRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceCoreV1NamespaceStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: Namespace;
}
export interface PatchCoreV1NamespaceStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface ListCoreV1NodeRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface CreateCoreV1NodeRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  body: Node;
}
export interface DeleteCoreV1CollectionNodeRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
}
export interface ReadCoreV1NodeRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceCoreV1NodeRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: Node;
}
export interface DeleteCoreV1NodeRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
  };
}
export interface PatchCoreV1NodeRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface ConnectCoreV1GetNodeProxyRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
  };
}
export interface ConnectCoreV1PostNodeProxyRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
  };
}
export interface ConnectCoreV1PutNodeProxyRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
  };
}
export interface ConnectCoreV1DeleteNodeProxyRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
  };
}
export interface ConnectCoreV1PatchNodeProxyRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
  };
}
export interface ConnectCoreV1GetNodeProxyWithPathRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
    path: string;
  };
}
export interface ConnectCoreV1PostNodeProxyWithPathRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
    path: string;
  };
}
export interface ConnectCoreV1PutNodeProxyWithPathRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
    path: string;
  };
}
export interface ConnectCoreV1DeleteNodeProxyWithPathRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
    path: string;
  };
}
export interface ConnectCoreV1PatchNodeProxyWithPathRequest {
  query: {
    path?: string;
  };
  path: {
    name: string;
    path: string;
  };
}
export interface ReadCoreV1NodeStatusRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceCoreV1NodeStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: Node;
}
export interface PatchCoreV1NodeStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface ListCoreV1PersistentVolumeClaimForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListCoreV1PersistentVolumeRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface CreateCoreV1PersistentVolumeRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  body: PersistentVolume;
}
export interface DeleteCoreV1CollectionPersistentVolumeRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
}
export interface ReadCoreV1PersistentVolumeRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceCoreV1PersistentVolumeRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: PersistentVolume;
}
export interface DeleteCoreV1PersistentVolumeRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
  };
}
export interface PatchCoreV1PersistentVolumeRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface ReadCoreV1PersistentVolumeStatusRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceCoreV1PersistentVolumeStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: PersistentVolume;
}
export interface PatchCoreV1PersistentVolumeStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface ListCoreV1PodForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListCoreV1PodTemplateForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListCoreV1ReplicationControllerForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListCoreV1ResourceQuotaForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListCoreV1SecretForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListCoreV1ServiceAccountForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListCoreV1ServiceForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchCoreV1ConfigMapListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchCoreV1EndpointsListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchCoreV1EventListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchCoreV1LimitRangeListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchCoreV1NamespaceListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchCoreV1NamespacedConfigMapListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchCoreV1NamespacedConfigMapRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface WatchCoreV1NamespacedEndpointsListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchCoreV1NamespacedEndpointsRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface WatchCoreV1NamespacedEventListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchCoreV1NamespacedEventRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface WatchCoreV1NamespacedLimitRangeListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchCoreV1NamespacedLimitRangeRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface WatchCoreV1NamespacedPersistentVolumeClaimListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchCoreV1NamespacedPersistentVolumeClaimRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface WatchCoreV1NamespacedPodListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchCoreV1NamespacedPodRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface WatchCoreV1NamespacedPodTemplateListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchCoreV1NamespacedPodTemplateRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface WatchCoreV1NamespacedReplicationControllerListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchCoreV1NamespacedReplicationControllerRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface WatchCoreV1NamespacedResourceQuotaListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchCoreV1NamespacedResourceQuotaRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface WatchCoreV1NamespacedSecretListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchCoreV1NamespacedSecretRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface WatchCoreV1NamespacedServiceAccountListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchCoreV1NamespacedServiceAccountRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface WatchCoreV1NamespacedServiceListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchCoreV1NamespacedServiceRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface WatchCoreV1NamespaceRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
  };
}
export interface WatchCoreV1NodeListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchCoreV1NodeRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
  };
}
export interface WatchCoreV1PersistentVolumeClaimListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchCoreV1PersistentVolumeListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchCoreV1PersistentVolumeRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
  };
}
export interface WatchCoreV1PodListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchCoreV1PodTemplateListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchCoreV1ReplicationControllerListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchCoreV1ResourceQuotaListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchCoreV1SecretListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchCoreV1ServiceAccountListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchCoreV1ServiceListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface GetAPIVersionsRequest {}
export interface ListAcmeCertManagerIoV1ChallengeForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListAcmeCertManagerIoV1NamespacedChallengeRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateAcmeCertManagerIoV1NamespacedChallengeRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: AcmeCertManagerIoV1Challenge;
}
export interface DeleteAcmeCertManagerIoV1CollectionNamespacedChallengeRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadAcmeCertManagerIoV1NamespacedChallengeRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceAcmeCertManagerIoV1NamespacedChallengeRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AcmeCertManagerIoV1Challenge;
}
export interface DeleteAcmeCertManagerIoV1NamespacedChallengeRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchAcmeCertManagerIoV1NamespacedChallengeRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadAcmeCertManagerIoV1NamespacedChallengeStatusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceAcmeCertManagerIoV1NamespacedChallengeStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AcmeCertManagerIoV1Challenge;
}
export interface PatchAcmeCertManagerIoV1NamespacedChallengeStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListAcmeCertManagerIoV1NamespacedOrderRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateAcmeCertManagerIoV1NamespacedOrderRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: AcmeCertManagerIoV1Order;
}
export interface DeleteAcmeCertManagerIoV1CollectionNamespacedOrderRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadAcmeCertManagerIoV1NamespacedOrderRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceAcmeCertManagerIoV1NamespacedOrderRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AcmeCertManagerIoV1Order;
}
export interface DeleteAcmeCertManagerIoV1NamespacedOrderRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchAcmeCertManagerIoV1NamespacedOrderRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadAcmeCertManagerIoV1NamespacedOrderStatusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceAcmeCertManagerIoV1NamespacedOrderStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AcmeCertManagerIoV1Order;
}
export interface PatchAcmeCertManagerIoV1NamespacedOrderStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListAcmeCertManagerIoV1OrderForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface GetAdmissionregistrationAPIGroupRequest {}
export interface GetAdmissionregistrationV1APIResourcesRequest {}
export interface ListAdmissionregistrationV1MutatingWebhookConfigurationRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface CreateAdmissionregistrationV1MutatingWebhookConfigurationRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  body: AdmissionregistrationK8sIoV1MutatingWebhookConfiguration;
}
export interface DeleteAdmissionregistrationV1CollectionMutatingWebhookConfigurationRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
}
export interface ReadAdmissionregistrationV1MutatingWebhookConfigurationRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceAdmissionregistrationV1MutatingWebhookConfigurationRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: AdmissionregistrationK8sIoV1MutatingWebhookConfiguration;
}
export interface DeleteAdmissionregistrationV1MutatingWebhookConfigurationRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
  };
}
export interface PatchAdmissionregistrationV1MutatingWebhookConfigurationRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface ListAdmissionregistrationV1ValidatingAdmissionPolicyRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface CreateAdmissionregistrationV1ValidatingAdmissionPolicyRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  body: AdmissionregistrationK8sIoV1ValidatingAdmissionPolicy;
}
export interface DeleteAdmissionregistrationV1CollectionValidatingAdmissionPolicyRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
}
export interface ReadAdmissionregistrationV1ValidatingAdmissionPolicyRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceAdmissionregistrationV1ValidatingAdmissionPolicyRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: AdmissionregistrationK8sIoV1ValidatingAdmissionPolicy;
}
export interface DeleteAdmissionregistrationV1ValidatingAdmissionPolicyRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
  };
}
export interface PatchAdmissionregistrationV1ValidatingAdmissionPolicyRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface ReadAdmissionregistrationV1ValidatingAdmissionPolicyStatusRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceAdmissionregistrationV1ValidatingAdmissionPolicyStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: AdmissionregistrationK8sIoV1ValidatingAdmissionPolicy;
}
export interface PatchAdmissionregistrationV1ValidatingAdmissionPolicyStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface ListAdmissionregistrationV1ValidatingAdmissionPolicyBindingRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface CreateAdmissionregistrationV1ValidatingAdmissionPolicyBindingRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  body: AdmissionregistrationK8sIoV1ValidatingAdmissionPolicyBinding;
}
export interface DeleteAdmissionregistrationV1CollectionValidatingAdmissionPolicyBindingRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
}
export interface ReadAdmissionregistrationV1ValidatingAdmissionPolicyBindingRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceAdmissionregistrationV1ValidatingAdmissionPolicyBindingRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: AdmissionregistrationK8sIoV1ValidatingAdmissionPolicyBinding;
}
export interface DeleteAdmissionregistrationV1ValidatingAdmissionPolicyBindingRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
  };
}
export interface PatchAdmissionregistrationV1ValidatingAdmissionPolicyBindingRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface ListAdmissionregistrationV1ValidatingWebhookConfigurationRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface CreateAdmissionregistrationV1ValidatingWebhookConfigurationRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  body: AdmissionregistrationK8sIoV1ValidatingWebhookConfiguration;
}
export interface DeleteAdmissionregistrationV1CollectionValidatingWebhookConfigurationRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
}
export interface ReadAdmissionregistrationV1ValidatingWebhookConfigurationRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceAdmissionregistrationV1ValidatingWebhookConfigurationRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: AdmissionregistrationK8sIoV1ValidatingWebhookConfiguration;
}
export interface DeleteAdmissionregistrationV1ValidatingWebhookConfigurationRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
  };
}
export interface PatchAdmissionregistrationV1ValidatingWebhookConfigurationRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface WatchAdmissionregistrationV1MutatingWebhookConfigurationListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchAdmissionregistrationV1MutatingWebhookConfigurationRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
  };
}
export interface WatchAdmissionregistrationV1ValidatingAdmissionPolicyListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchAdmissionregistrationV1ValidatingAdmissionPolicyRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
  };
}
export interface WatchAdmissionregistrationV1ValidatingAdmissionPolicyBindingListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchAdmissionregistrationV1ValidatingAdmissionPolicyBindingRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
  };
}
export interface WatchAdmissionregistrationV1ValidatingWebhookConfigurationListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchAdmissionregistrationV1ValidatingWebhookConfigurationRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
  };
}
export interface GetApiextensionsAPIGroupRequest {}
export interface GetApiextensionsV1APIResourcesRequest {}
export interface ListApiextensionsV1CustomResourceDefinitionRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface CreateApiextensionsV1CustomResourceDefinitionRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  body: ApiextensionsK8sIoV1CustomResourceDefinition;
}
export interface DeleteApiextensionsV1CollectionCustomResourceDefinitionRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
}
export interface ReadApiextensionsV1CustomResourceDefinitionRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceApiextensionsV1CustomResourceDefinitionRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: ApiextensionsK8sIoV1CustomResourceDefinition;
}
export interface DeleteApiextensionsV1CustomResourceDefinitionRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
  };
}
export interface PatchApiextensionsV1CustomResourceDefinitionRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface ReadApiextensionsV1CustomResourceDefinitionStatusRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceApiextensionsV1CustomResourceDefinitionStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: ApiextensionsK8sIoV1CustomResourceDefinition;
}
export interface PatchApiextensionsV1CustomResourceDefinitionStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface WatchApiextensionsV1CustomResourceDefinitionListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchApiextensionsV1CustomResourceDefinitionRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
  };
}
export interface GetApiregistrationAPIGroupRequest {}
export interface GetApiregistrationV1APIResourcesRequest {}
export interface ListApiregistrationV1APIServiceRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface CreateApiregistrationV1APIServiceRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  body: ApiregistrationK8sIoV1APIService;
}
export interface DeleteApiregistrationV1CollectionAPIServiceRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
}
export interface ReadApiregistrationV1APIServiceRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceApiregistrationV1APIServiceRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: ApiregistrationK8sIoV1APIService;
}
export interface DeleteApiregistrationV1APIServiceRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
  };
}
export interface PatchApiregistrationV1APIServiceRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface ReadApiregistrationV1APIServiceStatusRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceApiregistrationV1APIServiceStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: ApiregistrationK8sIoV1APIService;
}
export interface PatchApiregistrationV1APIServiceStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface WatchApiregistrationV1APIServiceListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchApiregistrationV1APIServiceRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
  };
}
export interface GetAppsAPIGroupRequest {}
export interface GetAppsV1APIResourcesRequest {}
export interface ListAppsV1ControllerRevisionForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListAppsV1DaemonSetForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListAppsV1DeploymentForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListAppsV1NamespacedControllerRevisionRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateAppsV1NamespacedControllerRevisionRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: AppsV1ControllerRevision;
}
export interface DeleteAppsV1CollectionNamespacedControllerRevisionRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadAppsV1NamespacedControllerRevisionRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceAppsV1NamespacedControllerRevisionRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AppsV1ControllerRevision;
}
export interface DeleteAppsV1NamespacedControllerRevisionRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchAppsV1NamespacedControllerRevisionRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListAppsV1NamespacedDaemonSetRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateAppsV1NamespacedDaemonSetRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: AppsV1DaemonSet;
}
export interface DeleteAppsV1CollectionNamespacedDaemonSetRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadAppsV1NamespacedDaemonSetRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceAppsV1NamespacedDaemonSetRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AppsV1DaemonSet;
}
export interface DeleteAppsV1NamespacedDaemonSetRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchAppsV1NamespacedDaemonSetRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadAppsV1NamespacedDaemonSetStatusRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceAppsV1NamespacedDaemonSetStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AppsV1DaemonSet;
}
export interface PatchAppsV1NamespacedDaemonSetStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListAppsV1NamespacedDeploymentRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateAppsV1NamespacedDeploymentRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: AppsV1Deployment;
}
export interface DeleteAppsV1CollectionNamespacedDeploymentRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadAppsV1NamespacedDeploymentRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceAppsV1NamespacedDeploymentRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AppsV1Deployment;
}
export interface DeleteAppsV1NamespacedDeploymentRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchAppsV1NamespacedDeploymentRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadAppsV1NamespacedDeploymentScaleRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceAppsV1NamespacedDeploymentScaleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AutoscalingV1Scale;
}
export interface PatchAppsV1NamespacedDeploymentScaleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadAppsV1NamespacedDeploymentStatusRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceAppsV1NamespacedDeploymentStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AppsV1Deployment;
}
export interface PatchAppsV1NamespacedDeploymentStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListAppsV1NamespacedReplicaSetRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateAppsV1NamespacedReplicaSetRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: AppsV1ReplicaSet;
}
export interface DeleteAppsV1CollectionNamespacedReplicaSetRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadAppsV1NamespacedReplicaSetRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceAppsV1NamespacedReplicaSetRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AppsV1ReplicaSet;
}
export interface DeleteAppsV1NamespacedReplicaSetRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchAppsV1NamespacedReplicaSetRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadAppsV1NamespacedReplicaSetScaleRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceAppsV1NamespacedReplicaSetScaleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AutoscalingV1Scale;
}
export interface PatchAppsV1NamespacedReplicaSetScaleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadAppsV1NamespacedReplicaSetStatusRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceAppsV1NamespacedReplicaSetStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AppsV1ReplicaSet;
}
export interface PatchAppsV1NamespacedReplicaSetStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListAppsV1NamespacedStatefulSetRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateAppsV1NamespacedStatefulSetRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: AppsV1StatefulSet;
}
export interface DeleteAppsV1CollectionNamespacedStatefulSetRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadAppsV1NamespacedStatefulSetRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceAppsV1NamespacedStatefulSetRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AppsV1StatefulSet;
}
export interface DeleteAppsV1NamespacedStatefulSetRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchAppsV1NamespacedStatefulSetRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadAppsV1NamespacedStatefulSetScaleRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceAppsV1NamespacedStatefulSetScaleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AutoscalingV1Scale;
}
export interface PatchAppsV1NamespacedStatefulSetScaleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadAppsV1NamespacedStatefulSetStatusRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceAppsV1NamespacedStatefulSetStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AppsV1StatefulSet;
}
export interface PatchAppsV1NamespacedStatefulSetStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListAppsV1ReplicaSetForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListAppsV1StatefulSetForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchAppsV1ControllerRevisionListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchAppsV1DaemonSetListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchAppsV1DeploymentListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchAppsV1NamespacedControllerRevisionListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchAppsV1NamespacedControllerRevisionRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface WatchAppsV1NamespacedDaemonSetListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchAppsV1NamespacedDaemonSetRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface WatchAppsV1NamespacedDeploymentListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchAppsV1NamespacedDeploymentRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface WatchAppsV1NamespacedReplicaSetListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchAppsV1NamespacedReplicaSetRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface WatchAppsV1NamespacedStatefulSetListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchAppsV1NamespacedStatefulSetRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface WatchAppsV1ReplicaSetListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchAppsV1StatefulSetListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface GetAuthenticationAPIGroupRequest {}
export interface GetAuthenticationV1APIResourcesRequest {}
export interface CreateAuthenticationV1SelfSubjectReviewRequest {
  query: {
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    pretty?: string;
  };
  body: AuthenticationK8sIoV1SelfSubjectReview;
}
export interface CreateAuthenticationV1TokenReviewRequest {
  query: {
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    pretty?: string;
  };
  body: AuthenticationK8sIoV1TokenReview;
}
export interface GetAuthorizationAPIGroupRequest {}
export interface GetAuthorizationV1APIResourcesRequest {}
export interface CreateAuthorizationV1NamespacedLocalSubjectAccessReviewRequest {
  query: {
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    pretty?: string;
  };
  path: {
    namespace: string;
  };
  body: AuthorizationK8sIoV1LocalSubjectAccessReview;
}
export interface CreateAuthorizationV1SelfSubjectAccessReviewRequest {
  query: {
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    pretty?: string;
  };
  body: AuthorizationK8sIoV1SelfSubjectAccessReview;
}
export interface CreateAuthorizationV1SelfSubjectRulesReviewRequest {
  query: {
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    pretty?: string;
  };
  body: AuthorizationK8sIoV1SelfSubjectRulesReview;
}
export interface CreateAuthorizationV1SubjectAccessReviewRequest {
  query: {
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    pretty?: string;
  };
  body: AuthorizationK8sIoV1SubjectAccessReview;
}
export interface ListAutoscalingInternalKnativeDevV1alpha1MetricForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListAutoscalingInternalKnativeDevV1alpha1NamespacedMetricRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateAutoscalingInternalKnativeDevV1alpha1NamespacedMetricRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: AutoscalingInternalKnativeDevV1alpha1Metric;
}
export interface DeleteAutoscalingInternalKnativeDevV1alpha1CollectionNamespacedMetricRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadAutoscalingInternalKnativeDevV1alpha1NamespacedMetricRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceAutoscalingInternalKnativeDevV1alpha1NamespacedMetricRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AutoscalingInternalKnativeDevV1alpha1Metric;
}
export interface DeleteAutoscalingInternalKnativeDevV1alpha1NamespacedMetricRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchAutoscalingInternalKnativeDevV1alpha1NamespacedMetricRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadAutoscalingInternalKnativeDevV1alpha1NamespacedMetricStatusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceAutoscalingInternalKnativeDevV1alpha1NamespacedMetricStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AutoscalingInternalKnativeDevV1alpha1Metric;
}
export interface PatchAutoscalingInternalKnativeDevV1alpha1NamespacedMetricStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListAutoscalingInternalKnativeDevV1alpha1NamespacedPodAutoscalerRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateAutoscalingInternalKnativeDevV1alpha1NamespacedPodAutoscalerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: AutoscalingInternalKnativeDevV1alpha1PodAutoscaler;
}
export interface DeleteAutoscalingInternalKnativeDevV1alpha1CollectionNamespacedPodAutoscalerRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadAutoscalingInternalKnativeDevV1alpha1NamespacedPodAutoscalerRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceAutoscalingInternalKnativeDevV1alpha1NamespacedPodAutoscalerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AutoscalingInternalKnativeDevV1alpha1PodAutoscaler;
}
export interface DeleteAutoscalingInternalKnativeDevV1alpha1NamespacedPodAutoscalerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchAutoscalingInternalKnativeDevV1alpha1NamespacedPodAutoscalerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadAutoscalingInternalKnativeDevV1alpha1NamespacedPodAutoscalerStatusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceAutoscalingInternalKnativeDevV1alpha1NamespacedPodAutoscalerStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AutoscalingInternalKnativeDevV1alpha1PodAutoscaler;
}
export interface PatchAutoscalingInternalKnativeDevV1alpha1NamespacedPodAutoscalerStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListAutoscalingInternalKnativeDevV1alpha1PodAutoscalerForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface GetAutoscalingAPIGroupRequest {}
export interface GetAutoscalingV1APIResourcesRequest {}
export interface ListAutoscalingV1HorizontalPodAutoscalerForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListAutoscalingV1NamespacedHorizontalPodAutoscalerRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateAutoscalingV1NamespacedHorizontalPodAutoscalerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: AutoscalingV1HorizontalPodAutoscaler;
}
export interface DeleteAutoscalingV1CollectionNamespacedHorizontalPodAutoscalerRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadAutoscalingV1NamespacedHorizontalPodAutoscalerRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceAutoscalingV1NamespacedHorizontalPodAutoscalerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AutoscalingV1HorizontalPodAutoscaler;
}
export interface DeleteAutoscalingV1NamespacedHorizontalPodAutoscalerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchAutoscalingV1NamespacedHorizontalPodAutoscalerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadAutoscalingV1NamespacedHorizontalPodAutoscalerStatusRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceAutoscalingV1NamespacedHorizontalPodAutoscalerStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AutoscalingV1HorizontalPodAutoscaler;
}
export interface PatchAutoscalingV1NamespacedHorizontalPodAutoscalerStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface WatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchAutoscalingV1NamespacedHorizontalPodAutoscalerListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchAutoscalingV1NamespacedHorizontalPodAutoscalerRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface GetAutoscalingV2APIResourcesRequest {}
export interface ListAutoscalingV2HorizontalPodAutoscalerForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListAutoscalingV2NamespacedHorizontalPodAutoscalerRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateAutoscalingV2NamespacedHorizontalPodAutoscalerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: AutoscalingV2HorizontalPodAutoscaler;
}
export interface DeleteAutoscalingV2CollectionNamespacedHorizontalPodAutoscalerRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadAutoscalingV2NamespacedHorizontalPodAutoscalerRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceAutoscalingV2NamespacedHorizontalPodAutoscalerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AutoscalingV2HorizontalPodAutoscaler;
}
export interface DeleteAutoscalingV2NamespacedHorizontalPodAutoscalerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchAutoscalingV2NamespacedHorizontalPodAutoscalerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadAutoscalingV2NamespacedHorizontalPodAutoscalerStatusRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceAutoscalingV2NamespacedHorizontalPodAutoscalerStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AutoscalingV2HorizontalPodAutoscaler;
}
export interface PatchAutoscalingV2NamespacedHorizontalPodAutoscalerStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface WatchAutoscalingV2HorizontalPodAutoscalerListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchAutoscalingV2NamespacedHorizontalPodAutoscalerListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchAutoscalingV2NamespacedHorizontalPodAutoscalerRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface GetBatchAPIGroupRequest {}
export interface GetBatchV1APIResourcesRequest {}
export interface ListBatchV1CronJobForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListBatchV1JobForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListBatchV1NamespacedCronJobRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateBatchV1NamespacedCronJobRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: BatchV1CronJob;
}
export interface DeleteBatchV1CollectionNamespacedCronJobRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadBatchV1NamespacedCronJobRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceBatchV1NamespacedCronJobRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: BatchV1CronJob;
}
export interface DeleteBatchV1NamespacedCronJobRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchBatchV1NamespacedCronJobRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadBatchV1NamespacedCronJobStatusRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceBatchV1NamespacedCronJobStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: BatchV1CronJob;
}
export interface PatchBatchV1NamespacedCronJobStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListBatchV1NamespacedJobRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateBatchV1NamespacedJobRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: BatchV1Job;
}
export interface DeleteBatchV1CollectionNamespacedJobRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadBatchV1NamespacedJobRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceBatchV1NamespacedJobRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: BatchV1Job;
}
export interface DeleteBatchV1NamespacedJobRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchBatchV1NamespacedJobRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadBatchV1NamespacedJobStatusRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceBatchV1NamespacedJobStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: BatchV1Job;
}
export interface PatchBatchV1NamespacedJobStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface WatchBatchV1CronJobListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchBatchV1JobListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchBatchV1NamespacedCronJobListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchBatchV1NamespacedCronJobRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface WatchBatchV1NamespacedJobListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchBatchV1NamespacedJobRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ListCachingInternalKnativeDevV1alpha1ImageForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListCachingInternalKnativeDevV1alpha1NamespacedImageRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateCachingInternalKnativeDevV1alpha1NamespacedImageRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: CachingInternalKnativeDevV1alpha1Image;
}
export interface DeleteCachingInternalKnativeDevV1alpha1CollectionNamespacedImageRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadCachingInternalKnativeDevV1alpha1NamespacedImageRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceCachingInternalKnativeDevV1alpha1NamespacedImageRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: CachingInternalKnativeDevV1alpha1Image;
}
export interface DeleteCachingInternalKnativeDevV1alpha1NamespacedImageRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchCachingInternalKnativeDevV1alpha1NamespacedImageRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadCachingInternalKnativeDevV1alpha1NamespacedImageStatusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceCachingInternalKnativeDevV1alpha1NamespacedImageStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: CachingInternalKnativeDevV1alpha1Image;
}
export interface PatchCachingInternalKnativeDevV1alpha1NamespacedImageStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListCertManagerIoV1CertificateRequestForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListCertManagerIoV1CertificateForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListCertManagerIoV1ClusterIssuerRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface CreateCertManagerIoV1ClusterIssuerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  body: CertManagerIoV1ClusterIssuer;
}
export interface DeleteCertManagerIoV1CollectionClusterIssuerRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ReadCertManagerIoV1ClusterIssuerRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceCertManagerIoV1ClusterIssuerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: CertManagerIoV1ClusterIssuer;
}
export interface DeleteCertManagerIoV1ClusterIssuerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
  };
}
export interface PatchCertManagerIoV1ClusterIssuerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface ReadCertManagerIoV1ClusterIssuerStatusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceCertManagerIoV1ClusterIssuerStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: CertManagerIoV1ClusterIssuer;
}
export interface PatchCertManagerIoV1ClusterIssuerStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface ListCertManagerIoV1IssuerForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListCertManagerIoV1NamespacedCertificateRequestRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateCertManagerIoV1NamespacedCertificateRequestRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: CertManagerIoV1CertificateRequest;
}
export interface DeleteCertManagerIoV1CollectionNamespacedCertificateRequestRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadCertManagerIoV1NamespacedCertificateRequestRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceCertManagerIoV1NamespacedCertificateRequestRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: CertManagerIoV1CertificateRequest;
}
export interface DeleteCertManagerIoV1NamespacedCertificateRequestRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchCertManagerIoV1NamespacedCertificateRequestRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadCertManagerIoV1NamespacedCertificateRequestStatusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceCertManagerIoV1NamespacedCertificateRequestStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: CertManagerIoV1CertificateRequest;
}
export interface PatchCertManagerIoV1NamespacedCertificateRequestStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListCertManagerIoV1NamespacedCertificateRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateCertManagerIoV1NamespacedCertificateRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: CertManagerIoV1Certificate;
}
export interface DeleteCertManagerIoV1CollectionNamespacedCertificateRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadCertManagerIoV1NamespacedCertificateRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceCertManagerIoV1NamespacedCertificateRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: CertManagerIoV1Certificate;
}
export interface DeleteCertManagerIoV1NamespacedCertificateRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchCertManagerIoV1NamespacedCertificateRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadCertManagerIoV1NamespacedCertificateStatusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceCertManagerIoV1NamespacedCertificateStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: CertManagerIoV1Certificate;
}
export interface PatchCertManagerIoV1NamespacedCertificateStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListCertManagerIoV1NamespacedIssuerRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateCertManagerIoV1NamespacedIssuerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: CertManagerIoV1Issuer;
}
export interface DeleteCertManagerIoV1CollectionNamespacedIssuerRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadCertManagerIoV1NamespacedIssuerRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceCertManagerIoV1NamespacedIssuerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: CertManagerIoV1Issuer;
}
export interface DeleteCertManagerIoV1NamespacedIssuerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchCertManagerIoV1NamespacedIssuerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadCertManagerIoV1NamespacedIssuerStatusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceCertManagerIoV1NamespacedIssuerStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: CertManagerIoV1Issuer;
}
export interface PatchCertManagerIoV1NamespacedIssuerStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface GetCertificatesAPIGroupRequest {}
export interface GetCertificatesV1APIResourcesRequest {}
export interface ListCertificatesV1CertificateSigningRequestRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface CreateCertificatesV1CertificateSigningRequestRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  body: CertificatesK8sIoV1CertificateSigningRequest;
}
export interface DeleteCertificatesV1CollectionCertificateSigningRequestRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
}
export interface ReadCertificatesV1CertificateSigningRequestRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceCertificatesV1CertificateSigningRequestRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: CertificatesK8sIoV1CertificateSigningRequest;
}
export interface DeleteCertificatesV1CertificateSigningRequestRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
  };
}
export interface PatchCertificatesV1CertificateSigningRequestRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface ReadCertificatesV1CertificateSigningRequestApprovalRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceCertificatesV1CertificateSigningRequestApprovalRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: CertificatesK8sIoV1CertificateSigningRequest;
}
export interface PatchCertificatesV1CertificateSigningRequestApprovalRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface ReadCertificatesV1CertificateSigningRequestStatusRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceCertificatesV1CertificateSigningRequestStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: CertificatesK8sIoV1CertificateSigningRequest;
}
export interface PatchCertificatesV1CertificateSigningRequestStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface WatchCertificatesV1CertificateSigningRequestListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchCertificatesV1CertificateSigningRequestRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
  };
}
export interface GetCoordinationAPIGroupRequest {}
export interface GetCoordinationV1APIResourcesRequest {}
export interface ListCoordinationV1LeaseForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListCoordinationV1NamespacedLeaseRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateCoordinationV1NamespacedLeaseRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: CoordinationK8sIoV1Lease;
}
export interface DeleteCoordinationV1CollectionNamespacedLeaseRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadCoordinationV1NamespacedLeaseRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceCoordinationV1NamespacedLeaseRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: CoordinationK8sIoV1Lease;
}
export interface DeleteCoordinationV1NamespacedLeaseRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchCoordinationV1NamespacedLeaseRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface WatchCoordinationV1LeaseListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchCoordinationV1NamespacedLeaseListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchCoordinationV1NamespacedLeaseRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface GetDiscoveryAPIGroupRequest {}
export interface GetDiscoveryV1APIResourcesRequest {}
export interface ListDiscoveryV1EndpointSliceForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListDiscoveryV1NamespacedEndpointSliceRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateDiscoveryV1NamespacedEndpointSliceRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: DiscoveryK8sIoV1EndpointSlice;
}
export interface DeleteDiscoveryV1CollectionNamespacedEndpointSliceRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadDiscoveryV1NamespacedEndpointSliceRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceDiscoveryV1NamespacedEndpointSliceRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: DiscoveryK8sIoV1EndpointSlice;
}
export interface DeleteDiscoveryV1NamespacedEndpointSliceRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchDiscoveryV1NamespacedEndpointSliceRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface WatchDiscoveryV1EndpointSliceListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchDiscoveryV1NamespacedEndpointSliceListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchDiscoveryV1NamespacedEndpointSliceRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface GetEventsAPIGroupRequest {}
export interface GetEventsV1APIResourcesRequest {}
export interface ListEventsV1EventForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListEventsV1NamespacedEventRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateEventsV1NamespacedEventRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: EventsK8sIoV1Event;
}
export interface DeleteEventsV1CollectionNamespacedEventRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadEventsV1NamespacedEventRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceEventsV1NamespacedEventRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: EventsK8sIoV1Event;
}
export interface DeleteEventsV1NamespacedEventRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchEventsV1NamespacedEventRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface WatchEventsV1EventListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchEventsV1NamespacedEventListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchEventsV1NamespacedEventRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface GetFlowcontrolApiserverAPIGroupRequest {}
export interface GetFlowcontrolApiserverV1APIResourcesRequest {}
export interface ListFlowcontrolApiserverV1FlowSchemaRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface CreateFlowcontrolApiserverV1FlowSchemaRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  body: FlowcontrolApiserverK8sIoV1FlowSchema;
}
export interface DeleteFlowcontrolApiserverV1CollectionFlowSchemaRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
}
export interface ReadFlowcontrolApiserverV1FlowSchemaRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceFlowcontrolApiserverV1FlowSchemaRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: FlowcontrolApiserverK8sIoV1FlowSchema;
}
export interface DeleteFlowcontrolApiserverV1FlowSchemaRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
  };
}
export interface PatchFlowcontrolApiserverV1FlowSchemaRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface ReadFlowcontrolApiserverV1FlowSchemaStatusRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceFlowcontrolApiserverV1FlowSchemaStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: FlowcontrolApiserverK8sIoV1FlowSchema;
}
export interface PatchFlowcontrolApiserverV1FlowSchemaStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface ListFlowcontrolApiserverV1PriorityLevelConfigurationRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface CreateFlowcontrolApiserverV1PriorityLevelConfigurationRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  body: FlowcontrolApiserverK8sIoV1PriorityLevelConfiguration;
}
export interface DeleteFlowcontrolApiserverV1CollectionPriorityLevelConfigurationRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
}
export interface ReadFlowcontrolApiserverV1PriorityLevelConfigurationRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceFlowcontrolApiserverV1PriorityLevelConfigurationRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: FlowcontrolApiserverK8sIoV1PriorityLevelConfiguration;
}
export interface DeleteFlowcontrolApiserverV1PriorityLevelConfigurationRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
  };
}
export interface PatchFlowcontrolApiserverV1PriorityLevelConfigurationRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface ReadFlowcontrolApiserverV1PriorityLevelConfigurationStatusRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceFlowcontrolApiserverV1PriorityLevelConfigurationStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: FlowcontrolApiserverK8sIoV1PriorityLevelConfiguration;
}
export interface PatchFlowcontrolApiserverV1PriorityLevelConfigurationStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface WatchFlowcontrolApiserverV1FlowSchemaListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchFlowcontrolApiserverV1FlowSchemaRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
  };
}
export interface WatchFlowcontrolApiserverV1PriorityLevelConfigurationListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchFlowcontrolApiserverV1PriorityLevelConfigurationRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
  };
}
export interface ListMonitoringCoreosComV1AlertmanagerForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListMonitoringCoreosComV1NamespacedAlertmanagerRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateMonitoringCoreosComV1NamespacedAlertmanagerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: MonitoringCoreosComV1Alertmanager;
}
export interface DeleteMonitoringCoreosComV1CollectionNamespacedAlertmanagerRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadMonitoringCoreosComV1NamespacedAlertmanagerRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceMonitoringCoreosComV1NamespacedAlertmanagerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: MonitoringCoreosComV1Alertmanager;
}
export interface DeleteMonitoringCoreosComV1NamespacedAlertmanagerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchMonitoringCoreosComV1NamespacedAlertmanagerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadMonitoringCoreosComV1NamespacedAlertmanagerScaleRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceMonitoringCoreosComV1NamespacedAlertmanagerScaleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AutoscalingV1Scale;
}
export interface PatchMonitoringCoreosComV1NamespacedAlertmanagerScaleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadMonitoringCoreosComV1NamespacedAlertmanagerStatusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceMonitoringCoreosComV1NamespacedAlertmanagerStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: MonitoringCoreosComV1Alertmanager;
}
export interface PatchMonitoringCoreosComV1NamespacedAlertmanagerStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListMonitoringCoreosComV1NamespacedPodMonitorRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateMonitoringCoreosComV1NamespacedPodMonitorRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: MonitoringCoreosComV1PodMonitor;
}
export interface DeleteMonitoringCoreosComV1CollectionNamespacedPodMonitorRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadMonitoringCoreosComV1NamespacedPodMonitorRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceMonitoringCoreosComV1NamespacedPodMonitorRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: MonitoringCoreosComV1PodMonitor;
}
export interface DeleteMonitoringCoreosComV1NamespacedPodMonitorRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchMonitoringCoreosComV1NamespacedPodMonitorRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListMonitoringCoreosComV1NamespacedProbeRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateMonitoringCoreosComV1NamespacedProbeRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: MonitoringCoreosComV1Probe;
}
export interface DeleteMonitoringCoreosComV1CollectionNamespacedProbeRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadMonitoringCoreosComV1NamespacedProbeRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceMonitoringCoreosComV1NamespacedProbeRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: MonitoringCoreosComV1Probe;
}
export interface DeleteMonitoringCoreosComV1NamespacedProbeRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchMonitoringCoreosComV1NamespacedProbeRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListMonitoringCoreosComV1NamespacedPrometheusRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateMonitoringCoreosComV1NamespacedPrometheusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: MonitoringCoreosComV1Prometheus;
}
export interface DeleteMonitoringCoreosComV1CollectionNamespacedPrometheusRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadMonitoringCoreosComV1NamespacedPrometheusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceMonitoringCoreosComV1NamespacedPrometheusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: MonitoringCoreosComV1Prometheus;
}
export interface DeleteMonitoringCoreosComV1NamespacedPrometheusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchMonitoringCoreosComV1NamespacedPrometheusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadMonitoringCoreosComV1NamespacedPrometheusScaleRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceMonitoringCoreosComV1NamespacedPrometheusScaleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AutoscalingV1Scale;
}
export interface PatchMonitoringCoreosComV1NamespacedPrometheusScaleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadMonitoringCoreosComV1NamespacedPrometheusStatusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceMonitoringCoreosComV1NamespacedPrometheusStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: MonitoringCoreosComV1Prometheus;
}
export interface PatchMonitoringCoreosComV1NamespacedPrometheusStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListMonitoringCoreosComV1NamespacedPrometheusRuleRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateMonitoringCoreosComV1NamespacedPrometheusRuleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: MonitoringCoreosComV1PrometheusRule;
}
export interface DeleteMonitoringCoreosComV1CollectionNamespacedPrometheusRuleRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadMonitoringCoreosComV1NamespacedPrometheusRuleRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceMonitoringCoreosComV1NamespacedPrometheusRuleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: MonitoringCoreosComV1PrometheusRule;
}
export interface DeleteMonitoringCoreosComV1NamespacedPrometheusRuleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchMonitoringCoreosComV1NamespacedPrometheusRuleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListMonitoringCoreosComV1NamespacedServiceMonitorRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateMonitoringCoreosComV1NamespacedServiceMonitorRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: MonitoringCoreosComV1ServiceMonitor;
}
export interface DeleteMonitoringCoreosComV1CollectionNamespacedServiceMonitorRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadMonitoringCoreosComV1NamespacedServiceMonitorRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceMonitoringCoreosComV1NamespacedServiceMonitorRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: MonitoringCoreosComV1ServiceMonitor;
}
export interface DeleteMonitoringCoreosComV1NamespacedServiceMonitorRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchMonitoringCoreosComV1NamespacedServiceMonitorRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadMonitoringCoreosComV1NamespacedServiceMonitorStatusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceMonitoringCoreosComV1NamespacedServiceMonitorStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: MonitoringCoreosComV1ServiceMonitor;
}
export interface PatchMonitoringCoreosComV1NamespacedServiceMonitorStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListMonitoringCoreosComV1NamespacedThanosRulerRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateMonitoringCoreosComV1NamespacedThanosRulerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: MonitoringCoreosComV1ThanosRuler;
}
export interface DeleteMonitoringCoreosComV1CollectionNamespacedThanosRulerRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadMonitoringCoreosComV1NamespacedThanosRulerRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceMonitoringCoreosComV1NamespacedThanosRulerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: MonitoringCoreosComV1ThanosRuler;
}
export interface DeleteMonitoringCoreosComV1NamespacedThanosRulerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchMonitoringCoreosComV1NamespacedThanosRulerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadMonitoringCoreosComV1NamespacedThanosRulerStatusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceMonitoringCoreosComV1NamespacedThanosRulerStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: MonitoringCoreosComV1ThanosRuler;
}
export interface PatchMonitoringCoreosComV1NamespacedThanosRulerStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListMonitoringCoreosComV1PodMonitorForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListMonitoringCoreosComV1ProbeForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListMonitoringCoreosComV1PrometheusForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListMonitoringCoreosComV1PrometheusRuleForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListMonitoringCoreosComV1ServiceMonitorForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListMonitoringCoreosComV1ThanosRulerForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListMonitoringCoreosComV1alpha1AlertmanagerConfigForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListMonitoringCoreosComV1alpha1NamespacedAlertmanagerConfigRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateMonitoringCoreosComV1alpha1NamespacedAlertmanagerConfigRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: MonitoringCoreosComV1alpha1AlertmanagerConfig;
}
export interface DeleteMonitoringCoreosComV1alpha1CollectionNamespacedAlertmanagerConfigRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadMonitoringCoreosComV1alpha1NamespacedAlertmanagerConfigRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceMonitoringCoreosComV1alpha1NamespacedAlertmanagerConfigRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: MonitoringCoreosComV1alpha1AlertmanagerConfig;
}
export interface DeleteMonitoringCoreosComV1alpha1NamespacedAlertmanagerConfigRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchMonitoringCoreosComV1alpha1NamespacedAlertmanagerConfigRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListMonitoringCoreosComV1alpha1NamespacedPrometheusAgentRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateMonitoringCoreosComV1alpha1NamespacedPrometheusAgentRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: MonitoringCoreosComV1alpha1PrometheusAgent;
}
export interface DeleteMonitoringCoreosComV1alpha1CollectionNamespacedPrometheusAgentRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadMonitoringCoreosComV1alpha1NamespacedPrometheusAgentRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceMonitoringCoreosComV1alpha1NamespacedPrometheusAgentRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: MonitoringCoreosComV1alpha1PrometheusAgent;
}
export interface DeleteMonitoringCoreosComV1alpha1NamespacedPrometheusAgentRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchMonitoringCoreosComV1alpha1NamespacedPrometheusAgentRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadMonitoringCoreosComV1alpha1NamespacedPrometheusAgentScaleRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceMonitoringCoreosComV1alpha1NamespacedPrometheusAgentScaleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AutoscalingV1Scale;
}
export interface PatchMonitoringCoreosComV1alpha1NamespacedPrometheusAgentScaleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadMonitoringCoreosComV1alpha1NamespacedPrometheusAgentStatusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceMonitoringCoreosComV1alpha1NamespacedPrometheusAgentStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: MonitoringCoreosComV1alpha1PrometheusAgent;
}
export interface PatchMonitoringCoreosComV1alpha1NamespacedPrometheusAgentStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListMonitoringCoreosComV1alpha1NamespacedScrapeConfigRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateMonitoringCoreosComV1alpha1NamespacedScrapeConfigRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: MonitoringCoreosComV1alpha1ScrapeConfig;
}
export interface DeleteMonitoringCoreosComV1alpha1CollectionNamespacedScrapeConfigRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadMonitoringCoreosComV1alpha1NamespacedScrapeConfigRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceMonitoringCoreosComV1alpha1NamespacedScrapeConfigRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: MonitoringCoreosComV1alpha1ScrapeConfig;
}
export interface DeleteMonitoringCoreosComV1alpha1NamespacedScrapeConfigRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchMonitoringCoreosComV1alpha1NamespacedScrapeConfigRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListMonitoringCoreosComV1alpha1PrometheusAgentForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListMonitoringCoreosComV1alpha1ScrapeConfigForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListNetworkingInternalKnativeDevV1alpha1CertificateForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListNetworkingInternalKnativeDevV1alpha1ClusterDomainClaimRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface CreateNetworkingInternalKnativeDevV1alpha1ClusterDomainClaimRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  body: NetworkingInternalKnativeDevV1alpha1ClusterDomainClaim;
}
export interface DeleteNetworkingInternalKnativeDevV1alpha1CollectionClusterDomainClaimRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ReadNetworkingInternalKnativeDevV1alpha1ClusterDomainClaimRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceNetworkingInternalKnativeDevV1alpha1ClusterDomainClaimRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: NetworkingInternalKnativeDevV1alpha1ClusterDomainClaim;
}
export interface DeleteNetworkingInternalKnativeDevV1alpha1ClusterDomainClaimRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
  };
}
export interface PatchNetworkingInternalKnativeDevV1alpha1ClusterDomainClaimRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface ReadNetworkingInternalKnativeDevV1alpha1ClusterDomainClaimStatusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceNetworkingInternalKnativeDevV1alpha1ClusterDomainClaimStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: NetworkingInternalKnativeDevV1alpha1ClusterDomainClaim;
}
export interface PatchNetworkingInternalKnativeDevV1alpha1ClusterDomainClaimStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface ListNetworkingInternalKnativeDevV1alpha1IngressForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListNetworkingInternalKnativeDevV1alpha1NamespacedCertificateRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateNetworkingInternalKnativeDevV1alpha1NamespacedCertificateRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: NetworkingInternalKnativeDevV1alpha1Certificate;
}
export interface DeleteNetworkingInternalKnativeDevV1alpha1CollectionNamespacedCertificateRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadNetworkingInternalKnativeDevV1alpha1NamespacedCertificateRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceNetworkingInternalKnativeDevV1alpha1NamespacedCertificateRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: NetworkingInternalKnativeDevV1alpha1Certificate;
}
export interface DeleteNetworkingInternalKnativeDevV1alpha1NamespacedCertificateRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchNetworkingInternalKnativeDevV1alpha1NamespacedCertificateRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadNetworkingInternalKnativeDevV1alpha1NamespacedCertificateStatusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceNetworkingInternalKnativeDevV1alpha1NamespacedCertificateStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: NetworkingInternalKnativeDevV1alpha1Certificate;
}
export interface PatchNetworkingInternalKnativeDevV1alpha1NamespacedCertificateStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListNetworkingInternalKnativeDevV1alpha1NamespacedIngressRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateNetworkingInternalKnativeDevV1alpha1NamespacedIngressRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: NetworkingInternalKnativeDevV1alpha1Ingress;
}
export interface DeleteNetworkingInternalKnativeDevV1alpha1CollectionNamespacedIngressRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadNetworkingInternalKnativeDevV1alpha1NamespacedIngressRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceNetworkingInternalKnativeDevV1alpha1NamespacedIngressRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: NetworkingInternalKnativeDevV1alpha1Ingress;
}
export interface DeleteNetworkingInternalKnativeDevV1alpha1NamespacedIngressRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchNetworkingInternalKnativeDevV1alpha1NamespacedIngressRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadNetworkingInternalKnativeDevV1alpha1NamespacedIngressStatusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceNetworkingInternalKnativeDevV1alpha1NamespacedIngressStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: NetworkingInternalKnativeDevV1alpha1Ingress;
}
export interface PatchNetworkingInternalKnativeDevV1alpha1NamespacedIngressStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListNetworkingInternalKnativeDevV1alpha1NamespacedServerlessServiceRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateNetworkingInternalKnativeDevV1alpha1NamespacedServerlessServiceRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: NetworkingInternalKnativeDevV1alpha1ServerlessService;
}
export interface DeleteNetworkingInternalKnativeDevV1alpha1CollectionNamespacedServerlessServiceRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadNetworkingInternalKnativeDevV1alpha1NamespacedServerlessServiceRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceNetworkingInternalKnativeDevV1alpha1NamespacedServerlessServiceRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: NetworkingInternalKnativeDevV1alpha1ServerlessService;
}
export interface DeleteNetworkingInternalKnativeDevV1alpha1NamespacedServerlessServiceRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchNetworkingInternalKnativeDevV1alpha1NamespacedServerlessServiceRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadNetworkingInternalKnativeDevV1alpha1NamespacedServerlessServiceStatusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceNetworkingInternalKnativeDevV1alpha1NamespacedServerlessServiceStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: NetworkingInternalKnativeDevV1alpha1ServerlessService;
}
export interface PatchNetworkingInternalKnativeDevV1alpha1NamespacedServerlessServiceStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListNetworkingInternalKnativeDevV1alpha1ServerlessServiceForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface GetNetworkingAPIGroupRequest {}
export interface GetNetworkingV1APIResourcesRequest {}
export interface ListNetworkingV1IngressClassRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface CreateNetworkingV1IngressClassRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  body: NetworkingK8sIoV1IngressClass;
}
export interface DeleteNetworkingV1CollectionIngressClassRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
}
export interface ReadNetworkingV1IngressClassRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceNetworkingV1IngressClassRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: NetworkingK8sIoV1IngressClass;
}
export interface DeleteNetworkingV1IngressClassRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
  };
}
export interface PatchNetworkingV1IngressClassRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface ListNetworkingV1IngressForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListNetworkingV1NamespacedIngressRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateNetworkingV1NamespacedIngressRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: NetworkingK8sIoV1Ingress;
}
export interface DeleteNetworkingV1CollectionNamespacedIngressRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadNetworkingV1NamespacedIngressRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceNetworkingV1NamespacedIngressRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: NetworkingK8sIoV1Ingress;
}
export interface DeleteNetworkingV1NamespacedIngressRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchNetworkingV1NamespacedIngressRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadNetworkingV1NamespacedIngressStatusRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceNetworkingV1NamespacedIngressStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: NetworkingK8sIoV1Ingress;
}
export interface PatchNetworkingV1NamespacedIngressStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListNetworkingV1NamespacedNetworkPolicyRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateNetworkingV1NamespacedNetworkPolicyRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: NetworkingK8sIoV1NetworkPolicy;
}
export interface DeleteNetworkingV1CollectionNamespacedNetworkPolicyRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadNetworkingV1NamespacedNetworkPolicyRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceNetworkingV1NamespacedNetworkPolicyRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: NetworkingK8sIoV1NetworkPolicy;
}
export interface DeleteNetworkingV1NamespacedNetworkPolicyRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchNetworkingV1NamespacedNetworkPolicyRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListNetworkingV1NetworkPolicyForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchNetworkingV1IngressClassListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchNetworkingV1IngressClassRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
  };
}
export interface WatchNetworkingV1IngressListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchNetworkingV1NamespacedIngressListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchNetworkingV1NamespacedIngressRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface WatchNetworkingV1NamespacedNetworkPolicyListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchNetworkingV1NamespacedNetworkPolicyRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface WatchNetworkingV1NetworkPolicyListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface GetNodeAPIGroupRequest {}
export interface GetNodeV1APIResourcesRequest {}
export interface ListNodeV1RuntimeClassRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface CreateNodeV1RuntimeClassRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  body: NodeK8sIoV1RuntimeClass;
}
export interface DeleteNodeV1CollectionRuntimeClassRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
}
export interface ReadNodeV1RuntimeClassRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceNodeV1RuntimeClassRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: NodeK8sIoV1RuntimeClass;
}
export interface DeleteNodeV1RuntimeClassRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
  };
}
export interface PatchNodeV1RuntimeClassRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface WatchNodeV1RuntimeClassListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchNodeV1RuntimeClassRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
  };
}
export interface GetPolicyAPIGroupRequest {}
export interface GetPolicyV1APIResourcesRequest {}
export interface ListPolicyV1NamespacedPodDisruptionBudgetRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreatePolicyV1NamespacedPodDisruptionBudgetRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: PolicyV1PodDisruptionBudget;
}
export interface DeletePolicyV1CollectionNamespacedPodDisruptionBudgetRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadPolicyV1NamespacedPodDisruptionBudgetRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplacePolicyV1NamespacedPodDisruptionBudgetRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: PolicyV1PodDisruptionBudget;
}
export interface DeletePolicyV1NamespacedPodDisruptionBudgetRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchPolicyV1NamespacedPodDisruptionBudgetRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadPolicyV1NamespacedPodDisruptionBudgetStatusRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplacePolicyV1NamespacedPodDisruptionBudgetStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: PolicyV1PodDisruptionBudget;
}
export interface PatchPolicyV1NamespacedPodDisruptionBudgetStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListPolicyV1PodDisruptionBudgetForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchPolicyV1NamespacedPodDisruptionBudgetListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchPolicyV1NamespacedPodDisruptionBudgetRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface WatchPolicyV1PodDisruptionBudgetListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListPostgresqlCnpgIoV1BackupForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListPostgresqlCnpgIoV1ClusterImageCatalogRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface CreatePostgresqlCnpgIoV1ClusterImageCatalogRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  body: PostgresqlCnpgIoV1ClusterImageCatalog;
}
export interface DeletePostgresqlCnpgIoV1CollectionClusterImageCatalogRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ReadPostgresqlCnpgIoV1ClusterImageCatalogRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplacePostgresqlCnpgIoV1ClusterImageCatalogRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: PostgresqlCnpgIoV1ClusterImageCatalog;
}
export interface DeletePostgresqlCnpgIoV1ClusterImageCatalogRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
  };
}
export interface PatchPostgresqlCnpgIoV1ClusterImageCatalogRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface ListPostgresqlCnpgIoV1ClusterForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListPostgresqlCnpgIoV1DatabaseForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListPostgresqlCnpgIoV1ImageCatalogForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListPostgresqlCnpgIoV1NamespacedBackupRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreatePostgresqlCnpgIoV1NamespacedBackupRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: PostgresqlCnpgIoV1Backup;
}
export interface DeletePostgresqlCnpgIoV1CollectionNamespacedBackupRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadPostgresqlCnpgIoV1NamespacedBackupRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplacePostgresqlCnpgIoV1NamespacedBackupRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: PostgresqlCnpgIoV1Backup;
}
export interface DeletePostgresqlCnpgIoV1NamespacedBackupRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchPostgresqlCnpgIoV1NamespacedBackupRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadPostgresqlCnpgIoV1NamespacedBackupStatusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplacePostgresqlCnpgIoV1NamespacedBackupStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: PostgresqlCnpgIoV1Backup;
}
export interface PatchPostgresqlCnpgIoV1NamespacedBackupStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListPostgresqlCnpgIoV1NamespacedClusterRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreatePostgresqlCnpgIoV1NamespacedClusterRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: PostgresqlCnpgIoV1Cluster;
}
export interface DeletePostgresqlCnpgIoV1CollectionNamespacedClusterRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadPostgresqlCnpgIoV1NamespacedClusterRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplacePostgresqlCnpgIoV1NamespacedClusterRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: PostgresqlCnpgIoV1Cluster;
}
export interface DeletePostgresqlCnpgIoV1NamespacedClusterRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchPostgresqlCnpgIoV1NamespacedClusterRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadPostgresqlCnpgIoV1NamespacedClusterScaleRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplacePostgresqlCnpgIoV1NamespacedClusterScaleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AutoscalingV1Scale;
}
export interface PatchPostgresqlCnpgIoV1NamespacedClusterScaleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadPostgresqlCnpgIoV1NamespacedClusterStatusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplacePostgresqlCnpgIoV1NamespacedClusterStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: PostgresqlCnpgIoV1Cluster;
}
export interface PatchPostgresqlCnpgIoV1NamespacedClusterStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListPostgresqlCnpgIoV1NamespacedDatabaseRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreatePostgresqlCnpgIoV1NamespacedDatabaseRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: PostgresqlCnpgIoV1Database;
}
export interface DeletePostgresqlCnpgIoV1CollectionNamespacedDatabaseRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadPostgresqlCnpgIoV1NamespacedDatabaseRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplacePostgresqlCnpgIoV1NamespacedDatabaseRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: PostgresqlCnpgIoV1Database;
}
export interface DeletePostgresqlCnpgIoV1NamespacedDatabaseRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchPostgresqlCnpgIoV1NamespacedDatabaseRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadPostgresqlCnpgIoV1NamespacedDatabaseStatusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplacePostgresqlCnpgIoV1NamespacedDatabaseStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: PostgresqlCnpgIoV1Database;
}
export interface PatchPostgresqlCnpgIoV1NamespacedDatabaseStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListPostgresqlCnpgIoV1NamespacedImageCatalogRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreatePostgresqlCnpgIoV1NamespacedImageCatalogRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: PostgresqlCnpgIoV1ImageCatalog;
}
export interface DeletePostgresqlCnpgIoV1CollectionNamespacedImageCatalogRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadPostgresqlCnpgIoV1NamespacedImageCatalogRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplacePostgresqlCnpgIoV1NamespacedImageCatalogRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: PostgresqlCnpgIoV1ImageCatalog;
}
export interface DeletePostgresqlCnpgIoV1NamespacedImageCatalogRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchPostgresqlCnpgIoV1NamespacedImageCatalogRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListPostgresqlCnpgIoV1NamespacedPoolerRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreatePostgresqlCnpgIoV1NamespacedPoolerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: PostgresqlCnpgIoV1Pooler;
}
export interface DeletePostgresqlCnpgIoV1CollectionNamespacedPoolerRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadPostgresqlCnpgIoV1NamespacedPoolerRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplacePostgresqlCnpgIoV1NamespacedPoolerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: PostgresqlCnpgIoV1Pooler;
}
export interface DeletePostgresqlCnpgIoV1NamespacedPoolerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchPostgresqlCnpgIoV1NamespacedPoolerRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadPostgresqlCnpgIoV1NamespacedPoolerScaleRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplacePostgresqlCnpgIoV1NamespacedPoolerScaleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: AutoscalingV1Scale;
}
export interface PatchPostgresqlCnpgIoV1NamespacedPoolerScaleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadPostgresqlCnpgIoV1NamespacedPoolerStatusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplacePostgresqlCnpgIoV1NamespacedPoolerStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: PostgresqlCnpgIoV1Pooler;
}
export interface PatchPostgresqlCnpgIoV1NamespacedPoolerStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListPostgresqlCnpgIoV1NamespacedPublicationRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreatePostgresqlCnpgIoV1NamespacedPublicationRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: PostgresqlCnpgIoV1Publication;
}
export interface DeletePostgresqlCnpgIoV1CollectionNamespacedPublicationRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadPostgresqlCnpgIoV1NamespacedPublicationRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplacePostgresqlCnpgIoV1NamespacedPublicationRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: PostgresqlCnpgIoV1Publication;
}
export interface DeletePostgresqlCnpgIoV1NamespacedPublicationRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchPostgresqlCnpgIoV1NamespacedPublicationRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadPostgresqlCnpgIoV1NamespacedPublicationStatusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplacePostgresqlCnpgIoV1NamespacedPublicationStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: PostgresqlCnpgIoV1Publication;
}
export interface PatchPostgresqlCnpgIoV1NamespacedPublicationStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListPostgresqlCnpgIoV1NamespacedScheduledBackupRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreatePostgresqlCnpgIoV1NamespacedScheduledBackupRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: PostgresqlCnpgIoV1ScheduledBackup;
}
export interface DeletePostgresqlCnpgIoV1CollectionNamespacedScheduledBackupRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadPostgresqlCnpgIoV1NamespacedScheduledBackupRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplacePostgresqlCnpgIoV1NamespacedScheduledBackupRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: PostgresqlCnpgIoV1ScheduledBackup;
}
export interface DeletePostgresqlCnpgIoV1NamespacedScheduledBackupRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchPostgresqlCnpgIoV1NamespacedScheduledBackupRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadPostgresqlCnpgIoV1NamespacedScheduledBackupStatusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplacePostgresqlCnpgIoV1NamespacedScheduledBackupStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: PostgresqlCnpgIoV1ScheduledBackup;
}
export interface PatchPostgresqlCnpgIoV1NamespacedScheduledBackupStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListPostgresqlCnpgIoV1NamespacedSubscriptionRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreatePostgresqlCnpgIoV1NamespacedSubscriptionRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: PostgresqlCnpgIoV1Subscription;
}
export interface DeletePostgresqlCnpgIoV1CollectionNamespacedSubscriptionRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadPostgresqlCnpgIoV1NamespacedSubscriptionRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplacePostgresqlCnpgIoV1NamespacedSubscriptionRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: PostgresqlCnpgIoV1Subscription;
}
export interface DeletePostgresqlCnpgIoV1NamespacedSubscriptionRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchPostgresqlCnpgIoV1NamespacedSubscriptionRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadPostgresqlCnpgIoV1NamespacedSubscriptionStatusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplacePostgresqlCnpgIoV1NamespacedSubscriptionStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: PostgresqlCnpgIoV1Subscription;
}
export interface PatchPostgresqlCnpgIoV1NamespacedSubscriptionStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListPostgresqlCnpgIoV1PoolerForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListPostgresqlCnpgIoV1PublicationForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListPostgresqlCnpgIoV1ScheduledBackupForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListPostgresqlCnpgIoV1SubscriptionForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface GetRbacAuthorizationAPIGroupRequest {}
export interface GetRbacAuthorizationV1APIResourcesRequest {}
export interface ListRbacAuthorizationV1ClusterRoleBindingRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface CreateRbacAuthorizationV1ClusterRoleBindingRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  body: RbacAuthorizationK8sIoV1ClusterRoleBinding;
}
export interface DeleteRbacAuthorizationV1CollectionClusterRoleBindingRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
}
export interface ReadRbacAuthorizationV1ClusterRoleBindingRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceRbacAuthorizationV1ClusterRoleBindingRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: RbacAuthorizationK8sIoV1ClusterRoleBinding;
}
export interface DeleteRbacAuthorizationV1ClusterRoleBindingRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
  };
}
export interface PatchRbacAuthorizationV1ClusterRoleBindingRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface ListRbacAuthorizationV1ClusterRoleRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface CreateRbacAuthorizationV1ClusterRoleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  body: RbacAuthorizationK8sIoV1ClusterRole;
}
export interface DeleteRbacAuthorizationV1CollectionClusterRoleRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
}
export interface ReadRbacAuthorizationV1ClusterRoleRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceRbacAuthorizationV1ClusterRoleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: RbacAuthorizationK8sIoV1ClusterRole;
}
export interface DeleteRbacAuthorizationV1ClusterRoleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
  };
}
export interface PatchRbacAuthorizationV1ClusterRoleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface ListRbacAuthorizationV1NamespacedRoleBindingRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateRbacAuthorizationV1NamespacedRoleBindingRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: RbacAuthorizationK8sIoV1RoleBinding;
}
export interface DeleteRbacAuthorizationV1CollectionNamespacedRoleBindingRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadRbacAuthorizationV1NamespacedRoleBindingRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceRbacAuthorizationV1NamespacedRoleBindingRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: RbacAuthorizationK8sIoV1RoleBinding;
}
export interface DeleteRbacAuthorizationV1NamespacedRoleBindingRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchRbacAuthorizationV1NamespacedRoleBindingRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListRbacAuthorizationV1NamespacedRoleRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateRbacAuthorizationV1NamespacedRoleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: RbacAuthorizationK8sIoV1Role;
}
export interface DeleteRbacAuthorizationV1CollectionNamespacedRoleRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadRbacAuthorizationV1NamespacedRoleRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceRbacAuthorizationV1NamespacedRoleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: RbacAuthorizationK8sIoV1Role;
}
export interface DeleteRbacAuthorizationV1NamespacedRoleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchRbacAuthorizationV1NamespacedRoleRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListRbacAuthorizationV1RoleBindingForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListRbacAuthorizationV1RoleForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchRbacAuthorizationV1ClusterRoleBindingListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchRbacAuthorizationV1ClusterRoleBindingRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
  };
}
export interface WatchRbacAuthorizationV1ClusterRoleListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchRbacAuthorizationV1ClusterRoleRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
  };
}
export interface WatchRbacAuthorizationV1NamespacedRoleBindingListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchRbacAuthorizationV1NamespacedRoleBindingRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface WatchRbacAuthorizationV1NamespacedRoleListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchRbacAuthorizationV1NamespacedRoleRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface WatchRbacAuthorizationV1RoleBindingListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchRbacAuthorizationV1RoleListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface GetSchedulingAPIGroupRequest {}
export interface GetSchedulingV1APIResourcesRequest {}
export interface ListSchedulingV1PriorityClassRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface CreateSchedulingV1PriorityClassRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  body: SchedulingK8sIoV1PriorityClass;
}
export interface DeleteSchedulingV1CollectionPriorityClassRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
}
export interface ReadSchedulingV1PriorityClassRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceSchedulingV1PriorityClassRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: SchedulingK8sIoV1PriorityClass;
}
export interface DeleteSchedulingV1PriorityClassRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
  };
}
export interface PatchSchedulingV1PriorityClassRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface WatchSchedulingV1PriorityClassListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchSchedulingV1PriorityClassRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
  };
}
export interface ListServingKnativeDevV1ConfigurationForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListServingKnativeDevV1NamespacedConfigurationRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateServingKnativeDevV1NamespacedConfigurationRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: ServingKnativeDevV1Configuration;
}
export interface DeleteServingKnativeDevV1CollectionNamespacedConfigurationRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadServingKnativeDevV1NamespacedConfigurationRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceServingKnativeDevV1NamespacedConfigurationRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: ServingKnativeDevV1Configuration;
}
export interface DeleteServingKnativeDevV1NamespacedConfigurationRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchServingKnativeDevV1NamespacedConfigurationRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadServingKnativeDevV1NamespacedConfigurationStatusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceServingKnativeDevV1NamespacedConfigurationStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: ServingKnativeDevV1Configuration;
}
export interface PatchServingKnativeDevV1NamespacedConfigurationStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListServingKnativeDevV1NamespacedRevisionRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateServingKnativeDevV1NamespacedRevisionRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: ServingKnativeDevV1Revision;
}
export interface DeleteServingKnativeDevV1CollectionNamespacedRevisionRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadServingKnativeDevV1NamespacedRevisionRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceServingKnativeDevV1NamespacedRevisionRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: ServingKnativeDevV1Revision;
}
export interface DeleteServingKnativeDevV1NamespacedRevisionRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchServingKnativeDevV1NamespacedRevisionRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadServingKnativeDevV1NamespacedRevisionStatusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceServingKnativeDevV1NamespacedRevisionStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: ServingKnativeDevV1Revision;
}
export interface PatchServingKnativeDevV1NamespacedRevisionStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListServingKnativeDevV1NamespacedRouteRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateServingKnativeDevV1NamespacedRouteRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: ServingKnativeDevV1Route;
}
export interface DeleteServingKnativeDevV1CollectionNamespacedRouteRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadServingKnativeDevV1NamespacedRouteRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceServingKnativeDevV1NamespacedRouteRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: ServingKnativeDevV1Route;
}
export interface DeleteServingKnativeDevV1NamespacedRouteRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchServingKnativeDevV1NamespacedRouteRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadServingKnativeDevV1NamespacedRouteStatusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceServingKnativeDevV1NamespacedRouteStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: ServingKnativeDevV1Route;
}
export interface PatchServingKnativeDevV1NamespacedRouteStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListServingKnativeDevV1NamespacedServiceRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateServingKnativeDevV1NamespacedServiceRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: ServingKnativeDevV1Service;
}
export interface DeleteServingKnativeDevV1CollectionNamespacedServiceRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface ReadServingKnativeDevV1NamespacedServiceRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceServingKnativeDevV1NamespacedServiceRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: ServingKnativeDevV1Service;
}
export interface DeleteServingKnativeDevV1NamespacedServiceRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchServingKnativeDevV1NamespacedServiceRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ReadServingKnativeDevV1NamespacedServiceStatusRequest {
  query: {
    pretty?: string;
    resourceVersion?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceServingKnativeDevV1NamespacedServiceStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: ServingKnativeDevV1Service;
}
export interface PatchServingKnativeDevV1NamespacedServiceStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListServingKnativeDevV1RevisionForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListServingKnativeDevV1RouteForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListServingKnativeDevV1ServiceForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface GetStorageAPIGroupRequest {}
export interface GetStorageV1APIResourcesRequest {}
export interface ListStorageV1CSIDriverRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface CreateStorageV1CSIDriverRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  body: StorageK8sIoV1CSIDriver;
}
export interface DeleteStorageV1CollectionCSIDriverRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
}
export interface ReadStorageV1CSIDriverRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceStorageV1CSIDriverRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: StorageK8sIoV1CSIDriver;
}
export interface DeleteStorageV1CSIDriverRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
  };
}
export interface PatchStorageV1CSIDriverRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface ListStorageV1CSINodeRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface CreateStorageV1CSINodeRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  body: StorageK8sIoV1CSINode;
}
export interface DeleteStorageV1CollectionCSINodeRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
}
export interface ReadStorageV1CSINodeRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceStorageV1CSINodeRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: StorageK8sIoV1CSINode;
}
export interface DeleteStorageV1CSINodeRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
  };
}
export interface PatchStorageV1CSINodeRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface ListStorageV1CSIStorageCapacityForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface ListStorageV1NamespacedCSIStorageCapacityRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface CreateStorageV1NamespacedCSIStorageCapacityRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    namespace: string;
  };
  body: StorageK8sIoV1CSIStorageCapacity;
}
export interface DeleteStorageV1CollectionNamespacedCSIStorageCapacityRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
  path: {
    namespace: string;
  };
}
export interface ReadStorageV1NamespacedCSIStorageCapacityRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface ReplaceStorageV1NamespacedCSIStorageCapacityRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: StorageK8sIoV1CSIStorageCapacity;
}
export interface DeleteStorageV1NamespacedCSIStorageCapacityRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface PatchStorageV1NamespacedCSIStorageCapacityRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
  body: Patch;
}
export interface ListStorageV1StorageClassRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface CreateStorageV1StorageClassRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  body: StorageK8sIoV1StorageClass;
}
export interface DeleteStorageV1CollectionStorageClassRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
}
export interface ReadStorageV1StorageClassRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceStorageV1StorageClassRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: StorageK8sIoV1StorageClass;
}
export interface DeleteStorageV1StorageClassRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
  };
}
export interface PatchStorageV1StorageClassRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface ListStorageV1VolumeAttachmentRequest {
  query: {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface CreateStorageV1VolumeAttachmentRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  body: StorageK8sIoV1VolumeAttachment;
}
export interface DeleteStorageV1CollectionVolumeAttachmentRequest {
  query: {
    pretty?: string;
    continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
  };
}
export interface ReadStorageV1VolumeAttachmentRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceStorageV1VolumeAttachmentRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: StorageK8sIoV1VolumeAttachment;
}
export interface DeleteStorageV1VolumeAttachmentRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean;
    orphanDependents?: boolean;
    propagationPolicy?: string;
  };
  path: {
    name: string;
  };
}
export interface PatchStorageV1VolumeAttachmentRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface ReadStorageV1VolumeAttachmentStatusRequest {
  query: {
    pretty?: string;
  };
  path: {
    name: string;
  };
}
export interface ReplaceStorageV1VolumeAttachmentStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
  };
  path: {
    name: string;
  };
  body: StorageK8sIoV1VolumeAttachment;
}
export interface PatchStorageV1VolumeAttachmentStatusRequest {
  query: {
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
  };
  path: {
    name: string;
  };
  body: Patch;
}
export interface WatchStorageV1CSIDriverListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchStorageV1CSIDriverRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
  };
}
export interface WatchStorageV1CSINodeListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchStorageV1CSINodeRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
  };
}
export interface WatchStorageV1CSIStorageCapacityListForAllNamespacesRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchStorageV1NamespacedCSIStorageCapacityListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    namespace: string;
  };
}
export interface WatchStorageV1NamespacedCSIStorageCapacityRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
    namespace: string;
  };
}
export interface WatchStorageV1StorageClassListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchStorageV1StorageClassRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
  };
}
export interface WatchStorageV1VolumeAttachmentListRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
}
export interface WatchStorageV1VolumeAttachmentRequest {
  query: {
    allowWatchBookmarks?: boolean;
    continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
  };
  path: {
    name: string;
  };
}
export interface GetServiceAccountIssuerOpenIDKeysetRequest {}
export interface GetCodeVersionRequest {}
export class KubernetesClient extends APIClient {
  constructor(options: APIClientOptions) {
    super(options);
  }
  async getSwaggerJSON() {
    const path = "/openapi/v2";
    return this.get(path);
  }
  async getServiceAccountIssuerOpenIDConfiguration(params: GetServiceAccountIssuerOpenIDConfigurationRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/.well-known/openid-configuration/`;
    return await this.get<string>(path, null, null, opts);
  }
  async getCoreAPIVersions(params: GetCoreAPIVersionsRequest, opts?: APIClientRequestOpts): Promise<APIVersions> {
    const path = `/api/`;
    return await this.get<APIVersions>(path, null, null, opts);
  }
  async getCoreV1APIResources(params: GetCoreV1APIResourcesRequest, opts?: APIClientRequestOpts): Promise<APIResourceList> {
    const path = `/api/v1/`;
    return await this.get<APIResourceList>(path, null, null, opts);
  }
  async listCoreV1ComponentStatus(params: ListCoreV1ComponentStatusRequest, opts?: APIClientRequestOpts): Promise<ComponentStatusList> {
    const path = `/api/v1/componentstatuses`;
    return await this.get<ComponentStatusList>(path, null, null, opts);
  }
  async readCoreV1ComponentStatus(params: ReadCoreV1ComponentStatusRequest, opts?: APIClientRequestOpts): Promise<ComponentStatus> {
    const path = `/api/v1/componentstatuses/${params.path.name}`;
    return await this.get<ComponentStatus>(path, null, null, opts);
  }
  async listCoreV1ConfigMapForAllNamespaces(params: ListCoreV1ConfigMapForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<ConfigMapList> {
    const path = `/api/v1/configmaps`;
    return await this.get<ConfigMapList>(path, null, null, opts);
  }
  async listCoreV1EndpointsForAllNamespaces(params: ListCoreV1EndpointsForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<EndpointsList> {
    const path = `/api/v1/endpoints`;
    return await this.get<EndpointsList>(path, null, null, opts);
  }
  async listCoreV1EventForAllNamespaces(params: ListCoreV1EventForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<EventList> {
    const path = `/api/v1/events`;
    return await this.get<EventList>(path, null, null, opts);
  }
  async listCoreV1LimitRangeForAllNamespaces(params: ListCoreV1LimitRangeForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<LimitRangeList> {
    const path = `/api/v1/limitranges`;
    return await this.get<LimitRangeList>(path, null, null, opts);
  }
  async listCoreV1Namespace(params: ListCoreV1NamespaceRequest, opts?: APIClientRequestOpts): Promise<NamespaceList> {
    const path = `/api/v1/namespaces`;
    return await this.get<NamespaceList>(path, null, null, opts);
  }
  async createCoreV1Namespace(params: CreateCoreV1NamespaceRequest, opts?: APIClientRequestOpts): Promise<Namespace> {
    const path = `/api/v1/namespaces`;
    return await this.post<Namespace>(path, params.query, params.body, opts);
  }
  async createCoreV1NamespacedBinding(params: CreateCoreV1NamespacedBindingRequest, opts?: APIClientRequestOpts): Promise<Binding> {
    const path = `/api/v1/namespaces/${params.path.namespace}/bindings`;
    return await this.post<Binding>(path, null, params.body, opts);
  }
  async listCoreV1NamespacedConfigMap(params: ListCoreV1NamespacedConfigMapRequest, opts?: APIClientRequestOpts): Promise<ConfigMapList> {
    const path = `/api/v1/namespaces/${params.path.namespace}/configmaps`;
    return await this.get<ConfigMapList>(path, null, null, opts);
  }
  async createCoreV1NamespacedConfigMap(params: CreateCoreV1NamespacedConfigMapRequest, opts?: APIClientRequestOpts): Promise<ConfigMap> {
    const path = `/api/v1/namespaces/${params.path.namespace}/configmaps`;
    return await this.post<ConfigMap>(path, params.query, params.body, opts);
  }
  async deleteCoreV1CollectionNamespacedConfigMap(params: DeleteCoreV1CollectionNamespacedConfigMapRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/api/v1/namespaces/${params.path.namespace}/configmaps`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readCoreV1NamespacedConfigMap(params: ReadCoreV1NamespacedConfigMapRequest, opts?: APIClientRequestOpts): Promise<ConfigMap> {
    const path = `/api/v1/namespaces/${params.path.namespace}/configmaps/${params.path.name}`;
    return await this.get<ConfigMap>(path, null, null, opts);
  }
  async replaceCoreV1NamespacedConfigMap(params: ReplaceCoreV1NamespacedConfigMapRequest, opts?: APIClientRequestOpts): Promise<ConfigMap> {
    const path = `/api/v1/namespaces/${params.path.namespace}/configmaps/${params.path.name}`;
    return await this.put<ConfigMap>(path, params.query, params.body, opts);
  }
  async deleteCoreV1NamespacedConfigMap(params: DeleteCoreV1NamespacedConfigMapRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/api/v1/namespaces/${params.path.namespace}/configmaps/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchCoreV1NamespacedConfigMap(params: PatchCoreV1NamespacedConfigMapRequest, opts?: APIClientRequestOpts): Promise<ConfigMap> {
    const path = `/api/v1/namespaces/${params.path.namespace}/configmaps/${params.path.name}`;
    return await this.patch<ConfigMap>(path, params.query, null, opts);
  }
  async listCoreV1NamespacedEndpoints(params: ListCoreV1NamespacedEndpointsRequest, opts?: APIClientRequestOpts): Promise<EndpointsList> {
    const path = `/api/v1/namespaces/${params.path.namespace}/endpoints`;
    return await this.get<EndpointsList>(path, null, null, opts);
  }
  async createCoreV1NamespacedEndpoints(params: CreateCoreV1NamespacedEndpointsRequest, opts?: APIClientRequestOpts): Promise<Endpoints> {
    const path = `/api/v1/namespaces/${params.path.namespace}/endpoints`;
    return await this.post<Endpoints>(path, params.query, params.body, opts);
  }
  async deleteCoreV1CollectionNamespacedEndpoints(params: DeleteCoreV1CollectionNamespacedEndpointsRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/api/v1/namespaces/${params.path.namespace}/endpoints`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readCoreV1NamespacedEndpoints(params: ReadCoreV1NamespacedEndpointsRequest, opts?: APIClientRequestOpts): Promise<Endpoints> {
    const path = `/api/v1/namespaces/${params.path.namespace}/endpoints/${params.path.name}`;
    return await this.get<Endpoints>(path, null, null, opts);
  }
  async replaceCoreV1NamespacedEndpoints(params: ReplaceCoreV1NamespacedEndpointsRequest, opts?: APIClientRequestOpts): Promise<Endpoints> {
    const path = `/api/v1/namespaces/${params.path.namespace}/endpoints/${params.path.name}`;
    return await this.put<Endpoints>(path, params.query, params.body, opts);
  }
  async deleteCoreV1NamespacedEndpoints(params: DeleteCoreV1NamespacedEndpointsRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/api/v1/namespaces/${params.path.namespace}/endpoints/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchCoreV1NamespacedEndpoints(params: PatchCoreV1NamespacedEndpointsRequest, opts?: APIClientRequestOpts): Promise<Endpoints> {
    const path = `/api/v1/namespaces/${params.path.namespace}/endpoints/${params.path.name}`;
    return await this.patch<Endpoints>(path, params.query, null, opts);
  }
  async listCoreV1NamespacedEvent(params: ListCoreV1NamespacedEventRequest, opts?: APIClientRequestOpts): Promise<EventList> {
    const path = `/api/v1/namespaces/${params.path.namespace}/events`;
    return await this.get<EventList>(path, null, null, opts);
  }
  async createCoreV1NamespacedEvent(params: CreateCoreV1NamespacedEventRequest, opts?: APIClientRequestOpts): Promise<Event> {
    const path = `/api/v1/namespaces/${params.path.namespace}/events`;
    return await this.post<Event>(path, params.query, params.body, opts);
  }
  async deleteCoreV1CollectionNamespacedEvent(params: DeleteCoreV1CollectionNamespacedEventRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/api/v1/namespaces/${params.path.namespace}/events`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readCoreV1NamespacedEvent(params: ReadCoreV1NamespacedEventRequest, opts?: APIClientRequestOpts): Promise<Event> {
    const path = `/api/v1/namespaces/${params.path.namespace}/events/${params.path.name}`;
    return await this.get<Event>(path, null, null, opts);
  }
  async replaceCoreV1NamespacedEvent(params: ReplaceCoreV1NamespacedEventRequest, opts?: APIClientRequestOpts): Promise<Event> {
    const path = `/api/v1/namespaces/${params.path.namespace}/events/${params.path.name}`;
    return await this.put<Event>(path, params.query, params.body, opts);
  }
  async deleteCoreV1NamespacedEvent(params: DeleteCoreV1NamespacedEventRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/api/v1/namespaces/${params.path.namespace}/events/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchCoreV1NamespacedEvent(params: PatchCoreV1NamespacedEventRequest, opts?: APIClientRequestOpts): Promise<Event> {
    const path = `/api/v1/namespaces/${params.path.namespace}/events/${params.path.name}`;
    return await this.patch<Event>(path, params.query, null, opts);
  }
  async listCoreV1NamespacedLimitRange(params: ListCoreV1NamespacedLimitRangeRequest, opts?: APIClientRequestOpts): Promise<LimitRangeList> {
    const path = `/api/v1/namespaces/${params.path.namespace}/limitranges`;
    return await this.get<LimitRangeList>(path, null, null, opts);
  }
  async createCoreV1NamespacedLimitRange(params: CreateCoreV1NamespacedLimitRangeRequest, opts?: APIClientRequestOpts): Promise<LimitRange> {
    const path = `/api/v1/namespaces/${params.path.namespace}/limitranges`;
    return await this.post<LimitRange>(path, params.query, params.body, opts);
  }
  async deleteCoreV1CollectionNamespacedLimitRange(params: DeleteCoreV1CollectionNamespacedLimitRangeRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/api/v1/namespaces/${params.path.namespace}/limitranges`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readCoreV1NamespacedLimitRange(params: ReadCoreV1NamespacedLimitRangeRequest, opts?: APIClientRequestOpts): Promise<LimitRange> {
    const path = `/api/v1/namespaces/${params.path.namespace}/limitranges/${params.path.name}`;
    return await this.get<LimitRange>(path, null, null, opts);
  }
  async replaceCoreV1NamespacedLimitRange(params: ReplaceCoreV1NamespacedLimitRangeRequest, opts?: APIClientRequestOpts): Promise<LimitRange> {
    const path = `/api/v1/namespaces/${params.path.namespace}/limitranges/${params.path.name}`;
    return await this.put<LimitRange>(path, params.query, params.body, opts);
  }
  async deleteCoreV1NamespacedLimitRange(params: DeleteCoreV1NamespacedLimitRangeRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/api/v1/namespaces/${params.path.namespace}/limitranges/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchCoreV1NamespacedLimitRange(params: PatchCoreV1NamespacedLimitRangeRequest, opts?: APIClientRequestOpts): Promise<LimitRange> {
    const path = `/api/v1/namespaces/${params.path.namespace}/limitranges/${params.path.name}`;
    return await this.patch<LimitRange>(path, params.query, null, opts);
  }
  async listCoreV1NamespacedPersistentVolumeClaim(params: ListCoreV1NamespacedPersistentVolumeClaimRequest, opts?: APIClientRequestOpts): Promise<PersistentVolumeClaimList> {
    const path = `/api/v1/namespaces/${params.path.namespace}/persistentvolumeclaims`;
    return await this.get<PersistentVolumeClaimList>(path, null, null, opts);
  }
  async createCoreV1NamespacedPersistentVolumeClaim(params: CreateCoreV1NamespacedPersistentVolumeClaimRequest, opts?: APIClientRequestOpts): Promise<PersistentVolumeClaim> {
    const path = `/api/v1/namespaces/${params.path.namespace}/persistentvolumeclaims`;
    return await this.post<PersistentVolumeClaim>(path, params.query, params.body, opts);
  }
  async deleteCoreV1CollectionNamespacedPersistentVolumeClaim(params: DeleteCoreV1CollectionNamespacedPersistentVolumeClaimRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/api/v1/namespaces/${params.path.namespace}/persistentvolumeclaims`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readCoreV1NamespacedPersistentVolumeClaim(params: ReadCoreV1NamespacedPersistentVolumeClaimRequest, opts?: APIClientRequestOpts): Promise<PersistentVolumeClaim> {
    const path = `/api/v1/namespaces/${params.path.namespace}/persistentvolumeclaims/${params.path.name}`;
    return await this.get<PersistentVolumeClaim>(path, null, null, opts);
  }
  async replaceCoreV1NamespacedPersistentVolumeClaim(params: ReplaceCoreV1NamespacedPersistentVolumeClaimRequest, opts?: APIClientRequestOpts): Promise<PersistentVolumeClaim> {
    const path = `/api/v1/namespaces/${params.path.namespace}/persistentvolumeclaims/${params.path.name}`;
    return await this.put<PersistentVolumeClaim>(path, params.query, params.body, opts);
  }
  async deleteCoreV1NamespacedPersistentVolumeClaim(params: DeleteCoreV1NamespacedPersistentVolumeClaimRequest, opts?: APIClientRequestOpts): Promise<PersistentVolumeClaim> {
    const path = `/api/v1/namespaces/${params.path.namespace}/persistentvolumeclaims/${params.path.name}`;
    return await this.delete<PersistentVolumeClaim>(path, params.query, null, opts);
  }
  async patchCoreV1NamespacedPersistentVolumeClaim(params: PatchCoreV1NamespacedPersistentVolumeClaimRequest, opts?: APIClientRequestOpts): Promise<PersistentVolumeClaim> {
    const path = `/api/v1/namespaces/${params.path.namespace}/persistentvolumeclaims/${params.path.name}`;
    return await this.patch<PersistentVolumeClaim>(path, params.query, null, opts);
  }
  async readCoreV1NamespacedPersistentVolumeClaimStatus(params: ReadCoreV1NamespacedPersistentVolumeClaimStatusRequest, opts?: APIClientRequestOpts): Promise<PersistentVolumeClaim> {
    const path = `/api/v1/namespaces/${params.path.namespace}/persistentvolumeclaims/${params.path.name}/status`;
    return await this.get<PersistentVolumeClaim>(path, null, null, opts);
  }
  async replaceCoreV1NamespacedPersistentVolumeClaimStatus(params: ReplaceCoreV1NamespacedPersistentVolumeClaimStatusRequest, opts?: APIClientRequestOpts): Promise<PersistentVolumeClaim> {
    const path = `/api/v1/namespaces/${params.path.namespace}/persistentvolumeclaims/${params.path.name}/status`;
    return await this.put<PersistentVolumeClaim>(path, params.query, params.body, opts);
  }
  async patchCoreV1NamespacedPersistentVolumeClaimStatus(params: PatchCoreV1NamespacedPersistentVolumeClaimStatusRequest, opts?: APIClientRequestOpts): Promise<PersistentVolumeClaim> {
    const path = `/api/v1/namespaces/${params.path.namespace}/persistentvolumeclaims/${params.path.name}/status`;
    return await this.patch<PersistentVolumeClaim>(path, params.query, null, opts);
  }
  async listCoreV1NamespacedPod(params: ListCoreV1NamespacedPodRequest, opts?: APIClientRequestOpts): Promise<PodList> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods`;
    return await this.get<PodList>(path, null, null, opts);
  }
  async createCoreV1NamespacedPod(params: CreateCoreV1NamespacedPodRequest, opts?: APIClientRequestOpts): Promise<Pod> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods`;
    return await this.post<Pod>(path, params.query, params.body, opts);
  }
  async deleteCoreV1CollectionNamespacedPod(params: DeleteCoreV1CollectionNamespacedPodRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readCoreV1NamespacedPod(params: ReadCoreV1NamespacedPodRequest, opts?: APIClientRequestOpts): Promise<Pod> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods/${params.path.name}`;
    return await this.get<Pod>(path, null, null, opts);
  }
  async replaceCoreV1NamespacedPod(params: ReplaceCoreV1NamespacedPodRequest, opts?: APIClientRequestOpts): Promise<Pod> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods/${params.path.name}`;
    return await this.put<Pod>(path, params.query, params.body, opts);
  }
  async deleteCoreV1NamespacedPod(params: DeleteCoreV1NamespacedPodRequest, opts?: APIClientRequestOpts): Promise<Pod> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods/${params.path.name}`;
    return await this.delete<Pod>(path, params.query, null, opts);
  }
  async patchCoreV1NamespacedPod(params: PatchCoreV1NamespacedPodRequest, opts?: APIClientRequestOpts): Promise<Pod> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods/${params.path.name}`;
    return await this.patch<Pod>(path, params.query, null, opts);
  }
  async connectCoreV1GetNamespacedPodAttach(params: ConnectCoreV1GetNamespacedPodAttachRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods/${params.path.name}/attach`;
    return await this.get<string>(path, null, null, opts);
  }
  async connectCoreV1PostNamespacedPodAttach(params: ConnectCoreV1PostNamespacedPodAttachRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods/${params.path.name}/attach`;
    return await this.post<string>(path, null, null, opts);
  }
  async createCoreV1NamespacedPodBinding(params: CreateCoreV1NamespacedPodBindingRequest, opts?: APIClientRequestOpts): Promise<Binding> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods/${params.path.name}/binding`;
    return await this.post<Binding>(path, null, params.body, opts);
  }
  async readCoreV1NamespacedPodEphemeralcontainers(params: ReadCoreV1NamespacedPodEphemeralcontainersRequest, opts?: APIClientRequestOpts): Promise<Pod> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods/${params.path.name}/ephemeralcontainers`;
    return await this.get<Pod>(path, null, null, opts);
  }
  async replaceCoreV1NamespacedPodEphemeralcontainers(params: ReplaceCoreV1NamespacedPodEphemeralcontainersRequest, opts?: APIClientRequestOpts): Promise<Pod> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods/${params.path.name}/ephemeralcontainers`;
    return await this.put<Pod>(path, params.query, params.body, opts);
  }
  async patchCoreV1NamespacedPodEphemeralcontainers(params: PatchCoreV1NamespacedPodEphemeralcontainersRequest, opts?: APIClientRequestOpts): Promise<Pod> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods/${params.path.name}/ephemeralcontainers`;
    return await this.patch<Pod>(path, params.query, null, opts);
  }
  async createCoreV1NamespacedPodEviction(params: CreateCoreV1NamespacedPodEvictionRequest, opts?: APIClientRequestOpts): Promise<PolicyV1Eviction> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods/${params.path.name}/eviction`;
    return await this.post<PolicyV1Eviction>(path, null, params.body, opts);
  }
  async connectCoreV1GetNamespacedPodExec(params: ConnectCoreV1GetNamespacedPodExecRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods/${params.path.name}/exec`;
    return await this.get<string>(path, null, null, opts);
  }
  async connectCoreV1PostNamespacedPodExec(params: ConnectCoreV1PostNamespacedPodExecRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods/${params.path.name}/exec`;
    return await this.post<string>(path, null, null, opts);
  }
  async readCoreV1NamespacedPodLog(params: ReadCoreV1NamespacedPodLogRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods/${params.path.name}/log`;
    return await this.get<string>(path, null, null, opts);
  }
  async connectCoreV1GetNamespacedPodPortforward(params: ConnectCoreV1GetNamespacedPodPortforwardRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods/${params.path.name}/portforward`;
    return await this.get<string>(path, null, null, opts);
  }
  async connectCoreV1PostNamespacedPodPortforward(params: ConnectCoreV1PostNamespacedPodPortforwardRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods/${params.path.name}/portforward`;
    return await this.post<string>(path, null, null, opts);
  }
  async connectCoreV1GetNamespacedPodProxy(params: ConnectCoreV1GetNamespacedPodProxyRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods/${params.path.name}/proxy`;
    return await this.get<string>(path, null, null, opts);
  }
  async connectCoreV1PostNamespacedPodProxy(params: ConnectCoreV1PostNamespacedPodProxyRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods/${params.path.name}/proxy`;
    return await this.post<string>(path, null, null, opts);
  }
  async connectCoreV1PutNamespacedPodProxy(params: ConnectCoreV1PutNamespacedPodProxyRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods/${params.path.name}/proxy`;
    return await this.put<string>(path, null, null, opts);
  }
  async connectCoreV1DeleteNamespacedPodProxy(params: ConnectCoreV1DeleteNamespacedPodProxyRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods/${params.path.name}/proxy`;
    return await this.delete<string>(path, null, null, opts);
  }
  async connectCoreV1PatchNamespacedPodProxy(params: ConnectCoreV1PatchNamespacedPodProxyRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods/${params.path.name}/proxy`;
    return await this.patch<string>(path, null, null, opts);
  }
  async connectCoreV1GetNamespacedPodProxyWithPath(params: ConnectCoreV1GetNamespacedPodProxyWithPathRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods/${params.path.name}/proxy/${params.path.path}`;
    return await this.get<string>(path, null, null, opts);
  }
  async connectCoreV1PostNamespacedPodProxyWithPath(params: ConnectCoreV1PostNamespacedPodProxyWithPathRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods/${params.path.name}/proxy/${params.path.path}`;
    return await this.post<string>(path, null, null, opts);
  }
  async connectCoreV1PutNamespacedPodProxyWithPath(params: ConnectCoreV1PutNamespacedPodProxyWithPathRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods/${params.path.name}/proxy/${params.path.path}`;
    return await this.put<string>(path, null, null, opts);
  }
  async connectCoreV1DeleteNamespacedPodProxyWithPath(params: ConnectCoreV1DeleteNamespacedPodProxyWithPathRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods/${params.path.name}/proxy/${params.path.path}`;
    return await this.delete<string>(path, null, null, opts);
  }
  async connectCoreV1PatchNamespacedPodProxyWithPath(params: ConnectCoreV1PatchNamespacedPodProxyWithPathRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods/${params.path.name}/proxy/${params.path.path}`;
    return await this.patch<string>(path, null, null, opts);
  }
  async readCoreV1NamespacedPodStatus(params: ReadCoreV1NamespacedPodStatusRequest, opts?: APIClientRequestOpts): Promise<Pod> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods/${params.path.name}/status`;
    return await this.get<Pod>(path, null, null, opts);
  }
  async replaceCoreV1NamespacedPodStatus(params: ReplaceCoreV1NamespacedPodStatusRequest, opts?: APIClientRequestOpts): Promise<Pod> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods/${params.path.name}/status`;
    return await this.put<Pod>(path, params.query, params.body, opts);
  }
  async patchCoreV1NamespacedPodStatus(params: PatchCoreV1NamespacedPodStatusRequest, opts?: APIClientRequestOpts): Promise<Pod> {
    const path = `/api/v1/namespaces/${params.path.namespace}/pods/${params.path.name}/status`;
    return await this.patch<Pod>(path, params.query, null, opts);
  }
  async listCoreV1NamespacedPodTemplate(params: ListCoreV1NamespacedPodTemplateRequest, opts?: APIClientRequestOpts): Promise<PodTemplateList> {
    const path = `/api/v1/namespaces/${params.path.namespace}/podtemplates`;
    return await this.get<PodTemplateList>(path, null, null, opts);
  }
  async createCoreV1NamespacedPodTemplate(params: CreateCoreV1NamespacedPodTemplateRequest, opts?: APIClientRequestOpts): Promise<PodTemplate> {
    const path = `/api/v1/namespaces/${params.path.namespace}/podtemplates`;
    return await this.post<PodTemplate>(path, params.query, params.body, opts);
  }
  async deleteCoreV1CollectionNamespacedPodTemplate(params: DeleteCoreV1CollectionNamespacedPodTemplateRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/api/v1/namespaces/${params.path.namespace}/podtemplates`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readCoreV1NamespacedPodTemplate(params: ReadCoreV1NamespacedPodTemplateRequest, opts?: APIClientRequestOpts): Promise<PodTemplate> {
    const path = `/api/v1/namespaces/${params.path.namespace}/podtemplates/${params.path.name}`;
    return await this.get<PodTemplate>(path, null, null, opts);
  }
  async replaceCoreV1NamespacedPodTemplate(params: ReplaceCoreV1NamespacedPodTemplateRequest, opts?: APIClientRequestOpts): Promise<PodTemplate> {
    const path = `/api/v1/namespaces/${params.path.namespace}/podtemplates/${params.path.name}`;
    return await this.put<PodTemplate>(path, params.query, params.body, opts);
  }
  async deleteCoreV1NamespacedPodTemplate(params: DeleteCoreV1NamespacedPodTemplateRequest, opts?: APIClientRequestOpts): Promise<PodTemplate> {
    const path = `/api/v1/namespaces/${params.path.namespace}/podtemplates/${params.path.name}`;
    return await this.delete<PodTemplate>(path, params.query, null, opts);
  }
  async patchCoreV1NamespacedPodTemplate(params: PatchCoreV1NamespacedPodTemplateRequest, opts?: APIClientRequestOpts): Promise<PodTemplate> {
    const path = `/api/v1/namespaces/${params.path.namespace}/podtemplates/${params.path.name}`;
    return await this.patch<PodTemplate>(path, params.query, null, opts);
  }
  async listCoreV1NamespacedReplicationController(params: ListCoreV1NamespacedReplicationControllerRequest, opts?: APIClientRequestOpts): Promise<ReplicationControllerList> {
    const path = `/api/v1/namespaces/${params.path.namespace}/replicationcontrollers`;
    return await this.get<ReplicationControllerList>(path, null, null, opts);
  }
  async createCoreV1NamespacedReplicationController(params: CreateCoreV1NamespacedReplicationControllerRequest, opts?: APIClientRequestOpts): Promise<ReplicationController> {
    const path = `/api/v1/namespaces/${params.path.namespace}/replicationcontrollers`;
    return await this.post<ReplicationController>(path, params.query, params.body, opts);
  }
  async deleteCoreV1CollectionNamespacedReplicationController(params: DeleteCoreV1CollectionNamespacedReplicationControllerRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/api/v1/namespaces/${params.path.namespace}/replicationcontrollers`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readCoreV1NamespacedReplicationController(params: ReadCoreV1NamespacedReplicationControllerRequest, opts?: APIClientRequestOpts): Promise<ReplicationController> {
    const path = `/api/v1/namespaces/${params.path.namespace}/replicationcontrollers/${params.path.name}`;
    return await this.get<ReplicationController>(path, null, null, opts);
  }
  async replaceCoreV1NamespacedReplicationController(params: ReplaceCoreV1NamespacedReplicationControllerRequest, opts?: APIClientRequestOpts): Promise<ReplicationController> {
    const path = `/api/v1/namespaces/${params.path.namespace}/replicationcontrollers/${params.path.name}`;
    return await this.put<ReplicationController>(path, params.query, params.body, opts);
  }
  async deleteCoreV1NamespacedReplicationController(params: DeleteCoreV1NamespacedReplicationControllerRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/api/v1/namespaces/${params.path.namespace}/replicationcontrollers/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchCoreV1NamespacedReplicationController(params: PatchCoreV1NamespacedReplicationControllerRequest, opts?: APIClientRequestOpts): Promise<ReplicationController> {
    const path = `/api/v1/namespaces/${params.path.namespace}/replicationcontrollers/${params.path.name}`;
    return await this.patch<ReplicationController>(path, params.query, null, opts);
  }
  async readCoreV1NamespacedReplicationControllerScale(params: ReadCoreV1NamespacedReplicationControllerScaleRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1Scale> {
    const path = `/api/v1/namespaces/${params.path.namespace}/replicationcontrollers/${params.path.name}/scale`;
    return await this.get<AutoscalingV1Scale>(path, null, null, opts);
  }
  async replaceCoreV1NamespacedReplicationControllerScale(params: ReplaceCoreV1NamespacedReplicationControllerScaleRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1Scale> {
    const path = `/api/v1/namespaces/${params.path.namespace}/replicationcontrollers/${params.path.name}/scale`;
    return await this.put<AutoscalingV1Scale>(path, params.query, params.body, opts);
  }
  async patchCoreV1NamespacedReplicationControllerScale(params: PatchCoreV1NamespacedReplicationControllerScaleRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1Scale> {
    const path = `/api/v1/namespaces/${params.path.namespace}/replicationcontrollers/${params.path.name}/scale`;
    return await this.patch<AutoscalingV1Scale>(path, params.query, null, opts);
  }
  async readCoreV1NamespacedReplicationControllerStatus(params: ReadCoreV1NamespacedReplicationControllerStatusRequest, opts?: APIClientRequestOpts): Promise<ReplicationController> {
    const path = `/api/v1/namespaces/${params.path.namespace}/replicationcontrollers/${params.path.name}/status`;
    return await this.get<ReplicationController>(path, null, null, opts);
  }
  async replaceCoreV1NamespacedReplicationControllerStatus(params: ReplaceCoreV1NamespacedReplicationControllerStatusRequest, opts?: APIClientRequestOpts): Promise<ReplicationController> {
    const path = `/api/v1/namespaces/${params.path.namespace}/replicationcontrollers/${params.path.name}/status`;
    return await this.put<ReplicationController>(path, params.query, params.body, opts);
  }
  async patchCoreV1NamespacedReplicationControllerStatus(params: PatchCoreV1NamespacedReplicationControllerStatusRequest, opts?: APIClientRequestOpts): Promise<ReplicationController> {
    const path = `/api/v1/namespaces/${params.path.namespace}/replicationcontrollers/${params.path.name}/status`;
    return await this.patch<ReplicationController>(path, params.query, null, opts);
  }
  async listCoreV1NamespacedResourceQuota(params: ListCoreV1NamespacedResourceQuotaRequest, opts?: APIClientRequestOpts): Promise<ResourceQuotaList> {
    const path = `/api/v1/namespaces/${params.path.namespace}/resourcequotas`;
    return await this.get<ResourceQuotaList>(path, null, null, opts);
  }
  async createCoreV1NamespacedResourceQuota(params: CreateCoreV1NamespacedResourceQuotaRequest, opts?: APIClientRequestOpts): Promise<ResourceQuota> {
    const path = `/api/v1/namespaces/${params.path.namespace}/resourcequotas`;
    return await this.post<ResourceQuota>(path, params.query, params.body, opts);
  }
  async deleteCoreV1CollectionNamespacedResourceQuota(params: DeleteCoreV1CollectionNamespacedResourceQuotaRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/api/v1/namespaces/${params.path.namespace}/resourcequotas`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readCoreV1NamespacedResourceQuota(params: ReadCoreV1NamespacedResourceQuotaRequest, opts?: APIClientRequestOpts): Promise<ResourceQuota> {
    const path = `/api/v1/namespaces/${params.path.namespace}/resourcequotas/${params.path.name}`;
    return await this.get<ResourceQuota>(path, null, null, opts);
  }
  async replaceCoreV1NamespacedResourceQuota(params: ReplaceCoreV1NamespacedResourceQuotaRequest, opts?: APIClientRequestOpts): Promise<ResourceQuota> {
    const path = `/api/v1/namespaces/${params.path.namespace}/resourcequotas/${params.path.name}`;
    return await this.put<ResourceQuota>(path, params.query, params.body, opts);
  }
  async deleteCoreV1NamespacedResourceQuota(params: DeleteCoreV1NamespacedResourceQuotaRequest, opts?: APIClientRequestOpts): Promise<ResourceQuota> {
    const path = `/api/v1/namespaces/${params.path.namespace}/resourcequotas/${params.path.name}`;
    return await this.delete<ResourceQuota>(path, params.query, null, opts);
  }
  async patchCoreV1NamespacedResourceQuota(params: PatchCoreV1NamespacedResourceQuotaRequest, opts?: APIClientRequestOpts): Promise<ResourceQuota> {
    const path = `/api/v1/namespaces/${params.path.namespace}/resourcequotas/${params.path.name}`;
    return await this.patch<ResourceQuota>(path, params.query, null, opts);
  }
  async readCoreV1NamespacedResourceQuotaStatus(params: ReadCoreV1NamespacedResourceQuotaStatusRequest, opts?: APIClientRequestOpts): Promise<ResourceQuota> {
    const path = `/api/v1/namespaces/${params.path.namespace}/resourcequotas/${params.path.name}/status`;
    return await this.get<ResourceQuota>(path, null, null, opts);
  }
  async replaceCoreV1NamespacedResourceQuotaStatus(params: ReplaceCoreV1NamespacedResourceQuotaStatusRequest, opts?: APIClientRequestOpts): Promise<ResourceQuota> {
    const path = `/api/v1/namespaces/${params.path.namespace}/resourcequotas/${params.path.name}/status`;
    return await this.put<ResourceQuota>(path, params.query, params.body, opts);
  }
  async patchCoreV1NamespacedResourceQuotaStatus(params: PatchCoreV1NamespacedResourceQuotaStatusRequest, opts?: APIClientRequestOpts): Promise<ResourceQuota> {
    const path = `/api/v1/namespaces/${params.path.namespace}/resourcequotas/${params.path.name}/status`;
    return await this.patch<ResourceQuota>(path, params.query, null, opts);
  }
  async listCoreV1NamespacedSecret(params: ListCoreV1NamespacedSecretRequest, opts?: APIClientRequestOpts): Promise<SecretList> {
    const path = `/api/v1/namespaces/${params.path.namespace}/secrets`;
    return await this.get<SecretList>(path, null, null, opts);
  }
  async createCoreV1NamespacedSecret(params: CreateCoreV1NamespacedSecretRequest, opts?: APIClientRequestOpts): Promise<Secret> {
    const path = `/api/v1/namespaces/${params.path.namespace}/secrets`;
    return await this.post<Secret>(path, params.query, params.body, opts);
  }
  async deleteCoreV1CollectionNamespacedSecret(params: DeleteCoreV1CollectionNamespacedSecretRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/api/v1/namespaces/${params.path.namespace}/secrets`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readCoreV1NamespacedSecret(params: ReadCoreV1NamespacedSecretRequest, opts?: APIClientRequestOpts): Promise<Secret> {
    const path = `/api/v1/namespaces/${params.path.namespace}/secrets/${params.path.name}`;
    return await this.get<Secret>(path, null, null, opts);
  }
  async replaceCoreV1NamespacedSecret(params: ReplaceCoreV1NamespacedSecretRequest, opts?: APIClientRequestOpts): Promise<Secret> {
    const path = `/api/v1/namespaces/${params.path.namespace}/secrets/${params.path.name}`;
    return await this.put<Secret>(path, params.query, params.body, opts);
  }
  async deleteCoreV1NamespacedSecret(params: DeleteCoreV1NamespacedSecretRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/api/v1/namespaces/${params.path.namespace}/secrets/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchCoreV1NamespacedSecret(params: PatchCoreV1NamespacedSecretRequest, opts?: APIClientRequestOpts): Promise<Secret> {
    const path = `/api/v1/namespaces/${params.path.namespace}/secrets/${params.path.name}`;
    return await this.patch<Secret>(path, params.query, null, opts);
  }
  async listCoreV1NamespacedServiceAccount(params: ListCoreV1NamespacedServiceAccountRequest, opts?: APIClientRequestOpts): Promise<ServiceAccountList> {
    const path = `/api/v1/namespaces/${params.path.namespace}/serviceaccounts`;
    return await this.get<ServiceAccountList>(path, null, null, opts);
  }
  async createCoreV1NamespacedServiceAccount(params: CreateCoreV1NamespacedServiceAccountRequest, opts?: APIClientRequestOpts): Promise<ServiceAccount> {
    const path = `/api/v1/namespaces/${params.path.namespace}/serviceaccounts`;
    return await this.post<ServiceAccount>(path, params.query, params.body, opts);
  }
  async deleteCoreV1CollectionNamespacedServiceAccount(params: DeleteCoreV1CollectionNamespacedServiceAccountRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/api/v1/namespaces/${params.path.namespace}/serviceaccounts`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readCoreV1NamespacedServiceAccount(params: ReadCoreV1NamespacedServiceAccountRequest, opts?: APIClientRequestOpts): Promise<ServiceAccount> {
    const path = `/api/v1/namespaces/${params.path.namespace}/serviceaccounts/${params.path.name}`;
    return await this.get<ServiceAccount>(path, null, null, opts);
  }
  async replaceCoreV1NamespacedServiceAccount(params: ReplaceCoreV1NamespacedServiceAccountRequest, opts?: APIClientRequestOpts): Promise<ServiceAccount> {
    const path = `/api/v1/namespaces/${params.path.namespace}/serviceaccounts/${params.path.name}`;
    return await this.put<ServiceAccount>(path, params.query, params.body, opts);
  }
  async deleteCoreV1NamespacedServiceAccount(params: DeleteCoreV1NamespacedServiceAccountRequest, opts?: APIClientRequestOpts): Promise<ServiceAccount> {
    const path = `/api/v1/namespaces/${params.path.namespace}/serviceaccounts/${params.path.name}`;
    return await this.delete<ServiceAccount>(path, params.query, null, opts);
  }
  async patchCoreV1NamespacedServiceAccount(params: PatchCoreV1NamespacedServiceAccountRequest, opts?: APIClientRequestOpts): Promise<ServiceAccount> {
    const path = `/api/v1/namespaces/${params.path.namespace}/serviceaccounts/${params.path.name}`;
    return await this.patch<ServiceAccount>(path, params.query, null, opts);
  }
  async createCoreV1NamespacedServiceAccountToken(params: CreateCoreV1NamespacedServiceAccountTokenRequest, opts?: APIClientRequestOpts): Promise<AuthenticationK8sIoV1TokenRequest> {
    const path = `/api/v1/namespaces/${params.path.namespace}/serviceaccounts/${params.path.name}/token`;
    return await this.post<AuthenticationK8sIoV1TokenRequest>(path, null, params.body, opts);
  }
  async listCoreV1NamespacedService(params: ListCoreV1NamespacedServiceRequest, opts?: APIClientRequestOpts): Promise<ServiceList> {
    const path = `/api/v1/namespaces/${params.path.namespace}/services`;
    return await this.get<ServiceList>(path, null, null, opts);
  }
  async createCoreV1NamespacedService(params: CreateCoreV1NamespacedServiceRequest, opts?: APIClientRequestOpts): Promise<Service> {
    const path = `/api/v1/namespaces/${params.path.namespace}/services`;
    return await this.post<Service>(path, params.query, params.body, opts);
  }
  async deleteCoreV1CollectionNamespacedService(params: DeleteCoreV1CollectionNamespacedServiceRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/api/v1/namespaces/${params.path.namespace}/services`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readCoreV1NamespacedService(params: ReadCoreV1NamespacedServiceRequest, opts?: APIClientRequestOpts): Promise<Service> {
    const path = `/api/v1/namespaces/${params.path.namespace}/services/${params.path.name}`;
    return await this.get<Service>(path, null, null, opts);
  }
  async replaceCoreV1NamespacedService(params: ReplaceCoreV1NamespacedServiceRequest, opts?: APIClientRequestOpts): Promise<Service> {
    const path = `/api/v1/namespaces/${params.path.namespace}/services/${params.path.name}`;
    return await this.put<Service>(path, params.query, params.body, opts);
  }
  async deleteCoreV1NamespacedService(params: DeleteCoreV1NamespacedServiceRequest, opts?: APIClientRequestOpts): Promise<Service> {
    const path = `/api/v1/namespaces/${params.path.namespace}/services/${params.path.name}`;
    return await this.delete<Service>(path, params.query, null, opts);
  }
  async patchCoreV1NamespacedService(params: PatchCoreV1NamespacedServiceRequest, opts?: APIClientRequestOpts): Promise<Service> {
    const path = `/api/v1/namespaces/${params.path.namespace}/services/${params.path.name}`;
    return await this.patch<Service>(path, params.query, null, opts);
  }
  async connectCoreV1GetNamespacedServiceProxy(params: ConnectCoreV1GetNamespacedServiceProxyRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/namespaces/${params.path.namespace}/services/${params.path.name}/proxy`;
    return await this.get<string>(path, null, null, opts);
  }
  async connectCoreV1PostNamespacedServiceProxy(params: ConnectCoreV1PostNamespacedServiceProxyRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/namespaces/${params.path.namespace}/services/${params.path.name}/proxy`;
    return await this.post<string>(path, null, null, opts);
  }
  async connectCoreV1PutNamespacedServiceProxy(params: ConnectCoreV1PutNamespacedServiceProxyRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/namespaces/${params.path.namespace}/services/${params.path.name}/proxy`;
    return await this.put<string>(path, null, null, opts);
  }
  async connectCoreV1DeleteNamespacedServiceProxy(params: ConnectCoreV1DeleteNamespacedServiceProxyRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/namespaces/${params.path.namespace}/services/${params.path.name}/proxy`;
    return await this.delete<string>(path, null, null, opts);
  }
  async connectCoreV1PatchNamespacedServiceProxy(params: ConnectCoreV1PatchNamespacedServiceProxyRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/namespaces/${params.path.namespace}/services/${params.path.name}/proxy`;
    return await this.patch<string>(path, null, null, opts);
  }
  async connectCoreV1GetNamespacedServiceProxyWithPath(params: ConnectCoreV1GetNamespacedServiceProxyWithPathRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/namespaces/${params.path.namespace}/services/${params.path.name}/proxy/${params.path.path}`;
    return await this.get<string>(path, null, null, opts);
  }
  async connectCoreV1PostNamespacedServiceProxyWithPath(params: ConnectCoreV1PostNamespacedServiceProxyWithPathRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/namespaces/${params.path.namespace}/services/${params.path.name}/proxy/${params.path.path}`;
    return await this.post<string>(path, null, null, opts);
  }
  async connectCoreV1PutNamespacedServiceProxyWithPath(params: ConnectCoreV1PutNamespacedServiceProxyWithPathRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/namespaces/${params.path.namespace}/services/${params.path.name}/proxy/${params.path.path}`;
    return await this.put<string>(path, null, null, opts);
  }
  async connectCoreV1DeleteNamespacedServiceProxyWithPath(params: ConnectCoreV1DeleteNamespacedServiceProxyWithPathRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/namespaces/${params.path.namespace}/services/${params.path.name}/proxy/${params.path.path}`;
    return await this.delete<string>(path, null, null, opts);
  }
  async connectCoreV1PatchNamespacedServiceProxyWithPath(params: ConnectCoreV1PatchNamespacedServiceProxyWithPathRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/namespaces/${params.path.namespace}/services/${params.path.name}/proxy/${params.path.path}`;
    return await this.patch<string>(path, null, null, opts);
  }
  async readCoreV1NamespacedServiceStatus(params: ReadCoreV1NamespacedServiceStatusRequest, opts?: APIClientRequestOpts): Promise<Service> {
    const path = `/api/v1/namespaces/${params.path.namespace}/services/${params.path.name}/status`;
    return await this.get<Service>(path, null, null, opts);
  }
  async replaceCoreV1NamespacedServiceStatus(params: ReplaceCoreV1NamespacedServiceStatusRequest, opts?: APIClientRequestOpts): Promise<Service> {
    const path = `/api/v1/namespaces/${params.path.namespace}/services/${params.path.name}/status`;
    return await this.put<Service>(path, params.query, params.body, opts);
  }
  async patchCoreV1NamespacedServiceStatus(params: PatchCoreV1NamespacedServiceStatusRequest, opts?: APIClientRequestOpts): Promise<Service> {
    const path = `/api/v1/namespaces/${params.path.namespace}/services/${params.path.name}/status`;
    return await this.patch<Service>(path, params.query, null, opts);
  }
  async readCoreV1Namespace(params: ReadCoreV1NamespaceRequest, opts?: APIClientRequestOpts): Promise<Namespace> {
    const path = `/api/v1/namespaces/${params.path.name}`;
    return await this.get<Namespace>(path, null, null, opts);
  }
  async replaceCoreV1Namespace(params: ReplaceCoreV1NamespaceRequest, opts?: APIClientRequestOpts): Promise<Namespace> {
    const path = `/api/v1/namespaces/${params.path.name}`;
    return await this.put<Namespace>(path, params.query, params.body, opts);
  }
  async deleteCoreV1Namespace(params: DeleteCoreV1NamespaceRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/api/v1/namespaces/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchCoreV1Namespace(params: PatchCoreV1NamespaceRequest, opts?: APIClientRequestOpts): Promise<Namespace> {
    const path = `/api/v1/namespaces/${params.path.name}`;
    return await this.patch<Namespace>(path, params.query, null, opts);
  }
  async replaceCoreV1NamespaceFinalize(params: ReplaceCoreV1NamespaceFinalizeRequest, opts?: APIClientRequestOpts): Promise<Namespace> {
    const path = `/api/v1/namespaces/${params.path.name}/finalize`;
    return await this.put<Namespace>(path, null, params.body, opts);
  }
  async readCoreV1NamespaceStatus(params: ReadCoreV1NamespaceStatusRequest, opts?: APIClientRequestOpts): Promise<Namespace> {
    const path = `/api/v1/namespaces/${params.path.name}/status`;
    return await this.get<Namespace>(path, null, null, opts);
  }
  async replaceCoreV1NamespaceStatus(params: ReplaceCoreV1NamespaceStatusRequest, opts?: APIClientRequestOpts): Promise<Namespace> {
    const path = `/api/v1/namespaces/${params.path.name}/status`;
    return await this.put<Namespace>(path, params.query, params.body, opts);
  }
  async patchCoreV1NamespaceStatus(params: PatchCoreV1NamespaceStatusRequest, opts?: APIClientRequestOpts): Promise<Namespace> {
    const path = `/api/v1/namespaces/${params.path.name}/status`;
    return await this.patch<Namespace>(path, params.query, null, opts);
  }
  async listCoreV1Node(params: ListCoreV1NodeRequest, opts?: APIClientRequestOpts): Promise<NodeList> {
    const path = `/api/v1/nodes`;
    return await this.get<NodeList>(path, null, null, opts);
  }
  async createCoreV1Node(params: CreateCoreV1NodeRequest, opts?: APIClientRequestOpts): Promise<Node> {
    const path = `/api/v1/nodes`;
    return await this.post<Node>(path, params.query, params.body, opts);
  }
  async deleteCoreV1CollectionNode(params: DeleteCoreV1CollectionNodeRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/api/v1/nodes`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readCoreV1Node(params: ReadCoreV1NodeRequest, opts?: APIClientRequestOpts): Promise<Node> {
    const path = `/api/v1/nodes/${params.path.name}`;
    return await this.get<Node>(path, null, null, opts);
  }
  async replaceCoreV1Node(params: ReplaceCoreV1NodeRequest, opts?: APIClientRequestOpts): Promise<Node> {
    const path = `/api/v1/nodes/${params.path.name}`;
    return await this.put<Node>(path, params.query, params.body, opts);
  }
  async deleteCoreV1Node(params: DeleteCoreV1NodeRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/api/v1/nodes/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchCoreV1Node(params: PatchCoreV1NodeRequest, opts?: APIClientRequestOpts): Promise<Node> {
    const path = `/api/v1/nodes/${params.path.name}`;
    return await this.patch<Node>(path, params.query, null, opts);
  }
  async connectCoreV1GetNodeProxy(params: ConnectCoreV1GetNodeProxyRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/nodes/${params.path.name}/proxy`;
    return await this.get<string>(path, null, null, opts);
  }
  async connectCoreV1PostNodeProxy(params: ConnectCoreV1PostNodeProxyRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/nodes/${params.path.name}/proxy`;
    return await this.post<string>(path, null, null, opts);
  }
  async connectCoreV1PutNodeProxy(params: ConnectCoreV1PutNodeProxyRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/nodes/${params.path.name}/proxy`;
    return await this.put<string>(path, null, null, opts);
  }
  async connectCoreV1DeleteNodeProxy(params: ConnectCoreV1DeleteNodeProxyRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/nodes/${params.path.name}/proxy`;
    return await this.delete<string>(path, null, null, opts);
  }
  async connectCoreV1PatchNodeProxy(params: ConnectCoreV1PatchNodeProxyRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/nodes/${params.path.name}/proxy`;
    return await this.patch<string>(path, null, null, opts);
  }
  async connectCoreV1GetNodeProxyWithPath(params: ConnectCoreV1GetNodeProxyWithPathRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/nodes/${params.path.name}/proxy/${params.path.path}`;
    return await this.get<string>(path, null, null, opts);
  }
  async connectCoreV1PostNodeProxyWithPath(params: ConnectCoreV1PostNodeProxyWithPathRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/nodes/${params.path.name}/proxy/${params.path.path}`;
    return await this.post<string>(path, null, null, opts);
  }
  async connectCoreV1PutNodeProxyWithPath(params: ConnectCoreV1PutNodeProxyWithPathRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/nodes/${params.path.name}/proxy/${params.path.path}`;
    return await this.put<string>(path, null, null, opts);
  }
  async connectCoreV1DeleteNodeProxyWithPath(params: ConnectCoreV1DeleteNodeProxyWithPathRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/nodes/${params.path.name}/proxy/${params.path.path}`;
    return await this.delete<string>(path, null, null, opts);
  }
  async connectCoreV1PatchNodeProxyWithPath(params: ConnectCoreV1PatchNodeProxyWithPathRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/api/v1/nodes/${params.path.name}/proxy/${params.path.path}`;
    return await this.patch<string>(path, null, null, opts);
  }
  async readCoreV1NodeStatus(params: ReadCoreV1NodeStatusRequest, opts?: APIClientRequestOpts): Promise<Node> {
    const path = `/api/v1/nodes/${params.path.name}/status`;
    return await this.get<Node>(path, null, null, opts);
  }
  async replaceCoreV1NodeStatus(params: ReplaceCoreV1NodeStatusRequest, opts?: APIClientRequestOpts): Promise<Node> {
    const path = `/api/v1/nodes/${params.path.name}/status`;
    return await this.put<Node>(path, params.query, params.body, opts);
  }
  async patchCoreV1NodeStatus(params: PatchCoreV1NodeStatusRequest, opts?: APIClientRequestOpts): Promise<Node> {
    const path = `/api/v1/nodes/${params.path.name}/status`;
    return await this.patch<Node>(path, params.query, null, opts);
  }
  async listCoreV1PersistentVolumeClaimForAllNamespaces(params: ListCoreV1PersistentVolumeClaimForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<PersistentVolumeClaimList> {
    const path = `/api/v1/persistentvolumeclaims`;
    return await this.get<PersistentVolumeClaimList>(path, null, null, opts);
  }
  async listCoreV1PersistentVolume(params: ListCoreV1PersistentVolumeRequest, opts?: APIClientRequestOpts): Promise<PersistentVolumeList> {
    const path = `/api/v1/persistentvolumes`;
    return await this.get<PersistentVolumeList>(path, null, null, opts);
  }
  async createCoreV1PersistentVolume(params: CreateCoreV1PersistentVolumeRequest, opts?: APIClientRequestOpts): Promise<PersistentVolume> {
    const path = `/api/v1/persistentvolumes`;
    return await this.post<PersistentVolume>(path, params.query, params.body, opts);
  }
  async deleteCoreV1CollectionPersistentVolume(params: DeleteCoreV1CollectionPersistentVolumeRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/api/v1/persistentvolumes`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readCoreV1PersistentVolume(params: ReadCoreV1PersistentVolumeRequest, opts?: APIClientRequestOpts): Promise<PersistentVolume> {
    const path = `/api/v1/persistentvolumes/${params.path.name}`;
    return await this.get<PersistentVolume>(path, null, null, opts);
  }
  async replaceCoreV1PersistentVolume(params: ReplaceCoreV1PersistentVolumeRequest, opts?: APIClientRequestOpts): Promise<PersistentVolume> {
    const path = `/api/v1/persistentvolumes/${params.path.name}`;
    return await this.put<PersistentVolume>(path, params.query, params.body, opts);
  }
  async deleteCoreV1PersistentVolume(params: DeleteCoreV1PersistentVolumeRequest, opts?: APIClientRequestOpts): Promise<PersistentVolume> {
    const path = `/api/v1/persistentvolumes/${params.path.name}`;
    return await this.delete<PersistentVolume>(path, params.query, null, opts);
  }
  async patchCoreV1PersistentVolume(params: PatchCoreV1PersistentVolumeRequest, opts?: APIClientRequestOpts): Promise<PersistentVolume> {
    const path = `/api/v1/persistentvolumes/${params.path.name}`;
    return await this.patch<PersistentVolume>(path, params.query, null, opts);
  }
  async readCoreV1PersistentVolumeStatus(params: ReadCoreV1PersistentVolumeStatusRequest, opts?: APIClientRequestOpts): Promise<PersistentVolume> {
    const path = `/api/v1/persistentvolumes/${params.path.name}/status`;
    return await this.get<PersistentVolume>(path, null, null, opts);
  }
  async replaceCoreV1PersistentVolumeStatus(params: ReplaceCoreV1PersistentVolumeStatusRequest, opts?: APIClientRequestOpts): Promise<PersistentVolume> {
    const path = `/api/v1/persistentvolumes/${params.path.name}/status`;
    return await this.put<PersistentVolume>(path, params.query, params.body, opts);
  }
  async patchCoreV1PersistentVolumeStatus(params: PatchCoreV1PersistentVolumeStatusRequest, opts?: APIClientRequestOpts): Promise<PersistentVolume> {
    const path = `/api/v1/persistentvolumes/${params.path.name}/status`;
    return await this.patch<PersistentVolume>(path, params.query, null, opts);
  }
  async listCoreV1PodForAllNamespaces(params: ListCoreV1PodForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<PodList> {
    const path = `/api/v1/pods`;
    return await this.get<PodList>(path, null, null, opts);
  }
  async listCoreV1PodTemplateForAllNamespaces(params: ListCoreV1PodTemplateForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<PodTemplateList> {
    const path = `/api/v1/podtemplates`;
    return await this.get<PodTemplateList>(path, null, null, opts);
  }
  async listCoreV1ReplicationControllerForAllNamespaces(params: ListCoreV1ReplicationControllerForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<ReplicationControllerList> {
    const path = `/api/v1/replicationcontrollers`;
    return await this.get<ReplicationControllerList>(path, null, null, opts);
  }
  async listCoreV1ResourceQuotaForAllNamespaces(params: ListCoreV1ResourceQuotaForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<ResourceQuotaList> {
    const path = `/api/v1/resourcequotas`;
    return await this.get<ResourceQuotaList>(path, null, null, opts);
  }
  async listCoreV1SecretForAllNamespaces(params: ListCoreV1SecretForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<SecretList> {
    const path = `/api/v1/secrets`;
    return await this.get<SecretList>(path, null, null, opts);
  }
  async listCoreV1ServiceAccountForAllNamespaces(params: ListCoreV1ServiceAccountForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<ServiceAccountList> {
    const path = `/api/v1/serviceaccounts`;
    return await this.get<ServiceAccountList>(path, null, null, opts);
  }
  async listCoreV1ServiceForAllNamespaces(params: ListCoreV1ServiceForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<ServiceList> {
    const path = `/api/v1/services`;
    return await this.get<ServiceList>(path, null, null, opts);
  }
  async watchCoreV1ConfigMapListForAllNamespaces(params: WatchCoreV1ConfigMapListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/configmaps`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1EndpointsListForAllNamespaces(params: WatchCoreV1EndpointsListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/endpoints`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1EventListForAllNamespaces(params: WatchCoreV1EventListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/events`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1LimitRangeListForAllNamespaces(params: WatchCoreV1LimitRangeListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/limitranges`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1NamespaceList(params: WatchCoreV1NamespaceListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/namespaces`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1NamespacedConfigMapList(params: WatchCoreV1NamespacedConfigMapListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/namespaces/${params.path.namespace}/configmaps`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1NamespacedConfigMap(params: WatchCoreV1NamespacedConfigMapRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/namespaces/${params.path.namespace}/configmaps/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1NamespacedEndpointsList(params: WatchCoreV1NamespacedEndpointsListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/namespaces/${params.path.namespace}/endpoints`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1NamespacedEndpoints(params: WatchCoreV1NamespacedEndpointsRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/namespaces/${params.path.namespace}/endpoints/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1NamespacedEventList(params: WatchCoreV1NamespacedEventListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/namespaces/${params.path.namespace}/events`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1NamespacedEvent(params: WatchCoreV1NamespacedEventRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/namespaces/${params.path.namespace}/events/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1NamespacedLimitRangeList(params: WatchCoreV1NamespacedLimitRangeListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/namespaces/${params.path.namespace}/limitranges`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1NamespacedLimitRange(params: WatchCoreV1NamespacedLimitRangeRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/namespaces/${params.path.namespace}/limitranges/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1NamespacedPersistentVolumeClaimList(params: WatchCoreV1NamespacedPersistentVolumeClaimListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/namespaces/${params.path.namespace}/persistentvolumeclaims`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1NamespacedPersistentVolumeClaim(params: WatchCoreV1NamespacedPersistentVolumeClaimRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/namespaces/${params.path.namespace}/persistentvolumeclaims/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1NamespacedPodList(params: WatchCoreV1NamespacedPodListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/namespaces/${params.path.namespace}/pods`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1NamespacedPod(params: WatchCoreV1NamespacedPodRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/namespaces/${params.path.namespace}/pods/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1NamespacedPodTemplateList(params: WatchCoreV1NamespacedPodTemplateListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/namespaces/${params.path.namespace}/podtemplates`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1NamespacedPodTemplate(params: WatchCoreV1NamespacedPodTemplateRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/namespaces/${params.path.namespace}/podtemplates/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1NamespacedReplicationControllerList(params: WatchCoreV1NamespacedReplicationControllerListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/namespaces/${params.path.namespace}/replicationcontrollers`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1NamespacedReplicationController(params: WatchCoreV1NamespacedReplicationControllerRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/namespaces/${params.path.namespace}/replicationcontrollers/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1NamespacedResourceQuotaList(params: WatchCoreV1NamespacedResourceQuotaListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/namespaces/${params.path.namespace}/resourcequotas`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1NamespacedResourceQuota(params: WatchCoreV1NamespacedResourceQuotaRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/namespaces/${params.path.namespace}/resourcequotas/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1NamespacedSecretList(params: WatchCoreV1NamespacedSecretListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/namespaces/${params.path.namespace}/secrets`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1NamespacedSecret(params: WatchCoreV1NamespacedSecretRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/namespaces/${params.path.namespace}/secrets/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1NamespacedServiceAccountList(params: WatchCoreV1NamespacedServiceAccountListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/namespaces/${params.path.namespace}/serviceaccounts`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1NamespacedServiceAccount(params: WatchCoreV1NamespacedServiceAccountRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/namespaces/${params.path.namespace}/serviceaccounts/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1NamespacedServiceList(params: WatchCoreV1NamespacedServiceListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/namespaces/${params.path.namespace}/services`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1NamespacedService(params: WatchCoreV1NamespacedServiceRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/namespaces/${params.path.namespace}/services/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1Namespace(params: WatchCoreV1NamespaceRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/namespaces/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1NodeList(params: WatchCoreV1NodeListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/nodes`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1Node(params: WatchCoreV1NodeRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/nodes/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1PersistentVolumeClaimListForAllNamespaces(params: WatchCoreV1PersistentVolumeClaimListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/persistentvolumeclaims`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1PersistentVolumeList(params: WatchCoreV1PersistentVolumeListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/persistentvolumes`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1PersistentVolume(params: WatchCoreV1PersistentVolumeRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/persistentvolumes/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1PodListForAllNamespaces(params: WatchCoreV1PodListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/pods`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1PodTemplateListForAllNamespaces(params: WatchCoreV1PodTemplateListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/podtemplates`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1ReplicationControllerListForAllNamespaces(params: WatchCoreV1ReplicationControllerListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/replicationcontrollers`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1ResourceQuotaListForAllNamespaces(params: WatchCoreV1ResourceQuotaListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/resourcequotas`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1SecretListForAllNamespaces(params: WatchCoreV1SecretListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/secrets`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1ServiceAccountListForAllNamespaces(params: WatchCoreV1ServiceAccountListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/serviceaccounts`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoreV1ServiceListForAllNamespaces(params: WatchCoreV1ServiceListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/api/v1/watch/services`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async getAPIVersions(params: GetAPIVersionsRequest, opts?: APIClientRequestOpts): Promise<APIGroupList> {
    const path = `/apis/`;
    return await this.get<APIGroupList>(path, null, null, opts);
  }
  async listAcmeCertManagerIoV1ChallengeForAllNamespaces(params: ListAcmeCertManagerIoV1ChallengeForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<AcmeCertManagerIoV1ChallengeList> {
    const path = `/apis/acme.cert-manager.io/v1/challenges`;
    return await this.get<AcmeCertManagerIoV1ChallengeList>(path, null, null, opts);
  }
  async listAcmeCertManagerIoV1NamespacedChallenge(params: ListAcmeCertManagerIoV1NamespacedChallengeRequest, opts?: APIClientRequestOpts): Promise<AcmeCertManagerIoV1ChallengeList> {
    const path = `/apis/acme.cert-manager.io/v1/namespaces/${params.path.namespace}/challenges`;
    return await this.get<AcmeCertManagerIoV1ChallengeList>(path, null, null, opts);
  }
  async createAcmeCertManagerIoV1NamespacedChallenge(params: CreateAcmeCertManagerIoV1NamespacedChallengeRequest, opts?: APIClientRequestOpts): Promise<AcmeCertManagerIoV1Challenge> {
    const path = `/apis/acme.cert-manager.io/v1/namespaces/${params.path.namespace}/challenges`;
    return await this.post<AcmeCertManagerIoV1Challenge>(path, params.query, params.body, opts);
  }
  async deleteAcmeCertManagerIoV1CollectionNamespacedChallenge(params: DeleteAcmeCertManagerIoV1CollectionNamespacedChallengeRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/acme.cert-manager.io/v1/namespaces/${params.path.namespace}/challenges`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readAcmeCertManagerIoV1NamespacedChallenge(params: ReadAcmeCertManagerIoV1NamespacedChallengeRequest, opts?: APIClientRequestOpts): Promise<AcmeCertManagerIoV1Challenge> {
    const path = `/apis/acme.cert-manager.io/v1/namespaces/${params.path.namespace}/challenges/${params.path.name}`;
    return await this.get<AcmeCertManagerIoV1Challenge>(path, null, null, opts);
  }
  async replaceAcmeCertManagerIoV1NamespacedChallenge(params: ReplaceAcmeCertManagerIoV1NamespacedChallengeRequest, opts?: APIClientRequestOpts): Promise<AcmeCertManagerIoV1Challenge> {
    const path = `/apis/acme.cert-manager.io/v1/namespaces/${params.path.namespace}/challenges/${params.path.name}`;
    return await this.put<AcmeCertManagerIoV1Challenge>(path, params.query, params.body, opts);
  }
  async deleteAcmeCertManagerIoV1NamespacedChallenge(params: DeleteAcmeCertManagerIoV1NamespacedChallengeRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/acme.cert-manager.io/v1/namespaces/${params.path.namespace}/challenges/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchAcmeCertManagerIoV1NamespacedChallenge(params: PatchAcmeCertManagerIoV1NamespacedChallengeRequest, opts?: APIClientRequestOpts): Promise<AcmeCertManagerIoV1Challenge> {
    const path = `/apis/acme.cert-manager.io/v1/namespaces/${params.path.namespace}/challenges/${params.path.name}`;
    return await this.patch<AcmeCertManagerIoV1Challenge>(path, params.query, null, opts);
  }
  async readAcmeCertManagerIoV1NamespacedChallengeStatus(params: ReadAcmeCertManagerIoV1NamespacedChallengeStatusRequest, opts?: APIClientRequestOpts): Promise<AcmeCertManagerIoV1Challenge> {
    const path = `/apis/acme.cert-manager.io/v1/namespaces/${params.path.namespace}/challenges/${params.path.name}/status`;
    return await this.get<AcmeCertManagerIoV1Challenge>(path, null, null, opts);
  }
  async replaceAcmeCertManagerIoV1NamespacedChallengeStatus(params: ReplaceAcmeCertManagerIoV1NamespacedChallengeStatusRequest, opts?: APIClientRequestOpts): Promise<AcmeCertManagerIoV1Challenge> {
    const path = `/apis/acme.cert-manager.io/v1/namespaces/${params.path.namespace}/challenges/${params.path.name}/status`;
    return await this.put<AcmeCertManagerIoV1Challenge>(path, params.query, params.body, opts);
  }
  async patchAcmeCertManagerIoV1NamespacedChallengeStatus(params: PatchAcmeCertManagerIoV1NamespacedChallengeStatusRequest, opts?: APIClientRequestOpts): Promise<AcmeCertManagerIoV1Challenge> {
    const path = `/apis/acme.cert-manager.io/v1/namespaces/${params.path.namespace}/challenges/${params.path.name}/status`;
    return await this.patch<AcmeCertManagerIoV1Challenge>(path, params.query, null, opts);
  }
  async listAcmeCertManagerIoV1NamespacedOrder(params: ListAcmeCertManagerIoV1NamespacedOrderRequest, opts?: APIClientRequestOpts): Promise<AcmeCertManagerIoV1OrderList> {
    const path = `/apis/acme.cert-manager.io/v1/namespaces/${params.path.namespace}/orders`;
    return await this.get<AcmeCertManagerIoV1OrderList>(path, null, null, opts);
  }
  async createAcmeCertManagerIoV1NamespacedOrder(params: CreateAcmeCertManagerIoV1NamespacedOrderRequest, opts?: APIClientRequestOpts): Promise<AcmeCertManagerIoV1Order> {
    const path = `/apis/acme.cert-manager.io/v1/namespaces/${params.path.namespace}/orders`;
    return await this.post<AcmeCertManagerIoV1Order>(path, params.query, params.body, opts);
  }
  async deleteAcmeCertManagerIoV1CollectionNamespacedOrder(params: DeleteAcmeCertManagerIoV1CollectionNamespacedOrderRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/acme.cert-manager.io/v1/namespaces/${params.path.namespace}/orders`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readAcmeCertManagerIoV1NamespacedOrder(params: ReadAcmeCertManagerIoV1NamespacedOrderRequest, opts?: APIClientRequestOpts): Promise<AcmeCertManagerIoV1Order> {
    const path = `/apis/acme.cert-manager.io/v1/namespaces/${params.path.namespace}/orders/${params.path.name}`;
    return await this.get<AcmeCertManagerIoV1Order>(path, null, null, opts);
  }
  async replaceAcmeCertManagerIoV1NamespacedOrder(params: ReplaceAcmeCertManagerIoV1NamespacedOrderRequest, opts?: APIClientRequestOpts): Promise<AcmeCertManagerIoV1Order> {
    const path = `/apis/acme.cert-manager.io/v1/namespaces/${params.path.namespace}/orders/${params.path.name}`;
    return await this.put<AcmeCertManagerIoV1Order>(path, params.query, params.body, opts);
  }
  async deleteAcmeCertManagerIoV1NamespacedOrder(params: DeleteAcmeCertManagerIoV1NamespacedOrderRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/acme.cert-manager.io/v1/namespaces/${params.path.namespace}/orders/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchAcmeCertManagerIoV1NamespacedOrder(params: PatchAcmeCertManagerIoV1NamespacedOrderRequest, opts?: APIClientRequestOpts): Promise<AcmeCertManagerIoV1Order> {
    const path = `/apis/acme.cert-manager.io/v1/namespaces/${params.path.namespace}/orders/${params.path.name}`;
    return await this.patch<AcmeCertManagerIoV1Order>(path, params.query, null, opts);
  }
  async readAcmeCertManagerIoV1NamespacedOrderStatus(params: ReadAcmeCertManagerIoV1NamespacedOrderStatusRequest, opts?: APIClientRequestOpts): Promise<AcmeCertManagerIoV1Order> {
    const path = `/apis/acme.cert-manager.io/v1/namespaces/${params.path.namespace}/orders/${params.path.name}/status`;
    return await this.get<AcmeCertManagerIoV1Order>(path, null, null, opts);
  }
  async replaceAcmeCertManagerIoV1NamespacedOrderStatus(params: ReplaceAcmeCertManagerIoV1NamespacedOrderStatusRequest, opts?: APIClientRequestOpts): Promise<AcmeCertManagerIoV1Order> {
    const path = `/apis/acme.cert-manager.io/v1/namespaces/${params.path.namespace}/orders/${params.path.name}/status`;
    return await this.put<AcmeCertManagerIoV1Order>(path, params.query, params.body, opts);
  }
  async patchAcmeCertManagerIoV1NamespacedOrderStatus(params: PatchAcmeCertManagerIoV1NamespacedOrderStatusRequest, opts?: APIClientRequestOpts): Promise<AcmeCertManagerIoV1Order> {
    const path = `/apis/acme.cert-manager.io/v1/namespaces/${params.path.namespace}/orders/${params.path.name}/status`;
    return await this.patch<AcmeCertManagerIoV1Order>(path, params.query, null, opts);
  }
  async listAcmeCertManagerIoV1OrderForAllNamespaces(params: ListAcmeCertManagerIoV1OrderForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<AcmeCertManagerIoV1OrderList> {
    const path = `/apis/acme.cert-manager.io/v1/orders`;
    return await this.get<AcmeCertManagerIoV1OrderList>(path, null, null, opts);
  }
  async getAdmissionregistrationAPIGroup(params: GetAdmissionregistrationAPIGroupRequest, opts?: APIClientRequestOpts): Promise<APIGroup> {
    const path = `/apis/admissionregistration.k8s.io/`;
    return await this.get<APIGroup>(path, null, null, opts);
  }
  async getAdmissionregistrationV1APIResources(params: GetAdmissionregistrationV1APIResourcesRequest, opts?: APIClientRequestOpts): Promise<APIResourceList> {
    const path = `/apis/admissionregistration.k8s.io/v1/`;
    return await this.get<APIResourceList>(path, null, null, opts);
  }
  async listAdmissionregistrationV1MutatingWebhookConfiguration(params: ListAdmissionregistrationV1MutatingWebhookConfigurationRequest, opts?: APIClientRequestOpts): Promise<AdmissionregistrationK8sIoV1MutatingWebhookConfigurationList> {
    const path = `/apis/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations`;
    return await this.get<AdmissionregistrationK8sIoV1MutatingWebhookConfigurationList>(path, null, null, opts);
  }
  async createAdmissionregistrationV1MutatingWebhookConfiguration(params: CreateAdmissionregistrationV1MutatingWebhookConfigurationRequest, opts?: APIClientRequestOpts): Promise<AdmissionregistrationK8sIoV1MutatingWebhookConfiguration> {
    const path = `/apis/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations`;
    return await this.post<AdmissionregistrationK8sIoV1MutatingWebhookConfiguration>(path, params.query, params.body, opts);
  }
  async deleteAdmissionregistrationV1CollectionMutatingWebhookConfiguration(params: DeleteAdmissionregistrationV1CollectionMutatingWebhookConfigurationRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readAdmissionregistrationV1MutatingWebhookConfiguration(params: ReadAdmissionregistrationV1MutatingWebhookConfigurationRequest, opts?: APIClientRequestOpts): Promise<AdmissionregistrationK8sIoV1MutatingWebhookConfiguration> {
    const path = `/apis/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations/${params.path.name}`;
    return await this.get<AdmissionregistrationK8sIoV1MutatingWebhookConfiguration>(path, null, null, opts);
  }
  async replaceAdmissionregistrationV1MutatingWebhookConfiguration(params: ReplaceAdmissionregistrationV1MutatingWebhookConfigurationRequest, opts?: APIClientRequestOpts): Promise<AdmissionregistrationK8sIoV1MutatingWebhookConfiguration> {
    const path = `/apis/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations/${params.path.name}`;
    return await this.put<AdmissionregistrationK8sIoV1MutatingWebhookConfiguration>(path, params.query, params.body, opts);
  }
  async deleteAdmissionregistrationV1MutatingWebhookConfiguration(params: DeleteAdmissionregistrationV1MutatingWebhookConfigurationRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchAdmissionregistrationV1MutatingWebhookConfiguration(params: PatchAdmissionregistrationV1MutatingWebhookConfigurationRequest, opts?: APIClientRequestOpts): Promise<AdmissionregistrationK8sIoV1MutatingWebhookConfiguration> {
    const path = `/apis/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations/${params.path.name}`;
    return await this.patch<AdmissionregistrationK8sIoV1MutatingWebhookConfiguration>(path, params.query, null, opts);
  }
  async listAdmissionregistrationV1ValidatingAdmissionPolicy(params: ListAdmissionregistrationV1ValidatingAdmissionPolicyRequest, opts?: APIClientRequestOpts): Promise<AdmissionregistrationK8sIoV1ValidatingAdmissionPolicyList> {
    const path = `/apis/admissionregistration.k8s.io/v1/validatingadmissionpolicies`;
    return await this.get<AdmissionregistrationK8sIoV1ValidatingAdmissionPolicyList>(path, null, null, opts);
  }
  async createAdmissionregistrationV1ValidatingAdmissionPolicy(params: CreateAdmissionregistrationV1ValidatingAdmissionPolicyRequest, opts?: APIClientRequestOpts): Promise<AdmissionregistrationK8sIoV1ValidatingAdmissionPolicy> {
    const path = `/apis/admissionregistration.k8s.io/v1/validatingadmissionpolicies`;
    return await this.post<AdmissionregistrationK8sIoV1ValidatingAdmissionPolicy>(path, params.query, params.body, opts);
  }
  async deleteAdmissionregistrationV1CollectionValidatingAdmissionPolicy(params: DeleteAdmissionregistrationV1CollectionValidatingAdmissionPolicyRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/admissionregistration.k8s.io/v1/validatingadmissionpolicies`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readAdmissionregistrationV1ValidatingAdmissionPolicy(params: ReadAdmissionregistrationV1ValidatingAdmissionPolicyRequest, opts?: APIClientRequestOpts): Promise<AdmissionregistrationK8sIoV1ValidatingAdmissionPolicy> {
    const path = `/apis/admissionregistration.k8s.io/v1/validatingadmissionpolicies/${params.path.name}`;
    return await this.get<AdmissionregistrationK8sIoV1ValidatingAdmissionPolicy>(path, null, null, opts);
  }
  async replaceAdmissionregistrationV1ValidatingAdmissionPolicy(params: ReplaceAdmissionregistrationV1ValidatingAdmissionPolicyRequest, opts?: APIClientRequestOpts): Promise<AdmissionregistrationK8sIoV1ValidatingAdmissionPolicy> {
    const path = `/apis/admissionregistration.k8s.io/v1/validatingadmissionpolicies/${params.path.name}`;
    return await this.put<AdmissionregistrationK8sIoV1ValidatingAdmissionPolicy>(path, params.query, params.body, opts);
  }
  async deleteAdmissionregistrationV1ValidatingAdmissionPolicy(params: DeleteAdmissionregistrationV1ValidatingAdmissionPolicyRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/admissionregistration.k8s.io/v1/validatingadmissionpolicies/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchAdmissionregistrationV1ValidatingAdmissionPolicy(params: PatchAdmissionregistrationV1ValidatingAdmissionPolicyRequest, opts?: APIClientRequestOpts): Promise<AdmissionregistrationK8sIoV1ValidatingAdmissionPolicy> {
    const path = `/apis/admissionregistration.k8s.io/v1/validatingadmissionpolicies/${params.path.name}`;
    return await this.patch<AdmissionregistrationK8sIoV1ValidatingAdmissionPolicy>(path, params.query, null, opts);
  }
  async readAdmissionregistrationV1ValidatingAdmissionPolicyStatus(params: ReadAdmissionregistrationV1ValidatingAdmissionPolicyStatusRequest, opts?: APIClientRequestOpts): Promise<AdmissionregistrationK8sIoV1ValidatingAdmissionPolicy> {
    const path = `/apis/admissionregistration.k8s.io/v1/validatingadmissionpolicies/${params.path.name}/status`;
    return await this.get<AdmissionregistrationK8sIoV1ValidatingAdmissionPolicy>(path, null, null, opts);
  }
  async replaceAdmissionregistrationV1ValidatingAdmissionPolicyStatus(params: ReplaceAdmissionregistrationV1ValidatingAdmissionPolicyStatusRequest, opts?: APIClientRequestOpts): Promise<AdmissionregistrationK8sIoV1ValidatingAdmissionPolicy> {
    const path = `/apis/admissionregistration.k8s.io/v1/validatingadmissionpolicies/${params.path.name}/status`;
    return await this.put<AdmissionregistrationK8sIoV1ValidatingAdmissionPolicy>(path, params.query, params.body, opts);
  }
  async patchAdmissionregistrationV1ValidatingAdmissionPolicyStatus(params: PatchAdmissionregistrationV1ValidatingAdmissionPolicyStatusRequest, opts?: APIClientRequestOpts): Promise<AdmissionregistrationK8sIoV1ValidatingAdmissionPolicy> {
    const path = `/apis/admissionregistration.k8s.io/v1/validatingadmissionpolicies/${params.path.name}/status`;
    return await this.patch<AdmissionregistrationK8sIoV1ValidatingAdmissionPolicy>(path, params.query, null, opts);
  }
  async listAdmissionregistrationV1ValidatingAdmissionPolicyBinding(params: ListAdmissionregistrationV1ValidatingAdmissionPolicyBindingRequest, opts?: APIClientRequestOpts): Promise<AdmissionregistrationK8sIoV1ValidatingAdmissionPolicyBindingList> {
    const path = `/apis/admissionregistration.k8s.io/v1/validatingadmissionpolicybindings`;
    return await this.get<AdmissionregistrationK8sIoV1ValidatingAdmissionPolicyBindingList>(path, null, null, opts);
  }
  async createAdmissionregistrationV1ValidatingAdmissionPolicyBinding(params: CreateAdmissionregistrationV1ValidatingAdmissionPolicyBindingRequest, opts?: APIClientRequestOpts): Promise<AdmissionregistrationK8sIoV1ValidatingAdmissionPolicyBinding> {
    const path = `/apis/admissionregistration.k8s.io/v1/validatingadmissionpolicybindings`;
    return await this.post<AdmissionregistrationK8sIoV1ValidatingAdmissionPolicyBinding>(path, params.query, params.body, opts);
  }
  async deleteAdmissionregistrationV1CollectionValidatingAdmissionPolicyBinding(params: DeleteAdmissionregistrationV1CollectionValidatingAdmissionPolicyBindingRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/admissionregistration.k8s.io/v1/validatingadmissionpolicybindings`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readAdmissionregistrationV1ValidatingAdmissionPolicyBinding(params: ReadAdmissionregistrationV1ValidatingAdmissionPolicyBindingRequest, opts?: APIClientRequestOpts): Promise<AdmissionregistrationK8sIoV1ValidatingAdmissionPolicyBinding> {
    const path = `/apis/admissionregistration.k8s.io/v1/validatingadmissionpolicybindings/${params.path.name}`;
    return await this.get<AdmissionregistrationK8sIoV1ValidatingAdmissionPolicyBinding>(path, null, null, opts);
  }
  async replaceAdmissionregistrationV1ValidatingAdmissionPolicyBinding(params: ReplaceAdmissionregistrationV1ValidatingAdmissionPolicyBindingRequest, opts?: APIClientRequestOpts): Promise<AdmissionregistrationK8sIoV1ValidatingAdmissionPolicyBinding> {
    const path = `/apis/admissionregistration.k8s.io/v1/validatingadmissionpolicybindings/${params.path.name}`;
    return await this.put<AdmissionregistrationK8sIoV1ValidatingAdmissionPolicyBinding>(path, params.query, params.body, opts);
  }
  async deleteAdmissionregistrationV1ValidatingAdmissionPolicyBinding(params: DeleteAdmissionregistrationV1ValidatingAdmissionPolicyBindingRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/admissionregistration.k8s.io/v1/validatingadmissionpolicybindings/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchAdmissionregistrationV1ValidatingAdmissionPolicyBinding(params: PatchAdmissionregistrationV1ValidatingAdmissionPolicyBindingRequest, opts?: APIClientRequestOpts): Promise<AdmissionregistrationK8sIoV1ValidatingAdmissionPolicyBinding> {
    const path = `/apis/admissionregistration.k8s.io/v1/validatingadmissionpolicybindings/${params.path.name}`;
    return await this.patch<AdmissionregistrationK8sIoV1ValidatingAdmissionPolicyBinding>(path, params.query, null, opts);
  }
  async listAdmissionregistrationV1ValidatingWebhookConfiguration(params: ListAdmissionregistrationV1ValidatingWebhookConfigurationRequest, opts?: APIClientRequestOpts): Promise<AdmissionregistrationK8sIoV1ValidatingWebhookConfigurationList> {
    const path = `/apis/admissionregistration.k8s.io/v1/validatingwebhookconfigurations`;
    return await this.get<AdmissionregistrationK8sIoV1ValidatingWebhookConfigurationList>(path, null, null, opts);
  }
  async createAdmissionregistrationV1ValidatingWebhookConfiguration(params: CreateAdmissionregistrationV1ValidatingWebhookConfigurationRequest, opts?: APIClientRequestOpts): Promise<AdmissionregistrationK8sIoV1ValidatingWebhookConfiguration> {
    const path = `/apis/admissionregistration.k8s.io/v1/validatingwebhookconfigurations`;
    return await this.post<AdmissionregistrationK8sIoV1ValidatingWebhookConfiguration>(path, params.query, params.body, opts);
  }
  async deleteAdmissionregistrationV1CollectionValidatingWebhookConfiguration(params: DeleteAdmissionregistrationV1CollectionValidatingWebhookConfigurationRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/admissionregistration.k8s.io/v1/validatingwebhookconfigurations`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readAdmissionregistrationV1ValidatingWebhookConfiguration(params: ReadAdmissionregistrationV1ValidatingWebhookConfigurationRequest, opts?: APIClientRequestOpts): Promise<AdmissionregistrationK8sIoV1ValidatingWebhookConfiguration> {
    const path = `/apis/admissionregistration.k8s.io/v1/validatingwebhookconfigurations/${params.path.name}`;
    return await this.get<AdmissionregistrationK8sIoV1ValidatingWebhookConfiguration>(path, null, null, opts);
  }
  async replaceAdmissionregistrationV1ValidatingWebhookConfiguration(params: ReplaceAdmissionregistrationV1ValidatingWebhookConfigurationRequest, opts?: APIClientRequestOpts): Promise<AdmissionregistrationK8sIoV1ValidatingWebhookConfiguration> {
    const path = `/apis/admissionregistration.k8s.io/v1/validatingwebhookconfigurations/${params.path.name}`;
    return await this.put<AdmissionregistrationK8sIoV1ValidatingWebhookConfiguration>(path, params.query, params.body, opts);
  }
  async deleteAdmissionregistrationV1ValidatingWebhookConfiguration(params: DeleteAdmissionregistrationV1ValidatingWebhookConfigurationRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/admissionregistration.k8s.io/v1/validatingwebhookconfigurations/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchAdmissionregistrationV1ValidatingWebhookConfiguration(params: PatchAdmissionregistrationV1ValidatingWebhookConfigurationRequest, opts?: APIClientRequestOpts): Promise<AdmissionregistrationK8sIoV1ValidatingWebhookConfiguration> {
    const path = `/apis/admissionregistration.k8s.io/v1/validatingwebhookconfigurations/${params.path.name}`;
    return await this.patch<AdmissionregistrationK8sIoV1ValidatingWebhookConfiguration>(path, params.query, null, opts);
  }
  async watchAdmissionregistrationV1MutatingWebhookConfigurationList(params: WatchAdmissionregistrationV1MutatingWebhookConfigurationListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/admissionregistration.k8s.io/v1/watch/mutatingwebhookconfigurations`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchAdmissionregistrationV1MutatingWebhookConfiguration(params: WatchAdmissionregistrationV1MutatingWebhookConfigurationRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/admissionregistration.k8s.io/v1/watch/mutatingwebhookconfigurations/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchAdmissionregistrationV1ValidatingAdmissionPolicyList(params: WatchAdmissionregistrationV1ValidatingAdmissionPolicyListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/admissionregistration.k8s.io/v1/watch/validatingadmissionpolicies`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchAdmissionregistrationV1ValidatingAdmissionPolicy(params: WatchAdmissionregistrationV1ValidatingAdmissionPolicyRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/admissionregistration.k8s.io/v1/watch/validatingadmissionpolicies/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchAdmissionregistrationV1ValidatingAdmissionPolicyBindingList(params: WatchAdmissionregistrationV1ValidatingAdmissionPolicyBindingListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/admissionregistration.k8s.io/v1/watch/validatingadmissionpolicybindings`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchAdmissionregistrationV1ValidatingAdmissionPolicyBinding(params: WatchAdmissionregistrationV1ValidatingAdmissionPolicyBindingRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/admissionregistration.k8s.io/v1/watch/validatingadmissionpolicybindings/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchAdmissionregistrationV1ValidatingWebhookConfigurationList(params: WatchAdmissionregistrationV1ValidatingWebhookConfigurationListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/admissionregistration.k8s.io/v1/watch/validatingwebhookconfigurations`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchAdmissionregistrationV1ValidatingWebhookConfiguration(params: WatchAdmissionregistrationV1ValidatingWebhookConfigurationRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/admissionregistration.k8s.io/v1/watch/validatingwebhookconfigurations/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async getApiextensionsAPIGroup(params: GetApiextensionsAPIGroupRequest, opts?: APIClientRequestOpts): Promise<APIGroup> {
    const path = `/apis/apiextensions.k8s.io/`;
    return await this.get<APIGroup>(path, null, null, opts);
  }
  async getApiextensionsV1APIResources(params: GetApiextensionsV1APIResourcesRequest, opts?: APIClientRequestOpts): Promise<APIResourceList> {
    const path = `/apis/apiextensions.k8s.io/v1/`;
    return await this.get<APIResourceList>(path, null, null, opts);
  }
  async listApiextensionsV1CustomResourceDefinition(params: ListApiextensionsV1CustomResourceDefinitionRequest, opts?: APIClientRequestOpts): Promise<ApiextensionsK8sIoV1CustomResourceDefinitionList> {
    const path = `/apis/apiextensions.k8s.io/v1/customresourcedefinitions`;
    return await this.get<ApiextensionsK8sIoV1CustomResourceDefinitionList>(path, null, null, opts);
  }
  async createApiextensionsV1CustomResourceDefinition(params: CreateApiextensionsV1CustomResourceDefinitionRequest, opts?: APIClientRequestOpts): Promise<ApiextensionsK8sIoV1CustomResourceDefinition> {
    const path = `/apis/apiextensions.k8s.io/v1/customresourcedefinitions`;
    return await this.post<ApiextensionsK8sIoV1CustomResourceDefinition>(path, params.query, params.body, opts);
  }
  async deleteApiextensionsV1CollectionCustomResourceDefinition(params: DeleteApiextensionsV1CollectionCustomResourceDefinitionRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/apiextensions.k8s.io/v1/customresourcedefinitions`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readApiextensionsV1CustomResourceDefinition(params: ReadApiextensionsV1CustomResourceDefinitionRequest, opts?: APIClientRequestOpts): Promise<ApiextensionsK8sIoV1CustomResourceDefinition> {
    const path = `/apis/apiextensions.k8s.io/v1/customresourcedefinitions/${params.path.name}`;
    return await this.get<ApiextensionsK8sIoV1CustomResourceDefinition>(path, null, null, opts);
  }
  async replaceApiextensionsV1CustomResourceDefinition(params: ReplaceApiextensionsV1CustomResourceDefinitionRequest, opts?: APIClientRequestOpts): Promise<ApiextensionsK8sIoV1CustomResourceDefinition> {
    const path = `/apis/apiextensions.k8s.io/v1/customresourcedefinitions/${params.path.name}`;
    return await this.put<ApiextensionsK8sIoV1CustomResourceDefinition>(path, params.query, params.body, opts);
  }
  async deleteApiextensionsV1CustomResourceDefinition(params: DeleteApiextensionsV1CustomResourceDefinitionRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/apiextensions.k8s.io/v1/customresourcedefinitions/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchApiextensionsV1CustomResourceDefinition(params: PatchApiextensionsV1CustomResourceDefinitionRequest, opts?: APIClientRequestOpts): Promise<ApiextensionsK8sIoV1CustomResourceDefinition> {
    const path = `/apis/apiextensions.k8s.io/v1/customresourcedefinitions/${params.path.name}`;
    return await this.patch<ApiextensionsK8sIoV1CustomResourceDefinition>(path, params.query, null, opts);
  }
  async readApiextensionsV1CustomResourceDefinitionStatus(params: ReadApiextensionsV1CustomResourceDefinitionStatusRequest, opts?: APIClientRequestOpts): Promise<ApiextensionsK8sIoV1CustomResourceDefinition> {
    const path = `/apis/apiextensions.k8s.io/v1/customresourcedefinitions/${params.path.name}/status`;
    return await this.get<ApiextensionsK8sIoV1CustomResourceDefinition>(path, null, null, opts);
  }
  async replaceApiextensionsV1CustomResourceDefinitionStatus(params: ReplaceApiextensionsV1CustomResourceDefinitionStatusRequest, opts?: APIClientRequestOpts): Promise<ApiextensionsK8sIoV1CustomResourceDefinition> {
    const path = `/apis/apiextensions.k8s.io/v1/customresourcedefinitions/${params.path.name}/status`;
    return await this.put<ApiextensionsK8sIoV1CustomResourceDefinition>(path, params.query, params.body, opts);
  }
  async patchApiextensionsV1CustomResourceDefinitionStatus(params: PatchApiextensionsV1CustomResourceDefinitionStatusRequest, opts?: APIClientRequestOpts): Promise<ApiextensionsK8sIoV1CustomResourceDefinition> {
    const path = `/apis/apiextensions.k8s.io/v1/customresourcedefinitions/${params.path.name}/status`;
    return await this.patch<ApiextensionsK8sIoV1CustomResourceDefinition>(path, params.query, null, opts);
  }
  async watchApiextensionsV1CustomResourceDefinitionList(params: WatchApiextensionsV1CustomResourceDefinitionListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/apiextensions.k8s.io/v1/watch/customresourcedefinitions`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchApiextensionsV1CustomResourceDefinition(params: WatchApiextensionsV1CustomResourceDefinitionRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/apiextensions.k8s.io/v1/watch/customresourcedefinitions/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async getApiregistrationAPIGroup(params: GetApiregistrationAPIGroupRequest, opts?: APIClientRequestOpts): Promise<APIGroup> {
    const path = `/apis/apiregistration.k8s.io/`;
    return await this.get<APIGroup>(path, null, null, opts);
  }
  async getApiregistrationV1APIResources(params: GetApiregistrationV1APIResourcesRequest, opts?: APIClientRequestOpts): Promise<APIResourceList> {
    const path = `/apis/apiregistration.k8s.io/v1/`;
    return await this.get<APIResourceList>(path, null, null, opts);
  }
  async listApiregistrationV1APIService(params: ListApiregistrationV1APIServiceRequest, opts?: APIClientRequestOpts): Promise<ApiregistrationK8sIoV1APIServiceList> {
    const path = `/apis/apiregistration.k8s.io/v1/apiservices`;
    return await this.get<ApiregistrationK8sIoV1APIServiceList>(path, null, null, opts);
  }
  async createApiregistrationV1APIService(params: CreateApiregistrationV1APIServiceRequest, opts?: APIClientRequestOpts): Promise<ApiregistrationK8sIoV1APIService> {
    const path = `/apis/apiregistration.k8s.io/v1/apiservices`;
    return await this.post<ApiregistrationK8sIoV1APIService>(path, params.query, params.body, opts);
  }
  async deleteApiregistrationV1CollectionAPIService(params: DeleteApiregistrationV1CollectionAPIServiceRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/apiregistration.k8s.io/v1/apiservices`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readApiregistrationV1APIService(params: ReadApiregistrationV1APIServiceRequest, opts?: APIClientRequestOpts): Promise<ApiregistrationK8sIoV1APIService> {
    const path = `/apis/apiregistration.k8s.io/v1/apiservices/${params.path.name}`;
    return await this.get<ApiregistrationK8sIoV1APIService>(path, null, null, opts);
  }
  async replaceApiregistrationV1APIService(params: ReplaceApiregistrationV1APIServiceRequest, opts?: APIClientRequestOpts): Promise<ApiregistrationK8sIoV1APIService> {
    const path = `/apis/apiregistration.k8s.io/v1/apiservices/${params.path.name}`;
    return await this.put<ApiregistrationK8sIoV1APIService>(path, params.query, params.body, opts);
  }
  async deleteApiregistrationV1APIService(params: DeleteApiregistrationV1APIServiceRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/apiregistration.k8s.io/v1/apiservices/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchApiregistrationV1APIService(params: PatchApiregistrationV1APIServiceRequest, opts?: APIClientRequestOpts): Promise<ApiregistrationK8sIoV1APIService> {
    const path = `/apis/apiregistration.k8s.io/v1/apiservices/${params.path.name}`;
    return await this.patch<ApiregistrationK8sIoV1APIService>(path, params.query, null, opts);
  }
  async readApiregistrationV1APIServiceStatus(params: ReadApiregistrationV1APIServiceStatusRequest, opts?: APIClientRequestOpts): Promise<ApiregistrationK8sIoV1APIService> {
    const path = `/apis/apiregistration.k8s.io/v1/apiservices/${params.path.name}/status`;
    return await this.get<ApiregistrationK8sIoV1APIService>(path, null, null, opts);
  }
  async replaceApiregistrationV1APIServiceStatus(params: ReplaceApiregistrationV1APIServiceStatusRequest, opts?: APIClientRequestOpts): Promise<ApiregistrationK8sIoV1APIService> {
    const path = `/apis/apiregistration.k8s.io/v1/apiservices/${params.path.name}/status`;
    return await this.put<ApiregistrationK8sIoV1APIService>(path, params.query, params.body, opts);
  }
  async patchApiregistrationV1APIServiceStatus(params: PatchApiregistrationV1APIServiceStatusRequest, opts?: APIClientRequestOpts): Promise<ApiregistrationK8sIoV1APIService> {
    const path = `/apis/apiregistration.k8s.io/v1/apiservices/${params.path.name}/status`;
    return await this.patch<ApiregistrationK8sIoV1APIService>(path, params.query, null, opts);
  }
  async watchApiregistrationV1APIServiceList(params: WatchApiregistrationV1APIServiceListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/apiregistration.k8s.io/v1/watch/apiservices`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchApiregistrationV1APIService(params: WatchApiregistrationV1APIServiceRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/apiregistration.k8s.io/v1/watch/apiservices/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async getAppsAPIGroup(params: GetAppsAPIGroupRequest, opts?: APIClientRequestOpts): Promise<APIGroup> {
    const path = `/apis/apps/`;
    return await this.get<APIGroup>(path, null, null, opts);
  }
  async getAppsV1APIResources(params: GetAppsV1APIResourcesRequest, opts?: APIClientRequestOpts): Promise<APIResourceList> {
    const path = `/apis/apps/v1/`;
    return await this.get<APIResourceList>(path, null, null, opts);
  }
  async listAppsV1ControllerRevisionForAllNamespaces(params: ListAppsV1ControllerRevisionForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<AppsV1ControllerRevisionList> {
    const path = `/apis/apps/v1/controllerrevisions`;
    return await this.get<AppsV1ControllerRevisionList>(path, null, null, opts);
  }
  async listAppsV1DaemonSetForAllNamespaces(params: ListAppsV1DaemonSetForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<AppsV1DaemonSetList> {
    const path = `/apis/apps/v1/daemonsets`;
    return await this.get<AppsV1DaemonSetList>(path, null, null, opts);
  }
  async listAppsV1DeploymentForAllNamespaces(params: ListAppsV1DeploymentForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<AppsV1DeploymentList> {
    const path = `/apis/apps/v1/deployments`;
    return await this.get<AppsV1DeploymentList>(path, null, null, opts);
  }
  async listAppsV1NamespacedControllerRevision(params: ListAppsV1NamespacedControllerRevisionRequest, opts?: APIClientRequestOpts): Promise<AppsV1ControllerRevisionList> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/controllerrevisions`;
    return await this.get<AppsV1ControllerRevisionList>(path, null, null, opts);
  }
  async createAppsV1NamespacedControllerRevision(params: CreateAppsV1NamespacedControllerRevisionRequest, opts?: APIClientRequestOpts): Promise<AppsV1ControllerRevision> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/controllerrevisions`;
    return await this.post<AppsV1ControllerRevision>(path, params.query, params.body, opts);
  }
  async deleteAppsV1CollectionNamespacedControllerRevision(params: DeleteAppsV1CollectionNamespacedControllerRevisionRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/controllerrevisions`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readAppsV1NamespacedControllerRevision(params: ReadAppsV1NamespacedControllerRevisionRequest, opts?: APIClientRequestOpts): Promise<AppsV1ControllerRevision> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/controllerrevisions/${params.path.name}`;
    return await this.get<AppsV1ControllerRevision>(path, null, null, opts);
  }
  async replaceAppsV1NamespacedControllerRevision(params: ReplaceAppsV1NamespacedControllerRevisionRequest, opts?: APIClientRequestOpts): Promise<AppsV1ControllerRevision> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/controllerrevisions/${params.path.name}`;
    return await this.put<AppsV1ControllerRevision>(path, params.query, params.body, opts);
  }
  async deleteAppsV1NamespacedControllerRevision(params: DeleteAppsV1NamespacedControllerRevisionRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/controllerrevisions/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchAppsV1NamespacedControllerRevision(params: PatchAppsV1NamespacedControllerRevisionRequest, opts?: APIClientRequestOpts): Promise<AppsV1ControllerRevision> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/controllerrevisions/${params.path.name}`;
    return await this.patch<AppsV1ControllerRevision>(path, params.query, null, opts);
  }
  async listAppsV1NamespacedDaemonSet(params: ListAppsV1NamespacedDaemonSetRequest, opts?: APIClientRequestOpts): Promise<AppsV1DaemonSetList> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/daemonsets`;
    return await this.get<AppsV1DaemonSetList>(path, null, null, opts);
  }
  async createAppsV1NamespacedDaemonSet(params: CreateAppsV1NamespacedDaemonSetRequest, opts?: APIClientRequestOpts): Promise<AppsV1DaemonSet> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/daemonsets`;
    return await this.post<AppsV1DaemonSet>(path, params.query, params.body, opts);
  }
  async deleteAppsV1CollectionNamespacedDaemonSet(params: DeleteAppsV1CollectionNamespacedDaemonSetRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/daemonsets`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readAppsV1NamespacedDaemonSet(params: ReadAppsV1NamespacedDaemonSetRequest, opts?: APIClientRequestOpts): Promise<AppsV1DaemonSet> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/daemonsets/${params.path.name}`;
    return await this.get<AppsV1DaemonSet>(path, null, null, opts);
  }
  async replaceAppsV1NamespacedDaemonSet(params: ReplaceAppsV1NamespacedDaemonSetRequest, opts?: APIClientRequestOpts): Promise<AppsV1DaemonSet> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/daemonsets/${params.path.name}`;
    return await this.put<AppsV1DaemonSet>(path, params.query, params.body, opts);
  }
  async deleteAppsV1NamespacedDaemonSet(params: DeleteAppsV1NamespacedDaemonSetRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/daemonsets/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchAppsV1NamespacedDaemonSet(params: PatchAppsV1NamespacedDaemonSetRequest, opts?: APIClientRequestOpts): Promise<AppsV1DaemonSet> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/daemonsets/${params.path.name}`;
    return await this.patch<AppsV1DaemonSet>(path, params.query, null, opts);
  }
  async readAppsV1NamespacedDaemonSetStatus(params: ReadAppsV1NamespacedDaemonSetStatusRequest, opts?: APIClientRequestOpts): Promise<AppsV1DaemonSet> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/daemonsets/${params.path.name}/status`;
    return await this.get<AppsV1DaemonSet>(path, null, null, opts);
  }
  async replaceAppsV1NamespacedDaemonSetStatus(params: ReplaceAppsV1NamespacedDaemonSetStatusRequest, opts?: APIClientRequestOpts): Promise<AppsV1DaemonSet> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/daemonsets/${params.path.name}/status`;
    return await this.put<AppsV1DaemonSet>(path, params.query, params.body, opts);
  }
  async patchAppsV1NamespacedDaemonSetStatus(params: PatchAppsV1NamespacedDaemonSetStatusRequest, opts?: APIClientRequestOpts): Promise<AppsV1DaemonSet> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/daemonsets/${params.path.name}/status`;
    return await this.patch<AppsV1DaemonSet>(path, params.query, null, opts);
  }
  async listAppsV1NamespacedDeployment(params: ListAppsV1NamespacedDeploymentRequest, opts?: APIClientRequestOpts): Promise<AppsV1DeploymentList> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/deployments`;
    return await this.get<AppsV1DeploymentList>(path, null, null, opts);
  }
  async createAppsV1NamespacedDeployment(params: CreateAppsV1NamespacedDeploymentRequest, opts?: APIClientRequestOpts): Promise<AppsV1Deployment> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/deployments`;
    return await this.post<AppsV1Deployment>(path, params.query, params.body, opts);
  }
  async deleteAppsV1CollectionNamespacedDeployment(params: DeleteAppsV1CollectionNamespacedDeploymentRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/deployments`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readAppsV1NamespacedDeployment(params: ReadAppsV1NamespacedDeploymentRequest, opts?: APIClientRequestOpts): Promise<AppsV1Deployment> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/deployments/${params.path.name}`;
    return await this.get<AppsV1Deployment>(path, null, null, opts);
  }
  async replaceAppsV1NamespacedDeployment(params: ReplaceAppsV1NamespacedDeploymentRequest, opts?: APIClientRequestOpts): Promise<AppsV1Deployment> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/deployments/${params.path.name}`;
    return await this.put<AppsV1Deployment>(path, params.query, params.body, opts);
  }
  async deleteAppsV1NamespacedDeployment(params: DeleteAppsV1NamespacedDeploymentRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/deployments/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchAppsV1NamespacedDeployment(params: PatchAppsV1NamespacedDeploymentRequest, opts?: APIClientRequestOpts): Promise<AppsV1Deployment> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/deployments/${params.path.name}`;
    return await this.patch<AppsV1Deployment>(path, params.query, null, opts);
  }
  async readAppsV1NamespacedDeploymentScale(params: ReadAppsV1NamespacedDeploymentScaleRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1Scale> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/deployments/${params.path.name}/scale`;
    return await this.get<AutoscalingV1Scale>(path, null, null, opts);
  }
  async replaceAppsV1NamespacedDeploymentScale(params: ReplaceAppsV1NamespacedDeploymentScaleRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1Scale> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/deployments/${params.path.name}/scale`;
    return await this.put<AutoscalingV1Scale>(path, params.query, params.body, opts);
  }
  async patchAppsV1NamespacedDeploymentScale(params: PatchAppsV1NamespacedDeploymentScaleRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1Scale> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/deployments/${params.path.name}/scale`;
    return await this.patch<AutoscalingV1Scale>(path, params.query, null, opts);
  }
  async readAppsV1NamespacedDeploymentStatus(params: ReadAppsV1NamespacedDeploymentStatusRequest, opts?: APIClientRequestOpts): Promise<AppsV1Deployment> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/deployments/${params.path.name}/status`;
    return await this.get<AppsV1Deployment>(path, null, null, opts);
  }
  async replaceAppsV1NamespacedDeploymentStatus(params: ReplaceAppsV1NamespacedDeploymentStatusRequest, opts?: APIClientRequestOpts): Promise<AppsV1Deployment> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/deployments/${params.path.name}/status`;
    return await this.put<AppsV1Deployment>(path, params.query, params.body, opts);
  }
  async patchAppsV1NamespacedDeploymentStatus(params: PatchAppsV1NamespacedDeploymentStatusRequest, opts?: APIClientRequestOpts): Promise<AppsV1Deployment> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/deployments/${params.path.name}/status`;
    return await this.patch<AppsV1Deployment>(path, params.query, null, opts);
  }
  async listAppsV1NamespacedReplicaSet(params: ListAppsV1NamespacedReplicaSetRequest, opts?: APIClientRequestOpts): Promise<AppsV1ReplicaSetList> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/replicasets`;
    return await this.get<AppsV1ReplicaSetList>(path, null, null, opts);
  }
  async createAppsV1NamespacedReplicaSet(params: CreateAppsV1NamespacedReplicaSetRequest, opts?: APIClientRequestOpts): Promise<AppsV1ReplicaSet> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/replicasets`;
    return await this.post<AppsV1ReplicaSet>(path, params.query, params.body, opts);
  }
  async deleteAppsV1CollectionNamespacedReplicaSet(params: DeleteAppsV1CollectionNamespacedReplicaSetRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/replicasets`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readAppsV1NamespacedReplicaSet(params: ReadAppsV1NamespacedReplicaSetRequest, opts?: APIClientRequestOpts): Promise<AppsV1ReplicaSet> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/replicasets/${params.path.name}`;
    return await this.get<AppsV1ReplicaSet>(path, null, null, opts);
  }
  async replaceAppsV1NamespacedReplicaSet(params: ReplaceAppsV1NamespacedReplicaSetRequest, opts?: APIClientRequestOpts): Promise<AppsV1ReplicaSet> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/replicasets/${params.path.name}`;
    return await this.put<AppsV1ReplicaSet>(path, params.query, params.body, opts);
  }
  async deleteAppsV1NamespacedReplicaSet(params: DeleteAppsV1NamespacedReplicaSetRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/replicasets/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchAppsV1NamespacedReplicaSet(params: PatchAppsV1NamespacedReplicaSetRequest, opts?: APIClientRequestOpts): Promise<AppsV1ReplicaSet> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/replicasets/${params.path.name}`;
    return await this.patch<AppsV1ReplicaSet>(path, params.query, null, opts);
  }
  async readAppsV1NamespacedReplicaSetScale(params: ReadAppsV1NamespacedReplicaSetScaleRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1Scale> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/replicasets/${params.path.name}/scale`;
    return await this.get<AutoscalingV1Scale>(path, null, null, opts);
  }
  async replaceAppsV1NamespacedReplicaSetScale(params: ReplaceAppsV1NamespacedReplicaSetScaleRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1Scale> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/replicasets/${params.path.name}/scale`;
    return await this.put<AutoscalingV1Scale>(path, params.query, params.body, opts);
  }
  async patchAppsV1NamespacedReplicaSetScale(params: PatchAppsV1NamespacedReplicaSetScaleRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1Scale> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/replicasets/${params.path.name}/scale`;
    return await this.patch<AutoscalingV1Scale>(path, params.query, null, opts);
  }
  async readAppsV1NamespacedReplicaSetStatus(params: ReadAppsV1NamespacedReplicaSetStatusRequest, opts?: APIClientRequestOpts): Promise<AppsV1ReplicaSet> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/replicasets/${params.path.name}/status`;
    return await this.get<AppsV1ReplicaSet>(path, null, null, opts);
  }
  async replaceAppsV1NamespacedReplicaSetStatus(params: ReplaceAppsV1NamespacedReplicaSetStatusRequest, opts?: APIClientRequestOpts): Promise<AppsV1ReplicaSet> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/replicasets/${params.path.name}/status`;
    return await this.put<AppsV1ReplicaSet>(path, params.query, params.body, opts);
  }
  async patchAppsV1NamespacedReplicaSetStatus(params: PatchAppsV1NamespacedReplicaSetStatusRequest, opts?: APIClientRequestOpts): Promise<AppsV1ReplicaSet> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/replicasets/${params.path.name}/status`;
    return await this.patch<AppsV1ReplicaSet>(path, params.query, null, opts);
  }
  async listAppsV1NamespacedStatefulSet(params: ListAppsV1NamespacedStatefulSetRequest, opts?: APIClientRequestOpts): Promise<AppsV1StatefulSetList> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/statefulsets`;
    return await this.get<AppsV1StatefulSetList>(path, null, null, opts);
  }
  async createAppsV1NamespacedStatefulSet(params: CreateAppsV1NamespacedStatefulSetRequest, opts?: APIClientRequestOpts): Promise<AppsV1StatefulSet> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/statefulsets`;
    return await this.post<AppsV1StatefulSet>(path, params.query, params.body, opts);
  }
  async deleteAppsV1CollectionNamespacedStatefulSet(params: DeleteAppsV1CollectionNamespacedStatefulSetRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/statefulsets`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readAppsV1NamespacedStatefulSet(params: ReadAppsV1NamespacedStatefulSetRequest, opts?: APIClientRequestOpts): Promise<AppsV1StatefulSet> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/statefulsets/${params.path.name}`;
    return await this.get<AppsV1StatefulSet>(path, null, null, opts);
  }
  async replaceAppsV1NamespacedStatefulSet(params: ReplaceAppsV1NamespacedStatefulSetRequest, opts?: APIClientRequestOpts): Promise<AppsV1StatefulSet> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/statefulsets/${params.path.name}`;
    return await this.put<AppsV1StatefulSet>(path, params.query, params.body, opts);
  }
  async deleteAppsV1NamespacedStatefulSet(params: DeleteAppsV1NamespacedStatefulSetRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/statefulsets/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchAppsV1NamespacedStatefulSet(params: PatchAppsV1NamespacedStatefulSetRequest, opts?: APIClientRequestOpts): Promise<AppsV1StatefulSet> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/statefulsets/${params.path.name}`;
    return await this.patch<AppsV1StatefulSet>(path, params.query, null, opts);
  }
  async readAppsV1NamespacedStatefulSetScale(params: ReadAppsV1NamespacedStatefulSetScaleRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1Scale> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/statefulsets/${params.path.name}/scale`;
    return await this.get<AutoscalingV1Scale>(path, null, null, opts);
  }
  async replaceAppsV1NamespacedStatefulSetScale(params: ReplaceAppsV1NamespacedStatefulSetScaleRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1Scale> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/statefulsets/${params.path.name}/scale`;
    return await this.put<AutoscalingV1Scale>(path, params.query, params.body, opts);
  }
  async patchAppsV1NamespacedStatefulSetScale(params: PatchAppsV1NamespacedStatefulSetScaleRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1Scale> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/statefulsets/${params.path.name}/scale`;
    return await this.patch<AutoscalingV1Scale>(path, params.query, null, opts);
  }
  async readAppsV1NamespacedStatefulSetStatus(params: ReadAppsV1NamespacedStatefulSetStatusRequest, opts?: APIClientRequestOpts): Promise<AppsV1StatefulSet> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/statefulsets/${params.path.name}/status`;
    return await this.get<AppsV1StatefulSet>(path, null, null, opts);
  }
  async replaceAppsV1NamespacedStatefulSetStatus(params: ReplaceAppsV1NamespacedStatefulSetStatusRequest, opts?: APIClientRequestOpts): Promise<AppsV1StatefulSet> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/statefulsets/${params.path.name}/status`;
    return await this.put<AppsV1StatefulSet>(path, params.query, params.body, opts);
  }
  async patchAppsV1NamespacedStatefulSetStatus(params: PatchAppsV1NamespacedStatefulSetStatusRequest, opts?: APIClientRequestOpts): Promise<AppsV1StatefulSet> {
    const path = `/apis/apps/v1/namespaces/${params.path.namespace}/statefulsets/${params.path.name}/status`;
    return await this.patch<AppsV1StatefulSet>(path, params.query, null, opts);
  }
  async listAppsV1ReplicaSetForAllNamespaces(params: ListAppsV1ReplicaSetForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<AppsV1ReplicaSetList> {
    const path = `/apis/apps/v1/replicasets`;
    return await this.get<AppsV1ReplicaSetList>(path, null, null, opts);
  }
  async listAppsV1StatefulSetForAllNamespaces(params: ListAppsV1StatefulSetForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<AppsV1StatefulSetList> {
    const path = `/apis/apps/v1/statefulsets`;
    return await this.get<AppsV1StatefulSetList>(path, null, null, opts);
  }
  async watchAppsV1ControllerRevisionListForAllNamespaces(params: WatchAppsV1ControllerRevisionListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/apps/v1/watch/controllerrevisions`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchAppsV1DaemonSetListForAllNamespaces(params: WatchAppsV1DaemonSetListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/apps/v1/watch/daemonsets`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchAppsV1DeploymentListForAllNamespaces(params: WatchAppsV1DeploymentListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/apps/v1/watch/deployments`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchAppsV1NamespacedControllerRevisionList(params: WatchAppsV1NamespacedControllerRevisionListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/apps/v1/watch/namespaces/${params.path.namespace}/controllerrevisions`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchAppsV1NamespacedControllerRevision(params: WatchAppsV1NamespacedControllerRevisionRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/apps/v1/watch/namespaces/${params.path.namespace}/controllerrevisions/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchAppsV1NamespacedDaemonSetList(params: WatchAppsV1NamespacedDaemonSetListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/apps/v1/watch/namespaces/${params.path.namespace}/daemonsets`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchAppsV1NamespacedDaemonSet(params: WatchAppsV1NamespacedDaemonSetRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/apps/v1/watch/namespaces/${params.path.namespace}/daemonsets/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchAppsV1NamespacedDeploymentList(params: WatchAppsV1NamespacedDeploymentListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/apps/v1/watch/namespaces/${params.path.namespace}/deployments`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchAppsV1NamespacedDeployment(params: WatchAppsV1NamespacedDeploymentRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/apps/v1/watch/namespaces/${params.path.namespace}/deployments/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchAppsV1NamespacedReplicaSetList(params: WatchAppsV1NamespacedReplicaSetListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/apps/v1/watch/namespaces/${params.path.namespace}/replicasets`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchAppsV1NamespacedReplicaSet(params: WatchAppsV1NamespacedReplicaSetRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/apps/v1/watch/namespaces/${params.path.namespace}/replicasets/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchAppsV1NamespacedStatefulSetList(params: WatchAppsV1NamespacedStatefulSetListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/apps/v1/watch/namespaces/${params.path.namespace}/statefulsets`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchAppsV1NamespacedStatefulSet(params: WatchAppsV1NamespacedStatefulSetRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/apps/v1/watch/namespaces/${params.path.namespace}/statefulsets/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchAppsV1ReplicaSetListForAllNamespaces(params: WatchAppsV1ReplicaSetListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/apps/v1/watch/replicasets`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchAppsV1StatefulSetListForAllNamespaces(params: WatchAppsV1StatefulSetListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/apps/v1/watch/statefulsets`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async getAuthenticationAPIGroup(params: GetAuthenticationAPIGroupRequest, opts?: APIClientRequestOpts): Promise<APIGroup> {
    const path = `/apis/authentication.k8s.io/`;
    return await this.get<APIGroup>(path, null, null, opts);
  }
  async getAuthenticationV1APIResources(params: GetAuthenticationV1APIResourcesRequest, opts?: APIClientRequestOpts): Promise<APIResourceList> {
    const path = `/apis/authentication.k8s.io/v1/`;
    return await this.get<APIResourceList>(path, null, null, opts);
  }
  async createAuthenticationV1SelfSubjectReview(params: CreateAuthenticationV1SelfSubjectReviewRequest, opts?: APIClientRequestOpts): Promise<AuthenticationK8sIoV1SelfSubjectReview> {
    const path = `/apis/authentication.k8s.io/v1/selfsubjectreviews`;
    return await this.post<AuthenticationK8sIoV1SelfSubjectReview>(path, null, params.body, opts);
  }
  async createAuthenticationV1TokenReview(params: CreateAuthenticationV1TokenReviewRequest, opts?: APIClientRequestOpts): Promise<AuthenticationK8sIoV1TokenReview> {
    const path = `/apis/authentication.k8s.io/v1/tokenreviews`;
    return await this.post<AuthenticationK8sIoV1TokenReview>(path, null, params.body, opts);
  }
  async getAuthorizationAPIGroup(params: GetAuthorizationAPIGroupRequest, opts?: APIClientRequestOpts): Promise<APIGroup> {
    const path = `/apis/authorization.k8s.io/`;
    return await this.get<APIGroup>(path, null, null, opts);
  }
  async getAuthorizationV1APIResources(params: GetAuthorizationV1APIResourcesRequest, opts?: APIClientRequestOpts): Promise<APIResourceList> {
    const path = `/apis/authorization.k8s.io/v1/`;
    return await this.get<APIResourceList>(path, null, null, opts);
  }
  async createAuthorizationV1NamespacedLocalSubjectAccessReview(params: CreateAuthorizationV1NamespacedLocalSubjectAccessReviewRequest, opts?: APIClientRequestOpts): Promise<AuthorizationK8sIoV1LocalSubjectAccessReview> {
    const path = `/apis/authorization.k8s.io/v1/namespaces/${params.path.namespace}/localsubjectaccessreviews`;
    return await this.post<AuthorizationK8sIoV1LocalSubjectAccessReview>(path, null, params.body, opts);
  }
  async createAuthorizationV1SelfSubjectAccessReview(params: CreateAuthorizationV1SelfSubjectAccessReviewRequest, opts?: APIClientRequestOpts): Promise<AuthorizationK8sIoV1SelfSubjectAccessReview> {
    const path = `/apis/authorization.k8s.io/v1/selfsubjectaccessreviews`;
    return await this.post<AuthorizationK8sIoV1SelfSubjectAccessReview>(path, null, params.body, opts);
  }
  async createAuthorizationV1SelfSubjectRulesReview(params: CreateAuthorizationV1SelfSubjectRulesReviewRequest, opts?: APIClientRequestOpts): Promise<AuthorizationK8sIoV1SelfSubjectRulesReview> {
    const path = `/apis/authorization.k8s.io/v1/selfsubjectrulesreviews`;
    return await this.post<AuthorizationK8sIoV1SelfSubjectRulesReview>(path, null, params.body, opts);
  }
  async createAuthorizationV1SubjectAccessReview(params: CreateAuthorizationV1SubjectAccessReviewRequest, opts?: APIClientRequestOpts): Promise<AuthorizationK8sIoV1SubjectAccessReview> {
    const path = `/apis/authorization.k8s.io/v1/subjectaccessreviews`;
    return await this.post<AuthorizationK8sIoV1SubjectAccessReview>(path, null, params.body, opts);
  }
  async listAutoscalingInternalKnativeDevV1alpha1MetricForAllNamespaces(params: ListAutoscalingInternalKnativeDevV1alpha1MetricForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<AutoscalingInternalKnativeDevV1alpha1MetricList> {
    const path = `/apis/autoscaling.internal.knative.dev/v1alpha1/metrics`;
    return await this.get<AutoscalingInternalKnativeDevV1alpha1MetricList>(path, null, null, opts);
  }
  async listAutoscalingInternalKnativeDevV1alpha1NamespacedMetric(params: ListAutoscalingInternalKnativeDevV1alpha1NamespacedMetricRequest, opts?: APIClientRequestOpts): Promise<AutoscalingInternalKnativeDevV1alpha1MetricList> {
    const path = `/apis/autoscaling.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/metrics`;
    return await this.get<AutoscalingInternalKnativeDevV1alpha1MetricList>(path, null, null, opts);
  }
  async createAutoscalingInternalKnativeDevV1alpha1NamespacedMetric(params: CreateAutoscalingInternalKnativeDevV1alpha1NamespacedMetricRequest, opts?: APIClientRequestOpts): Promise<AutoscalingInternalKnativeDevV1alpha1Metric> {
    const path = `/apis/autoscaling.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/metrics`;
    return await this.post<AutoscalingInternalKnativeDevV1alpha1Metric>(path, params.query, params.body, opts);
  }
  async deleteAutoscalingInternalKnativeDevV1alpha1CollectionNamespacedMetric(params: DeleteAutoscalingInternalKnativeDevV1alpha1CollectionNamespacedMetricRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/autoscaling.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/metrics`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readAutoscalingInternalKnativeDevV1alpha1NamespacedMetric(params: ReadAutoscalingInternalKnativeDevV1alpha1NamespacedMetricRequest, opts?: APIClientRequestOpts): Promise<AutoscalingInternalKnativeDevV1alpha1Metric> {
    const path = `/apis/autoscaling.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/metrics/${params.path.name}`;
    return await this.get<AutoscalingInternalKnativeDevV1alpha1Metric>(path, null, null, opts);
  }
  async replaceAutoscalingInternalKnativeDevV1alpha1NamespacedMetric(params: ReplaceAutoscalingInternalKnativeDevV1alpha1NamespacedMetricRequest, opts?: APIClientRequestOpts): Promise<AutoscalingInternalKnativeDevV1alpha1Metric> {
    const path = `/apis/autoscaling.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/metrics/${params.path.name}`;
    return await this.put<AutoscalingInternalKnativeDevV1alpha1Metric>(path, params.query, params.body, opts);
  }
  async deleteAutoscalingInternalKnativeDevV1alpha1NamespacedMetric(params: DeleteAutoscalingInternalKnativeDevV1alpha1NamespacedMetricRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/autoscaling.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/metrics/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchAutoscalingInternalKnativeDevV1alpha1NamespacedMetric(params: PatchAutoscalingInternalKnativeDevV1alpha1NamespacedMetricRequest, opts?: APIClientRequestOpts): Promise<AutoscalingInternalKnativeDevV1alpha1Metric> {
    const path = `/apis/autoscaling.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/metrics/${params.path.name}`;
    return await this.patch<AutoscalingInternalKnativeDevV1alpha1Metric>(path, params.query, null, opts);
  }
  async readAutoscalingInternalKnativeDevV1alpha1NamespacedMetricStatus(params: ReadAutoscalingInternalKnativeDevV1alpha1NamespacedMetricStatusRequest, opts?: APIClientRequestOpts): Promise<AutoscalingInternalKnativeDevV1alpha1Metric> {
    const path = `/apis/autoscaling.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/metrics/${params.path.name}/status`;
    return await this.get<AutoscalingInternalKnativeDevV1alpha1Metric>(path, null, null, opts);
  }
  async replaceAutoscalingInternalKnativeDevV1alpha1NamespacedMetricStatus(params: ReplaceAutoscalingInternalKnativeDevV1alpha1NamespacedMetricStatusRequest, opts?: APIClientRequestOpts): Promise<AutoscalingInternalKnativeDevV1alpha1Metric> {
    const path = `/apis/autoscaling.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/metrics/${params.path.name}/status`;
    return await this.put<AutoscalingInternalKnativeDevV1alpha1Metric>(path, params.query, params.body, opts);
  }
  async patchAutoscalingInternalKnativeDevV1alpha1NamespacedMetricStatus(params: PatchAutoscalingInternalKnativeDevV1alpha1NamespacedMetricStatusRequest, opts?: APIClientRequestOpts): Promise<AutoscalingInternalKnativeDevV1alpha1Metric> {
    const path = `/apis/autoscaling.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/metrics/${params.path.name}/status`;
    return await this.patch<AutoscalingInternalKnativeDevV1alpha1Metric>(path, params.query, null, opts);
  }
  async listAutoscalingInternalKnativeDevV1alpha1NamespacedPodAutoscaler(params: ListAutoscalingInternalKnativeDevV1alpha1NamespacedPodAutoscalerRequest, opts?: APIClientRequestOpts): Promise<AutoscalingInternalKnativeDevV1alpha1PodAutoscalerList> {
    const path = `/apis/autoscaling.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/podautoscalers`;
    return await this.get<AutoscalingInternalKnativeDevV1alpha1PodAutoscalerList>(path, null, null, opts);
  }
  async createAutoscalingInternalKnativeDevV1alpha1NamespacedPodAutoscaler(params: CreateAutoscalingInternalKnativeDevV1alpha1NamespacedPodAutoscalerRequest, opts?: APIClientRequestOpts): Promise<AutoscalingInternalKnativeDevV1alpha1PodAutoscaler> {
    const path = `/apis/autoscaling.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/podautoscalers`;
    return await this.post<AutoscalingInternalKnativeDevV1alpha1PodAutoscaler>(path, params.query, params.body, opts);
  }
  async deleteAutoscalingInternalKnativeDevV1alpha1CollectionNamespacedPodAutoscaler(params: DeleteAutoscalingInternalKnativeDevV1alpha1CollectionNamespacedPodAutoscalerRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/autoscaling.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/podautoscalers`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readAutoscalingInternalKnativeDevV1alpha1NamespacedPodAutoscaler(params: ReadAutoscalingInternalKnativeDevV1alpha1NamespacedPodAutoscalerRequest, opts?: APIClientRequestOpts): Promise<AutoscalingInternalKnativeDevV1alpha1PodAutoscaler> {
    const path = `/apis/autoscaling.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/podautoscalers/${params.path.name}`;
    return await this.get<AutoscalingInternalKnativeDevV1alpha1PodAutoscaler>(path, null, null, opts);
  }
  async replaceAutoscalingInternalKnativeDevV1alpha1NamespacedPodAutoscaler(params: ReplaceAutoscalingInternalKnativeDevV1alpha1NamespacedPodAutoscalerRequest, opts?: APIClientRequestOpts): Promise<AutoscalingInternalKnativeDevV1alpha1PodAutoscaler> {
    const path = `/apis/autoscaling.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/podautoscalers/${params.path.name}`;
    return await this.put<AutoscalingInternalKnativeDevV1alpha1PodAutoscaler>(path, params.query, params.body, opts);
  }
  async deleteAutoscalingInternalKnativeDevV1alpha1NamespacedPodAutoscaler(params: DeleteAutoscalingInternalKnativeDevV1alpha1NamespacedPodAutoscalerRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/autoscaling.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/podautoscalers/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchAutoscalingInternalKnativeDevV1alpha1NamespacedPodAutoscaler(params: PatchAutoscalingInternalKnativeDevV1alpha1NamespacedPodAutoscalerRequest, opts?: APIClientRequestOpts): Promise<AutoscalingInternalKnativeDevV1alpha1PodAutoscaler> {
    const path = `/apis/autoscaling.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/podautoscalers/${params.path.name}`;
    return await this.patch<AutoscalingInternalKnativeDevV1alpha1PodAutoscaler>(path, params.query, null, opts);
  }
  async readAutoscalingInternalKnativeDevV1alpha1NamespacedPodAutoscalerStatus(params: ReadAutoscalingInternalKnativeDevV1alpha1NamespacedPodAutoscalerStatusRequest, opts?: APIClientRequestOpts): Promise<AutoscalingInternalKnativeDevV1alpha1PodAutoscaler> {
    const path = `/apis/autoscaling.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/podautoscalers/${params.path.name}/status`;
    return await this.get<AutoscalingInternalKnativeDevV1alpha1PodAutoscaler>(path, null, null, opts);
  }
  async replaceAutoscalingInternalKnativeDevV1alpha1NamespacedPodAutoscalerStatus(params: ReplaceAutoscalingInternalKnativeDevV1alpha1NamespacedPodAutoscalerStatusRequest, opts?: APIClientRequestOpts): Promise<AutoscalingInternalKnativeDevV1alpha1PodAutoscaler> {
    const path = `/apis/autoscaling.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/podautoscalers/${params.path.name}/status`;
    return await this.put<AutoscalingInternalKnativeDevV1alpha1PodAutoscaler>(path, params.query, params.body, opts);
  }
  async patchAutoscalingInternalKnativeDevV1alpha1NamespacedPodAutoscalerStatus(params: PatchAutoscalingInternalKnativeDevV1alpha1NamespacedPodAutoscalerStatusRequest, opts?: APIClientRequestOpts): Promise<AutoscalingInternalKnativeDevV1alpha1PodAutoscaler> {
    const path = `/apis/autoscaling.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/podautoscalers/${params.path.name}/status`;
    return await this.patch<AutoscalingInternalKnativeDevV1alpha1PodAutoscaler>(path, params.query, null, opts);
  }
  async listAutoscalingInternalKnativeDevV1alpha1PodAutoscalerForAllNamespaces(params: ListAutoscalingInternalKnativeDevV1alpha1PodAutoscalerForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<AutoscalingInternalKnativeDevV1alpha1PodAutoscalerList> {
    const path = `/apis/autoscaling.internal.knative.dev/v1alpha1/podautoscalers`;
    return await this.get<AutoscalingInternalKnativeDevV1alpha1PodAutoscalerList>(path, null, null, opts);
  }
  async getAutoscalingAPIGroup(params: GetAutoscalingAPIGroupRequest, opts?: APIClientRequestOpts): Promise<APIGroup> {
    const path = `/apis/autoscaling/`;
    return await this.get<APIGroup>(path, null, null, opts);
  }
  async getAutoscalingV1APIResources(params: GetAutoscalingV1APIResourcesRequest, opts?: APIClientRequestOpts): Promise<APIResourceList> {
    const path = `/apis/autoscaling/v1/`;
    return await this.get<APIResourceList>(path, null, null, opts);
  }
  async listAutoscalingV1HorizontalPodAutoscalerForAllNamespaces(params: ListAutoscalingV1HorizontalPodAutoscalerForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1HorizontalPodAutoscalerList> {
    const path = `/apis/autoscaling/v1/horizontalpodautoscalers`;
    return await this.get<AutoscalingV1HorizontalPodAutoscalerList>(path, null, null, opts);
  }
  async listAutoscalingV1NamespacedHorizontalPodAutoscaler(params: ListAutoscalingV1NamespacedHorizontalPodAutoscalerRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1HorizontalPodAutoscalerList> {
    const path = `/apis/autoscaling/v1/namespaces/${params.path.namespace}/horizontalpodautoscalers`;
    return await this.get<AutoscalingV1HorizontalPodAutoscalerList>(path, null, null, opts);
  }
  async createAutoscalingV1NamespacedHorizontalPodAutoscaler(params: CreateAutoscalingV1NamespacedHorizontalPodAutoscalerRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1HorizontalPodAutoscaler> {
    const path = `/apis/autoscaling/v1/namespaces/${params.path.namespace}/horizontalpodautoscalers`;
    return await this.post<AutoscalingV1HorizontalPodAutoscaler>(path, params.query, params.body, opts);
  }
  async deleteAutoscalingV1CollectionNamespacedHorizontalPodAutoscaler(params: DeleteAutoscalingV1CollectionNamespacedHorizontalPodAutoscalerRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/autoscaling/v1/namespaces/${params.path.namespace}/horizontalpodautoscalers`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readAutoscalingV1NamespacedHorizontalPodAutoscaler(params: ReadAutoscalingV1NamespacedHorizontalPodAutoscalerRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1HorizontalPodAutoscaler> {
    const path = `/apis/autoscaling/v1/namespaces/${params.path.namespace}/horizontalpodautoscalers/${params.path.name}`;
    return await this.get<AutoscalingV1HorizontalPodAutoscaler>(path, null, null, opts);
  }
  async replaceAutoscalingV1NamespacedHorizontalPodAutoscaler(params: ReplaceAutoscalingV1NamespacedHorizontalPodAutoscalerRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1HorizontalPodAutoscaler> {
    const path = `/apis/autoscaling/v1/namespaces/${params.path.namespace}/horizontalpodautoscalers/${params.path.name}`;
    return await this.put<AutoscalingV1HorizontalPodAutoscaler>(path, params.query, params.body, opts);
  }
  async deleteAutoscalingV1NamespacedHorizontalPodAutoscaler(params: DeleteAutoscalingV1NamespacedHorizontalPodAutoscalerRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/autoscaling/v1/namespaces/${params.path.namespace}/horizontalpodautoscalers/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchAutoscalingV1NamespacedHorizontalPodAutoscaler(params: PatchAutoscalingV1NamespacedHorizontalPodAutoscalerRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1HorizontalPodAutoscaler> {
    const path = `/apis/autoscaling/v1/namespaces/${params.path.namespace}/horizontalpodautoscalers/${params.path.name}`;
    return await this.patch<AutoscalingV1HorizontalPodAutoscaler>(path, params.query, null, opts);
  }
  async readAutoscalingV1NamespacedHorizontalPodAutoscalerStatus(params: ReadAutoscalingV1NamespacedHorizontalPodAutoscalerStatusRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1HorizontalPodAutoscaler> {
    const path = `/apis/autoscaling/v1/namespaces/${params.path.namespace}/horizontalpodautoscalers/${params.path.name}/status`;
    return await this.get<AutoscalingV1HorizontalPodAutoscaler>(path, null, null, opts);
  }
  async replaceAutoscalingV1NamespacedHorizontalPodAutoscalerStatus(params: ReplaceAutoscalingV1NamespacedHorizontalPodAutoscalerStatusRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1HorizontalPodAutoscaler> {
    const path = `/apis/autoscaling/v1/namespaces/${params.path.namespace}/horizontalpodautoscalers/${params.path.name}/status`;
    return await this.put<AutoscalingV1HorizontalPodAutoscaler>(path, params.query, params.body, opts);
  }
  async patchAutoscalingV1NamespacedHorizontalPodAutoscalerStatus(params: PatchAutoscalingV1NamespacedHorizontalPodAutoscalerStatusRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1HorizontalPodAutoscaler> {
    const path = `/apis/autoscaling/v1/namespaces/${params.path.namespace}/horizontalpodautoscalers/${params.path.name}/status`;
    return await this.patch<AutoscalingV1HorizontalPodAutoscaler>(path, params.query, null, opts);
  }
  async watchAutoscalingV1HorizontalPodAutoscalerListForAllNamespaces(params: WatchAutoscalingV1HorizontalPodAutoscalerListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/autoscaling/v1/watch/horizontalpodautoscalers`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchAutoscalingV1NamespacedHorizontalPodAutoscalerList(params: WatchAutoscalingV1NamespacedHorizontalPodAutoscalerListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/autoscaling/v1/watch/namespaces/${params.path.namespace}/horizontalpodautoscalers`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchAutoscalingV1NamespacedHorizontalPodAutoscaler(params: WatchAutoscalingV1NamespacedHorizontalPodAutoscalerRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/autoscaling/v1/watch/namespaces/${params.path.namespace}/horizontalpodautoscalers/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async getAutoscalingV2APIResources(params: GetAutoscalingV2APIResourcesRequest, opts?: APIClientRequestOpts): Promise<APIResourceList> {
    const path = `/apis/autoscaling/v2/`;
    return await this.get<APIResourceList>(path, null, null, opts);
  }
  async listAutoscalingV2HorizontalPodAutoscalerForAllNamespaces(params: ListAutoscalingV2HorizontalPodAutoscalerForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV2HorizontalPodAutoscalerList> {
    const path = `/apis/autoscaling/v2/horizontalpodautoscalers`;
    return await this.get<AutoscalingV2HorizontalPodAutoscalerList>(path, null, null, opts);
  }
  async listAutoscalingV2NamespacedHorizontalPodAutoscaler(params: ListAutoscalingV2NamespacedHorizontalPodAutoscalerRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV2HorizontalPodAutoscalerList> {
    const path = `/apis/autoscaling/v2/namespaces/${params.path.namespace}/horizontalpodautoscalers`;
    return await this.get<AutoscalingV2HorizontalPodAutoscalerList>(path, null, null, opts);
  }
  async createAutoscalingV2NamespacedHorizontalPodAutoscaler(params: CreateAutoscalingV2NamespacedHorizontalPodAutoscalerRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV2HorizontalPodAutoscaler> {
    const path = `/apis/autoscaling/v2/namespaces/${params.path.namespace}/horizontalpodautoscalers`;
    return await this.post<AutoscalingV2HorizontalPodAutoscaler>(path, params.query, params.body, opts);
  }
  async deleteAutoscalingV2CollectionNamespacedHorizontalPodAutoscaler(params: DeleteAutoscalingV2CollectionNamespacedHorizontalPodAutoscalerRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/autoscaling/v2/namespaces/${params.path.namespace}/horizontalpodautoscalers`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readAutoscalingV2NamespacedHorizontalPodAutoscaler(params: ReadAutoscalingV2NamespacedHorizontalPodAutoscalerRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV2HorizontalPodAutoscaler> {
    const path = `/apis/autoscaling/v2/namespaces/${params.path.namespace}/horizontalpodautoscalers/${params.path.name}`;
    return await this.get<AutoscalingV2HorizontalPodAutoscaler>(path, null, null, opts);
  }
  async replaceAutoscalingV2NamespacedHorizontalPodAutoscaler(params: ReplaceAutoscalingV2NamespacedHorizontalPodAutoscalerRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV2HorizontalPodAutoscaler> {
    const path = `/apis/autoscaling/v2/namespaces/${params.path.namespace}/horizontalpodautoscalers/${params.path.name}`;
    return await this.put<AutoscalingV2HorizontalPodAutoscaler>(path, params.query, params.body, opts);
  }
  async deleteAutoscalingV2NamespacedHorizontalPodAutoscaler(params: DeleteAutoscalingV2NamespacedHorizontalPodAutoscalerRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/autoscaling/v2/namespaces/${params.path.namespace}/horizontalpodautoscalers/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchAutoscalingV2NamespacedHorizontalPodAutoscaler(params: PatchAutoscalingV2NamespacedHorizontalPodAutoscalerRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV2HorizontalPodAutoscaler> {
    const path = `/apis/autoscaling/v2/namespaces/${params.path.namespace}/horizontalpodautoscalers/${params.path.name}`;
    return await this.patch<AutoscalingV2HorizontalPodAutoscaler>(path, params.query, null, opts);
  }
  async readAutoscalingV2NamespacedHorizontalPodAutoscalerStatus(params: ReadAutoscalingV2NamespacedHorizontalPodAutoscalerStatusRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV2HorizontalPodAutoscaler> {
    const path = `/apis/autoscaling/v2/namespaces/${params.path.namespace}/horizontalpodautoscalers/${params.path.name}/status`;
    return await this.get<AutoscalingV2HorizontalPodAutoscaler>(path, null, null, opts);
  }
  async replaceAutoscalingV2NamespacedHorizontalPodAutoscalerStatus(params: ReplaceAutoscalingV2NamespacedHorizontalPodAutoscalerStatusRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV2HorizontalPodAutoscaler> {
    const path = `/apis/autoscaling/v2/namespaces/${params.path.namespace}/horizontalpodautoscalers/${params.path.name}/status`;
    return await this.put<AutoscalingV2HorizontalPodAutoscaler>(path, params.query, params.body, opts);
  }
  async patchAutoscalingV2NamespacedHorizontalPodAutoscalerStatus(params: PatchAutoscalingV2NamespacedHorizontalPodAutoscalerStatusRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV2HorizontalPodAutoscaler> {
    const path = `/apis/autoscaling/v2/namespaces/${params.path.namespace}/horizontalpodautoscalers/${params.path.name}/status`;
    return await this.patch<AutoscalingV2HorizontalPodAutoscaler>(path, params.query, null, opts);
  }
  async watchAutoscalingV2HorizontalPodAutoscalerListForAllNamespaces(params: WatchAutoscalingV2HorizontalPodAutoscalerListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/autoscaling/v2/watch/horizontalpodautoscalers`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchAutoscalingV2NamespacedHorizontalPodAutoscalerList(params: WatchAutoscalingV2NamespacedHorizontalPodAutoscalerListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/autoscaling/v2/watch/namespaces/${params.path.namespace}/horizontalpodautoscalers`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchAutoscalingV2NamespacedHorizontalPodAutoscaler(params: WatchAutoscalingV2NamespacedHorizontalPodAutoscalerRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/autoscaling/v2/watch/namespaces/${params.path.namespace}/horizontalpodautoscalers/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async getBatchAPIGroup(params: GetBatchAPIGroupRequest, opts?: APIClientRequestOpts): Promise<APIGroup> {
    const path = `/apis/batch/`;
    return await this.get<APIGroup>(path, null, null, opts);
  }
  async getBatchV1APIResources(params: GetBatchV1APIResourcesRequest, opts?: APIClientRequestOpts): Promise<APIResourceList> {
    const path = `/apis/batch/v1/`;
    return await this.get<APIResourceList>(path, null, null, opts);
  }
  async listBatchV1CronJobForAllNamespaces(params: ListBatchV1CronJobForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<BatchV1CronJobList> {
    const path = `/apis/batch/v1/cronjobs`;
    return await this.get<BatchV1CronJobList>(path, null, null, opts);
  }
  async listBatchV1JobForAllNamespaces(params: ListBatchV1JobForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<BatchV1JobList> {
    const path = `/apis/batch/v1/jobs`;
    return await this.get<BatchV1JobList>(path, null, null, opts);
  }
  async listBatchV1NamespacedCronJob(params: ListBatchV1NamespacedCronJobRequest, opts?: APIClientRequestOpts): Promise<BatchV1CronJobList> {
    const path = `/apis/batch/v1/namespaces/${params.path.namespace}/cronjobs`;
    return await this.get<BatchV1CronJobList>(path, null, null, opts);
  }
  async createBatchV1NamespacedCronJob(params: CreateBatchV1NamespacedCronJobRequest, opts?: APIClientRequestOpts): Promise<BatchV1CronJob> {
    const path = `/apis/batch/v1/namespaces/${params.path.namespace}/cronjobs`;
    return await this.post<BatchV1CronJob>(path, params.query, params.body, opts);
  }
  async deleteBatchV1CollectionNamespacedCronJob(params: DeleteBatchV1CollectionNamespacedCronJobRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/batch/v1/namespaces/${params.path.namespace}/cronjobs`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readBatchV1NamespacedCronJob(params: ReadBatchV1NamespacedCronJobRequest, opts?: APIClientRequestOpts): Promise<BatchV1CronJob> {
    const path = `/apis/batch/v1/namespaces/${params.path.namespace}/cronjobs/${params.path.name}`;
    return await this.get<BatchV1CronJob>(path, null, null, opts);
  }
  async replaceBatchV1NamespacedCronJob(params: ReplaceBatchV1NamespacedCronJobRequest, opts?: APIClientRequestOpts): Promise<BatchV1CronJob> {
    const path = `/apis/batch/v1/namespaces/${params.path.namespace}/cronjobs/${params.path.name}`;
    return await this.put<BatchV1CronJob>(path, params.query, params.body, opts);
  }
  async deleteBatchV1NamespacedCronJob(params: DeleteBatchV1NamespacedCronJobRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/batch/v1/namespaces/${params.path.namespace}/cronjobs/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchBatchV1NamespacedCronJob(params: PatchBatchV1NamespacedCronJobRequest, opts?: APIClientRequestOpts): Promise<BatchV1CronJob> {
    const path = `/apis/batch/v1/namespaces/${params.path.namespace}/cronjobs/${params.path.name}`;
    return await this.patch<BatchV1CronJob>(path, params.query, null, opts);
  }
  async readBatchV1NamespacedCronJobStatus(params: ReadBatchV1NamespacedCronJobStatusRequest, opts?: APIClientRequestOpts): Promise<BatchV1CronJob> {
    const path = `/apis/batch/v1/namespaces/${params.path.namespace}/cronjobs/${params.path.name}/status`;
    return await this.get<BatchV1CronJob>(path, null, null, opts);
  }
  async replaceBatchV1NamespacedCronJobStatus(params: ReplaceBatchV1NamespacedCronJobStatusRequest, opts?: APIClientRequestOpts): Promise<BatchV1CronJob> {
    const path = `/apis/batch/v1/namespaces/${params.path.namespace}/cronjobs/${params.path.name}/status`;
    return await this.put<BatchV1CronJob>(path, params.query, params.body, opts);
  }
  async patchBatchV1NamespacedCronJobStatus(params: PatchBatchV1NamespacedCronJobStatusRequest, opts?: APIClientRequestOpts): Promise<BatchV1CronJob> {
    const path = `/apis/batch/v1/namespaces/${params.path.namespace}/cronjobs/${params.path.name}/status`;
    return await this.patch<BatchV1CronJob>(path, params.query, null, opts);
  }
  async listBatchV1NamespacedJob(params: ListBatchV1NamespacedJobRequest, opts?: APIClientRequestOpts): Promise<BatchV1JobList> {
    const path = `/apis/batch/v1/namespaces/${params.path.namespace}/jobs`;
    return await this.get<BatchV1JobList>(path, null, null, opts);
  }
  async createBatchV1NamespacedJob(params: CreateBatchV1NamespacedJobRequest, opts?: APIClientRequestOpts): Promise<BatchV1Job> {
    const path = `/apis/batch/v1/namespaces/${params.path.namespace}/jobs`;
    return await this.post<BatchV1Job>(path, params.query, params.body, opts);
  }
  async deleteBatchV1CollectionNamespacedJob(params: DeleteBatchV1CollectionNamespacedJobRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/batch/v1/namespaces/${params.path.namespace}/jobs`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readBatchV1NamespacedJob(params: ReadBatchV1NamespacedJobRequest, opts?: APIClientRequestOpts): Promise<BatchV1Job> {
    const path = `/apis/batch/v1/namespaces/${params.path.namespace}/jobs/${params.path.name}`;
    return await this.get<BatchV1Job>(path, null, null, opts);
  }
  async replaceBatchV1NamespacedJob(params: ReplaceBatchV1NamespacedJobRequest, opts?: APIClientRequestOpts): Promise<BatchV1Job> {
    const path = `/apis/batch/v1/namespaces/${params.path.namespace}/jobs/${params.path.name}`;
    return await this.put<BatchV1Job>(path, params.query, params.body, opts);
  }
  async deleteBatchV1NamespacedJob(params: DeleteBatchV1NamespacedJobRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/batch/v1/namespaces/${params.path.namespace}/jobs/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchBatchV1NamespacedJob(params: PatchBatchV1NamespacedJobRequest, opts?: APIClientRequestOpts): Promise<BatchV1Job> {
    const path = `/apis/batch/v1/namespaces/${params.path.namespace}/jobs/${params.path.name}`;
    return await this.patch<BatchV1Job>(path, params.query, null, opts);
  }
  async readBatchV1NamespacedJobStatus(params: ReadBatchV1NamespacedJobStatusRequest, opts?: APIClientRequestOpts): Promise<BatchV1Job> {
    const path = `/apis/batch/v1/namespaces/${params.path.namespace}/jobs/${params.path.name}/status`;
    return await this.get<BatchV1Job>(path, null, null, opts);
  }
  async replaceBatchV1NamespacedJobStatus(params: ReplaceBatchV1NamespacedJobStatusRequest, opts?: APIClientRequestOpts): Promise<BatchV1Job> {
    const path = `/apis/batch/v1/namespaces/${params.path.namespace}/jobs/${params.path.name}/status`;
    return await this.put<BatchV1Job>(path, params.query, params.body, opts);
  }
  async patchBatchV1NamespacedJobStatus(params: PatchBatchV1NamespacedJobStatusRequest, opts?: APIClientRequestOpts): Promise<BatchV1Job> {
    const path = `/apis/batch/v1/namespaces/${params.path.namespace}/jobs/${params.path.name}/status`;
    return await this.patch<BatchV1Job>(path, params.query, null, opts);
  }
  async watchBatchV1CronJobListForAllNamespaces(params: WatchBatchV1CronJobListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/batch/v1/watch/cronjobs`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchBatchV1JobListForAllNamespaces(params: WatchBatchV1JobListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/batch/v1/watch/jobs`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchBatchV1NamespacedCronJobList(params: WatchBatchV1NamespacedCronJobListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/batch/v1/watch/namespaces/${params.path.namespace}/cronjobs`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchBatchV1NamespacedCronJob(params: WatchBatchV1NamespacedCronJobRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/batch/v1/watch/namespaces/${params.path.namespace}/cronjobs/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchBatchV1NamespacedJobList(params: WatchBatchV1NamespacedJobListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/batch/v1/watch/namespaces/${params.path.namespace}/jobs`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchBatchV1NamespacedJob(params: WatchBatchV1NamespacedJobRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/batch/v1/watch/namespaces/${params.path.namespace}/jobs/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async listCachingInternalKnativeDevV1alpha1ImageForAllNamespaces(params: ListCachingInternalKnativeDevV1alpha1ImageForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<CachingInternalKnativeDevV1alpha1ImageList> {
    const path = `/apis/caching.internal.knative.dev/v1alpha1/images`;
    return await this.get<CachingInternalKnativeDevV1alpha1ImageList>(path, null, null, opts);
  }
  async listCachingInternalKnativeDevV1alpha1NamespacedImage(params: ListCachingInternalKnativeDevV1alpha1NamespacedImageRequest, opts?: APIClientRequestOpts): Promise<CachingInternalKnativeDevV1alpha1ImageList> {
    const path = `/apis/caching.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/images`;
    return await this.get<CachingInternalKnativeDevV1alpha1ImageList>(path, null, null, opts);
  }
  async createCachingInternalKnativeDevV1alpha1NamespacedImage(params: CreateCachingInternalKnativeDevV1alpha1NamespacedImageRequest, opts?: APIClientRequestOpts): Promise<CachingInternalKnativeDevV1alpha1Image> {
    const path = `/apis/caching.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/images`;
    return await this.post<CachingInternalKnativeDevV1alpha1Image>(path, params.query, params.body, opts);
  }
  async deleteCachingInternalKnativeDevV1alpha1CollectionNamespacedImage(params: DeleteCachingInternalKnativeDevV1alpha1CollectionNamespacedImageRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/caching.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/images`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readCachingInternalKnativeDevV1alpha1NamespacedImage(params: ReadCachingInternalKnativeDevV1alpha1NamespacedImageRequest, opts?: APIClientRequestOpts): Promise<CachingInternalKnativeDevV1alpha1Image> {
    const path = `/apis/caching.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/images/${params.path.name}`;
    return await this.get<CachingInternalKnativeDevV1alpha1Image>(path, null, null, opts);
  }
  async replaceCachingInternalKnativeDevV1alpha1NamespacedImage(params: ReplaceCachingInternalKnativeDevV1alpha1NamespacedImageRequest, opts?: APIClientRequestOpts): Promise<CachingInternalKnativeDevV1alpha1Image> {
    const path = `/apis/caching.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/images/${params.path.name}`;
    return await this.put<CachingInternalKnativeDevV1alpha1Image>(path, params.query, params.body, opts);
  }
  async deleteCachingInternalKnativeDevV1alpha1NamespacedImage(params: DeleteCachingInternalKnativeDevV1alpha1NamespacedImageRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/caching.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/images/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchCachingInternalKnativeDevV1alpha1NamespacedImage(params: PatchCachingInternalKnativeDevV1alpha1NamespacedImageRequest, opts?: APIClientRequestOpts): Promise<CachingInternalKnativeDevV1alpha1Image> {
    const path = `/apis/caching.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/images/${params.path.name}`;
    return await this.patch<CachingInternalKnativeDevV1alpha1Image>(path, params.query, null, opts);
  }
  async readCachingInternalKnativeDevV1alpha1NamespacedImageStatus(params: ReadCachingInternalKnativeDevV1alpha1NamespacedImageStatusRequest, opts?: APIClientRequestOpts): Promise<CachingInternalKnativeDevV1alpha1Image> {
    const path = `/apis/caching.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/images/${params.path.name}/status`;
    return await this.get<CachingInternalKnativeDevV1alpha1Image>(path, null, null, opts);
  }
  async replaceCachingInternalKnativeDevV1alpha1NamespacedImageStatus(params: ReplaceCachingInternalKnativeDevV1alpha1NamespacedImageStatusRequest, opts?: APIClientRequestOpts): Promise<CachingInternalKnativeDevV1alpha1Image> {
    const path = `/apis/caching.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/images/${params.path.name}/status`;
    return await this.put<CachingInternalKnativeDevV1alpha1Image>(path, params.query, params.body, opts);
  }
  async patchCachingInternalKnativeDevV1alpha1NamespacedImageStatus(params: PatchCachingInternalKnativeDevV1alpha1NamespacedImageStatusRequest, opts?: APIClientRequestOpts): Promise<CachingInternalKnativeDevV1alpha1Image> {
    const path = `/apis/caching.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/images/${params.path.name}/status`;
    return await this.patch<CachingInternalKnativeDevV1alpha1Image>(path, params.query, null, opts);
  }
  async listCertManagerIoV1CertificateRequestForAllNamespaces(params: ListCertManagerIoV1CertificateRequestForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1CertificateRequestList> {
    const path = `/apis/cert-manager.io/v1/certificaterequests`;
    return await this.get<CertManagerIoV1CertificateRequestList>(path, null, null, opts);
  }
  async listCertManagerIoV1CertificateForAllNamespaces(params: ListCertManagerIoV1CertificateForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1CertificateList> {
    const path = `/apis/cert-manager.io/v1/certificates`;
    return await this.get<CertManagerIoV1CertificateList>(path, null, null, opts);
  }
  async listCertManagerIoV1ClusterIssuer(params: ListCertManagerIoV1ClusterIssuerRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1ClusterIssuerList> {
    const path = `/apis/cert-manager.io/v1/clusterissuers`;
    return await this.get<CertManagerIoV1ClusterIssuerList>(path, null, null, opts);
  }
  async createCertManagerIoV1ClusterIssuer(params: CreateCertManagerIoV1ClusterIssuerRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1ClusterIssuer> {
    const path = `/apis/cert-manager.io/v1/clusterissuers`;
    return await this.post<CertManagerIoV1ClusterIssuer>(path, params.query, params.body, opts);
  }
  async deleteCertManagerIoV1CollectionClusterIssuer(params: DeleteCertManagerIoV1CollectionClusterIssuerRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/cert-manager.io/v1/clusterissuers`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readCertManagerIoV1ClusterIssuer(params: ReadCertManagerIoV1ClusterIssuerRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1ClusterIssuer> {
    const path = `/apis/cert-manager.io/v1/clusterissuers/${params.path.name}`;
    return await this.get<CertManagerIoV1ClusterIssuer>(path, null, null, opts);
  }
  async replaceCertManagerIoV1ClusterIssuer(params: ReplaceCertManagerIoV1ClusterIssuerRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1ClusterIssuer> {
    const path = `/apis/cert-manager.io/v1/clusterissuers/${params.path.name}`;
    return await this.put<CertManagerIoV1ClusterIssuer>(path, params.query, params.body, opts);
  }
  async deleteCertManagerIoV1ClusterIssuer(params: DeleteCertManagerIoV1ClusterIssuerRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/cert-manager.io/v1/clusterissuers/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchCertManagerIoV1ClusterIssuer(params: PatchCertManagerIoV1ClusterIssuerRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1ClusterIssuer> {
    const path = `/apis/cert-manager.io/v1/clusterissuers/${params.path.name}`;
    return await this.patch<CertManagerIoV1ClusterIssuer>(path, params.query, null, opts);
  }
  async readCertManagerIoV1ClusterIssuerStatus(params: ReadCertManagerIoV1ClusterIssuerStatusRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1ClusterIssuer> {
    const path = `/apis/cert-manager.io/v1/clusterissuers/${params.path.name}/status`;
    return await this.get<CertManagerIoV1ClusterIssuer>(path, null, null, opts);
  }
  async replaceCertManagerIoV1ClusterIssuerStatus(params: ReplaceCertManagerIoV1ClusterIssuerStatusRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1ClusterIssuer> {
    const path = `/apis/cert-manager.io/v1/clusterissuers/${params.path.name}/status`;
    return await this.put<CertManagerIoV1ClusterIssuer>(path, params.query, params.body, opts);
  }
  async patchCertManagerIoV1ClusterIssuerStatus(params: PatchCertManagerIoV1ClusterIssuerStatusRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1ClusterIssuer> {
    const path = `/apis/cert-manager.io/v1/clusterissuers/${params.path.name}/status`;
    return await this.patch<CertManagerIoV1ClusterIssuer>(path, params.query, null, opts);
  }
  async listCertManagerIoV1IssuerForAllNamespaces(params: ListCertManagerIoV1IssuerForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1IssuerList> {
    const path = `/apis/cert-manager.io/v1/issuers`;
    return await this.get<CertManagerIoV1IssuerList>(path, null, null, opts);
  }
  async listCertManagerIoV1NamespacedCertificateRequest(params: ListCertManagerIoV1NamespacedCertificateRequestRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1CertificateRequestList> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/certificaterequests`;
    return await this.get<CertManagerIoV1CertificateRequestList>(path, null, null, opts);
  }
  async createCertManagerIoV1NamespacedCertificateRequest(params: CreateCertManagerIoV1NamespacedCertificateRequestRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1CertificateRequest> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/certificaterequests`;
    return await this.post<CertManagerIoV1CertificateRequest>(path, params.query, params.body, opts);
  }
  async deleteCertManagerIoV1CollectionNamespacedCertificateRequest(params: DeleteCertManagerIoV1CollectionNamespacedCertificateRequestRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/certificaterequests`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readCertManagerIoV1NamespacedCertificateRequest(params: ReadCertManagerIoV1NamespacedCertificateRequestRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1CertificateRequest> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/certificaterequests/${params.path.name}`;
    return await this.get<CertManagerIoV1CertificateRequest>(path, null, null, opts);
  }
  async replaceCertManagerIoV1NamespacedCertificateRequest(params: ReplaceCertManagerIoV1NamespacedCertificateRequestRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1CertificateRequest> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/certificaterequests/${params.path.name}`;
    return await this.put<CertManagerIoV1CertificateRequest>(path, params.query, params.body, opts);
  }
  async deleteCertManagerIoV1NamespacedCertificateRequest(params: DeleteCertManagerIoV1NamespacedCertificateRequestRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/certificaterequests/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchCertManagerIoV1NamespacedCertificateRequest(params: PatchCertManagerIoV1NamespacedCertificateRequestRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1CertificateRequest> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/certificaterequests/${params.path.name}`;
    return await this.patch<CertManagerIoV1CertificateRequest>(path, params.query, null, opts);
  }
  async readCertManagerIoV1NamespacedCertificateRequestStatus(params: ReadCertManagerIoV1NamespacedCertificateRequestStatusRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1CertificateRequest> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/certificaterequests/${params.path.name}/status`;
    return await this.get<CertManagerIoV1CertificateRequest>(path, null, null, opts);
  }
  async replaceCertManagerIoV1NamespacedCertificateRequestStatus(params: ReplaceCertManagerIoV1NamespacedCertificateRequestStatusRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1CertificateRequest> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/certificaterequests/${params.path.name}/status`;
    return await this.put<CertManagerIoV1CertificateRequest>(path, params.query, params.body, opts);
  }
  async patchCertManagerIoV1NamespacedCertificateRequestStatus(params: PatchCertManagerIoV1NamespacedCertificateRequestStatusRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1CertificateRequest> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/certificaterequests/${params.path.name}/status`;
    return await this.patch<CertManagerIoV1CertificateRequest>(path, params.query, null, opts);
  }
  async listCertManagerIoV1NamespacedCertificate(params: ListCertManagerIoV1NamespacedCertificateRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1CertificateList> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/certificates`;
    return await this.get<CertManagerIoV1CertificateList>(path, null, null, opts);
  }
  async createCertManagerIoV1NamespacedCertificate(params: CreateCertManagerIoV1NamespacedCertificateRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1Certificate> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/certificates`;
    return await this.post<CertManagerIoV1Certificate>(path, params.query, params.body, opts);
  }
  async deleteCertManagerIoV1CollectionNamespacedCertificate(params: DeleteCertManagerIoV1CollectionNamespacedCertificateRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/certificates`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readCertManagerIoV1NamespacedCertificate(params: ReadCertManagerIoV1NamespacedCertificateRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1Certificate> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/certificates/${params.path.name}`;
    return await this.get<CertManagerIoV1Certificate>(path, null, null, opts);
  }
  async replaceCertManagerIoV1NamespacedCertificate(params: ReplaceCertManagerIoV1NamespacedCertificateRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1Certificate> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/certificates/${params.path.name}`;
    return await this.put<CertManagerIoV1Certificate>(path, params.query, params.body, opts);
  }
  async deleteCertManagerIoV1NamespacedCertificate(params: DeleteCertManagerIoV1NamespacedCertificateRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/certificates/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchCertManagerIoV1NamespacedCertificate(params: PatchCertManagerIoV1NamespacedCertificateRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1Certificate> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/certificates/${params.path.name}`;
    return await this.patch<CertManagerIoV1Certificate>(path, params.query, null, opts);
  }
  async readCertManagerIoV1NamespacedCertificateStatus(params: ReadCertManagerIoV1NamespacedCertificateStatusRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1Certificate> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/certificates/${params.path.name}/status`;
    return await this.get<CertManagerIoV1Certificate>(path, null, null, opts);
  }
  async replaceCertManagerIoV1NamespacedCertificateStatus(params: ReplaceCertManagerIoV1NamespacedCertificateStatusRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1Certificate> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/certificates/${params.path.name}/status`;
    return await this.put<CertManagerIoV1Certificate>(path, params.query, params.body, opts);
  }
  async patchCertManagerIoV1NamespacedCertificateStatus(params: PatchCertManagerIoV1NamespacedCertificateStatusRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1Certificate> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/certificates/${params.path.name}/status`;
    return await this.patch<CertManagerIoV1Certificate>(path, params.query, null, opts);
  }
  async listCertManagerIoV1NamespacedIssuer(params: ListCertManagerIoV1NamespacedIssuerRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1IssuerList> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/issuers`;
    return await this.get<CertManagerIoV1IssuerList>(path, null, null, opts);
  }
  async createCertManagerIoV1NamespacedIssuer(params: CreateCertManagerIoV1NamespacedIssuerRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1Issuer> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/issuers`;
    return await this.post<CertManagerIoV1Issuer>(path, params.query, params.body, opts);
  }
  async deleteCertManagerIoV1CollectionNamespacedIssuer(params: DeleteCertManagerIoV1CollectionNamespacedIssuerRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/issuers`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readCertManagerIoV1NamespacedIssuer(params: ReadCertManagerIoV1NamespacedIssuerRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1Issuer> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/issuers/${params.path.name}`;
    return await this.get<CertManagerIoV1Issuer>(path, null, null, opts);
  }
  async replaceCertManagerIoV1NamespacedIssuer(params: ReplaceCertManagerIoV1NamespacedIssuerRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1Issuer> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/issuers/${params.path.name}`;
    return await this.put<CertManagerIoV1Issuer>(path, params.query, params.body, opts);
  }
  async deleteCertManagerIoV1NamespacedIssuer(params: DeleteCertManagerIoV1NamespacedIssuerRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/issuers/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchCertManagerIoV1NamespacedIssuer(params: PatchCertManagerIoV1NamespacedIssuerRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1Issuer> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/issuers/${params.path.name}`;
    return await this.patch<CertManagerIoV1Issuer>(path, params.query, null, opts);
  }
  async readCertManagerIoV1NamespacedIssuerStatus(params: ReadCertManagerIoV1NamespacedIssuerStatusRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1Issuer> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/issuers/${params.path.name}/status`;
    return await this.get<CertManagerIoV1Issuer>(path, null, null, opts);
  }
  async replaceCertManagerIoV1NamespacedIssuerStatus(params: ReplaceCertManagerIoV1NamespacedIssuerStatusRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1Issuer> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/issuers/${params.path.name}/status`;
    return await this.put<CertManagerIoV1Issuer>(path, params.query, params.body, opts);
  }
  async patchCertManagerIoV1NamespacedIssuerStatus(params: PatchCertManagerIoV1NamespacedIssuerStatusRequest, opts?: APIClientRequestOpts): Promise<CertManagerIoV1Issuer> {
    const path = `/apis/cert-manager.io/v1/namespaces/${params.path.namespace}/issuers/${params.path.name}/status`;
    return await this.patch<CertManagerIoV1Issuer>(path, params.query, null, opts);
  }
  async getCertificatesAPIGroup(params: GetCertificatesAPIGroupRequest, opts?: APIClientRequestOpts): Promise<APIGroup> {
    const path = `/apis/certificates.k8s.io/`;
    return await this.get<APIGroup>(path, null, null, opts);
  }
  async getCertificatesV1APIResources(params: GetCertificatesV1APIResourcesRequest, opts?: APIClientRequestOpts): Promise<APIResourceList> {
    const path = `/apis/certificates.k8s.io/v1/`;
    return await this.get<APIResourceList>(path, null, null, opts);
  }
  async listCertificatesV1CertificateSigningRequest(params: ListCertificatesV1CertificateSigningRequestRequest, opts?: APIClientRequestOpts): Promise<CertificatesK8sIoV1CertificateSigningRequestList> {
    const path = `/apis/certificates.k8s.io/v1/certificatesigningrequests`;
    return await this.get<CertificatesK8sIoV1CertificateSigningRequestList>(path, null, null, opts);
  }
  async createCertificatesV1CertificateSigningRequest(params: CreateCertificatesV1CertificateSigningRequestRequest, opts?: APIClientRequestOpts): Promise<CertificatesK8sIoV1CertificateSigningRequest> {
    const path = `/apis/certificates.k8s.io/v1/certificatesigningrequests`;
    return await this.post<CertificatesK8sIoV1CertificateSigningRequest>(path, params.query, params.body, opts);
  }
  async deleteCertificatesV1CollectionCertificateSigningRequest(params: DeleteCertificatesV1CollectionCertificateSigningRequestRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/certificates.k8s.io/v1/certificatesigningrequests`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readCertificatesV1CertificateSigningRequest(params: ReadCertificatesV1CertificateSigningRequestRequest, opts?: APIClientRequestOpts): Promise<CertificatesK8sIoV1CertificateSigningRequest> {
    const path = `/apis/certificates.k8s.io/v1/certificatesigningrequests/${params.path.name}`;
    return await this.get<CertificatesK8sIoV1CertificateSigningRequest>(path, null, null, opts);
  }
  async replaceCertificatesV1CertificateSigningRequest(params: ReplaceCertificatesV1CertificateSigningRequestRequest, opts?: APIClientRequestOpts): Promise<CertificatesK8sIoV1CertificateSigningRequest> {
    const path = `/apis/certificates.k8s.io/v1/certificatesigningrequests/${params.path.name}`;
    return await this.put<CertificatesK8sIoV1CertificateSigningRequest>(path, params.query, params.body, opts);
  }
  async deleteCertificatesV1CertificateSigningRequest(params: DeleteCertificatesV1CertificateSigningRequestRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/certificates.k8s.io/v1/certificatesigningrequests/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchCertificatesV1CertificateSigningRequest(params: PatchCertificatesV1CertificateSigningRequestRequest, opts?: APIClientRequestOpts): Promise<CertificatesK8sIoV1CertificateSigningRequest> {
    const path = `/apis/certificates.k8s.io/v1/certificatesigningrequests/${params.path.name}`;
    return await this.patch<CertificatesK8sIoV1CertificateSigningRequest>(path, params.query, null, opts);
  }
  async readCertificatesV1CertificateSigningRequestApproval(params: ReadCertificatesV1CertificateSigningRequestApprovalRequest, opts?: APIClientRequestOpts): Promise<CertificatesK8sIoV1CertificateSigningRequest> {
    const path = `/apis/certificates.k8s.io/v1/certificatesigningrequests/${params.path.name}/approval`;
    return await this.get<CertificatesK8sIoV1CertificateSigningRequest>(path, null, null, opts);
  }
  async replaceCertificatesV1CertificateSigningRequestApproval(params: ReplaceCertificatesV1CertificateSigningRequestApprovalRequest, opts?: APIClientRequestOpts): Promise<CertificatesK8sIoV1CertificateSigningRequest> {
    const path = `/apis/certificates.k8s.io/v1/certificatesigningrequests/${params.path.name}/approval`;
    return await this.put<CertificatesK8sIoV1CertificateSigningRequest>(path, params.query, params.body, opts);
  }
  async patchCertificatesV1CertificateSigningRequestApproval(params: PatchCertificatesV1CertificateSigningRequestApprovalRequest, opts?: APIClientRequestOpts): Promise<CertificatesK8sIoV1CertificateSigningRequest> {
    const path = `/apis/certificates.k8s.io/v1/certificatesigningrequests/${params.path.name}/approval`;
    return await this.patch<CertificatesK8sIoV1CertificateSigningRequest>(path, params.query, null, opts);
  }
  async readCertificatesV1CertificateSigningRequestStatus(params: ReadCertificatesV1CertificateSigningRequestStatusRequest, opts?: APIClientRequestOpts): Promise<CertificatesK8sIoV1CertificateSigningRequest> {
    const path = `/apis/certificates.k8s.io/v1/certificatesigningrequests/${params.path.name}/status`;
    return await this.get<CertificatesK8sIoV1CertificateSigningRequest>(path, null, null, opts);
  }
  async replaceCertificatesV1CertificateSigningRequestStatus(params: ReplaceCertificatesV1CertificateSigningRequestStatusRequest, opts?: APIClientRequestOpts): Promise<CertificatesK8sIoV1CertificateSigningRequest> {
    const path = `/apis/certificates.k8s.io/v1/certificatesigningrequests/${params.path.name}/status`;
    return await this.put<CertificatesK8sIoV1CertificateSigningRequest>(path, params.query, params.body, opts);
  }
  async patchCertificatesV1CertificateSigningRequestStatus(params: PatchCertificatesV1CertificateSigningRequestStatusRequest, opts?: APIClientRequestOpts): Promise<CertificatesK8sIoV1CertificateSigningRequest> {
    const path = `/apis/certificates.k8s.io/v1/certificatesigningrequests/${params.path.name}/status`;
    return await this.patch<CertificatesK8sIoV1CertificateSigningRequest>(path, params.query, null, opts);
  }
  async watchCertificatesV1CertificateSigningRequestList(params: WatchCertificatesV1CertificateSigningRequestListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/certificates.k8s.io/v1/watch/certificatesigningrequests`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCertificatesV1CertificateSigningRequest(params: WatchCertificatesV1CertificateSigningRequestRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/certificates.k8s.io/v1/watch/certificatesigningrequests/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async getCoordinationAPIGroup(params: GetCoordinationAPIGroupRequest, opts?: APIClientRequestOpts): Promise<APIGroup> {
    const path = `/apis/coordination.k8s.io/`;
    return await this.get<APIGroup>(path, null, null, opts);
  }
  async getCoordinationV1APIResources(params: GetCoordinationV1APIResourcesRequest, opts?: APIClientRequestOpts): Promise<APIResourceList> {
    const path = `/apis/coordination.k8s.io/v1/`;
    return await this.get<APIResourceList>(path, null, null, opts);
  }
  async listCoordinationV1LeaseForAllNamespaces(params: ListCoordinationV1LeaseForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<CoordinationK8sIoV1LeaseList> {
    const path = `/apis/coordination.k8s.io/v1/leases`;
    return await this.get<CoordinationK8sIoV1LeaseList>(path, null, null, opts);
  }
  async listCoordinationV1NamespacedLease(params: ListCoordinationV1NamespacedLeaseRequest, opts?: APIClientRequestOpts): Promise<CoordinationK8sIoV1LeaseList> {
    const path = `/apis/coordination.k8s.io/v1/namespaces/${params.path.namespace}/leases`;
    return await this.get<CoordinationK8sIoV1LeaseList>(path, null, null, opts);
  }
  async createCoordinationV1NamespacedLease(params: CreateCoordinationV1NamespacedLeaseRequest, opts?: APIClientRequestOpts): Promise<CoordinationK8sIoV1Lease> {
    const path = `/apis/coordination.k8s.io/v1/namespaces/${params.path.namespace}/leases`;
    return await this.post<CoordinationK8sIoV1Lease>(path, params.query, params.body, opts);
  }
  async deleteCoordinationV1CollectionNamespacedLease(params: DeleteCoordinationV1CollectionNamespacedLeaseRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/coordination.k8s.io/v1/namespaces/${params.path.namespace}/leases`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readCoordinationV1NamespacedLease(params: ReadCoordinationV1NamespacedLeaseRequest, opts?: APIClientRequestOpts): Promise<CoordinationK8sIoV1Lease> {
    const path = `/apis/coordination.k8s.io/v1/namespaces/${params.path.namespace}/leases/${params.path.name}`;
    return await this.get<CoordinationK8sIoV1Lease>(path, null, null, opts);
  }
  async replaceCoordinationV1NamespacedLease(params: ReplaceCoordinationV1NamespacedLeaseRequest, opts?: APIClientRequestOpts): Promise<CoordinationK8sIoV1Lease> {
    const path = `/apis/coordination.k8s.io/v1/namespaces/${params.path.namespace}/leases/${params.path.name}`;
    return await this.put<CoordinationK8sIoV1Lease>(path, params.query, params.body, opts);
  }
  async deleteCoordinationV1NamespacedLease(params: DeleteCoordinationV1NamespacedLeaseRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/coordination.k8s.io/v1/namespaces/${params.path.namespace}/leases/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchCoordinationV1NamespacedLease(params: PatchCoordinationV1NamespacedLeaseRequest, opts?: APIClientRequestOpts): Promise<CoordinationK8sIoV1Lease> {
    const path = `/apis/coordination.k8s.io/v1/namespaces/${params.path.namespace}/leases/${params.path.name}`;
    return await this.patch<CoordinationK8sIoV1Lease>(path, params.query, null, opts);
  }
  async watchCoordinationV1LeaseListForAllNamespaces(params: WatchCoordinationV1LeaseListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/coordination.k8s.io/v1/watch/leases`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoordinationV1NamespacedLeaseList(params: WatchCoordinationV1NamespacedLeaseListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/coordination.k8s.io/v1/watch/namespaces/${params.path.namespace}/leases`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchCoordinationV1NamespacedLease(params: WatchCoordinationV1NamespacedLeaseRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/coordination.k8s.io/v1/watch/namespaces/${params.path.namespace}/leases/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async getDiscoveryAPIGroup(params: GetDiscoveryAPIGroupRequest, opts?: APIClientRequestOpts): Promise<APIGroup> {
    const path = `/apis/discovery.k8s.io/`;
    return await this.get<APIGroup>(path, null, null, opts);
  }
  async getDiscoveryV1APIResources(params: GetDiscoveryV1APIResourcesRequest, opts?: APIClientRequestOpts): Promise<APIResourceList> {
    const path = `/apis/discovery.k8s.io/v1/`;
    return await this.get<APIResourceList>(path, null, null, opts);
  }
  async listDiscoveryV1EndpointSliceForAllNamespaces(params: ListDiscoveryV1EndpointSliceForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<DiscoveryK8sIoV1EndpointSliceList> {
    const path = `/apis/discovery.k8s.io/v1/endpointslices`;
    return await this.get<DiscoveryK8sIoV1EndpointSliceList>(path, null, null, opts);
  }
  async listDiscoveryV1NamespacedEndpointSlice(params: ListDiscoveryV1NamespacedEndpointSliceRequest, opts?: APIClientRequestOpts): Promise<DiscoveryK8sIoV1EndpointSliceList> {
    const path = `/apis/discovery.k8s.io/v1/namespaces/${params.path.namespace}/endpointslices`;
    return await this.get<DiscoveryK8sIoV1EndpointSliceList>(path, null, null, opts);
  }
  async createDiscoveryV1NamespacedEndpointSlice(params: CreateDiscoveryV1NamespacedEndpointSliceRequest, opts?: APIClientRequestOpts): Promise<DiscoveryK8sIoV1EndpointSlice> {
    const path = `/apis/discovery.k8s.io/v1/namespaces/${params.path.namespace}/endpointslices`;
    return await this.post<DiscoveryK8sIoV1EndpointSlice>(path, params.query, params.body, opts);
  }
  async deleteDiscoveryV1CollectionNamespacedEndpointSlice(params: DeleteDiscoveryV1CollectionNamespacedEndpointSliceRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/discovery.k8s.io/v1/namespaces/${params.path.namespace}/endpointslices`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readDiscoveryV1NamespacedEndpointSlice(params: ReadDiscoveryV1NamespacedEndpointSliceRequest, opts?: APIClientRequestOpts): Promise<DiscoveryK8sIoV1EndpointSlice> {
    const path = `/apis/discovery.k8s.io/v1/namespaces/${params.path.namespace}/endpointslices/${params.path.name}`;
    return await this.get<DiscoveryK8sIoV1EndpointSlice>(path, null, null, opts);
  }
  async replaceDiscoveryV1NamespacedEndpointSlice(params: ReplaceDiscoveryV1NamespacedEndpointSliceRequest, opts?: APIClientRequestOpts): Promise<DiscoveryK8sIoV1EndpointSlice> {
    const path = `/apis/discovery.k8s.io/v1/namespaces/${params.path.namespace}/endpointslices/${params.path.name}`;
    return await this.put<DiscoveryK8sIoV1EndpointSlice>(path, params.query, params.body, opts);
  }
  async deleteDiscoveryV1NamespacedEndpointSlice(params: DeleteDiscoveryV1NamespacedEndpointSliceRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/discovery.k8s.io/v1/namespaces/${params.path.namespace}/endpointslices/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchDiscoveryV1NamespacedEndpointSlice(params: PatchDiscoveryV1NamespacedEndpointSliceRequest, opts?: APIClientRequestOpts): Promise<DiscoveryK8sIoV1EndpointSlice> {
    const path = `/apis/discovery.k8s.io/v1/namespaces/${params.path.namespace}/endpointslices/${params.path.name}`;
    return await this.patch<DiscoveryK8sIoV1EndpointSlice>(path, params.query, null, opts);
  }
  async watchDiscoveryV1EndpointSliceListForAllNamespaces(params: WatchDiscoveryV1EndpointSliceListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/discovery.k8s.io/v1/watch/endpointslices`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchDiscoveryV1NamespacedEndpointSliceList(params: WatchDiscoveryV1NamespacedEndpointSliceListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/discovery.k8s.io/v1/watch/namespaces/${params.path.namespace}/endpointslices`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchDiscoveryV1NamespacedEndpointSlice(params: WatchDiscoveryV1NamespacedEndpointSliceRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/discovery.k8s.io/v1/watch/namespaces/${params.path.namespace}/endpointslices/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async getEventsAPIGroup(params: GetEventsAPIGroupRequest, opts?: APIClientRequestOpts): Promise<APIGroup> {
    const path = `/apis/events.k8s.io/`;
    return await this.get<APIGroup>(path, null, null, opts);
  }
  async getEventsV1APIResources(params: GetEventsV1APIResourcesRequest, opts?: APIClientRequestOpts): Promise<APIResourceList> {
    const path = `/apis/events.k8s.io/v1/`;
    return await this.get<APIResourceList>(path, null, null, opts);
  }
  async listEventsV1EventForAllNamespaces(params: ListEventsV1EventForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<EventsK8sIoV1EventList> {
    const path = `/apis/events.k8s.io/v1/events`;
    return await this.get<EventsK8sIoV1EventList>(path, null, null, opts);
  }
  async listEventsV1NamespacedEvent(params: ListEventsV1NamespacedEventRequest, opts?: APIClientRequestOpts): Promise<EventsK8sIoV1EventList> {
    const path = `/apis/events.k8s.io/v1/namespaces/${params.path.namespace}/events`;
    return await this.get<EventsK8sIoV1EventList>(path, null, null, opts);
  }
  async createEventsV1NamespacedEvent(params: CreateEventsV1NamespacedEventRequest, opts?: APIClientRequestOpts): Promise<EventsK8sIoV1Event> {
    const path = `/apis/events.k8s.io/v1/namespaces/${params.path.namespace}/events`;
    return await this.post<EventsK8sIoV1Event>(path, params.query, params.body, opts);
  }
  async deleteEventsV1CollectionNamespacedEvent(params: DeleteEventsV1CollectionNamespacedEventRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/events.k8s.io/v1/namespaces/${params.path.namespace}/events`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readEventsV1NamespacedEvent(params: ReadEventsV1NamespacedEventRequest, opts?: APIClientRequestOpts): Promise<EventsK8sIoV1Event> {
    const path = `/apis/events.k8s.io/v1/namespaces/${params.path.namespace}/events/${params.path.name}`;
    return await this.get<EventsK8sIoV1Event>(path, null, null, opts);
  }
  async replaceEventsV1NamespacedEvent(params: ReplaceEventsV1NamespacedEventRequest, opts?: APIClientRequestOpts): Promise<EventsK8sIoV1Event> {
    const path = `/apis/events.k8s.io/v1/namespaces/${params.path.namespace}/events/${params.path.name}`;
    return await this.put<EventsK8sIoV1Event>(path, params.query, params.body, opts);
  }
  async deleteEventsV1NamespacedEvent(params: DeleteEventsV1NamespacedEventRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/events.k8s.io/v1/namespaces/${params.path.namespace}/events/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchEventsV1NamespacedEvent(params: PatchEventsV1NamespacedEventRequest, opts?: APIClientRequestOpts): Promise<EventsK8sIoV1Event> {
    const path = `/apis/events.k8s.io/v1/namespaces/${params.path.namespace}/events/${params.path.name}`;
    return await this.patch<EventsK8sIoV1Event>(path, params.query, null, opts);
  }
  async watchEventsV1EventListForAllNamespaces(params: WatchEventsV1EventListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/events.k8s.io/v1/watch/events`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchEventsV1NamespacedEventList(params: WatchEventsV1NamespacedEventListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/events.k8s.io/v1/watch/namespaces/${params.path.namespace}/events`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchEventsV1NamespacedEvent(params: WatchEventsV1NamespacedEventRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/events.k8s.io/v1/watch/namespaces/${params.path.namespace}/events/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async getFlowcontrolApiserverAPIGroup(params: GetFlowcontrolApiserverAPIGroupRequest, opts?: APIClientRequestOpts): Promise<APIGroup> {
    const path = `/apis/flowcontrol.apiserver.k8s.io/`;
    return await this.get<APIGroup>(path, null, null, opts);
  }
  async getFlowcontrolApiserverV1APIResources(params: GetFlowcontrolApiserverV1APIResourcesRequest, opts?: APIClientRequestOpts): Promise<APIResourceList> {
    const path = `/apis/flowcontrol.apiserver.k8s.io/v1/`;
    return await this.get<APIResourceList>(path, null, null, opts);
  }
  async listFlowcontrolApiserverV1FlowSchema(params: ListFlowcontrolApiserverV1FlowSchemaRequest, opts?: APIClientRequestOpts): Promise<FlowcontrolApiserverK8sIoV1FlowSchemaList> {
    const path = `/apis/flowcontrol.apiserver.k8s.io/v1/flowschemas`;
    return await this.get<FlowcontrolApiserverK8sIoV1FlowSchemaList>(path, null, null, opts);
  }
  async createFlowcontrolApiserverV1FlowSchema(params: CreateFlowcontrolApiserverV1FlowSchemaRequest, opts?: APIClientRequestOpts): Promise<FlowcontrolApiserverK8sIoV1FlowSchema> {
    const path = `/apis/flowcontrol.apiserver.k8s.io/v1/flowschemas`;
    return await this.post<FlowcontrolApiserverK8sIoV1FlowSchema>(path, params.query, params.body, opts);
  }
  async deleteFlowcontrolApiserverV1CollectionFlowSchema(params: DeleteFlowcontrolApiserverV1CollectionFlowSchemaRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/flowcontrol.apiserver.k8s.io/v1/flowschemas`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readFlowcontrolApiserverV1FlowSchema(params: ReadFlowcontrolApiserverV1FlowSchemaRequest, opts?: APIClientRequestOpts): Promise<FlowcontrolApiserverK8sIoV1FlowSchema> {
    const path = `/apis/flowcontrol.apiserver.k8s.io/v1/flowschemas/${params.path.name}`;
    return await this.get<FlowcontrolApiserverK8sIoV1FlowSchema>(path, null, null, opts);
  }
  async replaceFlowcontrolApiserverV1FlowSchema(params: ReplaceFlowcontrolApiserverV1FlowSchemaRequest, opts?: APIClientRequestOpts): Promise<FlowcontrolApiserverK8sIoV1FlowSchema> {
    const path = `/apis/flowcontrol.apiserver.k8s.io/v1/flowschemas/${params.path.name}`;
    return await this.put<FlowcontrolApiserverK8sIoV1FlowSchema>(path, params.query, params.body, opts);
  }
  async deleteFlowcontrolApiserverV1FlowSchema(params: DeleteFlowcontrolApiserverV1FlowSchemaRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/flowcontrol.apiserver.k8s.io/v1/flowschemas/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchFlowcontrolApiserverV1FlowSchema(params: PatchFlowcontrolApiserverV1FlowSchemaRequest, opts?: APIClientRequestOpts): Promise<FlowcontrolApiserverK8sIoV1FlowSchema> {
    const path = `/apis/flowcontrol.apiserver.k8s.io/v1/flowschemas/${params.path.name}`;
    return await this.patch<FlowcontrolApiserverK8sIoV1FlowSchema>(path, params.query, null, opts);
  }
  async readFlowcontrolApiserverV1FlowSchemaStatus(params: ReadFlowcontrolApiserverV1FlowSchemaStatusRequest, opts?: APIClientRequestOpts): Promise<FlowcontrolApiserverK8sIoV1FlowSchema> {
    const path = `/apis/flowcontrol.apiserver.k8s.io/v1/flowschemas/${params.path.name}/status`;
    return await this.get<FlowcontrolApiserverK8sIoV1FlowSchema>(path, null, null, opts);
  }
  async replaceFlowcontrolApiserverV1FlowSchemaStatus(params: ReplaceFlowcontrolApiserverV1FlowSchemaStatusRequest, opts?: APIClientRequestOpts): Promise<FlowcontrolApiserverK8sIoV1FlowSchema> {
    const path = `/apis/flowcontrol.apiserver.k8s.io/v1/flowschemas/${params.path.name}/status`;
    return await this.put<FlowcontrolApiserverK8sIoV1FlowSchema>(path, params.query, params.body, opts);
  }
  async patchFlowcontrolApiserverV1FlowSchemaStatus(params: PatchFlowcontrolApiserverV1FlowSchemaStatusRequest, opts?: APIClientRequestOpts): Promise<FlowcontrolApiserverK8sIoV1FlowSchema> {
    const path = `/apis/flowcontrol.apiserver.k8s.io/v1/flowschemas/${params.path.name}/status`;
    return await this.patch<FlowcontrolApiserverK8sIoV1FlowSchema>(path, params.query, null, opts);
  }
  async listFlowcontrolApiserverV1PriorityLevelConfiguration(params: ListFlowcontrolApiserverV1PriorityLevelConfigurationRequest, opts?: APIClientRequestOpts): Promise<FlowcontrolApiserverK8sIoV1PriorityLevelConfigurationList> {
    const path = `/apis/flowcontrol.apiserver.k8s.io/v1/prioritylevelconfigurations`;
    return await this.get<FlowcontrolApiserverK8sIoV1PriorityLevelConfigurationList>(path, null, null, opts);
  }
  async createFlowcontrolApiserverV1PriorityLevelConfiguration(params: CreateFlowcontrolApiserverV1PriorityLevelConfigurationRequest, opts?: APIClientRequestOpts): Promise<FlowcontrolApiserverK8sIoV1PriorityLevelConfiguration> {
    const path = `/apis/flowcontrol.apiserver.k8s.io/v1/prioritylevelconfigurations`;
    return await this.post<FlowcontrolApiserverK8sIoV1PriorityLevelConfiguration>(path, params.query, params.body, opts);
  }
  async deleteFlowcontrolApiserverV1CollectionPriorityLevelConfiguration(params: DeleteFlowcontrolApiserverV1CollectionPriorityLevelConfigurationRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/flowcontrol.apiserver.k8s.io/v1/prioritylevelconfigurations`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readFlowcontrolApiserverV1PriorityLevelConfiguration(params: ReadFlowcontrolApiserverV1PriorityLevelConfigurationRequest, opts?: APIClientRequestOpts): Promise<FlowcontrolApiserverK8sIoV1PriorityLevelConfiguration> {
    const path = `/apis/flowcontrol.apiserver.k8s.io/v1/prioritylevelconfigurations/${params.path.name}`;
    return await this.get<FlowcontrolApiserverK8sIoV1PriorityLevelConfiguration>(path, null, null, opts);
  }
  async replaceFlowcontrolApiserverV1PriorityLevelConfiguration(params: ReplaceFlowcontrolApiserverV1PriorityLevelConfigurationRequest, opts?: APIClientRequestOpts): Promise<FlowcontrolApiserverK8sIoV1PriorityLevelConfiguration> {
    const path = `/apis/flowcontrol.apiserver.k8s.io/v1/prioritylevelconfigurations/${params.path.name}`;
    return await this.put<FlowcontrolApiserverK8sIoV1PriorityLevelConfiguration>(path, params.query, params.body, opts);
  }
  async deleteFlowcontrolApiserverV1PriorityLevelConfiguration(params: DeleteFlowcontrolApiserverV1PriorityLevelConfigurationRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/flowcontrol.apiserver.k8s.io/v1/prioritylevelconfigurations/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchFlowcontrolApiserverV1PriorityLevelConfiguration(params: PatchFlowcontrolApiserverV1PriorityLevelConfigurationRequest, opts?: APIClientRequestOpts): Promise<FlowcontrolApiserverK8sIoV1PriorityLevelConfiguration> {
    const path = `/apis/flowcontrol.apiserver.k8s.io/v1/prioritylevelconfigurations/${params.path.name}`;
    return await this.patch<FlowcontrolApiserverK8sIoV1PriorityLevelConfiguration>(path, params.query, null, opts);
  }
  async readFlowcontrolApiserverV1PriorityLevelConfigurationStatus(params: ReadFlowcontrolApiserverV1PriorityLevelConfigurationStatusRequest, opts?: APIClientRequestOpts): Promise<FlowcontrolApiserverK8sIoV1PriorityLevelConfiguration> {
    const path = `/apis/flowcontrol.apiserver.k8s.io/v1/prioritylevelconfigurations/${params.path.name}/status`;
    return await this.get<FlowcontrolApiserverK8sIoV1PriorityLevelConfiguration>(path, null, null, opts);
  }
  async replaceFlowcontrolApiserverV1PriorityLevelConfigurationStatus(params: ReplaceFlowcontrolApiserverV1PriorityLevelConfigurationStatusRequest, opts?: APIClientRequestOpts): Promise<FlowcontrolApiserverK8sIoV1PriorityLevelConfiguration> {
    const path = `/apis/flowcontrol.apiserver.k8s.io/v1/prioritylevelconfigurations/${params.path.name}/status`;
    return await this.put<FlowcontrolApiserverK8sIoV1PriorityLevelConfiguration>(path, params.query, params.body, opts);
  }
  async patchFlowcontrolApiserverV1PriorityLevelConfigurationStatus(params: PatchFlowcontrolApiserverV1PriorityLevelConfigurationStatusRequest, opts?: APIClientRequestOpts): Promise<FlowcontrolApiserverK8sIoV1PriorityLevelConfiguration> {
    const path = `/apis/flowcontrol.apiserver.k8s.io/v1/prioritylevelconfigurations/${params.path.name}/status`;
    return await this.patch<FlowcontrolApiserverK8sIoV1PriorityLevelConfiguration>(path, params.query, null, opts);
  }
  async watchFlowcontrolApiserverV1FlowSchemaList(params: WatchFlowcontrolApiserverV1FlowSchemaListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/flowcontrol.apiserver.k8s.io/v1/watch/flowschemas`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchFlowcontrolApiserverV1FlowSchema(params: WatchFlowcontrolApiserverV1FlowSchemaRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/flowcontrol.apiserver.k8s.io/v1/watch/flowschemas/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchFlowcontrolApiserverV1PriorityLevelConfigurationList(params: WatchFlowcontrolApiserverV1PriorityLevelConfigurationListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/flowcontrol.apiserver.k8s.io/v1/watch/prioritylevelconfigurations`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchFlowcontrolApiserverV1PriorityLevelConfiguration(params: WatchFlowcontrolApiserverV1PriorityLevelConfigurationRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/flowcontrol.apiserver.k8s.io/v1/watch/prioritylevelconfigurations/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async listMonitoringCoreosComV1AlertmanagerForAllNamespaces(params: ListMonitoringCoreosComV1AlertmanagerForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1AlertmanagerList> {
    const path = `/apis/monitoring.coreos.com/v1/alertmanagers`;
    return await this.get<MonitoringCoreosComV1AlertmanagerList>(path, null, null, opts);
  }
  async listMonitoringCoreosComV1NamespacedAlertmanager(params: ListMonitoringCoreosComV1NamespacedAlertmanagerRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1AlertmanagerList> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/alertmanagers`;
    return await this.get<MonitoringCoreosComV1AlertmanagerList>(path, null, null, opts);
  }
  async createMonitoringCoreosComV1NamespacedAlertmanager(params: CreateMonitoringCoreosComV1NamespacedAlertmanagerRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1Alertmanager> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/alertmanagers`;
    return await this.post<MonitoringCoreosComV1Alertmanager>(path, params.query, params.body, opts);
  }
  async deleteMonitoringCoreosComV1CollectionNamespacedAlertmanager(params: DeleteMonitoringCoreosComV1CollectionNamespacedAlertmanagerRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/alertmanagers`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readMonitoringCoreosComV1NamespacedAlertmanager(params: ReadMonitoringCoreosComV1NamespacedAlertmanagerRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1Alertmanager> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/alertmanagers/${params.path.name}`;
    return await this.get<MonitoringCoreosComV1Alertmanager>(path, null, null, opts);
  }
  async replaceMonitoringCoreosComV1NamespacedAlertmanager(params: ReplaceMonitoringCoreosComV1NamespacedAlertmanagerRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1Alertmanager> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/alertmanagers/${params.path.name}`;
    return await this.put<MonitoringCoreosComV1Alertmanager>(path, params.query, params.body, opts);
  }
  async deleteMonitoringCoreosComV1NamespacedAlertmanager(params: DeleteMonitoringCoreosComV1NamespacedAlertmanagerRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/alertmanagers/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchMonitoringCoreosComV1NamespacedAlertmanager(params: PatchMonitoringCoreosComV1NamespacedAlertmanagerRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1Alertmanager> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/alertmanagers/${params.path.name}`;
    return await this.patch<MonitoringCoreosComV1Alertmanager>(path, params.query, null, opts);
  }
  async readMonitoringCoreosComV1NamespacedAlertmanagerScale(params: ReadMonitoringCoreosComV1NamespacedAlertmanagerScaleRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1Scale> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/alertmanagers/${params.path.name}/scale`;
    return await this.get<AutoscalingV1Scale>(path, null, null, opts);
  }
  async replaceMonitoringCoreosComV1NamespacedAlertmanagerScale(params: ReplaceMonitoringCoreosComV1NamespacedAlertmanagerScaleRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1Scale> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/alertmanagers/${params.path.name}/scale`;
    return await this.put<AutoscalingV1Scale>(path, params.query, params.body, opts);
  }
  async patchMonitoringCoreosComV1NamespacedAlertmanagerScale(params: PatchMonitoringCoreosComV1NamespacedAlertmanagerScaleRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1Scale> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/alertmanagers/${params.path.name}/scale`;
    return await this.patch<AutoscalingV1Scale>(path, params.query, null, opts);
  }
  async readMonitoringCoreosComV1NamespacedAlertmanagerStatus(params: ReadMonitoringCoreosComV1NamespacedAlertmanagerStatusRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1Alertmanager> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/alertmanagers/${params.path.name}/status`;
    return await this.get<MonitoringCoreosComV1Alertmanager>(path, null, null, opts);
  }
  async replaceMonitoringCoreosComV1NamespacedAlertmanagerStatus(params: ReplaceMonitoringCoreosComV1NamespacedAlertmanagerStatusRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1Alertmanager> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/alertmanagers/${params.path.name}/status`;
    return await this.put<MonitoringCoreosComV1Alertmanager>(path, params.query, params.body, opts);
  }
  async patchMonitoringCoreosComV1NamespacedAlertmanagerStatus(params: PatchMonitoringCoreosComV1NamespacedAlertmanagerStatusRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1Alertmanager> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/alertmanagers/${params.path.name}/status`;
    return await this.patch<MonitoringCoreosComV1Alertmanager>(path, params.query, null, opts);
  }
  async listMonitoringCoreosComV1NamespacedPodMonitor(params: ListMonitoringCoreosComV1NamespacedPodMonitorRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1PodMonitorList> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/podmonitors`;
    return await this.get<MonitoringCoreosComV1PodMonitorList>(path, null, null, opts);
  }
  async createMonitoringCoreosComV1NamespacedPodMonitor(params: CreateMonitoringCoreosComV1NamespacedPodMonitorRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1PodMonitor> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/podmonitors`;
    return await this.post<MonitoringCoreosComV1PodMonitor>(path, params.query, params.body, opts);
  }
  async deleteMonitoringCoreosComV1CollectionNamespacedPodMonitor(params: DeleteMonitoringCoreosComV1CollectionNamespacedPodMonitorRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/podmonitors`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readMonitoringCoreosComV1NamespacedPodMonitor(params: ReadMonitoringCoreosComV1NamespacedPodMonitorRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1PodMonitor> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/podmonitors/${params.path.name}`;
    return await this.get<MonitoringCoreosComV1PodMonitor>(path, null, null, opts);
  }
  async replaceMonitoringCoreosComV1NamespacedPodMonitor(params: ReplaceMonitoringCoreosComV1NamespacedPodMonitorRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1PodMonitor> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/podmonitors/${params.path.name}`;
    return await this.put<MonitoringCoreosComV1PodMonitor>(path, params.query, params.body, opts);
  }
  async deleteMonitoringCoreosComV1NamespacedPodMonitor(params: DeleteMonitoringCoreosComV1NamespacedPodMonitorRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/podmonitors/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchMonitoringCoreosComV1NamespacedPodMonitor(params: PatchMonitoringCoreosComV1NamespacedPodMonitorRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1PodMonitor> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/podmonitors/${params.path.name}`;
    return await this.patch<MonitoringCoreosComV1PodMonitor>(path, params.query, null, opts);
  }
  async listMonitoringCoreosComV1NamespacedProbe(params: ListMonitoringCoreosComV1NamespacedProbeRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1ProbeList> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/probes`;
    return await this.get<MonitoringCoreosComV1ProbeList>(path, null, null, opts);
  }
  async createMonitoringCoreosComV1NamespacedProbe(params: CreateMonitoringCoreosComV1NamespacedProbeRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1Probe> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/probes`;
    return await this.post<MonitoringCoreosComV1Probe>(path, params.query, params.body, opts);
  }
  async deleteMonitoringCoreosComV1CollectionNamespacedProbe(params: DeleteMonitoringCoreosComV1CollectionNamespacedProbeRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/probes`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readMonitoringCoreosComV1NamespacedProbe(params: ReadMonitoringCoreosComV1NamespacedProbeRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1Probe> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/probes/${params.path.name}`;
    return await this.get<MonitoringCoreosComV1Probe>(path, null, null, opts);
  }
  async replaceMonitoringCoreosComV1NamespacedProbe(params: ReplaceMonitoringCoreosComV1NamespacedProbeRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1Probe> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/probes/${params.path.name}`;
    return await this.put<MonitoringCoreosComV1Probe>(path, params.query, params.body, opts);
  }
  async deleteMonitoringCoreosComV1NamespacedProbe(params: DeleteMonitoringCoreosComV1NamespacedProbeRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/probes/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchMonitoringCoreosComV1NamespacedProbe(params: PatchMonitoringCoreosComV1NamespacedProbeRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1Probe> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/probes/${params.path.name}`;
    return await this.patch<MonitoringCoreosComV1Probe>(path, params.query, null, opts);
  }
  async listMonitoringCoreosComV1NamespacedPrometheus(params: ListMonitoringCoreosComV1NamespacedPrometheusRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1PrometheusList> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/prometheuses`;
    return await this.get<MonitoringCoreosComV1PrometheusList>(path, null, null, opts);
  }
  async createMonitoringCoreosComV1NamespacedPrometheus(params: CreateMonitoringCoreosComV1NamespacedPrometheusRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1Prometheus> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/prometheuses`;
    return await this.post<MonitoringCoreosComV1Prometheus>(path, params.query, params.body, opts);
  }
  async deleteMonitoringCoreosComV1CollectionNamespacedPrometheus(params: DeleteMonitoringCoreosComV1CollectionNamespacedPrometheusRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/prometheuses`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readMonitoringCoreosComV1NamespacedPrometheus(params: ReadMonitoringCoreosComV1NamespacedPrometheusRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1Prometheus> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/prometheuses/${params.path.name}`;
    return await this.get<MonitoringCoreosComV1Prometheus>(path, null, null, opts);
  }
  async replaceMonitoringCoreosComV1NamespacedPrometheus(params: ReplaceMonitoringCoreosComV1NamespacedPrometheusRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1Prometheus> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/prometheuses/${params.path.name}`;
    return await this.put<MonitoringCoreosComV1Prometheus>(path, params.query, params.body, opts);
  }
  async deleteMonitoringCoreosComV1NamespacedPrometheus(params: DeleteMonitoringCoreosComV1NamespacedPrometheusRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/prometheuses/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchMonitoringCoreosComV1NamespacedPrometheus(params: PatchMonitoringCoreosComV1NamespacedPrometheusRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1Prometheus> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/prometheuses/${params.path.name}`;
    return await this.patch<MonitoringCoreosComV1Prometheus>(path, params.query, null, opts);
  }
  async readMonitoringCoreosComV1NamespacedPrometheusScale(params: ReadMonitoringCoreosComV1NamespacedPrometheusScaleRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1Scale> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/prometheuses/${params.path.name}/scale`;
    return await this.get<AutoscalingV1Scale>(path, null, null, opts);
  }
  async replaceMonitoringCoreosComV1NamespacedPrometheusScale(params: ReplaceMonitoringCoreosComV1NamespacedPrometheusScaleRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1Scale> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/prometheuses/${params.path.name}/scale`;
    return await this.put<AutoscalingV1Scale>(path, params.query, params.body, opts);
  }
  async patchMonitoringCoreosComV1NamespacedPrometheusScale(params: PatchMonitoringCoreosComV1NamespacedPrometheusScaleRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1Scale> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/prometheuses/${params.path.name}/scale`;
    return await this.patch<AutoscalingV1Scale>(path, params.query, null, opts);
  }
  async readMonitoringCoreosComV1NamespacedPrometheusStatus(params: ReadMonitoringCoreosComV1NamespacedPrometheusStatusRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1Prometheus> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/prometheuses/${params.path.name}/status`;
    return await this.get<MonitoringCoreosComV1Prometheus>(path, null, null, opts);
  }
  async replaceMonitoringCoreosComV1NamespacedPrometheusStatus(params: ReplaceMonitoringCoreosComV1NamespacedPrometheusStatusRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1Prometheus> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/prometheuses/${params.path.name}/status`;
    return await this.put<MonitoringCoreosComV1Prometheus>(path, params.query, params.body, opts);
  }
  async patchMonitoringCoreosComV1NamespacedPrometheusStatus(params: PatchMonitoringCoreosComV1NamespacedPrometheusStatusRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1Prometheus> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/prometheuses/${params.path.name}/status`;
    return await this.patch<MonitoringCoreosComV1Prometheus>(path, params.query, null, opts);
  }
  async listMonitoringCoreosComV1NamespacedPrometheusRule(params: ListMonitoringCoreosComV1NamespacedPrometheusRuleRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1PrometheusRuleList> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/prometheusrules`;
    return await this.get<MonitoringCoreosComV1PrometheusRuleList>(path, null, null, opts);
  }
  async createMonitoringCoreosComV1NamespacedPrometheusRule(params: CreateMonitoringCoreosComV1NamespacedPrometheusRuleRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1PrometheusRule> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/prometheusrules`;
    return await this.post<MonitoringCoreosComV1PrometheusRule>(path, params.query, params.body, opts);
  }
  async deleteMonitoringCoreosComV1CollectionNamespacedPrometheusRule(params: DeleteMonitoringCoreosComV1CollectionNamespacedPrometheusRuleRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/prometheusrules`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readMonitoringCoreosComV1NamespacedPrometheusRule(params: ReadMonitoringCoreosComV1NamespacedPrometheusRuleRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1PrometheusRule> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/prometheusrules/${params.path.name}`;
    return await this.get<MonitoringCoreosComV1PrometheusRule>(path, null, null, opts);
  }
  async replaceMonitoringCoreosComV1NamespacedPrometheusRule(params: ReplaceMonitoringCoreosComV1NamespacedPrometheusRuleRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1PrometheusRule> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/prometheusrules/${params.path.name}`;
    return await this.put<MonitoringCoreosComV1PrometheusRule>(path, params.query, params.body, opts);
  }
  async deleteMonitoringCoreosComV1NamespacedPrometheusRule(params: DeleteMonitoringCoreosComV1NamespacedPrometheusRuleRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/prometheusrules/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchMonitoringCoreosComV1NamespacedPrometheusRule(params: PatchMonitoringCoreosComV1NamespacedPrometheusRuleRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1PrometheusRule> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/prometheusrules/${params.path.name}`;
    return await this.patch<MonitoringCoreosComV1PrometheusRule>(path, params.query, null, opts);
  }
  async listMonitoringCoreosComV1NamespacedServiceMonitor(params: ListMonitoringCoreosComV1NamespacedServiceMonitorRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1ServiceMonitorList> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/servicemonitors`;
    return await this.get<MonitoringCoreosComV1ServiceMonitorList>(path, null, null, opts);
  }
  async createMonitoringCoreosComV1NamespacedServiceMonitor(params: CreateMonitoringCoreosComV1NamespacedServiceMonitorRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1ServiceMonitor> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/servicemonitors`;
    return await this.post<MonitoringCoreosComV1ServiceMonitor>(path, params.query, params.body, opts);
  }
  async deleteMonitoringCoreosComV1CollectionNamespacedServiceMonitor(params: DeleteMonitoringCoreosComV1CollectionNamespacedServiceMonitorRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/servicemonitors`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readMonitoringCoreosComV1NamespacedServiceMonitor(params: ReadMonitoringCoreosComV1NamespacedServiceMonitorRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1ServiceMonitor> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/servicemonitors/${params.path.name}`;
    return await this.get<MonitoringCoreosComV1ServiceMonitor>(path, null, null, opts);
  }
  async replaceMonitoringCoreosComV1NamespacedServiceMonitor(params: ReplaceMonitoringCoreosComV1NamespacedServiceMonitorRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1ServiceMonitor> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/servicemonitors/${params.path.name}`;
    return await this.put<MonitoringCoreosComV1ServiceMonitor>(path, params.query, params.body, opts);
  }
  async deleteMonitoringCoreosComV1NamespacedServiceMonitor(params: DeleteMonitoringCoreosComV1NamespacedServiceMonitorRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/servicemonitors/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchMonitoringCoreosComV1NamespacedServiceMonitor(params: PatchMonitoringCoreosComV1NamespacedServiceMonitorRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1ServiceMonitor> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/servicemonitors/${params.path.name}`;
    return await this.patch<MonitoringCoreosComV1ServiceMonitor>(path, params.query, null, opts);
  }
  async readMonitoringCoreosComV1NamespacedServiceMonitorStatus(params: ReadMonitoringCoreosComV1NamespacedServiceMonitorStatusRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1ServiceMonitor> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/servicemonitors/${params.path.name}/status`;
    return await this.get<MonitoringCoreosComV1ServiceMonitor>(path, null, null, opts);
  }
  async replaceMonitoringCoreosComV1NamespacedServiceMonitorStatus(params: ReplaceMonitoringCoreosComV1NamespacedServiceMonitorStatusRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1ServiceMonitor> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/servicemonitors/${params.path.name}/status`;
    return await this.put<MonitoringCoreosComV1ServiceMonitor>(path, params.query, params.body, opts);
  }
  async patchMonitoringCoreosComV1NamespacedServiceMonitorStatus(params: PatchMonitoringCoreosComV1NamespacedServiceMonitorStatusRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1ServiceMonitor> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/servicemonitors/${params.path.name}/status`;
    return await this.patch<MonitoringCoreosComV1ServiceMonitor>(path, params.query, null, opts);
  }
  async listMonitoringCoreosComV1NamespacedThanosRuler(params: ListMonitoringCoreosComV1NamespacedThanosRulerRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1ThanosRulerList> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/thanosrulers`;
    return await this.get<MonitoringCoreosComV1ThanosRulerList>(path, null, null, opts);
  }
  async createMonitoringCoreosComV1NamespacedThanosRuler(params: CreateMonitoringCoreosComV1NamespacedThanosRulerRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1ThanosRuler> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/thanosrulers`;
    return await this.post<MonitoringCoreosComV1ThanosRuler>(path, params.query, params.body, opts);
  }
  async deleteMonitoringCoreosComV1CollectionNamespacedThanosRuler(params: DeleteMonitoringCoreosComV1CollectionNamespacedThanosRulerRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/thanosrulers`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readMonitoringCoreosComV1NamespacedThanosRuler(params: ReadMonitoringCoreosComV1NamespacedThanosRulerRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1ThanosRuler> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/thanosrulers/${params.path.name}`;
    return await this.get<MonitoringCoreosComV1ThanosRuler>(path, null, null, opts);
  }
  async replaceMonitoringCoreosComV1NamespacedThanosRuler(params: ReplaceMonitoringCoreosComV1NamespacedThanosRulerRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1ThanosRuler> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/thanosrulers/${params.path.name}`;
    return await this.put<MonitoringCoreosComV1ThanosRuler>(path, params.query, params.body, opts);
  }
  async deleteMonitoringCoreosComV1NamespacedThanosRuler(params: DeleteMonitoringCoreosComV1NamespacedThanosRulerRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/thanosrulers/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchMonitoringCoreosComV1NamespacedThanosRuler(params: PatchMonitoringCoreosComV1NamespacedThanosRulerRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1ThanosRuler> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/thanosrulers/${params.path.name}`;
    return await this.patch<MonitoringCoreosComV1ThanosRuler>(path, params.query, null, opts);
  }
  async readMonitoringCoreosComV1NamespacedThanosRulerStatus(params: ReadMonitoringCoreosComV1NamespacedThanosRulerStatusRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1ThanosRuler> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/thanosrulers/${params.path.name}/status`;
    return await this.get<MonitoringCoreosComV1ThanosRuler>(path, null, null, opts);
  }
  async replaceMonitoringCoreosComV1NamespacedThanosRulerStatus(params: ReplaceMonitoringCoreosComV1NamespacedThanosRulerStatusRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1ThanosRuler> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/thanosrulers/${params.path.name}/status`;
    return await this.put<MonitoringCoreosComV1ThanosRuler>(path, params.query, params.body, opts);
  }
  async patchMonitoringCoreosComV1NamespacedThanosRulerStatus(params: PatchMonitoringCoreosComV1NamespacedThanosRulerStatusRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1ThanosRuler> {
    const path = `/apis/monitoring.coreos.com/v1/namespaces/${params.path.namespace}/thanosrulers/${params.path.name}/status`;
    return await this.patch<MonitoringCoreosComV1ThanosRuler>(path, params.query, null, opts);
  }
  async listMonitoringCoreosComV1PodMonitorForAllNamespaces(params: ListMonitoringCoreosComV1PodMonitorForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1PodMonitorList> {
    const path = `/apis/monitoring.coreos.com/v1/podmonitors`;
    return await this.get<MonitoringCoreosComV1PodMonitorList>(path, null, null, opts);
  }
  async listMonitoringCoreosComV1ProbeForAllNamespaces(params: ListMonitoringCoreosComV1ProbeForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1ProbeList> {
    const path = `/apis/monitoring.coreos.com/v1/probes`;
    return await this.get<MonitoringCoreosComV1ProbeList>(path, null, null, opts);
  }
  async listMonitoringCoreosComV1PrometheusForAllNamespaces(params: ListMonitoringCoreosComV1PrometheusForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1PrometheusList> {
    const path = `/apis/monitoring.coreos.com/v1/prometheuses`;
    return await this.get<MonitoringCoreosComV1PrometheusList>(path, null, null, opts);
  }
  async listMonitoringCoreosComV1PrometheusRuleForAllNamespaces(params: ListMonitoringCoreosComV1PrometheusRuleForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1PrometheusRuleList> {
    const path = `/apis/monitoring.coreos.com/v1/prometheusrules`;
    return await this.get<MonitoringCoreosComV1PrometheusRuleList>(path, null, null, opts);
  }
  async listMonitoringCoreosComV1ServiceMonitorForAllNamespaces(params: ListMonitoringCoreosComV1ServiceMonitorForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1ServiceMonitorList> {
    const path = `/apis/monitoring.coreos.com/v1/servicemonitors`;
    return await this.get<MonitoringCoreosComV1ServiceMonitorList>(path, null, null, opts);
  }
  async listMonitoringCoreosComV1ThanosRulerForAllNamespaces(params: ListMonitoringCoreosComV1ThanosRulerForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1ThanosRulerList> {
    const path = `/apis/monitoring.coreos.com/v1/thanosrulers`;
    return await this.get<MonitoringCoreosComV1ThanosRulerList>(path, null, null, opts);
  }
  async listMonitoringCoreosComV1alpha1AlertmanagerConfigForAllNamespaces(params: ListMonitoringCoreosComV1alpha1AlertmanagerConfigForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1alpha1AlertmanagerConfigList> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/alertmanagerconfigs`;
    return await this.get<MonitoringCoreosComV1alpha1AlertmanagerConfigList>(path, null, null, opts);
  }
  async listMonitoringCoreosComV1alpha1NamespacedAlertmanagerConfig(params: ListMonitoringCoreosComV1alpha1NamespacedAlertmanagerConfigRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1alpha1AlertmanagerConfigList> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/namespaces/${params.path.namespace}/alertmanagerconfigs`;
    return await this.get<MonitoringCoreosComV1alpha1AlertmanagerConfigList>(path, null, null, opts);
  }
  async createMonitoringCoreosComV1alpha1NamespacedAlertmanagerConfig(params: CreateMonitoringCoreosComV1alpha1NamespacedAlertmanagerConfigRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1alpha1AlertmanagerConfig> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/namespaces/${params.path.namespace}/alertmanagerconfigs`;
    return await this.post<MonitoringCoreosComV1alpha1AlertmanagerConfig>(path, params.query, params.body, opts);
  }
  async deleteMonitoringCoreosComV1alpha1CollectionNamespacedAlertmanagerConfig(params: DeleteMonitoringCoreosComV1alpha1CollectionNamespacedAlertmanagerConfigRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/namespaces/${params.path.namespace}/alertmanagerconfigs`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readMonitoringCoreosComV1alpha1NamespacedAlertmanagerConfig(params: ReadMonitoringCoreosComV1alpha1NamespacedAlertmanagerConfigRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1alpha1AlertmanagerConfig> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/namespaces/${params.path.namespace}/alertmanagerconfigs/${params.path.name}`;
    return await this.get<MonitoringCoreosComV1alpha1AlertmanagerConfig>(path, null, null, opts);
  }
  async replaceMonitoringCoreosComV1alpha1NamespacedAlertmanagerConfig(params: ReplaceMonitoringCoreosComV1alpha1NamespacedAlertmanagerConfigRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1alpha1AlertmanagerConfig> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/namespaces/${params.path.namespace}/alertmanagerconfigs/${params.path.name}`;
    return await this.put<MonitoringCoreosComV1alpha1AlertmanagerConfig>(path, params.query, params.body, opts);
  }
  async deleteMonitoringCoreosComV1alpha1NamespacedAlertmanagerConfig(params: DeleteMonitoringCoreosComV1alpha1NamespacedAlertmanagerConfigRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/namespaces/${params.path.namespace}/alertmanagerconfigs/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchMonitoringCoreosComV1alpha1NamespacedAlertmanagerConfig(params: PatchMonitoringCoreosComV1alpha1NamespacedAlertmanagerConfigRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1alpha1AlertmanagerConfig> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/namespaces/${params.path.namespace}/alertmanagerconfigs/${params.path.name}`;
    return await this.patch<MonitoringCoreosComV1alpha1AlertmanagerConfig>(path, params.query, null, opts);
  }
  async listMonitoringCoreosComV1alpha1NamespacedPrometheusAgent(params: ListMonitoringCoreosComV1alpha1NamespacedPrometheusAgentRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1alpha1PrometheusAgentList> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/namespaces/${params.path.namespace}/prometheusagents`;
    return await this.get<MonitoringCoreosComV1alpha1PrometheusAgentList>(path, null, null, opts);
  }
  async createMonitoringCoreosComV1alpha1NamespacedPrometheusAgent(params: CreateMonitoringCoreosComV1alpha1NamespacedPrometheusAgentRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1alpha1PrometheusAgent> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/namespaces/${params.path.namespace}/prometheusagents`;
    return await this.post<MonitoringCoreosComV1alpha1PrometheusAgent>(path, params.query, params.body, opts);
  }
  async deleteMonitoringCoreosComV1alpha1CollectionNamespacedPrometheusAgent(params: DeleteMonitoringCoreosComV1alpha1CollectionNamespacedPrometheusAgentRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/namespaces/${params.path.namespace}/prometheusagents`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readMonitoringCoreosComV1alpha1NamespacedPrometheusAgent(params: ReadMonitoringCoreosComV1alpha1NamespacedPrometheusAgentRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1alpha1PrometheusAgent> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/namespaces/${params.path.namespace}/prometheusagents/${params.path.name}`;
    return await this.get<MonitoringCoreosComV1alpha1PrometheusAgent>(path, null, null, opts);
  }
  async replaceMonitoringCoreosComV1alpha1NamespacedPrometheusAgent(params: ReplaceMonitoringCoreosComV1alpha1NamespacedPrometheusAgentRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1alpha1PrometheusAgent> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/namespaces/${params.path.namespace}/prometheusagents/${params.path.name}`;
    return await this.put<MonitoringCoreosComV1alpha1PrometheusAgent>(path, params.query, params.body, opts);
  }
  async deleteMonitoringCoreosComV1alpha1NamespacedPrometheusAgent(params: DeleteMonitoringCoreosComV1alpha1NamespacedPrometheusAgentRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/namespaces/${params.path.namespace}/prometheusagents/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchMonitoringCoreosComV1alpha1NamespacedPrometheusAgent(params: PatchMonitoringCoreosComV1alpha1NamespacedPrometheusAgentRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1alpha1PrometheusAgent> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/namespaces/${params.path.namespace}/prometheusagents/${params.path.name}`;
    return await this.patch<MonitoringCoreosComV1alpha1PrometheusAgent>(path, params.query, null, opts);
  }
  async readMonitoringCoreosComV1alpha1NamespacedPrometheusAgentScale(params: ReadMonitoringCoreosComV1alpha1NamespacedPrometheusAgentScaleRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1Scale> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/namespaces/${params.path.namespace}/prometheusagents/${params.path.name}/scale`;
    return await this.get<AutoscalingV1Scale>(path, null, null, opts);
  }
  async replaceMonitoringCoreosComV1alpha1NamespacedPrometheusAgentScale(params: ReplaceMonitoringCoreosComV1alpha1NamespacedPrometheusAgentScaleRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1Scale> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/namespaces/${params.path.namespace}/prometheusagents/${params.path.name}/scale`;
    return await this.put<AutoscalingV1Scale>(path, params.query, params.body, opts);
  }
  async patchMonitoringCoreosComV1alpha1NamespacedPrometheusAgentScale(params: PatchMonitoringCoreosComV1alpha1NamespacedPrometheusAgentScaleRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1Scale> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/namespaces/${params.path.namespace}/prometheusagents/${params.path.name}/scale`;
    return await this.patch<AutoscalingV1Scale>(path, params.query, null, opts);
  }
  async readMonitoringCoreosComV1alpha1NamespacedPrometheusAgentStatus(params: ReadMonitoringCoreosComV1alpha1NamespacedPrometheusAgentStatusRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1alpha1PrometheusAgent> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/namespaces/${params.path.namespace}/prometheusagents/${params.path.name}/status`;
    return await this.get<MonitoringCoreosComV1alpha1PrometheusAgent>(path, null, null, opts);
  }
  async replaceMonitoringCoreosComV1alpha1NamespacedPrometheusAgentStatus(params: ReplaceMonitoringCoreosComV1alpha1NamespacedPrometheusAgentStatusRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1alpha1PrometheusAgent> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/namespaces/${params.path.namespace}/prometheusagents/${params.path.name}/status`;
    return await this.put<MonitoringCoreosComV1alpha1PrometheusAgent>(path, params.query, params.body, opts);
  }
  async patchMonitoringCoreosComV1alpha1NamespacedPrometheusAgentStatus(params: PatchMonitoringCoreosComV1alpha1NamespacedPrometheusAgentStatusRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1alpha1PrometheusAgent> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/namespaces/${params.path.namespace}/prometheusagents/${params.path.name}/status`;
    return await this.patch<MonitoringCoreosComV1alpha1PrometheusAgent>(path, params.query, null, opts);
  }
  async listMonitoringCoreosComV1alpha1NamespacedScrapeConfig(params: ListMonitoringCoreosComV1alpha1NamespacedScrapeConfigRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1alpha1ScrapeConfigList> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/namespaces/${params.path.namespace}/scrapeconfigs`;
    return await this.get<MonitoringCoreosComV1alpha1ScrapeConfigList>(path, null, null, opts);
  }
  async createMonitoringCoreosComV1alpha1NamespacedScrapeConfig(params: CreateMonitoringCoreosComV1alpha1NamespacedScrapeConfigRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1alpha1ScrapeConfig> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/namespaces/${params.path.namespace}/scrapeconfigs`;
    return await this.post<MonitoringCoreosComV1alpha1ScrapeConfig>(path, params.query, params.body, opts);
  }
  async deleteMonitoringCoreosComV1alpha1CollectionNamespacedScrapeConfig(params: DeleteMonitoringCoreosComV1alpha1CollectionNamespacedScrapeConfigRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/namespaces/${params.path.namespace}/scrapeconfigs`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readMonitoringCoreosComV1alpha1NamespacedScrapeConfig(params: ReadMonitoringCoreosComV1alpha1NamespacedScrapeConfigRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1alpha1ScrapeConfig> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/namespaces/${params.path.namespace}/scrapeconfigs/${params.path.name}`;
    return await this.get<MonitoringCoreosComV1alpha1ScrapeConfig>(path, null, null, opts);
  }
  async replaceMonitoringCoreosComV1alpha1NamespacedScrapeConfig(params: ReplaceMonitoringCoreosComV1alpha1NamespacedScrapeConfigRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1alpha1ScrapeConfig> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/namespaces/${params.path.namespace}/scrapeconfigs/${params.path.name}`;
    return await this.put<MonitoringCoreosComV1alpha1ScrapeConfig>(path, params.query, params.body, opts);
  }
  async deleteMonitoringCoreosComV1alpha1NamespacedScrapeConfig(params: DeleteMonitoringCoreosComV1alpha1NamespacedScrapeConfigRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/namespaces/${params.path.namespace}/scrapeconfigs/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchMonitoringCoreosComV1alpha1NamespacedScrapeConfig(params: PatchMonitoringCoreosComV1alpha1NamespacedScrapeConfigRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1alpha1ScrapeConfig> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/namespaces/${params.path.namespace}/scrapeconfigs/${params.path.name}`;
    return await this.patch<MonitoringCoreosComV1alpha1ScrapeConfig>(path, params.query, null, opts);
  }
  async listMonitoringCoreosComV1alpha1PrometheusAgentForAllNamespaces(params: ListMonitoringCoreosComV1alpha1PrometheusAgentForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1alpha1PrometheusAgentList> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/prometheusagents`;
    return await this.get<MonitoringCoreosComV1alpha1PrometheusAgentList>(path, null, null, opts);
  }
  async listMonitoringCoreosComV1alpha1ScrapeConfigForAllNamespaces(params: ListMonitoringCoreosComV1alpha1ScrapeConfigForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<MonitoringCoreosComV1alpha1ScrapeConfigList> {
    const path = `/apis/monitoring.coreos.com/v1alpha1/scrapeconfigs`;
    return await this.get<MonitoringCoreosComV1alpha1ScrapeConfigList>(path, null, null, opts);
  }
  async listNetworkingInternalKnativeDevV1alpha1CertificateForAllNamespaces(params: ListNetworkingInternalKnativeDevV1alpha1CertificateForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1CertificateList> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/certificates`;
    return await this.get<NetworkingInternalKnativeDevV1alpha1CertificateList>(path, null, null, opts);
  }
  async listNetworkingInternalKnativeDevV1alpha1ClusterDomainClaim(params: ListNetworkingInternalKnativeDevV1alpha1ClusterDomainClaimRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1ClusterDomainClaimList> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/clusterdomainclaims`;
    return await this.get<NetworkingInternalKnativeDevV1alpha1ClusterDomainClaimList>(path, null, null, opts);
  }
  async createNetworkingInternalKnativeDevV1alpha1ClusterDomainClaim(params: CreateNetworkingInternalKnativeDevV1alpha1ClusterDomainClaimRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1ClusterDomainClaim> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/clusterdomainclaims`;
    return await this.post<NetworkingInternalKnativeDevV1alpha1ClusterDomainClaim>(path, params.query, params.body, opts);
  }
  async deleteNetworkingInternalKnativeDevV1alpha1CollectionClusterDomainClaim(params: DeleteNetworkingInternalKnativeDevV1alpha1CollectionClusterDomainClaimRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/clusterdomainclaims`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readNetworkingInternalKnativeDevV1alpha1ClusterDomainClaim(params: ReadNetworkingInternalKnativeDevV1alpha1ClusterDomainClaimRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1ClusterDomainClaim> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/clusterdomainclaims/${params.path.name}`;
    return await this.get<NetworkingInternalKnativeDevV1alpha1ClusterDomainClaim>(path, null, null, opts);
  }
  async replaceNetworkingInternalKnativeDevV1alpha1ClusterDomainClaim(params: ReplaceNetworkingInternalKnativeDevV1alpha1ClusterDomainClaimRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1ClusterDomainClaim> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/clusterdomainclaims/${params.path.name}`;
    return await this.put<NetworkingInternalKnativeDevV1alpha1ClusterDomainClaim>(path, params.query, params.body, opts);
  }
  async deleteNetworkingInternalKnativeDevV1alpha1ClusterDomainClaim(params: DeleteNetworkingInternalKnativeDevV1alpha1ClusterDomainClaimRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/clusterdomainclaims/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchNetworkingInternalKnativeDevV1alpha1ClusterDomainClaim(params: PatchNetworkingInternalKnativeDevV1alpha1ClusterDomainClaimRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1ClusterDomainClaim> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/clusterdomainclaims/${params.path.name}`;
    return await this.patch<NetworkingInternalKnativeDevV1alpha1ClusterDomainClaim>(path, params.query, null, opts);
  }
  async readNetworkingInternalKnativeDevV1alpha1ClusterDomainClaimStatus(params: ReadNetworkingInternalKnativeDevV1alpha1ClusterDomainClaimStatusRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1ClusterDomainClaim> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/clusterdomainclaims/${params.path.name}/status`;
    return await this.get<NetworkingInternalKnativeDevV1alpha1ClusterDomainClaim>(path, null, null, opts);
  }
  async replaceNetworkingInternalKnativeDevV1alpha1ClusterDomainClaimStatus(params: ReplaceNetworkingInternalKnativeDevV1alpha1ClusterDomainClaimStatusRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1ClusterDomainClaim> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/clusterdomainclaims/${params.path.name}/status`;
    return await this.put<NetworkingInternalKnativeDevV1alpha1ClusterDomainClaim>(path, params.query, params.body, opts);
  }
  async patchNetworkingInternalKnativeDevV1alpha1ClusterDomainClaimStatus(params: PatchNetworkingInternalKnativeDevV1alpha1ClusterDomainClaimStatusRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1ClusterDomainClaim> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/clusterdomainclaims/${params.path.name}/status`;
    return await this.patch<NetworkingInternalKnativeDevV1alpha1ClusterDomainClaim>(path, params.query, null, opts);
  }
  async listNetworkingInternalKnativeDevV1alpha1IngressForAllNamespaces(params: ListNetworkingInternalKnativeDevV1alpha1IngressForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1IngressList> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/ingresses`;
    return await this.get<NetworkingInternalKnativeDevV1alpha1IngressList>(path, null, null, opts);
  }
  async listNetworkingInternalKnativeDevV1alpha1NamespacedCertificate(params: ListNetworkingInternalKnativeDevV1alpha1NamespacedCertificateRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1CertificateList> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/certificates`;
    return await this.get<NetworkingInternalKnativeDevV1alpha1CertificateList>(path, null, null, opts);
  }
  async createNetworkingInternalKnativeDevV1alpha1NamespacedCertificate(params: CreateNetworkingInternalKnativeDevV1alpha1NamespacedCertificateRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1Certificate> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/certificates`;
    return await this.post<NetworkingInternalKnativeDevV1alpha1Certificate>(path, params.query, params.body, opts);
  }
  async deleteNetworkingInternalKnativeDevV1alpha1CollectionNamespacedCertificate(params: DeleteNetworkingInternalKnativeDevV1alpha1CollectionNamespacedCertificateRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/certificates`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readNetworkingInternalKnativeDevV1alpha1NamespacedCertificate(params: ReadNetworkingInternalKnativeDevV1alpha1NamespacedCertificateRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1Certificate> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/certificates/${params.path.name}`;
    return await this.get<NetworkingInternalKnativeDevV1alpha1Certificate>(path, null, null, opts);
  }
  async replaceNetworkingInternalKnativeDevV1alpha1NamespacedCertificate(params: ReplaceNetworkingInternalKnativeDevV1alpha1NamespacedCertificateRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1Certificate> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/certificates/${params.path.name}`;
    return await this.put<NetworkingInternalKnativeDevV1alpha1Certificate>(path, params.query, params.body, opts);
  }
  async deleteNetworkingInternalKnativeDevV1alpha1NamespacedCertificate(params: DeleteNetworkingInternalKnativeDevV1alpha1NamespacedCertificateRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/certificates/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchNetworkingInternalKnativeDevV1alpha1NamespacedCertificate(params: PatchNetworkingInternalKnativeDevV1alpha1NamespacedCertificateRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1Certificate> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/certificates/${params.path.name}`;
    return await this.patch<NetworkingInternalKnativeDevV1alpha1Certificate>(path, params.query, null, opts);
  }
  async readNetworkingInternalKnativeDevV1alpha1NamespacedCertificateStatus(params: ReadNetworkingInternalKnativeDevV1alpha1NamespacedCertificateStatusRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1Certificate> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/certificates/${params.path.name}/status`;
    return await this.get<NetworkingInternalKnativeDevV1alpha1Certificate>(path, null, null, opts);
  }
  async replaceNetworkingInternalKnativeDevV1alpha1NamespacedCertificateStatus(params: ReplaceNetworkingInternalKnativeDevV1alpha1NamespacedCertificateStatusRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1Certificate> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/certificates/${params.path.name}/status`;
    return await this.put<NetworkingInternalKnativeDevV1alpha1Certificate>(path, params.query, params.body, opts);
  }
  async patchNetworkingInternalKnativeDevV1alpha1NamespacedCertificateStatus(params: PatchNetworkingInternalKnativeDevV1alpha1NamespacedCertificateStatusRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1Certificate> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/certificates/${params.path.name}/status`;
    return await this.patch<NetworkingInternalKnativeDevV1alpha1Certificate>(path, params.query, null, opts);
  }
  async listNetworkingInternalKnativeDevV1alpha1NamespacedIngress(params: ListNetworkingInternalKnativeDevV1alpha1NamespacedIngressRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1IngressList> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/ingresses`;
    return await this.get<NetworkingInternalKnativeDevV1alpha1IngressList>(path, null, null, opts);
  }
  async createNetworkingInternalKnativeDevV1alpha1NamespacedIngress(params: CreateNetworkingInternalKnativeDevV1alpha1NamespacedIngressRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1Ingress> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/ingresses`;
    return await this.post<NetworkingInternalKnativeDevV1alpha1Ingress>(path, params.query, params.body, opts);
  }
  async deleteNetworkingInternalKnativeDevV1alpha1CollectionNamespacedIngress(params: DeleteNetworkingInternalKnativeDevV1alpha1CollectionNamespacedIngressRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/ingresses`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readNetworkingInternalKnativeDevV1alpha1NamespacedIngress(params: ReadNetworkingInternalKnativeDevV1alpha1NamespacedIngressRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1Ingress> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/ingresses/${params.path.name}`;
    return await this.get<NetworkingInternalKnativeDevV1alpha1Ingress>(path, null, null, opts);
  }
  async replaceNetworkingInternalKnativeDevV1alpha1NamespacedIngress(params: ReplaceNetworkingInternalKnativeDevV1alpha1NamespacedIngressRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1Ingress> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/ingresses/${params.path.name}`;
    return await this.put<NetworkingInternalKnativeDevV1alpha1Ingress>(path, params.query, params.body, opts);
  }
  async deleteNetworkingInternalKnativeDevV1alpha1NamespacedIngress(params: DeleteNetworkingInternalKnativeDevV1alpha1NamespacedIngressRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/ingresses/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchNetworkingInternalKnativeDevV1alpha1NamespacedIngress(params: PatchNetworkingInternalKnativeDevV1alpha1NamespacedIngressRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1Ingress> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/ingresses/${params.path.name}`;
    return await this.patch<NetworkingInternalKnativeDevV1alpha1Ingress>(path, params.query, null, opts);
  }
  async readNetworkingInternalKnativeDevV1alpha1NamespacedIngressStatus(params: ReadNetworkingInternalKnativeDevV1alpha1NamespacedIngressStatusRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1Ingress> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/ingresses/${params.path.name}/status`;
    return await this.get<NetworkingInternalKnativeDevV1alpha1Ingress>(path, null, null, opts);
  }
  async replaceNetworkingInternalKnativeDevV1alpha1NamespacedIngressStatus(params: ReplaceNetworkingInternalKnativeDevV1alpha1NamespacedIngressStatusRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1Ingress> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/ingresses/${params.path.name}/status`;
    return await this.put<NetworkingInternalKnativeDevV1alpha1Ingress>(path, params.query, params.body, opts);
  }
  async patchNetworkingInternalKnativeDevV1alpha1NamespacedIngressStatus(params: PatchNetworkingInternalKnativeDevV1alpha1NamespacedIngressStatusRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1Ingress> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/ingresses/${params.path.name}/status`;
    return await this.patch<NetworkingInternalKnativeDevV1alpha1Ingress>(path, params.query, null, opts);
  }
  async listNetworkingInternalKnativeDevV1alpha1NamespacedServerlessService(params: ListNetworkingInternalKnativeDevV1alpha1NamespacedServerlessServiceRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1ServerlessServiceList> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/serverlessservices`;
    return await this.get<NetworkingInternalKnativeDevV1alpha1ServerlessServiceList>(path, null, null, opts);
  }
  async createNetworkingInternalKnativeDevV1alpha1NamespacedServerlessService(params: CreateNetworkingInternalKnativeDevV1alpha1NamespacedServerlessServiceRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1ServerlessService> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/serverlessservices`;
    return await this.post<NetworkingInternalKnativeDevV1alpha1ServerlessService>(path, params.query, params.body, opts);
  }
  async deleteNetworkingInternalKnativeDevV1alpha1CollectionNamespacedServerlessService(params: DeleteNetworkingInternalKnativeDevV1alpha1CollectionNamespacedServerlessServiceRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/serverlessservices`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readNetworkingInternalKnativeDevV1alpha1NamespacedServerlessService(params: ReadNetworkingInternalKnativeDevV1alpha1NamespacedServerlessServiceRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1ServerlessService> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/serverlessservices/${params.path.name}`;
    return await this.get<NetworkingInternalKnativeDevV1alpha1ServerlessService>(path, null, null, opts);
  }
  async replaceNetworkingInternalKnativeDevV1alpha1NamespacedServerlessService(params: ReplaceNetworkingInternalKnativeDevV1alpha1NamespacedServerlessServiceRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1ServerlessService> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/serverlessservices/${params.path.name}`;
    return await this.put<NetworkingInternalKnativeDevV1alpha1ServerlessService>(path, params.query, params.body, opts);
  }
  async deleteNetworkingInternalKnativeDevV1alpha1NamespacedServerlessService(params: DeleteNetworkingInternalKnativeDevV1alpha1NamespacedServerlessServiceRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/serverlessservices/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchNetworkingInternalKnativeDevV1alpha1NamespacedServerlessService(params: PatchNetworkingInternalKnativeDevV1alpha1NamespacedServerlessServiceRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1ServerlessService> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/serverlessservices/${params.path.name}`;
    return await this.patch<NetworkingInternalKnativeDevV1alpha1ServerlessService>(path, params.query, null, opts);
  }
  async readNetworkingInternalKnativeDevV1alpha1NamespacedServerlessServiceStatus(params: ReadNetworkingInternalKnativeDevV1alpha1NamespacedServerlessServiceStatusRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1ServerlessService> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/serverlessservices/${params.path.name}/status`;
    return await this.get<NetworkingInternalKnativeDevV1alpha1ServerlessService>(path, null, null, opts);
  }
  async replaceNetworkingInternalKnativeDevV1alpha1NamespacedServerlessServiceStatus(params: ReplaceNetworkingInternalKnativeDevV1alpha1NamespacedServerlessServiceStatusRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1ServerlessService> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/serverlessservices/${params.path.name}/status`;
    return await this.put<NetworkingInternalKnativeDevV1alpha1ServerlessService>(path, params.query, params.body, opts);
  }
  async patchNetworkingInternalKnativeDevV1alpha1NamespacedServerlessServiceStatus(params: PatchNetworkingInternalKnativeDevV1alpha1NamespacedServerlessServiceStatusRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1ServerlessService> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/namespaces/${params.path.namespace}/serverlessservices/${params.path.name}/status`;
    return await this.patch<NetworkingInternalKnativeDevV1alpha1ServerlessService>(path, params.query, null, opts);
  }
  async listNetworkingInternalKnativeDevV1alpha1ServerlessServiceForAllNamespaces(params: ListNetworkingInternalKnativeDevV1alpha1ServerlessServiceForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<NetworkingInternalKnativeDevV1alpha1ServerlessServiceList> {
    const path = `/apis/networking.internal.knative.dev/v1alpha1/serverlessservices`;
    return await this.get<NetworkingInternalKnativeDevV1alpha1ServerlessServiceList>(path, null, null, opts);
  }
  async getNetworkingAPIGroup(params: GetNetworkingAPIGroupRequest, opts?: APIClientRequestOpts): Promise<APIGroup> {
    const path = `/apis/networking.k8s.io/`;
    return await this.get<APIGroup>(path, null, null, opts);
  }
  async getNetworkingV1APIResources(params: GetNetworkingV1APIResourcesRequest, opts?: APIClientRequestOpts): Promise<APIResourceList> {
    const path = `/apis/networking.k8s.io/v1/`;
    return await this.get<APIResourceList>(path, null, null, opts);
  }
  async listNetworkingV1IngressClass(params: ListNetworkingV1IngressClassRequest, opts?: APIClientRequestOpts): Promise<NetworkingK8sIoV1IngressClassList> {
    const path = `/apis/networking.k8s.io/v1/ingressclasses`;
    return await this.get<NetworkingK8sIoV1IngressClassList>(path, null, null, opts);
  }
  async createNetworkingV1IngressClass(params: CreateNetworkingV1IngressClassRequest, opts?: APIClientRequestOpts): Promise<NetworkingK8sIoV1IngressClass> {
    const path = `/apis/networking.k8s.io/v1/ingressclasses`;
    return await this.post<NetworkingK8sIoV1IngressClass>(path, params.query, params.body, opts);
  }
  async deleteNetworkingV1CollectionIngressClass(params: DeleteNetworkingV1CollectionIngressClassRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/networking.k8s.io/v1/ingressclasses`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readNetworkingV1IngressClass(params: ReadNetworkingV1IngressClassRequest, opts?: APIClientRequestOpts): Promise<NetworkingK8sIoV1IngressClass> {
    const path = `/apis/networking.k8s.io/v1/ingressclasses/${params.path.name}`;
    return await this.get<NetworkingK8sIoV1IngressClass>(path, null, null, opts);
  }
  async replaceNetworkingV1IngressClass(params: ReplaceNetworkingV1IngressClassRequest, opts?: APIClientRequestOpts): Promise<NetworkingK8sIoV1IngressClass> {
    const path = `/apis/networking.k8s.io/v1/ingressclasses/${params.path.name}`;
    return await this.put<NetworkingK8sIoV1IngressClass>(path, params.query, params.body, opts);
  }
  async deleteNetworkingV1IngressClass(params: DeleteNetworkingV1IngressClassRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/networking.k8s.io/v1/ingressclasses/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchNetworkingV1IngressClass(params: PatchNetworkingV1IngressClassRequest, opts?: APIClientRequestOpts): Promise<NetworkingK8sIoV1IngressClass> {
    const path = `/apis/networking.k8s.io/v1/ingressclasses/${params.path.name}`;
    return await this.patch<NetworkingK8sIoV1IngressClass>(path, params.query, null, opts);
  }
  async listNetworkingV1IngressForAllNamespaces(params: ListNetworkingV1IngressForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<NetworkingK8sIoV1IngressList> {
    const path = `/apis/networking.k8s.io/v1/ingresses`;
    return await this.get<NetworkingK8sIoV1IngressList>(path, null, null, opts);
  }
  async listNetworkingV1NamespacedIngress(params: ListNetworkingV1NamespacedIngressRequest, opts?: APIClientRequestOpts): Promise<NetworkingK8sIoV1IngressList> {
    const path = `/apis/networking.k8s.io/v1/namespaces/${params.path.namespace}/ingresses`;
    return await this.get<NetworkingK8sIoV1IngressList>(path, null, null, opts);
  }
  async createNetworkingV1NamespacedIngress(params: CreateNetworkingV1NamespacedIngressRequest, opts?: APIClientRequestOpts): Promise<NetworkingK8sIoV1Ingress> {
    const path = `/apis/networking.k8s.io/v1/namespaces/${params.path.namespace}/ingresses`;
    return await this.post<NetworkingK8sIoV1Ingress>(path, params.query, params.body, opts);
  }
  async deleteNetworkingV1CollectionNamespacedIngress(params: DeleteNetworkingV1CollectionNamespacedIngressRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/networking.k8s.io/v1/namespaces/${params.path.namespace}/ingresses`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readNetworkingV1NamespacedIngress(params: ReadNetworkingV1NamespacedIngressRequest, opts?: APIClientRequestOpts): Promise<NetworkingK8sIoV1Ingress> {
    const path = `/apis/networking.k8s.io/v1/namespaces/${params.path.namespace}/ingresses/${params.path.name}`;
    return await this.get<NetworkingK8sIoV1Ingress>(path, null, null, opts);
  }
  async replaceNetworkingV1NamespacedIngress(params: ReplaceNetworkingV1NamespacedIngressRequest, opts?: APIClientRequestOpts): Promise<NetworkingK8sIoV1Ingress> {
    const path = `/apis/networking.k8s.io/v1/namespaces/${params.path.namespace}/ingresses/${params.path.name}`;
    return await this.put<NetworkingK8sIoV1Ingress>(path, params.query, params.body, opts);
  }
  async deleteNetworkingV1NamespacedIngress(params: DeleteNetworkingV1NamespacedIngressRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/networking.k8s.io/v1/namespaces/${params.path.namespace}/ingresses/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchNetworkingV1NamespacedIngress(params: PatchNetworkingV1NamespacedIngressRequest, opts?: APIClientRequestOpts): Promise<NetworkingK8sIoV1Ingress> {
    const path = `/apis/networking.k8s.io/v1/namespaces/${params.path.namespace}/ingresses/${params.path.name}`;
    return await this.patch<NetworkingK8sIoV1Ingress>(path, params.query, null, opts);
  }
  async readNetworkingV1NamespacedIngressStatus(params: ReadNetworkingV1NamespacedIngressStatusRequest, opts?: APIClientRequestOpts): Promise<NetworkingK8sIoV1Ingress> {
    const path = `/apis/networking.k8s.io/v1/namespaces/${params.path.namespace}/ingresses/${params.path.name}/status`;
    return await this.get<NetworkingK8sIoV1Ingress>(path, null, null, opts);
  }
  async replaceNetworkingV1NamespacedIngressStatus(params: ReplaceNetworkingV1NamespacedIngressStatusRequest, opts?: APIClientRequestOpts): Promise<NetworkingK8sIoV1Ingress> {
    const path = `/apis/networking.k8s.io/v1/namespaces/${params.path.namespace}/ingresses/${params.path.name}/status`;
    return await this.put<NetworkingK8sIoV1Ingress>(path, params.query, params.body, opts);
  }
  async patchNetworkingV1NamespacedIngressStatus(params: PatchNetworkingV1NamespacedIngressStatusRequest, opts?: APIClientRequestOpts): Promise<NetworkingK8sIoV1Ingress> {
    const path = `/apis/networking.k8s.io/v1/namespaces/${params.path.namespace}/ingresses/${params.path.name}/status`;
    return await this.patch<NetworkingK8sIoV1Ingress>(path, params.query, null, opts);
  }
  async listNetworkingV1NamespacedNetworkPolicy(params: ListNetworkingV1NamespacedNetworkPolicyRequest, opts?: APIClientRequestOpts): Promise<NetworkingK8sIoV1NetworkPolicyList> {
    const path = `/apis/networking.k8s.io/v1/namespaces/${params.path.namespace}/networkpolicies`;
    return await this.get<NetworkingK8sIoV1NetworkPolicyList>(path, null, null, opts);
  }
  async createNetworkingV1NamespacedNetworkPolicy(params: CreateNetworkingV1NamespacedNetworkPolicyRequest, opts?: APIClientRequestOpts): Promise<NetworkingK8sIoV1NetworkPolicy> {
    const path = `/apis/networking.k8s.io/v1/namespaces/${params.path.namespace}/networkpolicies`;
    return await this.post<NetworkingK8sIoV1NetworkPolicy>(path, params.query, params.body, opts);
  }
  async deleteNetworkingV1CollectionNamespacedNetworkPolicy(params: DeleteNetworkingV1CollectionNamespacedNetworkPolicyRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/networking.k8s.io/v1/namespaces/${params.path.namespace}/networkpolicies`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readNetworkingV1NamespacedNetworkPolicy(params: ReadNetworkingV1NamespacedNetworkPolicyRequest, opts?: APIClientRequestOpts): Promise<NetworkingK8sIoV1NetworkPolicy> {
    const path = `/apis/networking.k8s.io/v1/namespaces/${params.path.namespace}/networkpolicies/${params.path.name}`;
    return await this.get<NetworkingK8sIoV1NetworkPolicy>(path, null, null, opts);
  }
  async replaceNetworkingV1NamespacedNetworkPolicy(params: ReplaceNetworkingV1NamespacedNetworkPolicyRequest, opts?: APIClientRequestOpts): Promise<NetworkingK8sIoV1NetworkPolicy> {
    const path = `/apis/networking.k8s.io/v1/namespaces/${params.path.namespace}/networkpolicies/${params.path.name}`;
    return await this.put<NetworkingK8sIoV1NetworkPolicy>(path, params.query, params.body, opts);
  }
  async deleteNetworkingV1NamespacedNetworkPolicy(params: DeleteNetworkingV1NamespacedNetworkPolicyRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/networking.k8s.io/v1/namespaces/${params.path.namespace}/networkpolicies/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchNetworkingV1NamespacedNetworkPolicy(params: PatchNetworkingV1NamespacedNetworkPolicyRequest, opts?: APIClientRequestOpts): Promise<NetworkingK8sIoV1NetworkPolicy> {
    const path = `/apis/networking.k8s.io/v1/namespaces/${params.path.namespace}/networkpolicies/${params.path.name}`;
    return await this.patch<NetworkingK8sIoV1NetworkPolicy>(path, params.query, null, opts);
  }
  async listNetworkingV1NetworkPolicyForAllNamespaces(params: ListNetworkingV1NetworkPolicyForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<NetworkingK8sIoV1NetworkPolicyList> {
    const path = `/apis/networking.k8s.io/v1/networkpolicies`;
    return await this.get<NetworkingK8sIoV1NetworkPolicyList>(path, null, null, opts);
  }
  async watchNetworkingV1IngressClassList(params: WatchNetworkingV1IngressClassListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/networking.k8s.io/v1/watch/ingressclasses`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchNetworkingV1IngressClass(params: WatchNetworkingV1IngressClassRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/networking.k8s.io/v1/watch/ingressclasses/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchNetworkingV1IngressListForAllNamespaces(params: WatchNetworkingV1IngressListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/networking.k8s.io/v1/watch/ingresses`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchNetworkingV1NamespacedIngressList(params: WatchNetworkingV1NamespacedIngressListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/networking.k8s.io/v1/watch/namespaces/${params.path.namespace}/ingresses`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchNetworkingV1NamespacedIngress(params: WatchNetworkingV1NamespacedIngressRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/networking.k8s.io/v1/watch/namespaces/${params.path.namespace}/ingresses/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchNetworkingV1NamespacedNetworkPolicyList(params: WatchNetworkingV1NamespacedNetworkPolicyListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/networking.k8s.io/v1/watch/namespaces/${params.path.namespace}/networkpolicies`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchNetworkingV1NamespacedNetworkPolicy(params: WatchNetworkingV1NamespacedNetworkPolicyRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/networking.k8s.io/v1/watch/namespaces/${params.path.namespace}/networkpolicies/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchNetworkingV1NetworkPolicyListForAllNamespaces(params: WatchNetworkingV1NetworkPolicyListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/networking.k8s.io/v1/watch/networkpolicies`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async getNodeAPIGroup(params: GetNodeAPIGroupRequest, opts?: APIClientRequestOpts): Promise<APIGroup> {
    const path = `/apis/node.k8s.io/`;
    return await this.get<APIGroup>(path, null, null, opts);
  }
  async getNodeV1APIResources(params: GetNodeV1APIResourcesRequest, opts?: APIClientRequestOpts): Promise<APIResourceList> {
    const path = `/apis/node.k8s.io/v1/`;
    return await this.get<APIResourceList>(path, null, null, opts);
  }
  async listNodeV1RuntimeClass(params: ListNodeV1RuntimeClassRequest, opts?: APIClientRequestOpts): Promise<NodeK8sIoV1RuntimeClassList> {
    const path = `/apis/node.k8s.io/v1/runtimeclasses`;
    return await this.get<NodeK8sIoV1RuntimeClassList>(path, null, null, opts);
  }
  async createNodeV1RuntimeClass(params: CreateNodeV1RuntimeClassRequest, opts?: APIClientRequestOpts): Promise<NodeK8sIoV1RuntimeClass> {
    const path = `/apis/node.k8s.io/v1/runtimeclasses`;
    return await this.post<NodeK8sIoV1RuntimeClass>(path, params.query, params.body, opts);
  }
  async deleteNodeV1CollectionRuntimeClass(params: DeleteNodeV1CollectionRuntimeClassRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/node.k8s.io/v1/runtimeclasses`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readNodeV1RuntimeClass(params: ReadNodeV1RuntimeClassRequest, opts?: APIClientRequestOpts): Promise<NodeK8sIoV1RuntimeClass> {
    const path = `/apis/node.k8s.io/v1/runtimeclasses/${params.path.name}`;
    return await this.get<NodeK8sIoV1RuntimeClass>(path, null, null, opts);
  }
  async replaceNodeV1RuntimeClass(params: ReplaceNodeV1RuntimeClassRequest, opts?: APIClientRequestOpts): Promise<NodeK8sIoV1RuntimeClass> {
    const path = `/apis/node.k8s.io/v1/runtimeclasses/${params.path.name}`;
    return await this.put<NodeK8sIoV1RuntimeClass>(path, params.query, params.body, opts);
  }
  async deleteNodeV1RuntimeClass(params: DeleteNodeV1RuntimeClassRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/node.k8s.io/v1/runtimeclasses/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchNodeV1RuntimeClass(params: PatchNodeV1RuntimeClassRequest, opts?: APIClientRequestOpts): Promise<NodeK8sIoV1RuntimeClass> {
    const path = `/apis/node.k8s.io/v1/runtimeclasses/${params.path.name}`;
    return await this.patch<NodeK8sIoV1RuntimeClass>(path, params.query, null, opts);
  }
  async watchNodeV1RuntimeClassList(params: WatchNodeV1RuntimeClassListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/node.k8s.io/v1/watch/runtimeclasses`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchNodeV1RuntimeClass(params: WatchNodeV1RuntimeClassRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/node.k8s.io/v1/watch/runtimeclasses/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async getPolicyAPIGroup(params: GetPolicyAPIGroupRequest, opts?: APIClientRequestOpts): Promise<APIGroup> {
    const path = `/apis/policy/`;
    return await this.get<APIGroup>(path, null, null, opts);
  }
  async getPolicyV1APIResources(params: GetPolicyV1APIResourcesRequest, opts?: APIClientRequestOpts): Promise<APIResourceList> {
    const path = `/apis/policy/v1/`;
    return await this.get<APIResourceList>(path, null, null, opts);
  }
  async listPolicyV1NamespacedPodDisruptionBudget(params: ListPolicyV1NamespacedPodDisruptionBudgetRequest, opts?: APIClientRequestOpts): Promise<PolicyV1PodDisruptionBudgetList> {
    const path = `/apis/policy/v1/namespaces/${params.path.namespace}/poddisruptionbudgets`;
    return await this.get<PolicyV1PodDisruptionBudgetList>(path, null, null, opts);
  }
  async createPolicyV1NamespacedPodDisruptionBudget(params: CreatePolicyV1NamespacedPodDisruptionBudgetRequest, opts?: APIClientRequestOpts): Promise<PolicyV1PodDisruptionBudget> {
    const path = `/apis/policy/v1/namespaces/${params.path.namespace}/poddisruptionbudgets`;
    return await this.post<PolicyV1PodDisruptionBudget>(path, params.query, params.body, opts);
  }
  async deletePolicyV1CollectionNamespacedPodDisruptionBudget(params: DeletePolicyV1CollectionNamespacedPodDisruptionBudgetRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/policy/v1/namespaces/${params.path.namespace}/poddisruptionbudgets`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readPolicyV1NamespacedPodDisruptionBudget(params: ReadPolicyV1NamespacedPodDisruptionBudgetRequest, opts?: APIClientRequestOpts): Promise<PolicyV1PodDisruptionBudget> {
    const path = `/apis/policy/v1/namespaces/${params.path.namespace}/poddisruptionbudgets/${params.path.name}`;
    return await this.get<PolicyV1PodDisruptionBudget>(path, null, null, opts);
  }
  async replacePolicyV1NamespacedPodDisruptionBudget(params: ReplacePolicyV1NamespacedPodDisruptionBudgetRequest, opts?: APIClientRequestOpts): Promise<PolicyV1PodDisruptionBudget> {
    const path = `/apis/policy/v1/namespaces/${params.path.namespace}/poddisruptionbudgets/${params.path.name}`;
    return await this.put<PolicyV1PodDisruptionBudget>(path, params.query, params.body, opts);
  }
  async deletePolicyV1NamespacedPodDisruptionBudget(params: DeletePolicyV1NamespacedPodDisruptionBudgetRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/policy/v1/namespaces/${params.path.namespace}/poddisruptionbudgets/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchPolicyV1NamespacedPodDisruptionBudget(params: PatchPolicyV1NamespacedPodDisruptionBudgetRequest, opts?: APIClientRequestOpts): Promise<PolicyV1PodDisruptionBudget> {
    const path = `/apis/policy/v1/namespaces/${params.path.namespace}/poddisruptionbudgets/${params.path.name}`;
    return await this.patch<PolicyV1PodDisruptionBudget>(path, params.query, null, opts);
  }
  async readPolicyV1NamespacedPodDisruptionBudgetStatus(params: ReadPolicyV1NamespacedPodDisruptionBudgetStatusRequest, opts?: APIClientRequestOpts): Promise<PolicyV1PodDisruptionBudget> {
    const path = `/apis/policy/v1/namespaces/${params.path.namespace}/poddisruptionbudgets/${params.path.name}/status`;
    return await this.get<PolicyV1PodDisruptionBudget>(path, null, null, opts);
  }
  async replacePolicyV1NamespacedPodDisruptionBudgetStatus(params: ReplacePolicyV1NamespacedPodDisruptionBudgetStatusRequest, opts?: APIClientRequestOpts): Promise<PolicyV1PodDisruptionBudget> {
    const path = `/apis/policy/v1/namespaces/${params.path.namespace}/poddisruptionbudgets/${params.path.name}/status`;
    return await this.put<PolicyV1PodDisruptionBudget>(path, params.query, params.body, opts);
  }
  async patchPolicyV1NamespacedPodDisruptionBudgetStatus(params: PatchPolicyV1NamespacedPodDisruptionBudgetStatusRequest, opts?: APIClientRequestOpts): Promise<PolicyV1PodDisruptionBudget> {
    const path = `/apis/policy/v1/namespaces/${params.path.namespace}/poddisruptionbudgets/${params.path.name}/status`;
    return await this.patch<PolicyV1PodDisruptionBudget>(path, params.query, null, opts);
  }
  async listPolicyV1PodDisruptionBudgetForAllNamespaces(params: ListPolicyV1PodDisruptionBudgetForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<PolicyV1PodDisruptionBudgetList> {
    const path = `/apis/policy/v1/poddisruptionbudgets`;
    return await this.get<PolicyV1PodDisruptionBudgetList>(path, null, null, opts);
  }
  async watchPolicyV1NamespacedPodDisruptionBudgetList(params: WatchPolicyV1NamespacedPodDisruptionBudgetListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/policy/v1/watch/namespaces/${params.path.namespace}/poddisruptionbudgets`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchPolicyV1NamespacedPodDisruptionBudget(params: WatchPolicyV1NamespacedPodDisruptionBudgetRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/policy/v1/watch/namespaces/${params.path.namespace}/poddisruptionbudgets/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchPolicyV1PodDisruptionBudgetListForAllNamespaces(params: WatchPolicyV1PodDisruptionBudgetListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/policy/v1/watch/poddisruptionbudgets`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async listPostgresqlCnpgIoV1BackupForAllNamespaces(params: ListPostgresqlCnpgIoV1BackupForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1BackupList> {
    const path = `/apis/postgresql.cnpg.io/v1/backups`;
    return await this.get<PostgresqlCnpgIoV1BackupList>(path, null, null, opts);
  }
  async listPostgresqlCnpgIoV1ClusterImageCatalog(params: ListPostgresqlCnpgIoV1ClusterImageCatalogRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1ClusterImageCatalogList> {
    const path = `/apis/postgresql.cnpg.io/v1/clusterimagecatalogs`;
    return await this.get<PostgresqlCnpgIoV1ClusterImageCatalogList>(path, null, null, opts);
  }
  async createPostgresqlCnpgIoV1ClusterImageCatalog(params: CreatePostgresqlCnpgIoV1ClusterImageCatalogRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1ClusterImageCatalog> {
    const path = `/apis/postgresql.cnpg.io/v1/clusterimagecatalogs`;
    return await this.post<PostgresqlCnpgIoV1ClusterImageCatalog>(path, params.query, params.body, opts);
  }
  async deletePostgresqlCnpgIoV1CollectionClusterImageCatalog(params: DeletePostgresqlCnpgIoV1CollectionClusterImageCatalogRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/postgresql.cnpg.io/v1/clusterimagecatalogs`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readPostgresqlCnpgIoV1ClusterImageCatalog(params: ReadPostgresqlCnpgIoV1ClusterImageCatalogRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1ClusterImageCatalog> {
    const path = `/apis/postgresql.cnpg.io/v1/clusterimagecatalogs/${params.path.name}`;
    return await this.get<PostgresqlCnpgIoV1ClusterImageCatalog>(path, null, null, opts);
  }
  async replacePostgresqlCnpgIoV1ClusterImageCatalog(params: ReplacePostgresqlCnpgIoV1ClusterImageCatalogRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1ClusterImageCatalog> {
    const path = `/apis/postgresql.cnpg.io/v1/clusterimagecatalogs/${params.path.name}`;
    return await this.put<PostgresqlCnpgIoV1ClusterImageCatalog>(path, params.query, params.body, opts);
  }
  async deletePostgresqlCnpgIoV1ClusterImageCatalog(params: DeletePostgresqlCnpgIoV1ClusterImageCatalogRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/postgresql.cnpg.io/v1/clusterimagecatalogs/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchPostgresqlCnpgIoV1ClusterImageCatalog(params: PatchPostgresqlCnpgIoV1ClusterImageCatalogRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1ClusterImageCatalog> {
    const path = `/apis/postgresql.cnpg.io/v1/clusterimagecatalogs/${params.path.name}`;
    return await this.patch<PostgresqlCnpgIoV1ClusterImageCatalog>(path, params.query, null, opts);
  }
  async listPostgresqlCnpgIoV1ClusterForAllNamespaces(params: ListPostgresqlCnpgIoV1ClusterForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1ClusterList> {
    const path = `/apis/postgresql.cnpg.io/v1/clusters`;
    return await this.get<PostgresqlCnpgIoV1ClusterList>(path, null, null, opts);
  }
  async listPostgresqlCnpgIoV1DatabaseForAllNamespaces(params: ListPostgresqlCnpgIoV1DatabaseForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1DatabaseList> {
    const path = `/apis/postgresql.cnpg.io/v1/databases`;
    return await this.get<PostgresqlCnpgIoV1DatabaseList>(path, null, null, opts);
  }
  async listPostgresqlCnpgIoV1ImageCatalogForAllNamespaces(params: ListPostgresqlCnpgIoV1ImageCatalogForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1ImageCatalogList> {
    const path = `/apis/postgresql.cnpg.io/v1/imagecatalogs`;
    return await this.get<PostgresqlCnpgIoV1ImageCatalogList>(path, null, null, opts);
  }
  async listPostgresqlCnpgIoV1NamespacedBackup(params: ListPostgresqlCnpgIoV1NamespacedBackupRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1BackupList> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/backups`;
    return await this.get<PostgresqlCnpgIoV1BackupList>(path, null, null, opts);
  }
  async createPostgresqlCnpgIoV1NamespacedBackup(params: CreatePostgresqlCnpgIoV1NamespacedBackupRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Backup> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/backups`;
    return await this.post<PostgresqlCnpgIoV1Backup>(path, params.query, params.body, opts);
  }
  async deletePostgresqlCnpgIoV1CollectionNamespacedBackup(params: DeletePostgresqlCnpgIoV1CollectionNamespacedBackupRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/backups`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readPostgresqlCnpgIoV1NamespacedBackup(params: ReadPostgresqlCnpgIoV1NamespacedBackupRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Backup> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/backups/${params.path.name}`;
    return await this.get<PostgresqlCnpgIoV1Backup>(path, null, null, opts);
  }
  async replacePostgresqlCnpgIoV1NamespacedBackup(params: ReplacePostgresqlCnpgIoV1NamespacedBackupRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Backup> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/backups/${params.path.name}`;
    return await this.put<PostgresqlCnpgIoV1Backup>(path, params.query, params.body, opts);
  }
  async deletePostgresqlCnpgIoV1NamespacedBackup(params: DeletePostgresqlCnpgIoV1NamespacedBackupRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/backups/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchPostgresqlCnpgIoV1NamespacedBackup(params: PatchPostgresqlCnpgIoV1NamespacedBackupRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Backup> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/backups/${params.path.name}`;
    return await this.patch<PostgresqlCnpgIoV1Backup>(path, params.query, null, opts);
  }
  async readPostgresqlCnpgIoV1NamespacedBackupStatus(params: ReadPostgresqlCnpgIoV1NamespacedBackupStatusRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Backup> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/backups/${params.path.name}/status`;
    return await this.get<PostgresqlCnpgIoV1Backup>(path, null, null, opts);
  }
  async replacePostgresqlCnpgIoV1NamespacedBackupStatus(params: ReplacePostgresqlCnpgIoV1NamespacedBackupStatusRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Backup> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/backups/${params.path.name}/status`;
    return await this.put<PostgresqlCnpgIoV1Backup>(path, params.query, params.body, opts);
  }
  async patchPostgresqlCnpgIoV1NamespacedBackupStatus(params: PatchPostgresqlCnpgIoV1NamespacedBackupStatusRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Backup> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/backups/${params.path.name}/status`;
    return await this.patch<PostgresqlCnpgIoV1Backup>(path, params.query, null, opts);
  }
  async listPostgresqlCnpgIoV1NamespacedCluster(params: ListPostgresqlCnpgIoV1NamespacedClusterRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1ClusterList> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/clusters`;
    return await this.get<PostgresqlCnpgIoV1ClusterList>(path, null, null, opts);
  }
  async createPostgresqlCnpgIoV1NamespacedCluster(params: CreatePostgresqlCnpgIoV1NamespacedClusterRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Cluster> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/clusters`;
    return await this.post<PostgresqlCnpgIoV1Cluster>(path, params.query, params.body, opts);
  }
  async deletePostgresqlCnpgIoV1CollectionNamespacedCluster(params: DeletePostgresqlCnpgIoV1CollectionNamespacedClusterRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/clusters`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readPostgresqlCnpgIoV1NamespacedCluster(params: ReadPostgresqlCnpgIoV1NamespacedClusterRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Cluster> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/clusters/${params.path.name}`;
    return await this.get<PostgresqlCnpgIoV1Cluster>(path, null, null, opts);
  }
  async replacePostgresqlCnpgIoV1NamespacedCluster(params: ReplacePostgresqlCnpgIoV1NamespacedClusterRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Cluster> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/clusters/${params.path.name}`;
    return await this.put<PostgresqlCnpgIoV1Cluster>(path, params.query, params.body, opts);
  }
  async deletePostgresqlCnpgIoV1NamespacedCluster(params: DeletePostgresqlCnpgIoV1NamespacedClusterRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/clusters/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchPostgresqlCnpgIoV1NamespacedCluster(params: PatchPostgresqlCnpgIoV1NamespacedClusterRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Cluster> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/clusters/${params.path.name}`;
    return await this.patch<PostgresqlCnpgIoV1Cluster>(path, params.query, null, opts);
  }
  async readPostgresqlCnpgIoV1NamespacedClusterScale(params: ReadPostgresqlCnpgIoV1NamespacedClusterScaleRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1Scale> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/clusters/${params.path.name}/scale`;
    return await this.get<AutoscalingV1Scale>(path, null, null, opts);
  }
  async replacePostgresqlCnpgIoV1NamespacedClusterScale(params: ReplacePostgresqlCnpgIoV1NamespacedClusterScaleRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1Scale> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/clusters/${params.path.name}/scale`;
    return await this.put<AutoscalingV1Scale>(path, params.query, params.body, opts);
  }
  async patchPostgresqlCnpgIoV1NamespacedClusterScale(params: PatchPostgresqlCnpgIoV1NamespacedClusterScaleRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1Scale> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/clusters/${params.path.name}/scale`;
    return await this.patch<AutoscalingV1Scale>(path, params.query, null, opts);
  }
  async readPostgresqlCnpgIoV1NamespacedClusterStatus(params: ReadPostgresqlCnpgIoV1NamespacedClusterStatusRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Cluster> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/clusters/${params.path.name}/status`;
    return await this.get<PostgresqlCnpgIoV1Cluster>(path, null, null, opts);
  }
  async replacePostgresqlCnpgIoV1NamespacedClusterStatus(params: ReplacePostgresqlCnpgIoV1NamespacedClusterStatusRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Cluster> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/clusters/${params.path.name}/status`;
    return await this.put<PostgresqlCnpgIoV1Cluster>(path, params.query, params.body, opts);
  }
  async patchPostgresqlCnpgIoV1NamespacedClusterStatus(params: PatchPostgresqlCnpgIoV1NamespacedClusterStatusRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Cluster> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/clusters/${params.path.name}/status`;
    return await this.patch<PostgresqlCnpgIoV1Cluster>(path, params.query, null, opts);
  }
  async listPostgresqlCnpgIoV1NamespacedDatabase(params: ListPostgresqlCnpgIoV1NamespacedDatabaseRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1DatabaseList> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/databases`;
    return await this.get<PostgresqlCnpgIoV1DatabaseList>(path, null, null, opts);
  }
  async createPostgresqlCnpgIoV1NamespacedDatabase(params: CreatePostgresqlCnpgIoV1NamespacedDatabaseRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Database> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/databases`;
    return await this.post<PostgresqlCnpgIoV1Database>(path, params.query, params.body, opts);
  }
  async deletePostgresqlCnpgIoV1CollectionNamespacedDatabase(params: DeletePostgresqlCnpgIoV1CollectionNamespacedDatabaseRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/databases`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readPostgresqlCnpgIoV1NamespacedDatabase(params: ReadPostgresqlCnpgIoV1NamespacedDatabaseRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Database> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/databases/${params.path.name}`;
    return await this.get<PostgresqlCnpgIoV1Database>(path, null, null, opts);
  }
  async replacePostgresqlCnpgIoV1NamespacedDatabase(params: ReplacePostgresqlCnpgIoV1NamespacedDatabaseRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Database> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/databases/${params.path.name}`;
    return await this.put<PostgresqlCnpgIoV1Database>(path, params.query, params.body, opts);
  }
  async deletePostgresqlCnpgIoV1NamespacedDatabase(params: DeletePostgresqlCnpgIoV1NamespacedDatabaseRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/databases/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchPostgresqlCnpgIoV1NamespacedDatabase(params: PatchPostgresqlCnpgIoV1NamespacedDatabaseRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Database> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/databases/${params.path.name}`;
    return await this.patch<PostgresqlCnpgIoV1Database>(path, params.query, null, opts);
  }
  async readPostgresqlCnpgIoV1NamespacedDatabaseStatus(params: ReadPostgresqlCnpgIoV1NamespacedDatabaseStatusRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Database> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/databases/${params.path.name}/status`;
    return await this.get<PostgresqlCnpgIoV1Database>(path, null, null, opts);
  }
  async replacePostgresqlCnpgIoV1NamespacedDatabaseStatus(params: ReplacePostgresqlCnpgIoV1NamespacedDatabaseStatusRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Database> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/databases/${params.path.name}/status`;
    return await this.put<PostgresqlCnpgIoV1Database>(path, params.query, params.body, opts);
  }
  async patchPostgresqlCnpgIoV1NamespacedDatabaseStatus(params: PatchPostgresqlCnpgIoV1NamespacedDatabaseStatusRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Database> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/databases/${params.path.name}/status`;
    return await this.patch<PostgresqlCnpgIoV1Database>(path, params.query, null, opts);
  }
  async listPostgresqlCnpgIoV1NamespacedImageCatalog(params: ListPostgresqlCnpgIoV1NamespacedImageCatalogRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1ImageCatalogList> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/imagecatalogs`;
    return await this.get<PostgresqlCnpgIoV1ImageCatalogList>(path, null, null, opts);
  }
  async createPostgresqlCnpgIoV1NamespacedImageCatalog(params: CreatePostgresqlCnpgIoV1NamespacedImageCatalogRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1ImageCatalog> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/imagecatalogs`;
    return await this.post<PostgresqlCnpgIoV1ImageCatalog>(path, params.query, params.body, opts);
  }
  async deletePostgresqlCnpgIoV1CollectionNamespacedImageCatalog(params: DeletePostgresqlCnpgIoV1CollectionNamespacedImageCatalogRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/imagecatalogs`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readPostgresqlCnpgIoV1NamespacedImageCatalog(params: ReadPostgresqlCnpgIoV1NamespacedImageCatalogRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1ImageCatalog> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/imagecatalogs/${params.path.name}`;
    return await this.get<PostgresqlCnpgIoV1ImageCatalog>(path, null, null, opts);
  }
  async replacePostgresqlCnpgIoV1NamespacedImageCatalog(params: ReplacePostgresqlCnpgIoV1NamespacedImageCatalogRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1ImageCatalog> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/imagecatalogs/${params.path.name}`;
    return await this.put<PostgresqlCnpgIoV1ImageCatalog>(path, params.query, params.body, opts);
  }
  async deletePostgresqlCnpgIoV1NamespacedImageCatalog(params: DeletePostgresqlCnpgIoV1NamespacedImageCatalogRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/imagecatalogs/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchPostgresqlCnpgIoV1NamespacedImageCatalog(params: PatchPostgresqlCnpgIoV1NamespacedImageCatalogRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1ImageCatalog> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/imagecatalogs/${params.path.name}`;
    return await this.patch<PostgresqlCnpgIoV1ImageCatalog>(path, params.query, null, opts);
  }
  async listPostgresqlCnpgIoV1NamespacedPooler(params: ListPostgresqlCnpgIoV1NamespacedPoolerRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1PoolerList> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/poolers`;
    return await this.get<PostgresqlCnpgIoV1PoolerList>(path, null, null, opts);
  }
  async createPostgresqlCnpgIoV1NamespacedPooler(params: CreatePostgresqlCnpgIoV1NamespacedPoolerRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Pooler> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/poolers`;
    return await this.post<PostgresqlCnpgIoV1Pooler>(path, params.query, params.body, opts);
  }
  async deletePostgresqlCnpgIoV1CollectionNamespacedPooler(params: DeletePostgresqlCnpgIoV1CollectionNamespacedPoolerRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/poolers`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readPostgresqlCnpgIoV1NamespacedPooler(params: ReadPostgresqlCnpgIoV1NamespacedPoolerRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Pooler> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/poolers/${params.path.name}`;
    return await this.get<PostgresqlCnpgIoV1Pooler>(path, null, null, opts);
  }
  async replacePostgresqlCnpgIoV1NamespacedPooler(params: ReplacePostgresqlCnpgIoV1NamespacedPoolerRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Pooler> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/poolers/${params.path.name}`;
    return await this.put<PostgresqlCnpgIoV1Pooler>(path, params.query, params.body, opts);
  }
  async deletePostgresqlCnpgIoV1NamespacedPooler(params: DeletePostgresqlCnpgIoV1NamespacedPoolerRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/poolers/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchPostgresqlCnpgIoV1NamespacedPooler(params: PatchPostgresqlCnpgIoV1NamespacedPoolerRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Pooler> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/poolers/${params.path.name}`;
    return await this.patch<PostgresqlCnpgIoV1Pooler>(path, params.query, null, opts);
  }
  async readPostgresqlCnpgIoV1NamespacedPoolerScale(params: ReadPostgresqlCnpgIoV1NamespacedPoolerScaleRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1Scale> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/poolers/${params.path.name}/scale`;
    return await this.get<AutoscalingV1Scale>(path, null, null, opts);
  }
  async replacePostgresqlCnpgIoV1NamespacedPoolerScale(params: ReplacePostgresqlCnpgIoV1NamespacedPoolerScaleRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1Scale> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/poolers/${params.path.name}/scale`;
    return await this.put<AutoscalingV1Scale>(path, params.query, params.body, opts);
  }
  async patchPostgresqlCnpgIoV1NamespacedPoolerScale(params: PatchPostgresqlCnpgIoV1NamespacedPoolerScaleRequest, opts?: APIClientRequestOpts): Promise<AutoscalingV1Scale> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/poolers/${params.path.name}/scale`;
    return await this.patch<AutoscalingV1Scale>(path, params.query, null, opts);
  }
  async readPostgresqlCnpgIoV1NamespacedPoolerStatus(params: ReadPostgresqlCnpgIoV1NamespacedPoolerStatusRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Pooler> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/poolers/${params.path.name}/status`;
    return await this.get<PostgresqlCnpgIoV1Pooler>(path, null, null, opts);
  }
  async replacePostgresqlCnpgIoV1NamespacedPoolerStatus(params: ReplacePostgresqlCnpgIoV1NamespacedPoolerStatusRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Pooler> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/poolers/${params.path.name}/status`;
    return await this.put<PostgresqlCnpgIoV1Pooler>(path, params.query, params.body, opts);
  }
  async patchPostgresqlCnpgIoV1NamespacedPoolerStatus(params: PatchPostgresqlCnpgIoV1NamespacedPoolerStatusRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Pooler> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/poolers/${params.path.name}/status`;
    return await this.patch<PostgresqlCnpgIoV1Pooler>(path, params.query, null, opts);
  }
  async listPostgresqlCnpgIoV1NamespacedPublication(params: ListPostgresqlCnpgIoV1NamespacedPublicationRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1PublicationList> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/publications`;
    return await this.get<PostgresqlCnpgIoV1PublicationList>(path, null, null, opts);
  }
  async createPostgresqlCnpgIoV1NamespacedPublication(params: CreatePostgresqlCnpgIoV1NamespacedPublicationRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Publication> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/publications`;
    return await this.post<PostgresqlCnpgIoV1Publication>(path, params.query, params.body, opts);
  }
  async deletePostgresqlCnpgIoV1CollectionNamespacedPublication(params: DeletePostgresqlCnpgIoV1CollectionNamespacedPublicationRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/publications`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readPostgresqlCnpgIoV1NamespacedPublication(params: ReadPostgresqlCnpgIoV1NamespacedPublicationRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Publication> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/publications/${params.path.name}`;
    return await this.get<PostgresqlCnpgIoV1Publication>(path, null, null, opts);
  }
  async replacePostgresqlCnpgIoV1NamespacedPublication(params: ReplacePostgresqlCnpgIoV1NamespacedPublicationRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Publication> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/publications/${params.path.name}`;
    return await this.put<PostgresqlCnpgIoV1Publication>(path, params.query, params.body, opts);
  }
  async deletePostgresqlCnpgIoV1NamespacedPublication(params: DeletePostgresqlCnpgIoV1NamespacedPublicationRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/publications/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchPostgresqlCnpgIoV1NamespacedPublication(params: PatchPostgresqlCnpgIoV1NamespacedPublicationRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Publication> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/publications/${params.path.name}`;
    return await this.patch<PostgresqlCnpgIoV1Publication>(path, params.query, null, opts);
  }
  async readPostgresqlCnpgIoV1NamespacedPublicationStatus(params: ReadPostgresqlCnpgIoV1NamespacedPublicationStatusRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Publication> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/publications/${params.path.name}/status`;
    return await this.get<PostgresqlCnpgIoV1Publication>(path, null, null, opts);
  }
  async replacePostgresqlCnpgIoV1NamespacedPublicationStatus(params: ReplacePostgresqlCnpgIoV1NamespacedPublicationStatusRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Publication> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/publications/${params.path.name}/status`;
    return await this.put<PostgresqlCnpgIoV1Publication>(path, params.query, params.body, opts);
  }
  async patchPostgresqlCnpgIoV1NamespacedPublicationStatus(params: PatchPostgresqlCnpgIoV1NamespacedPublicationStatusRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Publication> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/publications/${params.path.name}/status`;
    return await this.patch<PostgresqlCnpgIoV1Publication>(path, params.query, null, opts);
  }
  async listPostgresqlCnpgIoV1NamespacedScheduledBackup(params: ListPostgresqlCnpgIoV1NamespacedScheduledBackupRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1ScheduledBackupList> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/scheduledbackups`;
    return await this.get<PostgresqlCnpgIoV1ScheduledBackupList>(path, null, null, opts);
  }
  async createPostgresqlCnpgIoV1NamespacedScheduledBackup(params: CreatePostgresqlCnpgIoV1NamespacedScheduledBackupRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1ScheduledBackup> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/scheduledbackups`;
    return await this.post<PostgresqlCnpgIoV1ScheduledBackup>(path, params.query, params.body, opts);
  }
  async deletePostgresqlCnpgIoV1CollectionNamespacedScheduledBackup(params: DeletePostgresqlCnpgIoV1CollectionNamespacedScheduledBackupRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/scheduledbackups`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readPostgresqlCnpgIoV1NamespacedScheduledBackup(params: ReadPostgresqlCnpgIoV1NamespacedScheduledBackupRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1ScheduledBackup> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/scheduledbackups/${params.path.name}`;
    return await this.get<PostgresqlCnpgIoV1ScheduledBackup>(path, null, null, opts);
  }
  async replacePostgresqlCnpgIoV1NamespacedScheduledBackup(params: ReplacePostgresqlCnpgIoV1NamespacedScheduledBackupRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1ScheduledBackup> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/scheduledbackups/${params.path.name}`;
    return await this.put<PostgresqlCnpgIoV1ScheduledBackup>(path, params.query, params.body, opts);
  }
  async deletePostgresqlCnpgIoV1NamespacedScheduledBackup(params: DeletePostgresqlCnpgIoV1NamespacedScheduledBackupRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/scheduledbackups/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchPostgresqlCnpgIoV1NamespacedScheduledBackup(params: PatchPostgresqlCnpgIoV1NamespacedScheduledBackupRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1ScheduledBackup> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/scheduledbackups/${params.path.name}`;
    return await this.patch<PostgresqlCnpgIoV1ScheduledBackup>(path, params.query, null, opts);
  }
  async readPostgresqlCnpgIoV1NamespacedScheduledBackupStatus(params: ReadPostgresqlCnpgIoV1NamespacedScheduledBackupStatusRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1ScheduledBackup> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/scheduledbackups/${params.path.name}/status`;
    return await this.get<PostgresqlCnpgIoV1ScheduledBackup>(path, null, null, opts);
  }
  async replacePostgresqlCnpgIoV1NamespacedScheduledBackupStatus(params: ReplacePostgresqlCnpgIoV1NamespacedScheduledBackupStatusRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1ScheduledBackup> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/scheduledbackups/${params.path.name}/status`;
    return await this.put<PostgresqlCnpgIoV1ScheduledBackup>(path, params.query, params.body, opts);
  }
  async patchPostgresqlCnpgIoV1NamespacedScheduledBackupStatus(params: PatchPostgresqlCnpgIoV1NamespacedScheduledBackupStatusRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1ScheduledBackup> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/scheduledbackups/${params.path.name}/status`;
    return await this.patch<PostgresqlCnpgIoV1ScheduledBackup>(path, params.query, null, opts);
  }
  async listPostgresqlCnpgIoV1NamespacedSubscription(params: ListPostgresqlCnpgIoV1NamespacedSubscriptionRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1SubscriptionList> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/subscriptions`;
    return await this.get<PostgresqlCnpgIoV1SubscriptionList>(path, null, null, opts);
  }
  async createPostgresqlCnpgIoV1NamespacedSubscription(params: CreatePostgresqlCnpgIoV1NamespacedSubscriptionRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Subscription> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/subscriptions`;
    return await this.post<PostgresqlCnpgIoV1Subscription>(path, params.query, params.body, opts);
  }
  async deletePostgresqlCnpgIoV1CollectionNamespacedSubscription(params: DeletePostgresqlCnpgIoV1CollectionNamespacedSubscriptionRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/subscriptions`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readPostgresqlCnpgIoV1NamespacedSubscription(params: ReadPostgresqlCnpgIoV1NamespacedSubscriptionRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Subscription> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/subscriptions/${params.path.name}`;
    return await this.get<PostgresqlCnpgIoV1Subscription>(path, null, null, opts);
  }
  async replacePostgresqlCnpgIoV1NamespacedSubscription(params: ReplacePostgresqlCnpgIoV1NamespacedSubscriptionRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Subscription> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/subscriptions/${params.path.name}`;
    return await this.put<PostgresqlCnpgIoV1Subscription>(path, params.query, params.body, opts);
  }
  async deletePostgresqlCnpgIoV1NamespacedSubscription(params: DeletePostgresqlCnpgIoV1NamespacedSubscriptionRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/subscriptions/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchPostgresqlCnpgIoV1NamespacedSubscription(params: PatchPostgresqlCnpgIoV1NamespacedSubscriptionRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Subscription> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/subscriptions/${params.path.name}`;
    return await this.patch<PostgresqlCnpgIoV1Subscription>(path, params.query, null, opts);
  }
  async readPostgresqlCnpgIoV1NamespacedSubscriptionStatus(params: ReadPostgresqlCnpgIoV1NamespacedSubscriptionStatusRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Subscription> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/subscriptions/${params.path.name}/status`;
    return await this.get<PostgresqlCnpgIoV1Subscription>(path, null, null, opts);
  }
  async replacePostgresqlCnpgIoV1NamespacedSubscriptionStatus(params: ReplacePostgresqlCnpgIoV1NamespacedSubscriptionStatusRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Subscription> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/subscriptions/${params.path.name}/status`;
    return await this.put<PostgresqlCnpgIoV1Subscription>(path, params.query, params.body, opts);
  }
  async patchPostgresqlCnpgIoV1NamespacedSubscriptionStatus(params: PatchPostgresqlCnpgIoV1NamespacedSubscriptionStatusRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1Subscription> {
    const path = `/apis/postgresql.cnpg.io/v1/namespaces/${params.path.namespace}/subscriptions/${params.path.name}/status`;
    return await this.patch<PostgresqlCnpgIoV1Subscription>(path, params.query, null, opts);
  }
  async listPostgresqlCnpgIoV1PoolerForAllNamespaces(params: ListPostgresqlCnpgIoV1PoolerForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1PoolerList> {
    const path = `/apis/postgresql.cnpg.io/v1/poolers`;
    return await this.get<PostgresqlCnpgIoV1PoolerList>(path, null, null, opts);
  }
  async listPostgresqlCnpgIoV1PublicationForAllNamespaces(params: ListPostgresqlCnpgIoV1PublicationForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1PublicationList> {
    const path = `/apis/postgresql.cnpg.io/v1/publications`;
    return await this.get<PostgresqlCnpgIoV1PublicationList>(path, null, null, opts);
  }
  async listPostgresqlCnpgIoV1ScheduledBackupForAllNamespaces(params: ListPostgresqlCnpgIoV1ScheduledBackupForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1ScheduledBackupList> {
    const path = `/apis/postgresql.cnpg.io/v1/scheduledbackups`;
    return await this.get<PostgresqlCnpgIoV1ScheduledBackupList>(path, null, null, opts);
  }
  async listPostgresqlCnpgIoV1SubscriptionForAllNamespaces(params: ListPostgresqlCnpgIoV1SubscriptionForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<PostgresqlCnpgIoV1SubscriptionList> {
    const path = `/apis/postgresql.cnpg.io/v1/subscriptions`;
    return await this.get<PostgresqlCnpgIoV1SubscriptionList>(path, null, null, opts);
  }
  async getRbacAuthorizationAPIGroup(params: GetRbacAuthorizationAPIGroupRequest, opts?: APIClientRequestOpts): Promise<APIGroup> {
    const path = `/apis/rbac.authorization.k8s.io/`;
    return await this.get<APIGroup>(path, null, null, opts);
  }
  async getRbacAuthorizationV1APIResources(params: GetRbacAuthorizationV1APIResourcesRequest, opts?: APIClientRequestOpts): Promise<APIResourceList> {
    const path = `/apis/rbac.authorization.k8s.io/v1/`;
    return await this.get<APIResourceList>(path, null, null, opts);
  }
  async listRbacAuthorizationV1ClusterRoleBinding(params: ListRbacAuthorizationV1ClusterRoleBindingRequest, opts?: APIClientRequestOpts): Promise<RbacAuthorizationK8sIoV1ClusterRoleBindingList> {
    const path = `/apis/rbac.authorization.k8s.io/v1/clusterrolebindings`;
    return await this.get<RbacAuthorizationK8sIoV1ClusterRoleBindingList>(path, null, null, opts);
  }
  async createRbacAuthorizationV1ClusterRoleBinding(params: CreateRbacAuthorizationV1ClusterRoleBindingRequest, opts?: APIClientRequestOpts): Promise<RbacAuthorizationK8sIoV1ClusterRoleBinding> {
    const path = `/apis/rbac.authorization.k8s.io/v1/clusterrolebindings`;
    return await this.post<RbacAuthorizationK8sIoV1ClusterRoleBinding>(path, params.query, params.body, opts);
  }
  async deleteRbacAuthorizationV1CollectionClusterRoleBinding(params: DeleteRbacAuthorizationV1CollectionClusterRoleBindingRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/rbac.authorization.k8s.io/v1/clusterrolebindings`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readRbacAuthorizationV1ClusterRoleBinding(params: ReadRbacAuthorizationV1ClusterRoleBindingRequest, opts?: APIClientRequestOpts): Promise<RbacAuthorizationK8sIoV1ClusterRoleBinding> {
    const path = `/apis/rbac.authorization.k8s.io/v1/clusterrolebindings/${params.path.name}`;
    return await this.get<RbacAuthorizationK8sIoV1ClusterRoleBinding>(path, null, null, opts);
  }
  async replaceRbacAuthorizationV1ClusterRoleBinding(params: ReplaceRbacAuthorizationV1ClusterRoleBindingRequest, opts?: APIClientRequestOpts): Promise<RbacAuthorizationK8sIoV1ClusterRoleBinding> {
    const path = `/apis/rbac.authorization.k8s.io/v1/clusterrolebindings/${params.path.name}`;
    return await this.put<RbacAuthorizationK8sIoV1ClusterRoleBinding>(path, params.query, params.body, opts);
  }
  async deleteRbacAuthorizationV1ClusterRoleBinding(params: DeleteRbacAuthorizationV1ClusterRoleBindingRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/rbac.authorization.k8s.io/v1/clusterrolebindings/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchRbacAuthorizationV1ClusterRoleBinding(params: PatchRbacAuthorizationV1ClusterRoleBindingRequest, opts?: APIClientRequestOpts): Promise<RbacAuthorizationK8sIoV1ClusterRoleBinding> {
    const path = `/apis/rbac.authorization.k8s.io/v1/clusterrolebindings/${params.path.name}`;
    return await this.patch<RbacAuthorizationK8sIoV1ClusterRoleBinding>(path, params.query, null, opts);
  }
  async listRbacAuthorizationV1ClusterRole(params: ListRbacAuthorizationV1ClusterRoleRequest, opts?: APIClientRequestOpts): Promise<RbacAuthorizationK8sIoV1ClusterRoleList> {
    const path = `/apis/rbac.authorization.k8s.io/v1/clusterroles`;
    return await this.get<RbacAuthorizationK8sIoV1ClusterRoleList>(path, null, null, opts);
  }
  async createRbacAuthorizationV1ClusterRole(params: CreateRbacAuthorizationV1ClusterRoleRequest, opts?: APIClientRequestOpts): Promise<RbacAuthorizationK8sIoV1ClusterRole> {
    const path = `/apis/rbac.authorization.k8s.io/v1/clusterroles`;
    return await this.post<RbacAuthorizationK8sIoV1ClusterRole>(path, params.query, params.body, opts);
  }
  async deleteRbacAuthorizationV1CollectionClusterRole(params: DeleteRbacAuthorizationV1CollectionClusterRoleRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/rbac.authorization.k8s.io/v1/clusterroles`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readRbacAuthorizationV1ClusterRole(params: ReadRbacAuthorizationV1ClusterRoleRequest, opts?: APIClientRequestOpts): Promise<RbacAuthorizationK8sIoV1ClusterRole> {
    const path = `/apis/rbac.authorization.k8s.io/v1/clusterroles/${params.path.name}`;
    return await this.get<RbacAuthorizationK8sIoV1ClusterRole>(path, null, null, opts);
  }
  async replaceRbacAuthorizationV1ClusterRole(params: ReplaceRbacAuthorizationV1ClusterRoleRequest, opts?: APIClientRequestOpts): Promise<RbacAuthorizationK8sIoV1ClusterRole> {
    const path = `/apis/rbac.authorization.k8s.io/v1/clusterroles/${params.path.name}`;
    return await this.put<RbacAuthorizationK8sIoV1ClusterRole>(path, params.query, params.body, opts);
  }
  async deleteRbacAuthorizationV1ClusterRole(params: DeleteRbacAuthorizationV1ClusterRoleRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/rbac.authorization.k8s.io/v1/clusterroles/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchRbacAuthorizationV1ClusterRole(params: PatchRbacAuthorizationV1ClusterRoleRequest, opts?: APIClientRequestOpts): Promise<RbacAuthorizationK8sIoV1ClusterRole> {
    const path = `/apis/rbac.authorization.k8s.io/v1/clusterroles/${params.path.name}`;
    return await this.patch<RbacAuthorizationK8sIoV1ClusterRole>(path, params.query, null, opts);
  }
  async listRbacAuthorizationV1NamespacedRoleBinding(params: ListRbacAuthorizationV1NamespacedRoleBindingRequest, opts?: APIClientRequestOpts): Promise<RbacAuthorizationK8sIoV1RoleBindingList> {
    const path = `/apis/rbac.authorization.k8s.io/v1/namespaces/${params.path.namespace}/rolebindings`;
    return await this.get<RbacAuthorizationK8sIoV1RoleBindingList>(path, null, null, opts);
  }
  async createRbacAuthorizationV1NamespacedRoleBinding(params: CreateRbacAuthorizationV1NamespacedRoleBindingRequest, opts?: APIClientRequestOpts): Promise<RbacAuthorizationK8sIoV1RoleBinding> {
    const path = `/apis/rbac.authorization.k8s.io/v1/namespaces/${params.path.namespace}/rolebindings`;
    return await this.post<RbacAuthorizationK8sIoV1RoleBinding>(path, params.query, params.body, opts);
  }
  async deleteRbacAuthorizationV1CollectionNamespacedRoleBinding(params: DeleteRbacAuthorizationV1CollectionNamespacedRoleBindingRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/rbac.authorization.k8s.io/v1/namespaces/${params.path.namespace}/rolebindings`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readRbacAuthorizationV1NamespacedRoleBinding(params: ReadRbacAuthorizationV1NamespacedRoleBindingRequest, opts?: APIClientRequestOpts): Promise<RbacAuthorizationK8sIoV1RoleBinding> {
    const path = `/apis/rbac.authorization.k8s.io/v1/namespaces/${params.path.namespace}/rolebindings/${params.path.name}`;
    return await this.get<RbacAuthorizationK8sIoV1RoleBinding>(path, null, null, opts);
  }
  async replaceRbacAuthorizationV1NamespacedRoleBinding(params: ReplaceRbacAuthorizationV1NamespacedRoleBindingRequest, opts?: APIClientRequestOpts): Promise<RbacAuthorizationK8sIoV1RoleBinding> {
    const path = `/apis/rbac.authorization.k8s.io/v1/namespaces/${params.path.namespace}/rolebindings/${params.path.name}`;
    return await this.put<RbacAuthorizationK8sIoV1RoleBinding>(path, params.query, params.body, opts);
  }
  async deleteRbacAuthorizationV1NamespacedRoleBinding(params: DeleteRbacAuthorizationV1NamespacedRoleBindingRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/rbac.authorization.k8s.io/v1/namespaces/${params.path.namespace}/rolebindings/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchRbacAuthorizationV1NamespacedRoleBinding(params: PatchRbacAuthorizationV1NamespacedRoleBindingRequest, opts?: APIClientRequestOpts): Promise<RbacAuthorizationK8sIoV1RoleBinding> {
    const path = `/apis/rbac.authorization.k8s.io/v1/namespaces/${params.path.namespace}/rolebindings/${params.path.name}`;
    return await this.patch<RbacAuthorizationK8sIoV1RoleBinding>(path, params.query, null, opts);
  }
  async listRbacAuthorizationV1NamespacedRole(params: ListRbacAuthorizationV1NamespacedRoleRequest, opts?: APIClientRequestOpts): Promise<RbacAuthorizationK8sIoV1RoleList> {
    const path = `/apis/rbac.authorization.k8s.io/v1/namespaces/${params.path.namespace}/roles`;
    return await this.get<RbacAuthorizationK8sIoV1RoleList>(path, null, null, opts);
  }
  async createRbacAuthorizationV1NamespacedRole(params: CreateRbacAuthorizationV1NamespacedRoleRequest, opts?: APIClientRequestOpts): Promise<RbacAuthorizationK8sIoV1Role> {
    const path = `/apis/rbac.authorization.k8s.io/v1/namespaces/${params.path.namespace}/roles`;
    return await this.post<RbacAuthorizationK8sIoV1Role>(path, params.query, params.body, opts);
  }
  async deleteRbacAuthorizationV1CollectionNamespacedRole(params: DeleteRbacAuthorizationV1CollectionNamespacedRoleRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/rbac.authorization.k8s.io/v1/namespaces/${params.path.namespace}/roles`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readRbacAuthorizationV1NamespacedRole(params: ReadRbacAuthorizationV1NamespacedRoleRequest, opts?: APIClientRequestOpts): Promise<RbacAuthorizationK8sIoV1Role> {
    const path = `/apis/rbac.authorization.k8s.io/v1/namespaces/${params.path.namespace}/roles/${params.path.name}`;
    return await this.get<RbacAuthorizationK8sIoV1Role>(path, null, null, opts);
  }
  async replaceRbacAuthorizationV1NamespacedRole(params: ReplaceRbacAuthorizationV1NamespacedRoleRequest, opts?: APIClientRequestOpts): Promise<RbacAuthorizationK8sIoV1Role> {
    const path = `/apis/rbac.authorization.k8s.io/v1/namespaces/${params.path.namespace}/roles/${params.path.name}`;
    return await this.put<RbacAuthorizationK8sIoV1Role>(path, params.query, params.body, opts);
  }
  async deleteRbacAuthorizationV1NamespacedRole(params: DeleteRbacAuthorizationV1NamespacedRoleRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/rbac.authorization.k8s.io/v1/namespaces/${params.path.namespace}/roles/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchRbacAuthorizationV1NamespacedRole(params: PatchRbacAuthorizationV1NamespacedRoleRequest, opts?: APIClientRequestOpts): Promise<RbacAuthorizationK8sIoV1Role> {
    const path = `/apis/rbac.authorization.k8s.io/v1/namespaces/${params.path.namespace}/roles/${params.path.name}`;
    return await this.patch<RbacAuthorizationK8sIoV1Role>(path, params.query, null, opts);
  }
  async listRbacAuthorizationV1RoleBindingForAllNamespaces(params: ListRbacAuthorizationV1RoleBindingForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<RbacAuthorizationK8sIoV1RoleBindingList> {
    const path = `/apis/rbac.authorization.k8s.io/v1/rolebindings`;
    return await this.get<RbacAuthorizationK8sIoV1RoleBindingList>(path, null, null, opts);
  }
  async listRbacAuthorizationV1RoleForAllNamespaces(params: ListRbacAuthorizationV1RoleForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<RbacAuthorizationK8sIoV1RoleList> {
    const path = `/apis/rbac.authorization.k8s.io/v1/roles`;
    return await this.get<RbacAuthorizationK8sIoV1RoleList>(path, null, null, opts);
  }
  async watchRbacAuthorizationV1ClusterRoleBindingList(params: WatchRbacAuthorizationV1ClusterRoleBindingListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/rbac.authorization.k8s.io/v1/watch/clusterrolebindings`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchRbacAuthorizationV1ClusterRoleBinding(params: WatchRbacAuthorizationV1ClusterRoleBindingRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/rbac.authorization.k8s.io/v1/watch/clusterrolebindings/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchRbacAuthorizationV1ClusterRoleList(params: WatchRbacAuthorizationV1ClusterRoleListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/rbac.authorization.k8s.io/v1/watch/clusterroles`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchRbacAuthorizationV1ClusterRole(params: WatchRbacAuthorizationV1ClusterRoleRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/rbac.authorization.k8s.io/v1/watch/clusterroles/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchRbacAuthorizationV1NamespacedRoleBindingList(params: WatchRbacAuthorizationV1NamespacedRoleBindingListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/rbac.authorization.k8s.io/v1/watch/namespaces/${params.path.namespace}/rolebindings`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchRbacAuthorizationV1NamespacedRoleBinding(params: WatchRbacAuthorizationV1NamespacedRoleBindingRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/rbac.authorization.k8s.io/v1/watch/namespaces/${params.path.namespace}/rolebindings/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchRbacAuthorizationV1NamespacedRoleList(params: WatchRbacAuthorizationV1NamespacedRoleListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/rbac.authorization.k8s.io/v1/watch/namespaces/${params.path.namespace}/roles`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchRbacAuthorizationV1NamespacedRole(params: WatchRbacAuthorizationV1NamespacedRoleRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/rbac.authorization.k8s.io/v1/watch/namespaces/${params.path.namespace}/roles/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchRbacAuthorizationV1RoleBindingListForAllNamespaces(params: WatchRbacAuthorizationV1RoleBindingListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/rbac.authorization.k8s.io/v1/watch/rolebindings`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchRbacAuthorizationV1RoleListForAllNamespaces(params: WatchRbacAuthorizationV1RoleListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/rbac.authorization.k8s.io/v1/watch/roles`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async getSchedulingAPIGroup(params: GetSchedulingAPIGroupRequest, opts?: APIClientRequestOpts): Promise<APIGroup> {
    const path = `/apis/scheduling.k8s.io/`;
    return await this.get<APIGroup>(path, null, null, opts);
  }
  async getSchedulingV1APIResources(params: GetSchedulingV1APIResourcesRequest, opts?: APIClientRequestOpts): Promise<APIResourceList> {
    const path = `/apis/scheduling.k8s.io/v1/`;
    return await this.get<APIResourceList>(path, null, null, opts);
  }
  async listSchedulingV1PriorityClass(params: ListSchedulingV1PriorityClassRequest, opts?: APIClientRequestOpts): Promise<SchedulingK8sIoV1PriorityClassList> {
    const path = `/apis/scheduling.k8s.io/v1/priorityclasses`;
    return await this.get<SchedulingK8sIoV1PriorityClassList>(path, null, null, opts);
  }
  async createSchedulingV1PriorityClass(params: CreateSchedulingV1PriorityClassRequest, opts?: APIClientRequestOpts): Promise<SchedulingK8sIoV1PriorityClass> {
    const path = `/apis/scheduling.k8s.io/v1/priorityclasses`;
    return await this.post<SchedulingK8sIoV1PriorityClass>(path, params.query, params.body, opts);
  }
  async deleteSchedulingV1CollectionPriorityClass(params: DeleteSchedulingV1CollectionPriorityClassRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/scheduling.k8s.io/v1/priorityclasses`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readSchedulingV1PriorityClass(params: ReadSchedulingV1PriorityClassRequest, opts?: APIClientRequestOpts): Promise<SchedulingK8sIoV1PriorityClass> {
    const path = `/apis/scheduling.k8s.io/v1/priorityclasses/${params.path.name}`;
    return await this.get<SchedulingK8sIoV1PriorityClass>(path, null, null, opts);
  }
  async replaceSchedulingV1PriorityClass(params: ReplaceSchedulingV1PriorityClassRequest, opts?: APIClientRequestOpts): Promise<SchedulingK8sIoV1PriorityClass> {
    const path = `/apis/scheduling.k8s.io/v1/priorityclasses/${params.path.name}`;
    return await this.put<SchedulingK8sIoV1PriorityClass>(path, params.query, params.body, opts);
  }
  async deleteSchedulingV1PriorityClass(params: DeleteSchedulingV1PriorityClassRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/scheduling.k8s.io/v1/priorityclasses/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchSchedulingV1PriorityClass(params: PatchSchedulingV1PriorityClassRequest, opts?: APIClientRequestOpts): Promise<SchedulingK8sIoV1PriorityClass> {
    const path = `/apis/scheduling.k8s.io/v1/priorityclasses/${params.path.name}`;
    return await this.patch<SchedulingK8sIoV1PriorityClass>(path, params.query, null, opts);
  }
  async watchSchedulingV1PriorityClassList(params: WatchSchedulingV1PriorityClassListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/scheduling.k8s.io/v1/watch/priorityclasses`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchSchedulingV1PriorityClass(params: WatchSchedulingV1PriorityClassRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/scheduling.k8s.io/v1/watch/priorityclasses/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async listServingKnativeDevV1ConfigurationForAllNamespaces(params: ListServingKnativeDevV1ConfigurationForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1ConfigurationList> {
    const path = `/apis/serving.knative.dev/v1/configurations`;
    return await this.get<ServingKnativeDevV1ConfigurationList>(path, null, null, opts);
  }
  async listServingKnativeDevV1NamespacedConfiguration(params: ListServingKnativeDevV1NamespacedConfigurationRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1ConfigurationList> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/configurations`;
    return await this.get<ServingKnativeDevV1ConfigurationList>(path, null, null, opts);
  }
  async createServingKnativeDevV1NamespacedConfiguration(params: CreateServingKnativeDevV1NamespacedConfigurationRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1Configuration> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/configurations`;
    return await this.post<ServingKnativeDevV1Configuration>(path, params.query, params.body, opts);
  }
  async deleteServingKnativeDevV1CollectionNamespacedConfiguration(params: DeleteServingKnativeDevV1CollectionNamespacedConfigurationRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/configurations`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readServingKnativeDevV1NamespacedConfiguration(params: ReadServingKnativeDevV1NamespacedConfigurationRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1Configuration> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/configurations/${params.path.name}`;
    return await this.get<ServingKnativeDevV1Configuration>(path, null, null, opts);
  }
  async replaceServingKnativeDevV1NamespacedConfiguration(params: ReplaceServingKnativeDevV1NamespacedConfigurationRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1Configuration> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/configurations/${params.path.name}`;
    return await this.put<ServingKnativeDevV1Configuration>(path, params.query, params.body, opts);
  }
  async deleteServingKnativeDevV1NamespacedConfiguration(params: DeleteServingKnativeDevV1NamespacedConfigurationRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/configurations/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchServingKnativeDevV1NamespacedConfiguration(params: PatchServingKnativeDevV1NamespacedConfigurationRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1Configuration> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/configurations/${params.path.name}`;
    return await this.patch<ServingKnativeDevV1Configuration>(path, params.query, null, opts);
  }
  async readServingKnativeDevV1NamespacedConfigurationStatus(params: ReadServingKnativeDevV1NamespacedConfigurationStatusRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1Configuration> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/configurations/${params.path.name}/status`;
    return await this.get<ServingKnativeDevV1Configuration>(path, null, null, opts);
  }
  async replaceServingKnativeDevV1NamespacedConfigurationStatus(params: ReplaceServingKnativeDevV1NamespacedConfigurationStatusRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1Configuration> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/configurations/${params.path.name}/status`;
    return await this.put<ServingKnativeDevV1Configuration>(path, params.query, params.body, opts);
  }
  async patchServingKnativeDevV1NamespacedConfigurationStatus(params: PatchServingKnativeDevV1NamespacedConfigurationStatusRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1Configuration> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/configurations/${params.path.name}/status`;
    return await this.patch<ServingKnativeDevV1Configuration>(path, params.query, null, opts);
  }
  async listServingKnativeDevV1NamespacedRevision(params: ListServingKnativeDevV1NamespacedRevisionRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1RevisionList> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/revisions`;
    return await this.get<ServingKnativeDevV1RevisionList>(path, null, null, opts);
  }
  async createServingKnativeDevV1NamespacedRevision(params: CreateServingKnativeDevV1NamespacedRevisionRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1Revision> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/revisions`;
    return await this.post<ServingKnativeDevV1Revision>(path, params.query, params.body, opts);
  }
  async deleteServingKnativeDevV1CollectionNamespacedRevision(params: DeleteServingKnativeDevV1CollectionNamespacedRevisionRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/revisions`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readServingKnativeDevV1NamespacedRevision(params: ReadServingKnativeDevV1NamespacedRevisionRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1Revision> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/revisions/${params.path.name}`;
    return await this.get<ServingKnativeDevV1Revision>(path, null, null, opts);
  }
  async replaceServingKnativeDevV1NamespacedRevision(params: ReplaceServingKnativeDevV1NamespacedRevisionRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1Revision> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/revisions/${params.path.name}`;
    return await this.put<ServingKnativeDevV1Revision>(path, params.query, params.body, opts);
  }
  async deleteServingKnativeDevV1NamespacedRevision(params: DeleteServingKnativeDevV1NamespacedRevisionRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/revisions/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchServingKnativeDevV1NamespacedRevision(params: PatchServingKnativeDevV1NamespacedRevisionRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1Revision> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/revisions/${params.path.name}`;
    return await this.patch<ServingKnativeDevV1Revision>(path, params.query, null, opts);
  }
  async readServingKnativeDevV1NamespacedRevisionStatus(params: ReadServingKnativeDevV1NamespacedRevisionStatusRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1Revision> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/revisions/${params.path.name}/status`;
    return await this.get<ServingKnativeDevV1Revision>(path, null, null, opts);
  }
  async replaceServingKnativeDevV1NamespacedRevisionStatus(params: ReplaceServingKnativeDevV1NamespacedRevisionStatusRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1Revision> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/revisions/${params.path.name}/status`;
    return await this.put<ServingKnativeDevV1Revision>(path, params.query, params.body, opts);
  }
  async patchServingKnativeDevV1NamespacedRevisionStatus(params: PatchServingKnativeDevV1NamespacedRevisionStatusRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1Revision> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/revisions/${params.path.name}/status`;
    return await this.patch<ServingKnativeDevV1Revision>(path, params.query, null, opts);
  }
  async listServingKnativeDevV1NamespacedRoute(params: ListServingKnativeDevV1NamespacedRouteRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1RouteList> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/routes`;
    return await this.get<ServingKnativeDevV1RouteList>(path, null, null, opts);
  }
  async createServingKnativeDevV1NamespacedRoute(params: CreateServingKnativeDevV1NamespacedRouteRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1Route> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/routes`;
    return await this.post<ServingKnativeDevV1Route>(path, params.query, params.body, opts);
  }
  async deleteServingKnativeDevV1CollectionNamespacedRoute(params: DeleteServingKnativeDevV1CollectionNamespacedRouteRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/routes`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readServingKnativeDevV1NamespacedRoute(params: ReadServingKnativeDevV1NamespacedRouteRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1Route> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/routes/${params.path.name}`;
    return await this.get<ServingKnativeDevV1Route>(path, null, null, opts);
  }
  async replaceServingKnativeDevV1NamespacedRoute(params: ReplaceServingKnativeDevV1NamespacedRouteRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1Route> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/routes/${params.path.name}`;
    return await this.put<ServingKnativeDevV1Route>(path, params.query, params.body, opts);
  }
  async deleteServingKnativeDevV1NamespacedRoute(params: DeleteServingKnativeDevV1NamespacedRouteRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/routes/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchServingKnativeDevV1NamespacedRoute(params: PatchServingKnativeDevV1NamespacedRouteRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1Route> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/routes/${params.path.name}`;
    return await this.patch<ServingKnativeDevV1Route>(path, params.query, null, opts);
  }
  async readServingKnativeDevV1NamespacedRouteStatus(params: ReadServingKnativeDevV1NamespacedRouteStatusRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1Route> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/routes/${params.path.name}/status`;
    return await this.get<ServingKnativeDevV1Route>(path, null, null, opts);
  }
  async replaceServingKnativeDevV1NamespacedRouteStatus(params: ReplaceServingKnativeDevV1NamespacedRouteStatusRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1Route> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/routes/${params.path.name}/status`;
    return await this.put<ServingKnativeDevV1Route>(path, params.query, params.body, opts);
  }
  async patchServingKnativeDevV1NamespacedRouteStatus(params: PatchServingKnativeDevV1NamespacedRouteStatusRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1Route> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/routes/${params.path.name}/status`;
    return await this.patch<ServingKnativeDevV1Route>(path, params.query, null, opts);
  }
  async listServingKnativeDevV1NamespacedService(params: ListServingKnativeDevV1NamespacedServiceRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1ServiceList> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/services`;
    return await this.get<ServingKnativeDevV1ServiceList>(path, null, null, opts);
  }
  async createServingKnativeDevV1NamespacedService(params: CreateServingKnativeDevV1NamespacedServiceRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1Service> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/services`;
    return await this.post<ServingKnativeDevV1Service>(path, params.query, params.body, opts);
  }
  async deleteServingKnativeDevV1CollectionNamespacedService(params: DeleteServingKnativeDevV1CollectionNamespacedServiceRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/services`;
    return await this.delete<Status>(path, null, null, opts);
  }
  async readServingKnativeDevV1NamespacedService(params: ReadServingKnativeDevV1NamespacedServiceRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1Service> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/services/${params.path.name}`;
    return await this.get<ServingKnativeDevV1Service>(path, null, null, opts);
  }
  async replaceServingKnativeDevV1NamespacedService(params: ReplaceServingKnativeDevV1NamespacedServiceRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1Service> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/services/${params.path.name}`;
    return await this.put<ServingKnativeDevV1Service>(path, params.query, params.body, opts);
  }
  async deleteServingKnativeDevV1NamespacedService(params: DeleteServingKnativeDevV1NamespacedServiceRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/services/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchServingKnativeDevV1NamespacedService(params: PatchServingKnativeDevV1NamespacedServiceRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1Service> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/services/${params.path.name}`;
    return await this.patch<ServingKnativeDevV1Service>(path, params.query, null, opts);
  }
  async readServingKnativeDevV1NamespacedServiceStatus(params: ReadServingKnativeDevV1NamespacedServiceStatusRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1Service> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/services/${params.path.name}/status`;
    return await this.get<ServingKnativeDevV1Service>(path, null, null, opts);
  }
  async replaceServingKnativeDevV1NamespacedServiceStatus(params: ReplaceServingKnativeDevV1NamespacedServiceStatusRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1Service> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/services/${params.path.name}/status`;
    return await this.put<ServingKnativeDevV1Service>(path, params.query, params.body, opts);
  }
  async patchServingKnativeDevV1NamespacedServiceStatus(params: PatchServingKnativeDevV1NamespacedServiceStatusRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1Service> {
    const path = `/apis/serving.knative.dev/v1/namespaces/${params.path.namespace}/services/${params.path.name}/status`;
    return await this.patch<ServingKnativeDevV1Service>(path, params.query, null, opts);
  }
  async listServingKnativeDevV1RevisionForAllNamespaces(params: ListServingKnativeDevV1RevisionForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1RevisionList> {
    const path = `/apis/serving.knative.dev/v1/revisions`;
    return await this.get<ServingKnativeDevV1RevisionList>(path, null, null, opts);
  }
  async listServingKnativeDevV1RouteForAllNamespaces(params: ListServingKnativeDevV1RouteForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1RouteList> {
    const path = `/apis/serving.knative.dev/v1/routes`;
    return await this.get<ServingKnativeDevV1RouteList>(path, null, null, opts);
  }
  async listServingKnativeDevV1ServiceForAllNamespaces(params: ListServingKnativeDevV1ServiceForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<ServingKnativeDevV1ServiceList> {
    const path = `/apis/serving.knative.dev/v1/services`;
    return await this.get<ServingKnativeDevV1ServiceList>(path, null, null, opts);
  }
  async getStorageAPIGroup(params: GetStorageAPIGroupRequest, opts?: APIClientRequestOpts): Promise<APIGroup> {
    const path = `/apis/storage.k8s.io/`;
    return await this.get<APIGroup>(path, null, null, opts);
  }
  async getStorageV1APIResources(params: GetStorageV1APIResourcesRequest, opts?: APIClientRequestOpts): Promise<APIResourceList> {
    const path = `/apis/storage.k8s.io/v1/`;
    return await this.get<APIResourceList>(path, null, null, opts);
  }
  async listStorageV1CSIDriver(params: ListStorageV1CSIDriverRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1CSIDriverList> {
    const path = `/apis/storage.k8s.io/v1/csidrivers`;
    return await this.get<StorageK8sIoV1CSIDriverList>(path, null, null, opts);
  }
  async createStorageV1CSIDriver(params: CreateStorageV1CSIDriverRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1CSIDriver> {
    const path = `/apis/storage.k8s.io/v1/csidrivers`;
    return await this.post<StorageK8sIoV1CSIDriver>(path, params.query, params.body, opts);
  }
  async deleteStorageV1CollectionCSIDriver(params: DeleteStorageV1CollectionCSIDriverRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/storage.k8s.io/v1/csidrivers`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readStorageV1CSIDriver(params: ReadStorageV1CSIDriverRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1CSIDriver> {
    const path = `/apis/storage.k8s.io/v1/csidrivers/${params.path.name}`;
    return await this.get<StorageK8sIoV1CSIDriver>(path, null, null, opts);
  }
  async replaceStorageV1CSIDriver(params: ReplaceStorageV1CSIDriverRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1CSIDriver> {
    const path = `/apis/storage.k8s.io/v1/csidrivers/${params.path.name}`;
    return await this.put<StorageK8sIoV1CSIDriver>(path, params.query, params.body, opts);
  }
  async deleteStorageV1CSIDriver(params: DeleteStorageV1CSIDriverRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1CSIDriver> {
    const path = `/apis/storage.k8s.io/v1/csidrivers/${params.path.name}`;
    return await this.delete<StorageK8sIoV1CSIDriver>(path, params.query, null, opts);
  }
  async patchStorageV1CSIDriver(params: PatchStorageV1CSIDriverRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1CSIDriver> {
    const path = `/apis/storage.k8s.io/v1/csidrivers/${params.path.name}`;
    return await this.patch<StorageK8sIoV1CSIDriver>(path, params.query, null, opts);
  }
  async listStorageV1CSINode(params: ListStorageV1CSINodeRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1CSINodeList> {
    const path = `/apis/storage.k8s.io/v1/csinodes`;
    return await this.get<StorageK8sIoV1CSINodeList>(path, null, null, opts);
  }
  async createStorageV1CSINode(params: CreateStorageV1CSINodeRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1CSINode> {
    const path = `/apis/storage.k8s.io/v1/csinodes`;
    return await this.post<StorageK8sIoV1CSINode>(path, params.query, params.body, opts);
  }
  async deleteStorageV1CollectionCSINode(params: DeleteStorageV1CollectionCSINodeRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/storage.k8s.io/v1/csinodes`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readStorageV1CSINode(params: ReadStorageV1CSINodeRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1CSINode> {
    const path = `/apis/storage.k8s.io/v1/csinodes/${params.path.name}`;
    return await this.get<StorageK8sIoV1CSINode>(path, null, null, opts);
  }
  async replaceStorageV1CSINode(params: ReplaceStorageV1CSINodeRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1CSINode> {
    const path = `/apis/storage.k8s.io/v1/csinodes/${params.path.name}`;
    return await this.put<StorageK8sIoV1CSINode>(path, params.query, params.body, opts);
  }
  async deleteStorageV1CSINode(params: DeleteStorageV1CSINodeRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1CSINode> {
    const path = `/apis/storage.k8s.io/v1/csinodes/${params.path.name}`;
    return await this.delete<StorageK8sIoV1CSINode>(path, params.query, null, opts);
  }
  async patchStorageV1CSINode(params: PatchStorageV1CSINodeRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1CSINode> {
    const path = `/apis/storage.k8s.io/v1/csinodes/${params.path.name}`;
    return await this.patch<StorageK8sIoV1CSINode>(path, params.query, null, opts);
  }
  async listStorageV1CSIStorageCapacityForAllNamespaces(params: ListStorageV1CSIStorageCapacityForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1CSIStorageCapacityList> {
    const path = `/apis/storage.k8s.io/v1/csistoragecapacities`;
    return await this.get<StorageK8sIoV1CSIStorageCapacityList>(path, null, null, opts);
  }
  async listStorageV1NamespacedCSIStorageCapacity(params: ListStorageV1NamespacedCSIStorageCapacityRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1CSIStorageCapacityList> {
    const path = `/apis/storage.k8s.io/v1/namespaces/${params.path.namespace}/csistoragecapacities`;
    return await this.get<StorageK8sIoV1CSIStorageCapacityList>(path, null, null, opts);
  }
  async createStorageV1NamespacedCSIStorageCapacity(params: CreateStorageV1NamespacedCSIStorageCapacityRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1CSIStorageCapacity> {
    const path = `/apis/storage.k8s.io/v1/namespaces/${params.path.namespace}/csistoragecapacities`;
    return await this.post<StorageK8sIoV1CSIStorageCapacity>(path, params.query, params.body, opts);
  }
  async deleteStorageV1CollectionNamespacedCSIStorageCapacity(params: DeleteStorageV1CollectionNamespacedCSIStorageCapacityRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/storage.k8s.io/v1/namespaces/${params.path.namespace}/csistoragecapacities`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readStorageV1NamespacedCSIStorageCapacity(params: ReadStorageV1NamespacedCSIStorageCapacityRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1CSIStorageCapacity> {
    const path = `/apis/storage.k8s.io/v1/namespaces/${params.path.namespace}/csistoragecapacities/${params.path.name}`;
    return await this.get<StorageK8sIoV1CSIStorageCapacity>(path, null, null, opts);
  }
  async replaceStorageV1NamespacedCSIStorageCapacity(params: ReplaceStorageV1NamespacedCSIStorageCapacityRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1CSIStorageCapacity> {
    const path = `/apis/storage.k8s.io/v1/namespaces/${params.path.namespace}/csistoragecapacities/${params.path.name}`;
    return await this.put<StorageK8sIoV1CSIStorageCapacity>(path, params.query, params.body, opts);
  }
  async deleteStorageV1NamespacedCSIStorageCapacity(params: DeleteStorageV1NamespacedCSIStorageCapacityRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/storage.k8s.io/v1/namespaces/${params.path.namespace}/csistoragecapacities/${params.path.name}`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async patchStorageV1NamespacedCSIStorageCapacity(params: PatchStorageV1NamespacedCSIStorageCapacityRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1CSIStorageCapacity> {
    const path = `/apis/storage.k8s.io/v1/namespaces/${params.path.namespace}/csistoragecapacities/${params.path.name}`;
    return await this.patch<StorageK8sIoV1CSIStorageCapacity>(path, params.query, null, opts);
  }
  async listStorageV1StorageClass(params: ListStorageV1StorageClassRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1StorageClassList> {
    const path = `/apis/storage.k8s.io/v1/storageclasses`;
    return await this.get<StorageK8sIoV1StorageClassList>(path, null, null, opts);
  }
  async createStorageV1StorageClass(params: CreateStorageV1StorageClassRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1StorageClass> {
    const path = `/apis/storage.k8s.io/v1/storageclasses`;
    return await this.post<StorageK8sIoV1StorageClass>(path, params.query, params.body, opts);
  }
  async deleteStorageV1CollectionStorageClass(params: DeleteStorageV1CollectionStorageClassRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/storage.k8s.io/v1/storageclasses`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readStorageV1StorageClass(params: ReadStorageV1StorageClassRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1StorageClass> {
    const path = `/apis/storage.k8s.io/v1/storageclasses/${params.path.name}`;
    return await this.get<StorageK8sIoV1StorageClass>(path, null, null, opts);
  }
  async replaceStorageV1StorageClass(params: ReplaceStorageV1StorageClassRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1StorageClass> {
    const path = `/apis/storage.k8s.io/v1/storageclasses/${params.path.name}`;
    return await this.put<StorageK8sIoV1StorageClass>(path, params.query, params.body, opts);
  }
  async deleteStorageV1StorageClass(params: DeleteStorageV1StorageClassRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1StorageClass> {
    const path = `/apis/storage.k8s.io/v1/storageclasses/${params.path.name}`;
    return await this.delete<StorageK8sIoV1StorageClass>(path, params.query, null, opts);
  }
  async patchStorageV1StorageClass(params: PatchStorageV1StorageClassRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1StorageClass> {
    const path = `/apis/storage.k8s.io/v1/storageclasses/${params.path.name}`;
    return await this.patch<StorageK8sIoV1StorageClass>(path, params.query, null, opts);
  }
  async listStorageV1VolumeAttachment(params: ListStorageV1VolumeAttachmentRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1VolumeAttachmentList> {
    const path = `/apis/storage.k8s.io/v1/volumeattachments`;
    return await this.get<StorageK8sIoV1VolumeAttachmentList>(path, null, null, opts);
  }
  async createStorageV1VolumeAttachment(params: CreateStorageV1VolumeAttachmentRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1VolumeAttachment> {
    const path = `/apis/storage.k8s.io/v1/volumeattachments`;
    return await this.post<StorageK8sIoV1VolumeAttachment>(path, params.query, params.body, opts);
  }
  async deleteStorageV1CollectionVolumeAttachment(params: DeleteStorageV1CollectionVolumeAttachmentRequest, opts?: APIClientRequestOpts): Promise<Status> {
    const path = `/apis/storage.k8s.io/v1/volumeattachments`;
    return await this.delete<Status>(path, params.query, null, opts);
  }
  async readStorageV1VolumeAttachment(params: ReadStorageV1VolumeAttachmentRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1VolumeAttachment> {
    const path = `/apis/storage.k8s.io/v1/volumeattachments/${params.path.name}`;
    return await this.get<StorageK8sIoV1VolumeAttachment>(path, null, null, opts);
  }
  async replaceStorageV1VolumeAttachment(params: ReplaceStorageV1VolumeAttachmentRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1VolumeAttachment> {
    const path = `/apis/storage.k8s.io/v1/volumeattachments/${params.path.name}`;
    return await this.put<StorageK8sIoV1VolumeAttachment>(path, params.query, params.body, opts);
  }
  async deleteStorageV1VolumeAttachment(params: DeleteStorageV1VolumeAttachmentRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1VolumeAttachment> {
    const path = `/apis/storage.k8s.io/v1/volumeattachments/${params.path.name}`;
    return await this.delete<StorageK8sIoV1VolumeAttachment>(path, params.query, null, opts);
  }
  async patchStorageV1VolumeAttachment(params: PatchStorageV1VolumeAttachmentRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1VolumeAttachment> {
    const path = `/apis/storage.k8s.io/v1/volumeattachments/${params.path.name}`;
    return await this.patch<StorageK8sIoV1VolumeAttachment>(path, params.query, null, opts);
  }
  async readStorageV1VolumeAttachmentStatus(params: ReadStorageV1VolumeAttachmentStatusRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1VolumeAttachment> {
    const path = `/apis/storage.k8s.io/v1/volumeattachments/${params.path.name}/status`;
    return await this.get<StorageK8sIoV1VolumeAttachment>(path, null, null, opts);
  }
  async replaceStorageV1VolumeAttachmentStatus(params: ReplaceStorageV1VolumeAttachmentStatusRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1VolumeAttachment> {
    const path = `/apis/storage.k8s.io/v1/volumeattachments/${params.path.name}/status`;
    return await this.put<StorageK8sIoV1VolumeAttachment>(path, params.query, params.body, opts);
  }
  async patchStorageV1VolumeAttachmentStatus(params: PatchStorageV1VolumeAttachmentStatusRequest, opts?: APIClientRequestOpts): Promise<StorageK8sIoV1VolumeAttachment> {
    const path = `/apis/storage.k8s.io/v1/volumeattachments/${params.path.name}/status`;
    return await this.patch<StorageK8sIoV1VolumeAttachment>(path, params.query, null, opts);
  }
  async watchStorageV1CSIDriverList(params: WatchStorageV1CSIDriverListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/storage.k8s.io/v1/watch/csidrivers`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchStorageV1CSIDriver(params: WatchStorageV1CSIDriverRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/storage.k8s.io/v1/watch/csidrivers/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchStorageV1CSINodeList(params: WatchStorageV1CSINodeListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/storage.k8s.io/v1/watch/csinodes`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchStorageV1CSINode(params: WatchStorageV1CSINodeRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/storage.k8s.io/v1/watch/csinodes/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchStorageV1CSIStorageCapacityListForAllNamespaces(params: WatchStorageV1CSIStorageCapacityListForAllNamespacesRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/storage.k8s.io/v1/watch/csistoragecapacities`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchStorageV1NamespacedCSIStorageCapacityList(params: WatchStorageV1NamespacedCSIStorageCapacityListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/storage.k8s.io/v1/watch/namespaces/${params.path.namespace}/csistoragecapacities`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchStorageV1NamespacedCSIStorageCapacity(params: WatchStorageV1NamespacedCSIStorageCapacityRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/storage.k8s.io/v1/watch/namespaces/${params.path.namespace}/csistoragecapacities/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchStorageV1StorageClassList(params: WatchStorageV1StorageClassListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/storage.k8s.io/v1/watch/storageclasses`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchStorageV1StorageClass(params: WatchStorageV1StorageClassRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/storage.k8s.io/v1/watch/storageclasses/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchStorageV1VolumeAttachmentList(params: WatchStorageV1VolumeAttachmentListRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/storage.k8s.io/v1/watch/volumeattachments`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async watchStorageV1VolumeAttachment(params: WatchStorageV1VolumeAttachmentRequest, opts?: APIClientRequestOpts): Promise<WatchEvent> {
    const path = `/apis/storage.k8s.io/v1/watch/volumeattachments/${params.path.name}`;
    return await this.get<WatchEvent>(path, null, null, opts);
  }
  async getServiceAccountIssuerOpenIDKeyset(params: GetServiceAccountIssuerOpenIDKeysetRequest, opts?: APIClientRequestOpts): Promise<string> {
    const path = `/openid/v1/jwks/`;
    return await this.get<string>(path, null, null, opts);
  }
  async getCodeVersion(params: GetCodeVersionRequest, opts?: APIClientRequestOpts): Promise<Info> {
    const path = `/version/`;
    return await this.get<Info>(path, null, null, opts);
  }
}